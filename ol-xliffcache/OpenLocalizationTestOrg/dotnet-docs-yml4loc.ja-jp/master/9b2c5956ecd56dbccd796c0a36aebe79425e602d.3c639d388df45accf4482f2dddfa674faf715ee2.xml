{"nodes":[{"content":"Provides a mechanism that synchronizes access to objects.","nodes":[{"pos":[0,57],"content":"Provides a mechanism that synchronizes access to objects.","nodes":[{"content":"Provides a mechanism that synchronizes access to objects.","pos":[0,57]}]}],"pos":[1429,1487],"yaml":true},{"content":"The <xref:System.Threading.Monitor> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=fullName>, and <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> methods. Object locks provide the ability to restrict access to a block of code, commonly called a critical section. While a thread owns the lock for an object, no other thread can acquire that lock. You can also use the <xref:System.Threading.Monitor> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.  \n  \n In this article:  \n  \n [The Monitor class: An overview](#Overview)   \n [The lock object](#Lock)   \n [The critical section](#CriticalSection)   \n [Pulse, PulseAll, and Wait](#Pulse)   \n [Monitors and wait handles](#WaitHandles)  \n  \n<a name=\"Overview\"></a>   \n## The Monitor class: An overview  \n <xref:System.Threading.Monitor> has the following features:  \n  \n-   It is associated with an object on demand.  \n  \n-   It is unbound, which means it can be called directly from any context.  \n  \n-   An instance of the <xref:System.Threading.Monitor> class cannot be created; the methods of the <xref:System.Threading.Monitor> class are all static. Each method is passed the synchronized object that controls access to the critical section.  \n  \n> [!NOTE]\n>  Use the <xref:System.Threading.Monitor> class to lock objects other than strings (that is, reference types other than <xref:System.String>), not value types. For details, see the overloads of the <xref:System.Threading.Monitor.Enter%2A> method and [The lock object](#Lock) section later in this article.  \n  \n The following table describes the actions that can be taken by threads that access synchronized objects:  \n  \n|Action|Description|  \n|------------|-----------------|  \n|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|Acquires a lock for an object. This action also marks the beginning of a critical section. No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.|  \n|<xref:System.Threading.Monitor.Wait%2A>|Releases the lock on an object in order to permit other threads to lock and access the object. The calling thread waits while another thread accesses the object. Pulse signals are used to notify waiting threads about changes to an object's state.|  \n|<xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A>|Sends a signal to one or more waiting threads. The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock. The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object. Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.|  \n|<xref:System.Threading.Monitor.Exit%2A>|Releases the lock on an object. This action also marks the end of a critical section protected by the locked object.|  \n  \n Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], there are two sets of overloads for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.TryEnter%2A> methods. One set of overloads has a `ref` (in C#) or `ByRef` (in Visual Basic) <xref:System.Boolean> parameter that is atomically set to `true` if the lock is acquired, even if an exception is thrown when acquiring the lock. Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.  \n  \n<a name=\"Lock\"></a>   \n## The lock object  \n The Monitor class consists of `static` (in C#) or  `Shared` (in Visual Basic) methods that operate on an object that controls access to the critical section.  The following information is maintained for each synchronized object:  \n  \n-   A reference to the thread that currently holds the lock.  \n  \n-   A reference to a ready queue, which contains the threads that are ready to obtain the lock.  \n  \n-   A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.  \n  \n <xref:System.Threading.Monitor> locks objects (that is, reference types), not value types. While you can pass a value type to <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, it is boxed separately for each call. Since each call creates a separate object, <xref:System.Threading.Monitor.Enter%2A> never blocks, and the code it is supposedly protecting is not really synchronized. In addition, the object passed to <xref:System.Threading.Monitor.Exit%2A> is different from the object passed to <xref:System.Threading.Monitor.Enter%2A>, so <xref:System.Threading.Monitor> throws <xref:System.Threading.SynchronizationLockException> exception with the message \"Object synchronization method was called from an unsynchronized block of code.\"  \n  \n The following example illustrates this problem. It launches ten tasks, each of which just sleeps for 250 milliseconds. Each task then updates a counter variable, `nTasks`, which is intended to count the number of tasks that actually launched and executed. Because `nTasks` is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks. However, as the output from the example shows, each of the tasks throws a <xref:System.Threading.SynchronizationLockException> exception.  \n  \n [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]\n [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  \n  \n Each task throws a <xref:System.Threading.SynchronizationLockException> exception because the `nTasks` variable is boxed before the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> method in each task. In other words, each method call is passed a separate variable that is independent of the others. `nTasks` is boxed again in the call to the <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> method. Once again, this creates ten new boxed variables, which are independent of each other, `nTasks`, and the ten boxed variables created in the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> method. The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.  \n  \n Although you can box a value type variable before calling <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this. Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.  \n  \n [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]\n [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  \n  \n When selecting an object on which to synchronize, you should lock only on private or internal objects. Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.  \n  \n Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.  \n  \n<a name=\"CriticalSection\"></a>   \n## The critical section  \n Use the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods to mark the beginning and end of a critical section.  \n  \n> [!NOTE]\n>  The functionality provided by the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods is identical to that provided by the [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic, except that the language constructs wrap the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=fullName> method overload and the <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> method in a `try`â€¦`finally` block to ensure that the monitor is released.  \n  \n If the critical section is a set of contiguous instructions, then the lock acquired by the <xref:System.Threading.Monitor.Enter%2A> method guarantees that only a single thread can execute the enclosed code with the locked object. In this case, we recommend that you place that code in a `try` block and place the call to the <xref:System.Threading.Monitor.Exit%2A> method in a `finally` block. This ensures that the lock is released even if an exception occurs. The following code fragment illustrates this pattern.  \n  \n [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]\n [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  \n  \n This facility is typically used to synchronize access to a static or instance method of a class.  \n  \n If a critical section spans an entire method, the locking facility can be achieved by placing the <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=fullName> on the method, and specifying the <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> value in the constructor of <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=fullName>. When you use this attribute, the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> method calls are not needed. The following code fragment illustrates this pattern:  \n  \n [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]\n [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  \n  \n Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <xref:System.Threading.Monitor> class, the C# [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement, or the Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement inside of the method instead of the attribute.  \n  \n While it is possible for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.  \n  \n<a name=\"Pulse\"></a>   \n## Pulse, PulseAll, and Wait  \n Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <xref:System.Threading.Monitor.Wait%2A?displayProperty=fullName>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=fullName>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=fullName> methods.  \n  \n <xref:System.Threading.Monitor.Wait%2A> releases the lock if it is held, allows a waiting thread or threads to obtain the lock and enter the critical section,   and waits to be notified by a call to the <xref:System.Threading.Monitor.Pulse%2A?displayProperty=fullName> or <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=fullName> method. When <xref:System.Threading.Monitor.Wait%2A> is notified, it returns and obtains the lock again.  \n  \n Both <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> signal for the next thread in the wait queue to proceed.  \n  \n<a name=\"WaitHandles\"></a>   \n## Monitors and wait handles  \n It is important to note the distinction between the use of the <xref:System.Threading.Monitor> class and <xref:System.Threading.WaitHandle> objects.  \n  \n-   The <xref:System.Threading.Monitor> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.  \n  \n-   <xref:System.Threading.WaitHandle> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.","nodes":[{"pos":[0,823],"content":"The <xref:System.Threading.Monitor> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=fullName>, and <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> methods. Object locks provide the ability to restrict access to a block of code, commonly called a critical section. While a thread owns the lock for an object, no other thread can acquire that lock. You can also use the <xref:System.Threading.Monitor> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.","nodes":[{"content":"The <xref:System.Threading.Monitor> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=fullName>, and <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> methods. Object locks provide the ability to restrict access to a block of code, commonly called a critical section. While a thread owns the lock for an object, no other thread can acquire that lock. You can also use the <xref:System.Threading.Monitor> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.","pos":[0,823],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.TryEnter%2A?displayProperty=fullName&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName&gt;</ph> methods.","pos":[0,378],"source":"The <xref:System.Threading.Monitor> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=fullName>, and <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> methods."},{"content":"Object locks provide the ability to restrict access to a block of code, commonly called a critical section.","pos":[379,486]},{"content":"While a thread owns the lock for an object, no other thread can acquire that lock.","pos":[487,569]},{"content":"You can also use the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.","pos":[570,823],"source":" You can also use the <xref:System.Threading.Monitor> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object."}]}]},{"pos":[830,846],"content":"In this article:","nodes":[{"content":"In this article:","pos":[0,16]}]},{"pos":[853,1056],"content":"[The Monitor class: An overview](#Overview)   \n [The lock object](#Lock)   \n [The critical section](#CriticalSection)   \n [Pulse, PulseAll, and Wait](#Pulse)   \n [Monitors and wait handles](#WaitHandles)","nodes":[{"content":"<bpt id=\"p1\">[</bpt>The Monitor class: An overview<ept id=\"p1\">](#Overview)</ept><ph id=\"ph1\"> </ph>","pos":[0,44],"source":"[The Monitor class: An overview](#Overview) "},{"content":"<bpt id=\"p1\"> [</bpt>The lock object<ept id=\"p1\">](#Lock)</ept><ph id=\"ph1\"> </ph>","pos":[47,73],"source":" [The lock object](#Lock) "},{"content":"<bpt id=\"p1\"> [</bpt>The critical section<ept id=\"p1\">](#CriticalSection)</ept><ph id=\"ph1\"> </ph>","pos":[76,118],"source":" [The critical section](#CriticalSection) "},{"content":"<bpt id=\"p1\"> [</bpt>Pulse, PulseAll, and Wait<ept id=\"p1\">](#Pulse)</ept><ph id=\"ph1\"> </ph>","pos":[121,158],"source":" [Pulse, PulseAll, and Wait](#Pulse) "},{"content":"<bpt id=\"p1\"> [</bpt>Monitors and wait handles<ept id=\"p1\">](#WaitHandles)</ept>","pos":[161,203],"source":" [Monitors and wait handles](#WaitHandles)"}]},{"pos":[1092,1122],"content":"The Monitor class: An overview","linkify":"The Monitor class: An overview","nodes":[{"content":"The Monitor class: An overview","pos":[0,30]}]},{"pos":[1126,1185],"content":"<xref:System.Threading.Monitor> has the following features:","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> has the following features:","pos":[0,59],"source":"<xref:System.Threading.Monitor> has the following features:"}]},{"pos":[1195,1237],"content":"It is associated with an object on demand.","nodes":[{"content":"It is associated with an object on demand.","pos":[0,42]}]},{"pos":[1247,1317],"content":"It is unbound, which means it can be called directly from any context.","nodes":[{"content":"It is unbound, which means it can be called directly from any context.","pos":[0,70]}]},{"pos":[1327,1567],"content":"An instance of the <xref:System.Threading.Monitor> class cannot be created; the methods of the <xref:System.Threading.Monitor> class are all static. Each method is passed the synchronized object that controls access to the critical section.","nodes":[{"content":"An instance of the <xref:System.Threading.Monitor> class cannot be created; the methods of the <xref:System.Threading.Monitor> class are all static. Each method is passed the synchronized object that controls access to the critical section.","pos":[0,240],"nodes":[{"content":"An instance of the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class cannot be created; the methods of the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor&gt;</ph> class are all static.","pos":[0,148],"source":"An instance of the <xref:System.Threading.Monitor> class cannot be created; the methods of the <xref:System.Threading.Monitor> class are all static."},{"content":"Each method is passed the synchronized object that controls access to the critical section.","pos":[149,240]}]}]},{"pos":[1575,1889],"content":"[!NOTE]\n Use the <xref:System.Threading.Monitor> class to lock objects other than strings (that is, reference types other than <xref:System.String>), not value types. For details, see the overloads of the <xref:System.Threading.Monitor.Enter%2A> method and [The lock object](#Lock) section later in this article.","leadings":["","> "],"nodes":[{"content":" Use the <xref:System.Threading.Monitor> class to lock objects other than strings (that is, reference types other than <xref:System.String>), not value types. For details, see the overloads of the <xref:System.Threading.Monitor.Enter%2A> method and [The lock object](#Lock) section later in this article.","pos":[8,312],"nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class to lock objects other than strings (that is, reference types other than <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>), not value types.","pos":[1,158],"source":" Use the <xref:System.Threading.Monitor> class to lock objects other than strings (that is, reference types other than <xref:System.String>), not value types."},{"content":"For details, see the overloads of the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> method and <bpt id=\"p1\">[</bpt>The lock object<ept id=\"p1\">](#Lock)</ept> section later in this article.","pos":[159,304],"source":" For details, see the overloads of the <xref:System.Threading.Monitor.Enter%2A> method and [The lock object](#Lock) section later in this article."}]}]},{"pos":[1896,2000],"content":"The following table describes the actions that can be taken by threads that access synchronized objects:","nodes":[{"content":"The following table describes the actions that can be taken by threads that access synchronized objects:","pos":[0,104]}]},{"pos":[2007,2013],"content":"Action","nodes":[{"content":"Action","pos":[0,6]}]},{"pos":[2014,2025],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[2065,2150],"content":"<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>","pos":[0,85],"source":"<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>"}]},{"pos":[2151,2385],"content":"Acquires a lock for an object. This action also marks the beginning of a critical section. No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.","nodes":[{"content":"Acquires a lock for an object. This action also marks the beginning of a critical section. No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.","pos":[0,234],"nodes":[{"content":"Acquires a lock for an object.","pos":[0,30]},{"content":"This action also marks the beginning of a critical section.","pos":[31,90]},{"content":"No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.","pos":[91,234]}]}]},{"pos":[2390,2429],"content":"<xref:System.Threading.Monitor.Wait%2A>","nodes":[]},{"pos":[2430,2676],"content":"Releases the lock on an object in order to permit other threads to lock and access the object. The calling thread waits while another thread accesses the object. Pulse signals are used to notify waiting threads about changes to an object's state.","nodes":[{"content":"Releases the lock on an object in order to permit other threads to lock and access the object. The calling thread waits while another thread accesses the object. Pulse signals are used to notify waiting threads about changes to an object's state.","pos":[0,246],"nodes":[{"content":"Releases the lock on an object in order to permit other threads to lock and access the object.","pos":[0,94]},{"content":"The calling thread waits while another thread accesses the object.","pos":[95,161]},{"content":"Pulse signals are used to notify waiting threads about changes to an object's state.","pos":[162,246]}]}]},{"pos":[2681,2775],"content":"<xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A>","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> (signal), <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>","pos":[0,94],"source":"<xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A>"}]},{"pos":[2776,3200],"content":"Sends a signal to one or more waiting threads. The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock. The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object. Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.","nodes":[{"content":"Sends a signal to one or more waiting threads. The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock. The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object. Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.","pos":[0,424],"nodes":[{"content":"Sends a signal to one or more waiting threads.","pos":[0,46]},{"content":"The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock.","pos":[47,188]},{"content":"The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object.","pos":[189,306]},{"content":"Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.","pos":[307,424]}]}]},{"pos":[3205,3244],"content":"<xref:System.Threading.Monitor.Exit%2A>","nodes":[]},{"pos":[3245,3361],"content":"Releases the lock on an object. This action also marks the end of a critical section protected by the locked object.","nodes":[{"content":"Releases the lock on an object. This action also marks the end of a critical section protected by the locked object.","pos":[0,116],"nodes":[{"content":"Releases the lock on an object.","pos":[0,31]},{"content":"This action also marks the end of a critical section protected by the locked object.","pos":[32,116]}]}]},{"pos":[3369,3953],"content":"Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], there are two sets of overloads for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.TryEnter%2A> methods. One set of overloads has a `ref` (in C#) or `ByRef` (in Visual Basic) <xref:System.Boolean> parameter that is atomically set to `true` if the lock is acquired, even if an exception is thrown when acquiring the lock. Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.","nodes":[{"content":"Beginning with the <ph id=\"ph1\">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, there are two sets of overloads for the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph> methods.","pos":[0,213],"source":"Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], there are two sets of overloads for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.TryEnter%2A> methods."},{"content":"One set of overloads has a <ph id=\"ph1\">`ref`</ph> (in C#) or <ph id=\"ph2\">`ByRef`</ph> (in Visual Basic) <ph id=\"ph3\">&lt;xref:System.Boolean&gt;</ph> parameter that is atomically set to <ph id=\"ph4\">`true`</ph> if the lock is acquired, even if an exception is thrown when acquiring the lock.","pos":[214,429],"source":" One set of overloads has a `ref` (in C#) or `ByRef` (in Visual Basic) <xref:System.Boolean> parameter that is atomically set to `true` if the lock is acquired, even if an exception is thrown when acquiring the lock."},{"content":"Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.","pos":[430,584]}]},{"pos":[3985,4000],"content":"The lock object","linkify":"The lock object","nodes":[{"content":"The lock object","pos":[0,15]}]},{"pos":[4004,4232],"content":"The Monitor class consists of `static` (in C#) or  `Shared` (in Visual Basic) methods that operate on an object that controls access to the critical section.  The following information is maintained for each synchronized object:","nodes":[{"content":"The Monitor class consists of <ph id=\"ph1\">`static`</ph> (in C#) or  <ph id=\"ph2\">`Shared`</ph> (in Visual Basic) methods that operate on an object that controls access to the critical section.","pos":[0,157],"source":"The Monitor class consists of `static` (in C#) or  `Shared` (in Visual Basic) methods that operate on an object that controls access to the critical section."},{"content":"The following information is maintained for each synchronized object:","pos":[159,228]}]},{"pos":[4242,4298],"content":"A reference to the thread that currently holds the lock.","nodes":[{"content":"A reference to the thread that currently holds the lock.","pos":[0,56]}]},{"pos":[4308,4399],"content":"A reference to a ready queue, which contains the threads that are ready to obtain the lock.","nodes":[{"content":"A reference to a ready queue, which contains the threads that are ready to obtain the lock.","pos":[0,91]}]},{"pos":[4409,4548],"content":"A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.","nodes":[{"content":"A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.","pos":[0,139]}]},{"pos":[4555,5329],"content":"<xref:System.Threading.Monitor> locks objects (that is, reference types), not value types. While you can pass a value type to <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, it is boxed separately for each call. Since each call creates a separate object, <xref:System.Threading.Monitor.Enter%2A> never blocks, and the code it is supposedly protecting is not really synchronized. In addition, the object passed to <xref:System.Threading.Monitor.Exit%2A> is different from the object passed to <xref:System.Threading.Monitor.Enter%2A>, so <xref:System.Threading.Monitor> throws <xref:System.Threading.SynchronizationLockException> exception with the message \"Object synchronization method was called from an unsynchronized block of code.\"","nodes":[{"content":"<xref:System.Threading.Monitor> locks objects (that is, reference types), not value types. While you can pass a value type to <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, it is boxed separately for each call. Since each call creates a separate object, <xref:System.Threading.Monitor.Enter%2A> never blocks, and the code it is supposedly protecting is not really synchronized. In addition, the object passed to <xref:System.Threading.Monitor.Exit%2A> is different from the object passed to <xref:System.Threading.Monitor.Enter%2A>, so <xref:System.Threading.Monitor> throws <xref:System.Threading.SynchronizationLockException> exception with the message \"Object synchronization method was called from an unsynchronized block of code.\"","pos":[0,774],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> locks objects (that is, reference types), not value types.","pos":[0,90],"source":"<xref:System.Threading.Monitor> locks objects (that is, reference types), not value types."},{"content":"While you can pass a value type to <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, it is boxed separately for each call.","pos":[91,249],"source":" While you can pass a value type to <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, it is boxed separately for each call."},{"content":"Since each call creates a separate object, <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> never blocks, and the code it is supposedly protecting is not really synchronized.","pos":[250,416],"source":" Since each call creates a separate object, <xref:System.Threading.Monitor.Enter%2A> never blocks, and the code it is supposedly protecting is not really synchronized."},{"content":"In addition, the object passed to <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> is different from the object passed to <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, so <ph id=\"ph3\">&lt;xref:System.Threading.Monitor&gt;</ph> throws <ph id=\"ph4\">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> exception with the message \"Object synchronization method was called from an unsynchronized block of code.\"","pos":[417,774],"source":" In addition, the object passed to <xref:System.Threading.Monitor.Exit%2A> is different from the object passed to <xref:System.Threading.Monitor.Enter%2A>, so <xref:System.Threading.Monitor> throws <xref:System.Threading.SynchronizationLockException> exception with the message \"Object synchronization method was called from an unsynchronized block of code.\""}]}]},{"pos":[5336,5903],"content":"The following example illustrates this problem. It launches ten tasks, each of which just sleeps for 250 milliseconds. Each task then updates a counter variable, `nTasks`, which is intended to count the number of tasks that actually launched and executed. Because `nTasks` is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks. However, as the output from the example shows, each of the tasks throws a <xref:System.Threading.SynchronizationLockException> exception.","nodes":[{"content":"The following example illustrates this problem.","pos":[0,47]},{"content":"It launches ten tasks, each of which just sleeps for 250 milliseconds.","pos":[48,118]},{"content":"Each task then updates a counter variable, <ph id=\"ph1\">`nTasks`</ph>, which is intended to count the number of tasks that actually launched and executed.","pos":[119,255],"source":" Each task then updates a counter variable, `nTasks`, which is intended to count the number of tasks that actually launched and executed."},{"content":"Because <ph id=\"ph1\">`nTasks`</ph> is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks.","pos":[256,429],"source":" Because `nTasks` is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks."},{"content":"However, as the output from the example shows, each of the tasks throws a <ph id=\"ph1\">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> exception.","pos":[430,567],"source":" However, as the output from the example shows, each of the tasks throws a <xref:System.Threading.SynchronizationLockException> exception."}]},{"pos":[5910,6147],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Conceptual.Monitors#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>Conceptual.Monitors#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)</ept><ept id=\"p3\">]</ept>","leadings":[""," "],"source":"[!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]\n[!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]"},{"pos":[6154,6964],"content":"Each task throws a <xref:System.Threading.SynchronizationLockException> exception because the `nTasks` variable is boxed before the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> method in each task. In other words, each method call is passed a separate variable that is independent of the others. `nTasks` is boxed again in the call to the <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> method. Once again, this creates ten new boxed variables, which are independent of each other, `nTasks`, and the ten boxed variables created in the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> method. The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.","nodes":[{"content":"Each task throws a <ph id=\"ph1\">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> exception because the <ph id=\"ph2\">`nTasks`</ph> variable is boxed before the call to the <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;</ph> method in each task.","pos":[0,230],"source":"Each task throws a <xref:System.Threading.SynchronizationLockException> exception because the `nTasks` variable is boxed before the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> method in each task."},{"content":"In other words, each method call is passed a separate variable that is independent of the others.","pos":[231,328]},{"content":"<ph id=\"ph1\">`nTasks`</ph> is boxed again in the call to the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName&gt;</ph> method.","pos":[329,444],"source":"`nTasks` is boxed again in the call to the <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> method."},{"content":"Once again, this creates ten new boxed variables, which are independent of each other, <ph id=\"ph1\">`nTasks`</ph>, and the ten boxed variables created in the call to the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName&gt;</ph> method.","pos":[445,670],"source":" Once again, this creates ten new boxed variables, which are independent of each other, `nTasks`, and the ten boxed variables created in the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> method."},{"content":"The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.","pos":[671,810]}]},{"pos":[6971,7362],"content":"Although you can box a value type variable before calling <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this. Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.","nodes":[{"content":"Although you can box a value type variable before calling <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this. Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.","pos":[0,391],"nodes":[{"content":"Although you can box a value type variable before calling <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this.","pos":[0,263],"source":"Although you can box a value type variable before calling <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this."},{"content":"Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.","pos":[264,391]}]}]},{"pos":[7369,7604],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>Conceptual.Monitors#3<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>Conceptual.Monitors#3<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)</ept><ept id=\"p3\">]</ept>","leadings":[""," "],"source":"[!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]\n[!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]"},{"pos":[7611,7856],"content":"When selecting an object on which to synchronize, you should lock only on private or internal objects. Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.","nodes":[{"content":"When selecting an object on which to synchronize, you should lock only on private or internal objects. Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.","pos":[0,245],"nodes":[{"content":"When selecting an object on which to synchronize, you should lock only on private or internal objects.","pos":[0,102]},{"content":"Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.","pos":[103,245]}]}]},{"pos":[7863,8016],"content":"Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.","nodes":[{"content":"Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <ph id=\"ph1\">&lt;xref:System.MarshalByRefObject&gt;</ph>.","pos":[0,153],"source":"Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>."}]},{"pos":[8059,8079],"content":"The critical section","linkify":"The critical section","nodes":[{"content":"The critical section","pos":[0,20]}]},{"pos":[8083,8236],"content":"Use the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods to mark the beginning and end of a critical section.","nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> methods to mark the beginning and end of a critical section.","pos":[0,153],"source":"Use the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods to mark the beginning and end of a critical section."}]},{"pos":[8244,8931],"content":"[!NOTE]\n The functionality provided by the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods is identical to that provided by the [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic, except that the language constructs wrap the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=fullName> method overload and the <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> method in a `try`â€¦`finally` block to ensure that the monitor is released.","leadings":["","> "],"nodes":[{"content":" The functionality provided by the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods is identical to that provided by the [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic, except that the language constructs wrap the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=fullName> method overload and the <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> method in a `try`â€¦`finally` block to ensure that the monitor is released.","pos":[8,685],"nodes":[{"content":"The functionality provided by the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> methods is identical to that provided by the <bpt id=\"p1\">[</bpt>lock<ept id=\"p1\">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> statement in C# and the <bpt id=\"p2\">[</bpt>SyncLock<ept id=\"p2\">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> statement in Visual Basic, except that the language constructs wrap the <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=fullName&gt;</ph> method overload and the <ph id=\"ph4\">&lt;xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName&gt;</ph> method in a <ph id=\"ph5\">`try`</ph>â€¦<ph id=\"ph6\">`finally`</ph>","pos":[1,631],"source":" The functionality provided by the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods is identical to that provided by the [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic, except that the language constructs wrap the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=fullName> method overload and the <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> method in a `try`â€¦`finally`"},{"content":"block to ensure that the monitor is released.","pos":[632,677]}]}]},{"pos":[8938,9453],"content":"If the critical section is a set of contiguous instructions, then the lock acquired by the <xref:System.Threading.Monitor.Enter%2A> method guarantees that only a single thread can execute the enclosed code with the locked object. In this case, we recommend that you place that code in a `try` block and place the call to the <xref:System.Threading.Monitor.Exit%2A> method in a `finally` block. This ensures that the lock is released even if an exception occurs. The following code fragment illustrates this pattern.","nodes":[{"content":"If the critical section is a set of contiguous instructions, then the lock acquired by the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> method guarantees that only a single thread can execute the enclosed code with the locked object.","pos":[0,229],"source":"If the critical section is a set of contiguous instructions, then the lock acquired by the <xref:System.Threading.Monitor.Enter%2A> method guarantees that only a single thread can execute the enclosed code with the locked object."},{"content":"In this case, we recommend that you place that code in a <ph id=\"ph1\">`try`</ph> block and place the call to the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> method in a <ph id=\"ph3\">`finally`</ph> block.","pos":[230,393],"source":" In this case, we recommend that you place that code in a `try` block and place the call to the <xref:System.Threading.Monitor.Exit%2A> method in a `finally` block."},{"content":"This ensures that the lock is released even if an exception occurs.","pos":[394,461]},{"content":"The following code fragment illustrates this pattern.","pos":[462,515]}]},{"pos":[9460,9755],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Threading.Monitor.Class#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Threading.Monitor.Class#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]\n [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]"},{"pos":[9762,9858],"content":"This facility is typically used to synchronize access to a static or instance method of a class.","nodes":[{"content":"This facility is typically used to synchronize access to a static or instance method of a class.","pos":[0,96]}]},{"pos":[9865,10464],"content":"If a critical section spans an entire method, the locking facility can be achieved by placing the <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=fullName> on the method, and specifying the <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> value in the constructor of <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=fullName>. When you use this attribute, the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> method calls are not needed. The following code fragment illustrates this pattern:","nodes":[{"content":"If a critical section spans an entire method, the locking facility can be achieved by placing the <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=fullName> on the method, and specifying the <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> value in the constructor of <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=fullName>. When you use this attribute, the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> method calls are not needed. The following code fragment illustrates this pattern:","pos":[0,599],"nodes":[{"content":"If a critical section spans an entire method, the locking facility can be achieved by placing the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=fullName&gt;</ph> on the method, and specifying the <ph id=\"ph2\">&lt;xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized&gt;</ph> value in the constructor of <ph id=\"ph3\">&lt;xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=fullName&gt;</ph>.","pos":[0,398],"source":"If a critical section spans an entire method, the locking facility can be achieved by placing the <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=fullName> on the method, and specifying the <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> value in the constructor of <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=fullName>."},{"content":"When you use this attribute, the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> method calls are not needed.","pos":[399,545],"source":" When you use this attribute, the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> method calls are not needed."},{"content":"The following code fragment illustrates this pattern:","pos":[546,599]}]}]},{"pos":[10471,10766],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Threading.Monitor.Class#3<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Threading.Monitor.Class#3<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]\n [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]"},{"pos":[10773,11195],"content":"Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class, the C# <bpt id=\"p1\">[</bpt>lock<ept id=\"p1\">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> statement, or the Visual Basic <bpt id=\"p2\">[</bpt>SyncLock<ept id=\"p2\">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> statement inside of the method instead of the attribute.","source":"Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <xref:System.Threading.Monitor> class, the C# [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement, or the Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement inside of the method instead of the attribute."},{"pos":[11202,11442],"content":"While it is possible for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.","nodes":[{"content":"While it is possible for the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.","pos":[0,240],"source":"While it is possible for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended."}]},{"pos":[11475,11500],"content":"Pulse, PulseAll, and Wait","linkify":"Pulse, PulseAll, and Wait","nodes":[{"content":"Pulse, PulseAll, and Wait","pos":[0,25]}]},{"pos":[11504,11823],"content":"Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <xref:System.Threading.Monitor.Wait%2A?displayProperty=fullName>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=fullName>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=fullName> methods.","nodes":[{"content":"Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A?displayProperty=fullName&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=fullName&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=fullName&gt;</ph> methods.","pos":[0,319],"source":"Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <xref:System.Threading.Monitor.Wait%2A?displayProperty=fullName>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=fullName>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=fullName> methods."}]},{"pos":[11830,12275],"content":"<xref:System.Threading.Monitor.Wait%2A> releases the lock if it is held, allows a waiting thread or threads to obtain the lock and enter the critical section,   and waits to be notified by a call to the <xref:System.Threading.Monitor.Pulse%2A?displayProperty=fullName> or <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=fullName> method. When <xref:System.Threading.Monitor.Wait%2A> is notified, it returns and obtains the lock again.","nodes":[{"content":"<xref:System.Threading.Monitor.Wait%2A> releases the lock if it is held, allows a waiting thread or threads to obtain the lock and enter the critical section,   and waits to be notified by a call to the <xref:System.Threading.Monitor.Pulse%2A?displayProperty=fullName> or <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=fullName> method. When <xref:System.Threading.Monitor.Wait%2A> is notified, it returns and obtains the lock again.","pos":[0,445],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> releases the lock if it is held, allows a waiting thread or threads to obtain the lock and enter the critical section,   and waits to be notified by a call to the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A?displayProperty=fullName&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.PulseAll%2A?displayProperty=fullName&gt;</ph> method.","pos":[0,348],"source":"<xref:System.Threading.Monitor.Wait%2A> releases the lock if it is held, allows a waiting thread or threads to obtain the lock and enter the critical section,   and waits to be notified by a call to the <xref:System.Threading.Monitor.Pulse%2A?displayProperty=fullName> or <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=fullName> method."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> is notified, it returns and obtains the lock again.","pos":[349,445],"source":" When <xref:System.Threading.Monitor.Wait%2A> is notified, it returns and obtains the lock again."}]}]},{"pos":[12282,12432],"content":"Both <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> signal for the next thread in the wait queue to proceed.","nodes":[{"content":"Both <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> signal for the next thread in the wait queue to proceed.","pos":[0,150],"source":"Both <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> signal for the next thread in the wait queue to proceed."}]},{"pos":[12471,12496],"content":"Monitors and wait handles","linkify":"Monitors and wait handles","nodes":[{"content":"Monitors and wait handles","pos":[0,25]}]},{"pos":[12500,12648],"content":"It is important to note the distinction between the use of the <xref:System.Threading.Monitor> class and <xref:System.Threading.WaitHandle> objects.","nodes":[{"content":"It is important to note the distinction between the use of the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class and <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle&gt;</ph> objects.","pos":[0,148],"source":"It is important to note the distinction between the use of the <xref:System.Threading.Monitor> class and <xref:System.Threading.WaitHandle> objects."}]},{"pos":[12658,12814],"content":"The <xref:System.Threading.Monitor> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.","pos":[0,156],"source":"The <xref:System.Threading.Monitor> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements."}]},{"pos":[12824,13077],"content":"<xref:System.Threading.WaitHandle> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.","pos":[0,253],"source":"<xref:System.Threading.WaitHandle> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once."}]}],"pos":[1498,14689],"yaml":true,"extradata":"MT"},{"content":"Acquires an exclusive lock on the specified object.","nodes":[{"pos":[0,51],"content":"Acquires an exclusive lock on the specified object.","nodes":[{"content":"Acquires an exclusive lock on the specified object.","pos":[0,51]}]}],"pos":[22173,22225],"yaml":true},{"content":"Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the parameter. If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object. It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.  \n  \n Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. When you pass a value type variable to `Enter`, it is boxed as an object. If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block. In this case, the code that `Monitor` is supposedly protecting is not protected. Furthermore, when you pass the variable to `Exit`, still another separate object is created. Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>. For more information, see the conceptual topic [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).  \n  \n <xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object. A <xref:System.Threading.ThreadInterruptedException> will be thrown.  \n  \n Use a C# `try`â€¦`finally` block (`Try`â€¦`Finally` in Visual Basic) to ensure that you release the monitor, or use the C# `lock` statement (`SyncLock` statement in Visual Basic), which wraps the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods in a `try`â€¦`finally` block.","nodes":[{"pos":[0,511],"content":"Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the parameter. If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object. It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.","nodes":[{"content":"Use <ph id=\"ph1\">`Enter`</ph> to acquire the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor&gt;</ph> on the object passed as the parameter.","pos":[0,97],"source":"Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the parameter."},{"content":"If another thread has executed an <ph id=\"ph1\">`Enter`</ph> on the object but has not yet executed the corresponding <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, the current thread will block until the other thread releases the object.","pos":[98,311],"source":" If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object."},{"content":"It is legal for the same thread to invoke <ph id=\"ph1\">`Enter`</ph> more than once without it blocking; however, an equal number of <ph id=\"ph2\">`Exit`</ph> calls must be invoked before other threads waiting on the object will unblock.","pos":[312,511],"source":" It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock."}]},{"pos":[518,1261],"content":"Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. When you pass a value type variable to `Enter`, it is boxed as an object. If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block. In this case, the code that `Monitor` is supposedly protecting is not protected. Furthermore, when you pass the variable to `Exit`, still another separate object is created. Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>. For more information, see the conceptual topic [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).","nodes":[{"content":"Use <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.","pos":[0,96],"source":"Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types."},{"content":"When you pass a value type variable to <ph id=\"ph1\">`Enter`</ph>, it is boxed as an object.","pos":[97,170],"source":" When you pass a value type variable to `Enter`, it is boxed as an object."},{"content":"If you pass the same variable to <ph id=\"ph1\">`Enter`</ph> again, it is boxed as a separate object, and the thread does not block.","pos":[171,283],"source":" If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block."},{"content":"In this case, the code that <ph id=\"ph1\">`Monitor`</ph> is supposedly protecting is not protected.","pos":[284,364],"source":" In this case, the code that `Monitor` is supposedly protecting is not protected."},{"content":"Furthermore, when you pass the variable to <ph id=\"ph1\">`Exit`</ph>, still another separate object is created.","pos":[365,457],"source":" Furthermore, when you pass the variable to `Exit`, still another separate object is created."},{"content":"Because the object passed to <ph id=\"ph1\">`Exit`</ph> is different from the object passed to <ph id=\"ph2\">`Enter`</ph>, <ph id=\"ph3\">`Monitor`</ph> throws <ph id=\"ph4\">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.","pos":[458,612],"source":" Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>."},{"content":"For more information, see the conceptual topic <bpt id=\"p1\">[</bpt>Monitors<ept id=\"p1\">](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)</ept>.","pos":[613,743],"source":" For more information, see the conceptual topic [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)."}]},{"pos":[1268,1454],"content":"<xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object. A <xref:System.Threading.ThreadInterruptedException> will be thrown.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Thread.Interrupt%2A&gt;</ph> can interrupt threads that are waiting to enter a <ph id=\"ph2\">`Monitor`</ph> on an object.","pos":[0,117],"source":"<xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object."},{"content":"A <ph id=\"ph1\">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> will be thrown.","pos":[118,186],"source":" A <xref:System.Threading.ThreadInterruptedException> will be thrown."}]},{"pos":[1461,1773],"content":"Use a C# `try`â€¦`finally` block (`Try`â€¦`Finally` in Visual Basic) to ensure that you release the monitor, or use the C# `lock` statement (`SyncLock` statement in Visual Basic), which wraps the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods in a `try`â€¦`finally` block.","nodes":[{"content":"Use a C# <ph id=\"ph1\">`try`</ph>â€¦<ph id=\"ph2\">`finally`</ph>","pos":[0,24],"source":"Use a C# `try`â€¦`finally`"},{"content":"block (<ph id=\"ph1\">`Try`</ph>â€¦<ph id=\"ph2\">`Finally`</ph>","pos":[25,47],"source":" block (`Try`â€¦`Finally`"},{"content":"in Visual Basic) to ensure that you release the monitor, or use the C# <ph id=\"ph1\">`lock`</ph> statement (<ph id=\"ph2\">`SyncLock`</ph> statement in Visual Basic), which wraps the <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> methods in a <ph id=\"ph5\">`try`</ph>â€¦<ph id=\"ph6\">`finally`</ph>","pos":[48,305],"source":" in Visual Basic) to ensure that you release the monitor, or use the C# `lock` statement (`SyncLock` statement in Visual Basic), which wraps the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods in a `try`â€¦`finally`"},{"content":"block.","pos":[306,312]}]}],"pos":[22236,24018],"yaml":true,"extradata":"MT"},{"content":"The object on which to acquire the monitor lock.","nodes":[{"pos":[0,48],"content":"The object on which to acquire the monitor lock.","nodes":[{"content":"The object on which to acquire the monitor lock.","pos":[0,48]}]}],"pos":[24565,24614],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[24774,24816],"yaml":true},{"content":"Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.","nodes":[{"pos":[0,122],"content":"Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.","nodes":[{"content":"Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.","pos":[0,122]}]}],"pos":[26343,26466],"yaml":true},{"content":"Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the `obj` parameter. If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object. It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.  \n  \n If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends. This allows the program to determine, in all cases, whether it is necessary to release the lock. If this method returns without throwing an exception, the variable specified for the `lockTaken` parameter is always `true`, and there is no need to test it.  \n  \n Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. When you pass a value type variable to `Enter`, it is boxed as an object. If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block. In this case, the code that `Monitor` is supposedly protecting is not protected. Furthermore, when you pass the variable to `Exit`, another separate object is created. Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>. For more information, see the conceptual topic [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).  \n  \n <xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object. A <xref:System.Threading.ThreadInterruptedException> will be thrown.","nodes":[{"pos":[0,517],"content":"Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the `obj` parameter. If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object. It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.","nodes":[{"content":"Use <ph id=\"ph1\">`Enter`</ph> to acquire the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor&gt;</ph> on the object passed as the <ph id=\"ph3\">`obj`</ph> parameter.","pos":[0,103],"source":"Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the `obj` parameter."},{"content":"If another thread has executed an <ph id=\"ph1\">`Enter`</ph> on the object but has not yet executed the corresponding <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph>, the current thread will block until the other thread releases the object.","pos":[104,317],"source":" If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object."},{"content":"It is legal for the same thread to invoke <ph id=\"ph1\">`Enter`</ph> more than once without it blocking; however, an equal number of <ph id=\"ph2\">`Exit`</ph> calls must be invoked before other threads waiting on the object will unblock.","pos":[318,517],"source":" It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock."}]},{"pos":[524,925],"content":"If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends. This allows the program to determine, in all cases, whether it is necessary to release the lock. If this method returns without throwing an exception, the variable specified for the `lockTaken` parameter is always `true`, and there is no need to test it.","nodes":[{"content":"If the lock was not taken because an exception was thrown, the variable specified for the <ph id=\"ph1\">`lockTaken`</ph> parameter is <ph id=\"ph2\">`false`</ph> after this method ends.","pos":[0,146],"source":"If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends."},{"content":"This allows the program to determine, in all cases, whether it is necessary to release the lock.","pos":[147,243]},{"content":"If this method returns without throwing an exception, the variable specified for the <ph id=\"ph1\">`lockTaken`</ph> parameter is always <ph id=\"ph2\">`true`</ph>, and there is no need to test it.","pos":[244,401],"source":" If this method returns without throwing an exception, the variable specified for the `lockTaken` parameter is always `true`, and there is no need to test it."}]},{"pos":[932,1669],"content":"Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. When you pass a value type variable to `Enter`, it is boxed as an object. If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block. In this case, the code that `Monitor` is supposedly protecting is not protected. Furthermore, when you pass the variable to `Exit`, another separate object is created. Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>. For more information, see the conceptual topic [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).","nodes":[{"content":"Use <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.","pos":[0,96],"source":"Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types."},{"content":"When you pass a value type variable to <ph id=\"ph1\">`Enter`</ph>, it is boxed as an object.","pos":[97,170],"source":" When you pass a value type variable to `Enter`, it is boxed as an object."},{"content":"If you pass the same variable to <ph id=\"ph1\">`Enter`</ph> again, it is boxed as a separate object, and the thread does not block.","pos":[171,283],"source":" If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block."},{"content":"In this case, the code that <ph id=\"ph1\">`Monitor`</ph> is supposedly protecting is not protected.","pos":[284,364],"source":" In this case, the code that `Monitor` is supposedly protecting is not protected."},{"content":"Furthermore, when you pass the variable to <ph id=\"ph1\">`Exit`</ph>, another separate object is created.","pos":[365,451],"source":" Furthermore, when you pass the variable to `Exit`, another separate object is created."},{"content":"Because the object passed to <ph id=\"ph1\">`Exit`</ph> is different from the object passed to <ph id=\"ph2\">`Enter`</ph>, <ph id=\"ph3\">`Monitor`</ph> throws <ph id=\"ph4\">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph>.","pos":[452,606],"source":" Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>."},{"content":"For more information, see the conceptual topic <bpt id=\"p1\">[</bpt>Monitors<ept id=\"p1\">](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)</ept>.","pos":[607,737],"source":" For more information, see the conceptual topic [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db)."}]},{"pos":[1676,1862],"content":"<xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object. A <xref:System.Threading.ThreadInterruptedException> will be thrown.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Thread.Interrupt%2A&gt;</ph> can interrupt threads that are waiting to enter a <ph id=\"ph2\">`Monitor`</ph> on an object.","pos":[0,117],"source":"<xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object."},{"content":"A <ph id=\"ph1\">&lt;xref:System.Threading.ThreadInterruptedException&gt;</ph> will be thrown.","pos":[118,186],"source":" A <xref:System.Threading.ThreadInterruptedException> will be thrown."}]}],"pos":[26477,28348],"yaml":true,"extradata":"MT"},{"content":"The object on which to wait.","nodes":[{"pos":[0,28],"content":"The object on which to wait.","nodes":[{"content":"The object on which to wait.","pos":[0,28]}]}],"pos":[29237,29266],"yaml":true},{"content":"The result of the attempt to acquire the lock, passed by reference. The input must be `false`. The output is `true` if the lock is acquired; otherwise, the output is `false`. The output is set even if an exception occurs during the attempt to acquire the lock.  \n  \n Note   If no exception occurs, the output of this method is always `true`.","nodes":[{"pos":[0,260],"content":"The result of the attempt to acquire the lock, passed by reference. The input must be `false`. The output is `true` if the lock is acquired; otherwise, the output is `false`. The output is set even if an exception occurs during the attempt to acquire the lock.","nodes":[{"content":"The result of the attempt to acquire the lock, passed by reference.","pos":[0,67]},{"content":"The input must be <ph id=\"ph1\">`false`</ph>.","pos":[68,94],"source":" The input must be `false`."},{"content":"The output is <ph id=\"ph1\">`true`</ph> if the lock is acquired; otherwise, the output is <ph id=\"ph2\">`false`</ph>.","pos":[95,174],"source":" The output is `true` if the lock is acquired; otherwise, the output is `false`."},{"content":"The output is set even if an exception occurs during the attempt to acquire the lock.","pos":[175,260]}]},{"pos":[267,341],"content":"Note   If no exception occurs, the output of this method is always <ph id=\"ph1\">`true`</ph>.","source":"Note   If no exception occurs, the output of this method is always `true`."}],"pos":[29332,29678],"yaml":true},{"content":"The input to <code>lockTaken</code> is `true`.","nodes":[{"pos":[0,46],"content":"The input to <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`true`</ph>.","source":"The input to <code>lockTaken</code> is `true`."}],"pos":[29830,29877],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[29979,30021],"yaml":true},{"content":"Releases an exclusive lock on the specified object.","nodes":[{"pos":[0,51],"content":"Releases an exclusive lock on the specified object.","nodes":[{"content":"Releases an exclusive lock on the specified object.","pos":[0,51]}]}],"pos":[31450,31502],"yaml":true},{"content":"The calling thread must own the lock on the `obj` parameter. If the calling thread owns the lock on the specified object, and has made an equal number of `Exit` and <xref:System.Threading.Monitor.Enter%2A> calls for the object, then the lock is released. If the calling thread has not invoked `Exit` as many times as `Enter`, the lock is not released.  \n  \n If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock. If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls `Exit`. To move one or more waiting threads into the ready queue, call <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> before invoking `Exit`.","nodes":[{"pos":[0,351],"content":"The calling thread must own the lock on the `obj` parameter. If the calling thread owns the lock on the specified object, and has made an equal number of `Exit` and <xref:System.Threading.Monitor.Enter%2A> calls for the object, then the lock is released. If the calling thread has not invoked `Exit` as many times as `Enter`, the lock is not released.","nodes":[{"content":"The calling thread must own the lock on the <ph id=\"ph1\">`obj`</ph> parameter.","pos":[0,60],"source":"The calling thread must own the lock on the `obj` parameter."},{"content":"If the calling thread owns the lock on the specified object, and has made an equal number of <ph id=\"ph1\">`Exit`</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> calls for the object, then the lock is released.","pos":[61,254],"source":" If the calling thread owns the lock on the specified object, and has made an equal number of `Exit` and <xref:System.Threading.Monitor.Enter%2A> calls for the object, then the lock is released."},{"content":"If the calling thread has not invoked <ph id=\"ph1\">`Exit`</ph> as many times as <ph id=\"ph2\">`Enter`</ph>, the lock is not released.","pos":[255,351],"source":" If the calling thread has not invoked `Exit` as many times as `Enter`, the lock is not released."}]},{"pos":[358,815],"content":"If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock. If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls `Exit`. To move one or more waiting threads into the ready queue, call <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> before invoking `Exit`.","nodes":[{"content":"If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock.","pos":[0,118]},{"content":"If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls <ph id=\"ph1\">`Exit`</ph>.","pos":[119,282],"source":" If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls `Exit`."},{"content":"To move one or more waiting threads into the ready queue, call <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> before invoking <ph id=\"ph3\">`Exit`</ph>.","pos":[283,457],"source":" To move one or more waiting threads into the ready queue, call <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> before invoking `Exit`."}]}],"pos":[31513,32333],"yaml":true,"extradata":"MT"},{"content":"The object on which to release the lock.","nodes":[{"pos":[0,40],"content":"The object on which to release the lock.","nodes":[{"content":"The object on which to release the lock.","pos":[0,40]}]}],"pos":[32878,32919],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[33078,33120],"yaml":true},{"content":"The current thread does not own the lock for the specified object.","nodes":[{"pos":[0,66],"content":"The current thread does not own the lock for the specified object.","nodes":[{"content":"The current thread does not own the lock for the specified object.","pos":[0,66]}]}],"pos":[33256,33323],"yaml":true},{"content":"Determines whether the current thread holds the lock on the specified object.","nodes":[{"pos":[0,77],"content":"Determines whether the current thread holds the lock on the specified object.","nodes":[{"content":"Determines whether the current thread holds the lock on the specified object.","pos":[0,77]}]}],"pos":[34799,34877],"yaml":true},{"content":"This method works only for locks that are acquired by using the methods of the <xref:System.Threading.Monitor> class, or by using the C# `lock` statement or the Visual Basic `SyncLock` statement, which are implemented with <xref:System.Threading.Monitor>.  \n  \n Use this method with diagnostic tools, such as the <xref:System.Diagnostics.Debug.Assert%2A> method and the <xref:System.Diagnostics.Contracts.Contract> class, to debug locking issues that involve the <xref:System.Threading.Monitor>class.","nodes":[{"pos":[0,255],"content":"This method works only for locks that are acquired by using the methods of the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class, or by using the C# <ph id=\"ph2\">`lock`</ph> statement or the Visual Basic <ph id=\"ph3\">`SyncLock`</ph> statement, which are implemented with <ph id=\"ph4\">&lt;xref:System.Threading.Monitor&gt;</ph>.","source":"This method works only for locks that are acquired by using the methods of the <xref:System.Threading.Monitor> class, or by using the C# `lock` statement or the Visual Basic `SyncLock` statement, which are implemented with <xref:System.Threading.Monitor>."},{"pos":[262,500],"content":"Use this method with diagnostic tools, such as the <xref:System.Diagnostics.Debug.Assert%2A> method and the <xref:System.Diagnostics.Contracts.Contract> class, to debug locking issues that involve the <xref:System.Threading.Monitor>class.","nodes":[{"content":"Use this method with diagnostic tools, such as the <ph id=\"ph1\">&lt;xref:System.Diagnostics.Debug.Assert%2A&gt;</ph> method and the <ph id=\"ph2\">&lt;xref:System.Diagnostics.Contracts.Contract&gt;</ph> class, to debug locking issues that involve the <ph id=\"ph3\">&lt;xref:System.Threading.Monitor&gt;</ph>class.","pos":[0,238],"source":"Use this method with diagnostic tools, such as the <xref:System.Diagnostics.Debug.Assert%2A> method and the <xref:System.Diagnostics.Contracts.Contract> class, to debug locking issues that involve the <xref:System.Threading.Monitor>class."}]}],"pos":[34888,35393],"yaml":true,"extradata":"MT"},{"content":"The object to test.","nodes":[{"pos":[0,19],"content":"The object to test.","nodes":[{"content":"The object to test.","pos":[0,19]}]}],"pos":[35534,35554],"yaml":true},{"content":"`true` if the current thread holds the lock on <code>obj</code>; otherwise, `false`.","nodes":[{"pos":[0,84],"content":"<ph id=\"ph1\">`true`</ph> if the current thread holds the lock on <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept>; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the current thread holds the lock on <code>obj</code>; otherwise, `false`."}],"pos":[35612,35699],"yaml":true},{"content":"<code>obj</code> is `null`.","nodes":[{"pos":[0,27],"content":"<ph id=\"ph1\">&lt;code&gt;obj&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>obj</code> is `null`."}],"pos":[35863,35891],"yaml":true},{"content":"Notifies a thread in the waiting queue of a change in the locked object's state.","nodes":[{"pos":[0,80],"content":"Notifies a thread in the waiting queue of a change in the locked object's state.","nodes":[{"content":"Notifies a thread in the waiting queue of a change in the locked object's state.","pos":[0,80]}]}],"pos":[37343,37424],"yaml":true},{"content":"Only the current owner of the lock can signal a waiting object using `Pulse`.  \n  \n The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock. Upon receiving the pulse, the waiting thread is moved to the ready queue. When the thread that invoked `Pulse` releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.  \n  \n> [!IMPORTANT]\n>  The <xref:System.Threading.Monitor> class does not maintain state indicating that the <xref:System.Threading.Monitor.Pulse%2A> method has been called. Thus, if you call <xref:System.Threading.Monitor.Pulse%2A> when no threads are waiting, the next thread that calls <xref:System.Threading.Monitor.Wait%2A> blocks as if <xref:System.Threading.Monitor.Pulse%2A> had never been called. If two threads are using <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.Wait%2A> to interact, this could result in a deadlock. Contrast this with the behavior of the <xref:System.Threading.AutoResetEvent> class: If you signal an <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, and there are no threads waiting, the <xref:System.Threading.AutoResetEvent> remains in a signaled state until a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>. The <xref:System.Threading.AutoResetEvent> releases that thread and returns to the unsignaled state.  \n  \n Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.  \n  \n The `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.  \n  \n To signal multiple threads, use the <xref:System.Threading.Monitor.PulseAll%2A> method.","nodes":[{"pos":[0,77],"content":"Only the current owner of the lock can signal a waiting object using <ph id=\"ph1\">`Pulse`</ph>.","source":"Only the current owner of the lock can signal a waiting object using `Pulse`."},{"pos":[84,453],"content":"The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock. Upon receiving the pulse, the waiting thread is moved to the ready queue. When the thread that invoked `Pulse` releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.","nodes":[{"content":"The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock.","pos":[0,131]},{"content":"Upon receiving the pulse, the waiting thread is moved to the ready queue.","pos":[132,205]},{"content":"When the thread that invoked <ph id=\"ph1\">`Pulse`</ph> releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.","pos":[206,369],"source":" When the thread that invoked `Pulse` releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock."}]},{"pos":[461,1597],"content":"[!IMPORTANT]\n The <xref:System.Threading.Monitor> class does not maintain state indicating that the <xref:System.Threading.Monitor.Pulse%2A> method has been called. Thus, if you call <xref:System.Threading.Monitor.Pulse%2A> when no threads are waiting, the next thread that calls <xref:System.Threading.Monitor.Wait%2A> blocks as if <xref:System.Threading.Monitor.Pulse%2A> had never been called. If two threads are using <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.Wait%2A> to interact, this could result in a deadlock. Contrast this with the behavior of the <xref:System.Threading.AutoResetEvent> class: If you signal an <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, and there are no threads waiting, the <xref:System.Threading.AutoResetEvent> remains in a signaled state until a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>. The <xref:System.Threading.AutoResetEvent> releases that thread and returns to the unsignaled state.","leadings":["","> "],"nodes":[{"content":" The <xref:System.Threading.Monitor> class does not maintain state indicating that the <xref:System.Threading.Monitor.Pulse%2A> method has been called. Thus, if you call <xref:System.Threading.Monitor.Pulse%2A> when no threads are waiting, the next thread that calls <xref:System.Threading.Monitor.Wait%2A> blocks as if <xref:System.Threading.Monitor.Pulse%2A> had never been called. If two threads are using <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.Wait%2A> to interact, this could result in a deadlock. Contrast this with the behavior of the <xref:System.Threading.AutoResetEvent> class: If you signal an <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, and there are no threads waiting, the <xref:System.Threading.AutoResetEvent> remains in a signaled state until a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>. The <xref:System.Threading.AutoResetEvent> releases that thread and returns to the unsignaled state.","pos":[13,1134],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class does not maintain state indicating that the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method has been called.","pos":[1,151],"source":" The <xref:System.Threading.Monitor> class does not maintain state indicating that the <xref:System.Threading.Monitor.Pulse%2A> method has been called."},{"content":"Thus, if you call <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> when no threads are waiting, the next thread that calls <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> blocks as if <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> had never been called.","pos":[152,383],"source":" Thus, if you call <xref:System.Threading.Monitor.Pulse%2A> when no threads are waiting, the next thread that calls <xref:System.Threading.Monitor.Wait%2A> blocks as if <xref:System.Threading.Monitor.Pulse%2A> had never been called."},{"content":"If two threads are using <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> to interact, this could result in a deadlock.","pos":[384,539],"source":" If two threads are using <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.Wait%2A> to interact, this could result in a deadlock."},{"content":"Contrast this with the behavior of the <ph id=\"ph1\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> class: If you signal an <ph id=\"ph2\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> by calling its <ph id=\"ph3\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method, and there are no threads waiting, the <ph id=\"ph4\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> remains in a signaled state until a thread calls <ph id=\"ph5\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>, <ph id=\"ph6\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph>, or <ph id=\"ph7\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph>.","pos":[540,1020],"source":" Contrast this with the behavior of the <xref:System.Threading.AutoResetEvent> class: If you signal an <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, and there are no threads waiting, the <xref:System.Threading.AutoResetEvent> remains in a signaled state until a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> releases that thread and returns to the unsignaled state.","pos":[1021,1121],"source":" The <xref:System.Threading.AutoResetEvent> releases that thread and returns to the unsignaled state."}]}]},{"pos":[1604,1956],"content":"Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.","nodes":[{"content":"Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.","pos":[0,352]}]},{"pos":[1963,2130],"content":"The <ph id=\"ph1\">`Pulse`</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> methods must be invoked from within a synchronized block of code.","source":"The `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code."},{"pos":[2137,2224],"content":"To signal multiple threads, use the <xref:System.Threading.Monitor.PulseAll%2A> method.","nodes":[{"content":"To signal multiple threads, use the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.","pos":[0,87],"source":"To signal multiple threads, use the <xref:System.Threading.Monitor.PulseAll%2A> method."}]}],"pos":[37435,39673],"yaml":true,"extradata":"MT"},{"content":"The object a thread is waiting for.","nodes":[{"pos":[0,35],"content":"The object a thread is waiting for.","nodes":[{"content":"The object a thread is waiting for.","pos":[0,35]}]}],"pos":[39810,39846],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[40006,40048],"yaml":true},{"content":"The calling thread does not own the lock for the specified object.","nodes":[{"pos":[0,66],"content":"The calling thread does not own the lock for the specified object.","nodes":[{"content":"The calling thread does not own the lock for the specified object.","pos":[0,66]}]}],"pos":[40184,40251],"yaml":true},{"content":"Notifies all waiting threads of a change in the object's state.","nodes":[{"pos":[0,63],"content":"Notifies all waiting threads of a change in the object's state.","nodes":[{"content":"Notifies all waiting threads of a change in the object's state.","pos":[0,63]}]}],"pos":[41721,41785],"yaml":true},{"content":"The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object. After the signal is sent, the waiting threads are moved to the ready queue. When the thread that invoked `PulseAll` releases the lock, the next thread in the ready queue acquires the lock.  \n  \n Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.  \n  \n The <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.  \n  \n The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.  \n  \n To signal a single thread, use the `Pulse` method.","nodes":[{"pos":[0,337],"content":"The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object. After the signal is sent, the waiting threads are moved to the ready queue. When the thread that invoked `PulseAll` releases the lock, the next thread in the ready queue acquires the lock.","nodes":[{"content":"The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object.","pos":[0,148]},{"content":"After the signal is sent, the waiting threads are moved to the ready queue.","pos":[149,224]},{"content":"When the thread that invoked <ph id=\"ph1\">`PulseAll`</ph> releases the lock, the next thread in the ready queue acquires the lock.","pos":[225,337],"source":" When the thread that invoked `PulseAll` releases the lock, the next thread in the ready queue acquires the lock."}]},{"pos":[344,696],"content":"Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.","nodes":[{"content":"Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.","pos":[0,352]}]},{"pos":[703,870],"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id=\"ph2\">`PulseAll`</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> methods must be invoked from within a synchronized block of code.","source":"The <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code."},{"pos":[877,1048],"content":"The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.","nodes":[{"content":"The remarks for the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.","pos":[0,171],"source":"The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting."}]},{"pos":[1055,1105],"content":"To signal a single thread, use the <ph id=\"ph1\">`Pulse`</ph> method.","source":"To signal a single thread, use the `Pulse` method."}],"pos":[41796,42912],"yaml":true,"extradata":"MT"},{"content":"The object that sends the pulse.","nodes":[{"pos":[0,32],"content":"The object that sends the pulse.","nodes":[{"content":"The object that sends the pulse.","pos":[0,32]}]}],"pos":[43052,43085],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[43248,43290],"yaml":true},{"content":"The calling thread does not own the lock for the specified object.","nodes":[{"pos":[0,66],"content":"The calling thread does not own the lock for the specified object.","nodes":[{"content":"The calling thread does not own the lock for the specified object.","pos":[0,66]}]}],"pos":[43426,43493],"yaml":true},{"content":"Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.","nodes":[{"pos":[0,168],"content":"Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.","nodes":[{"content":"Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.","pos":[0,168]}]}],"pos":[45116,45285],"yaml":true},{"content":"If the value of the `timeout` parameter converted to milliseconds equals â€“1, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>. If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  \n  \n If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends. This allows the program to determine, in all cases, whether it is necessary to release the lock.  \n  \n> [!NOTE]\n>  Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For more information, see the <xref:System.Threading.Monitor> class topic.  \n  \n To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.  \n  \n [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]\n [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]","nodes":[{"pos":[0,289],"content":"If the value of the `timeout` parameter converted to milliseconds equals â€“1, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>. If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.","nodes":[{"content":"If the value of the <ph id=\"ph1\">`timeout`</ph> parameter converted to milliseconds equals â€“1, this method is equivalent to <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%28System.Object%29&gt;</ph>.","pos":[0,163],"source":"If the value of the `timeout` parameter converted to milliseconds equals â€“1, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>."},{"content":"If the value of <ph id=\"ph1\">`timeout`</ph> equals 0, this method is equivalent to <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%29&gt;</ph>.","pos":[164,289],"source":" If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>."}]},{"pos":[296,539],"content":"If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends. This allows the program to determine, in all cases, whether it is necessary to release the lock.","nodes":[{"content":"If the lock was not taken because an exception was thrown, the variable specified for the <ph id=\"ph1\">`lockTaken`</ph> parameter is <ph id=\"ph2\">`false`</ph> after this method ends.","pos":[0,146],"source":"If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends."},{"content":"This allows the program to determine, in all cases, whether it is necessary to release the lock.","pos":[147,243]}]},{"pos":[547,729],"content":"[!NOTE]\n Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For more information, see the <xref:System.Threading.Monitor> class topic.","leadings":["","> "],"nodes":[{"content":" Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For more information, see the <xref:System.Threading.Monitor> class topic.","pos":[8,180],"nodes":[{"content":"Use <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.","pos":[1,97],"source":" Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types."},{"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class topic.","pos":[98,172],"source":" For more information, see the <xref:System.Threading.Monitor> class topic."}]}]},{"pos":[736,1172],"content":"To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.","nodes":[{"content":"To ensure that the thread does not enter the critical section, you should examine the value of <ph id=\"ph1\">`lockTaken`</ph> and  execute code in the critical section only if its value is <ph id=\"ph2\">`true`</ph>.","pos":[0,177],"source":"To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`."},{"content":"The following code fragment shows the pattern used to call this method.","pos":[178,249]},{"content":"Note that you should call <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id=\"ph2\">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.","pos":[250,436],"source":" Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs."}]},{"pos":[1179,1486],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Threading.Monitor.TryEnter#6<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Threading.Monitor.TryEnter#6<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]\n [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]"}],"pos":[45296,46795],"yaml":true,"extradata":"MT"},{"content":"The object on which to acquire the lock.","nodes":[{"pos":[0,40],"content":"The object on which to acquire the lock.","nodes":[{"content":"The object on which to acquire the lock.","pos":[0,40]}]}],"pos":[46973,47014],"yaml":true},{"content":"The amount of time to wait for the lock. A value of â€“1 millisecond specifies an infinite wait.","nodes":[{"pos":[0,94],"content":"The amount of time to wait for the lock. A value of â€“1 millisecond specifies an infinite wait.","nodes":[{"content":"The amount of time to wait for the lock. A value of â€“1 millisecond specifies an infinite wait.","pos":[0,94],"nodes":[{"content":"The amount of time to wait for the lock.","pos":[0,40]},{"content":"A value of â€“1 millisecond specifies an infinite wait.","pos":[41,94]}]}]}],"pos":[47079,47174],"yaml":true},{"content":"The result of the attempt to acquire the lock, passed by reference. The input must be `false`. The output is `true` if the lock is acquired; otherwise, the output is `false`. The output is set even if an exception occurs during the attempt to acquire the lock.","nodes":[{"pos":[0,260],"content":"The result of the attempt to acquire the lock, passed by reference. The input must be `false`. The output is `true` if the lock is acquired; otherwise, the output is `false`. The output is set even if an exception occurs during the attempt to acquire the lock.","nodes":[{"content":"The result of the attempt to acquire the lock, passed by reference.","pos":[0,67]},{"content":"The input must be <ph id=\"ph1\">`false`</ph>.","pos":[68,94],"source":" The input must be `false`."},{"content":"The output is <ph id=\"ph1\">`true`</ph> if the lock is acquired; otherwise, the output is <ph id=\"ph2\">`false`</ph>.","pos":[95,174],"source":" The output is `true` if the lock is acquired; otherwise, the output is `false`."},{"content":"The output is set even if an exception occurs during the attempt to acquire the lock.","pos":[175,260]}]}],"pos":[47240,47501],"yaml":true},{"content":"The input to <code>lockTaken</code> is `true`.","nodes":[{"pos":[0,46],"content":"The input to <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`true`</ph>.","source":"The input to <code>lockTaken</code> is `true`."}],"pos":[47656,47703],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[47805,47847],"yaml":true},{"content":"The value of <code>timeout</code> in milliseconds is negative and is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (â€“1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,217],"content":"The value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> in milliseconds is negative and is not equal to <ph id=\"ph2\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (â€“1 millisecond), or is greater than <ph id=\"ph3\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"The value of <code>timeout</code> in milliseconds is negative and is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (â€“1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[47961,48179],"yaml":true},{"content":"Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.","nodes":[{"pos":[0,176],"content":"Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.","nodes":[{"content":"Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.","pos":[0,176]}]}],"pos":[49767,49944],"yaml":true},{"content":"If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>. If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  \n  \n If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends. This allows the program to determine, in all cases, whether it is necessary to release the lock.  \n  \n> [!NOTE]\n>  Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For more information, see the <xref:System.Threading.Monitor> class topic.  \n  \n To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.  \n  \n [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]\n [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]","nodes":[{"pos":[0,299],"content":"If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>. If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.","nodes":[{"content":"If the <ph id=\"ph1\">`millisecondsTimeout`</ph> parameter equals <ph id=\"ph2\">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph>, this method is equivalent to <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Enter%28System.Object%29&gt;</ph>.","pos":[0,174],"source":"If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>."},{"content":"If <ph id=\"ph1\">`millisecondsTimeout`</ph> equals 0, this method is equivalent to <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.TryEnter%28System.Object%29&gt;</ph>.","pos":[175,299],"source":" If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>."}]},{"pos":[306,549],"content":"If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends. This allows the program to determine, in all cases, whether it is necessary to release the lock.","nodes":[{"content":"If the lock was not taken because an exception was thrown, the variable specified for the <ph id=\"ph1\">`lockTaken`</ph> parameter is <ph id=\"ph2\">`false`</ph> after this method ends.","pos":[0,146],"source":"If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends."},{"content":"This allows the program to determine, in all cases, whether it is necessary to release the lock.","pos":[147,243]}]},{"pos":[557,739],"content":"[!NOTE]\n Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For more information, see the <xref:System.Threading.Monitor> class topic.","leadings":["","> "],"nodes":[{"content":" Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For more information, see the <xref:System.Threading.Monitor> class topic.","pos":[8,180],"nodes":[{"content":"Use <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.","pos":[1,97],"source":" Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types."},{"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class topic.","pos":[98,172],"source":" For more information, see the <xref:System.Threading.Monitor> class topic."}]}]},{"pos":[746,1182],"content":"To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.","nodes":[{"content":"To ensure that the thread does not enter the critical section, you should examine the value of <ph id=\"ph1\">`lockTaken`</ph> and  execute code in the critical section only if its value is <ph id=\"ph2\">`true`</ph>.","pos":[0,177],"source":"To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`."},{"content":"The following code fragment shows the pattern used to call this method.","pos":[178,249]},{"content":"Note that you should call <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id=\"ph2\">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.","pos":[250,436],"source":" Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs."}]},{"pos":[1189,1496],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Threading.Monitor.TryEnter#4<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Threading.Monitor.TryEnter#4<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]\n [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]"}],"pos":[49955,51464],"yaml":true,"extradata":"MT"},{"content":"The object on which to acquire the lock.","nodes":[{"pos":[0,40],"content":"The object on which to acquire the lock.","nodes":[{"content":"The object on which to acquire the lock.","pos":[0,40]}]}],"pos":[52384,52425],"yaml":true},{"content":"The number of milliseconds to wait for the lock.","nodes":[{"pos":[0,48],"content":"The number of milliseconds to wait for the lock.","nodes":[{"content":"The number of milliseconds to wait for the lock.","pos":[0,48]}]}],"pos":[52499,52548],"yaml":true},{"content":"The result of the attempt to acquire the lock, passed by reference. The input must be `false`. The output is `true` if the lock is acquired; otherwise, the output is `false`. The output is set even if an exception occurs during the attempt to acquire the lock.","nodes":[{"pos":[0,260],"content":"The result of the attempt to acquire the lock, passed by reference. The input must be `false`. The output is `true` if the lock is acquired; otherwise, the output is `false`. The output is set even if an exception occurs during the attempt to acquire the lock.","nodes":[{"content":"The result of the attempt to acquire the lock, passed by reference.","pos":[0,67]},{"content":"The input must be <ph id=\"ph1\">`false`</ph>.","pos":[68,94],"source":" The input must be `false`."},{"content":"The output is <ph id=\"ph1\">`true`</ph> if the lock is acquired; otherwise, the output is <ph id=\"ph2\">`false`</ph>.","pos":[95,174],"source":" The output is `true` if the lock is acquired; otherwise, the output is `false`."},{"content":"The output is set even if an exception occurs during the attempt to acquire the lock.","pos":[175,260]}]}],"pos":[52614,52875],"yaml":true},{"content":"The input to <code>lockTaken</code> is `true`.","nodes":[{"pos":[0,46],"content":"The input to <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`true`</ph>.","source":"The input to <code>lockTaken</code> is `true`."}],"pos":[53030,53077],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[53179,53221],"yaml":true},{"content":"<code>millisecondsTimeout</code> is negative, and not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref>.","nodes":[{"pos":[0,118],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is negative, and not equal to <ph id=\"ph2\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph>.","source":"<code>millisecondsTimeout</code> is negative, and not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref>."}],"pos":[53335,53454],"yaml":true},{"content":"Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.","nodes":[{"pos":[0,97],"content":"Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.","nodes":[{"content":"Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.","pos":[0,97]}]}],"pos":[54985,55083],"yaml":true},{"content":"If the value of the `timeout` parameter converted to milliseconds equals â€“1, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>. If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.  \n  \n> [!NOTE]\n>  Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For details, see the <xref:System.Threading.Monitor> class topic.  \n  \n To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.  \n  \n [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]\n [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]","nodes":[{"pos":[0,257],"content":"If the value of the `timeout` parameter converted to milliseconds equals â€“1, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>. If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.","nodes":[{"content":"If the value of the <ph id=\"ph1\">`timeout`</ph> parameter converted to milliseconds equals â€“1, this method is equivalent to <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>.","pos":[0,147],"source":"If the value of the `timeout` parameter converted to milliseconds equals â€“1, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>."},{"content":"If the value of <ph id=\"ph1\">`timeout`</ph> equals 0, this method is equivalent to <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>.","pos":[148,257],"source":" If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>."}]},{"pos":[265,438],"content":"[!NOTE]\n Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For details, see the <xref:System.Threading.Monitor> class topic.","leadings":["","> "],"nodes":[{"content":" Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For details, see the <xref:System.Threading.Monitor> class topic.","pos":[8,171],"nodes":[{"content":"Use <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.","pos":[1,97],"source":" Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types."},{"content":"For details, see the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> class topic.","pos":[98,163],"source":" For details, see the <xref:System.Threading.Monitor> class topic."}]}]},{"pos":[445,889],"content":"To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.","nodes":[{"content":"To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is <ph id=\"ph1\">`true`</ph>.","pos":[0,185],"source":"To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`."},{"content":"The following code fragment shows the pattern used to call this method.","pos":[186,257]},{"content":"Note that you should call <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id=\"ph2\">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.","pos":[258,444],"source":" Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs."}]},{"pos":[896,1203],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Threading.Monitor.TryEnter#5<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Threading.Monitor.TryEnter#5<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]\n [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]"}],"pos":[55094,56308],"yaml":true,"extradata":"MT"},{"content":"The object on which to acquire the lock.","nodes":[{"pos":[0,40],"content":"The object on which to acquire the lock.","nodes":[{"content":"The object on which to acquire the lock.","pos":[0,40]}]}],"pos":[56466,56507],"yaml":true},{"content":"A <xref href=\"System.TimeSpan\"></xref> representing the amount of time to wait for the lock. A value of â€“1 millisecond specifies an infinite wait.","nodes":[{"pos":[0,146],"content":"A <xref href=\"System.TimeSpan\"></xref> representing the amount of time to wait for the lock. A value of â€“1 millisecond specifies an infinite wait.","nodes":[{"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> representing the amount of time to wait for the lock.","pos":[0,92],"source":"A <xref href=\"System.TimeSpan\"></xref> representing the amount of time to wait for the lock."},{"content":"A value of â€“1 millisecond specifies an infinite wait.","pos":[93,146]}]}],"pos":[56572,56719],"yaml":true},{"content":"`true` if the current thread acquires the lock; otherwise, `false`.","nodes":[{"pos":[0,67],"content":"<ph id=\"ph1\">`true`</ph> if the current thread acquires the lock; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the current thread acquires the lock; otherwise, `false`."}],"pos":[56777,56847],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[57010,57052],"yaml":true},{"content":"The value of <code>timeout</code> in milliseconds is negative and is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (â€“1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,217],"content":"The value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> in milliseconds is negative and is not equal to <ph id=\"ph2\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (â€“1 millisecond), or is greater than <ph id=\"ph3\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"The value of <code>timeout</code> in milliseconds is negative and is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (â€“1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[57166,57384],"yaml":true},{"content":"Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.","nodes":[{"pos":[0,105],"content":"Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.","nodes":[{"content":"Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.","pos":[0,105]}]}],"pos":[58897,59003],"yaml":true},{"content":"If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>. If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.  \n  \n> [!NOTE]\n>  Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For details, see the <xref:System.Threading.Monitor> article.  \n  \n To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.  \n  \n [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]\n [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]","nodes":[{"pos":[0,267],"content":"If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>. If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.","nodes":[{"content":"If the <ph id=\"ph1\">`millisecondsTimeout`</ph> parameter equals <ph id=\"ph2\">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph>, this method is equivalent to <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>.","pos":[0,158],"source":"If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>."},{"content":"If <ph id=\"ph1\">`millisecondsTimeout`</ph> equals 0, this method is equivalent to <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.TryEnter%2A&gt;</ph>.","pos":[159,267],"source":" If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>."}]},{"pos":[275,444],"content":"[!NOTE]\n Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For details, see the <xref:System.Threading.Monitor> article.","leadings":["","> "],"nodes":[{"content":" Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For details, see the <xref:System.Threading.Monitor> article.","pos":[8,167],"nodes":[{"content":"Use <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.","pos":[1,97],"source":" Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types."},{"content":"For details, see the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> article.","pos":[98,159],"source":" For details, see the <xref:System.Threading.Monitor> article."}]}]},{"pos":[451,895],"content":"To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.","nodes":[{"content":"To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is <ph id=\"ph1\">`true`</ph>.","pos":[0,185],"source":"To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`."},{"content":"The following code fragment shows the pattern used to call this method.","pos":[186,257]},{"content":"Note that you should call <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id=\"ph2\">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.","pos":[258,444],"source":" Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs."}]},{"pos":[902,1209],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Threading.Monitor.TryEnter#3<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Threading.Monitor.TryEnter#3<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]\n [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]"}],"pos":[59014,60234],"yaml":true,"extradata":"MT"},{"content":"The object on which to acquire the lock.","nodes":[{"pos":[0,40],"content":"The object on which to acquire the lock.","nodes":[{"content":"The object on which to acquire the lock.","pos":[0,40]}]}],"pos":[60399,60440],"yaml":true},{"content":"The number of milliseconds to wait for the lock.","nodes":[{"pos":[0,48],"content":"The number of milliseconds to wait for the lock.","nodes":[{"content":"The number of milliseconds to wait for the lock.","pos":[0,48]}]}],"pos":[60514,60563],"yaml":true},{"content":"`true` if the current thread acquires the lock; otherwise, `false`.","nodes":[{"pos":[0,67],"content":"<ph id=\"ph1\">`true`</ph> if the current thread acquires the lock; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the current thread acquires the lock; otherwise, `false`."}],"pos":[60621,60691],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[60854,60896],"yaml":true},{"content":"<code>millisecondsTimeout</code> is negative, and not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref>.","nodes":[{"pos":[0,118],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is negative, and not equal to <ph id=\"ph2\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph>.","source":"<code>millisecondsTimeout</code> is negative, and not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref>."}],"pos":[61010,61129],"yaml":true},{"content":"Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.","nodes":[{"pos":[0,133],"content":"Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.","nodes":[{"content":"Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.","pos":[0,133]}]}],"pos":[62657,62791],"yaml":true},{"content":"If successful, this method acquires an exclusive lock on the `obj` parameter. This method returns immediately, whether or not the lock is available.  \n  \n If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends. This allows the program to determine, in all cases, whether it is necessary to release the lock.  \n  \n This method is similar to <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, but it will never block the current thread. If the thread cannot enter without blocking, the `lockTaken` argument is set to `false` when the method returns.  \n  \n> [!NOTE]\n>  Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For more information, see the <xref:System.Threading.Monitor> article.  \n  \n To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.  \n  \n [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]\n [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]","nodes":[{"pos":[0,148],"content":"If successful, this method acquires an exclusive lock on the `obj` parameter. This method returns immediately, whether or not the lock is available.","nodes":[{"content":"If successful, this method acquires an exclusive lock on the <ph id=\"ph1\">`obj`</ph> parameter.","pos":[0,77],"source":"If successful, this method acquires an exclusive lock on the `obj` parameter."},{"content":"This method returns immediately, whether or not the lock is available.","pos":[78,148]}]},{"pos":[155,398],"content":"If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends. This allows the program to determine, in all cases, whether it is necessary to release the lock.","nodes":[{"content":"If the lock was not taken because an exception was thrown, the variable specified for the <ph id=\"ph1\">`lockTaken`</ph> parameter is <ph id=\"ph2\">`false`</ph> after this method ends.","pos":[0,146],"source":"If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends."},{"content":"This allows the program to determine, in all cases, whether it is necessary to release the lock.","pos":[147,243]}]},{"pos":[405,665],"content":"This method is similar to <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, but it will never block the current thread. If the thread cannot enter without blocking, the `lockTaken` argument is set to `false` when the method returns.","nodes":[{"content":"This method is similar to <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29&gt;</ph>, but it will never block the current thread.","pos":[0,147],"source":"This method is similar to <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, but it will never block the current thread."},{"content":"If the thread cannot enter without blocking, the <ph id=\"ph1\">`lockTaken`</ph> argument is set to <ph id=\"ph2\">`false`</ph> when the method returns.","pos":[148,260],"source":" If the thread cannot enter without blocking, the `lockTaken` argument is set to `false` when the method returns."}]},{"pos":[673,851],"content":"[!NOTE]\n Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For more information, see the <xref:System.Threading.Monitor> article.","leadings":["","> "],"nodes":[{"content":" Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For more information, see the <xref:System.Threading.Monitor> article.","pos":[8,176],"nodes":[{"content":"Use <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.","pos":[1,97],"source":" Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types."},{"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> article.","pos":[98,168],"source":" For more information, see the <xref:System.Threading.Monitor> article."}]}]},{"pos":[858,1294],"content":"To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.","nodes":[{"content":"To ensure that the thread does not enter the critical section, you should examine the value of <ph id=\"ph1\">`lockTaken`</ph> and  execute code in the critical section only if its value is <ph id=\"ph2\">`true`</ph>.","pos":[0,177],"source":"To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`."},{"content":"The following code fragment shows the pattern used to call this method.","pos":[178,249]},{"content":"Note that you should call <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id=\"ph2\">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.","pos":[250,436],"source":" Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs."}]},{"pos":[1301,1608],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Threading.Monitor.TryEnter#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Threading.Monitor.TryEnter#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]\n [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]"}],"pos":[62802,64425],"yaml":true,"extradata":"MT"},{"content":"The object on which to acquire the lock.","nodes":[{"pos":[0,40],"content":"The object on which to acquire the lock.","nodes":[{"content":"The object on which to acquire the lock.","pos":[0,40]}]}],"pos":[65320,65361],"yaml":true},{"content":"The result of the attempt to acquire the lock, passed by reference. The input must be `false`. The output is `true` if the lock is acquired; otherwise, the output is `false`. The output is set even if an exception occurs during the attempt to acquire the lock.","nodes":[{"pos":[0,260],"content":"The result of the attempt to acquire the lock, passed by reference. The input must be `false`. The output is `true` if the lock is acquired; otherwise, the output is `false`. The output is set even if an exception occurs during the attempt to acquire the lock.","nodes":[{"content":"The result of the attempt to acquire the lock, passed by reference.","pos":[0,67]},{"content":"The input must be <ph id=\"ph1\">`false`</ph>.","pos":[68,94],"source":" The input must be `false`."},{"content":"The output is <ph id=\"ph1\">`true`</ph> if the lock is acquired; otherwise, the output is <ph id=\"ph2\">`false`</ph>.","pos":[95,174],"source":" The output is `true` if the lock is acquired; otherwise, the output is `false`."},{"content":"The output is set even if an exception occurs during the attempt to acquire the lock.","pos":[175,260]}]}],"pos":[65427,65688],"yaml":true},{"content":"The input to <code>lockTaken</code> is `true`.","nodes":[{"pos":[0,46],"content":"The input to <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`true`</ph>.","source":"The input to <code>lockTaken</code> is `true`."}],"pos":[65843,65890],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[65992,66034],"yaml":true},{"content":"Attempts to acquire an exclusive lock on the specified object.","nodes":[{"pos":[0,62],"content":"Attempts to acquire an exclusive lock on the specified object.","nodes":[{"content":"Attempts to acquire an exclusive lock on the specified object.","pos":[0,62]}]}],"pos":[67487,67550],"yaml":true},{"content":"If successful, this method acquires an exclusive lock on the `obj` parameter. This method returns immediately, whether or not the lock is available.  \n  \n This method is similar to <xref:System.Threading.Monitor.Enter%2A>, but it will never block the current thread. If the thread cannot enter without blocking, the method returns `false,`.  \n  \n> [!NOTE]\n>  Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For details, see the <xref:System.Threading.Monitor> article.  \n  \n To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.  \n  \n [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]\n [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]","nodes":[{"pos":[0,148],"content":"If successful, this method acquires an exclusive lock on the `obj` parameter. This method returns immediately, whether or not the lock is available.","nodes":[{"content":"If successful, this method acquires an exclusive lock on the <ph id=\"ph1\">`obj`</ph> parameter.","pos":[0,77],"source":"If successful, this method acquires an exclusive lock on the `obj` parameter."},{"content":"This method returns immediately, whether or not the lock is available.","pos":[78,148]}]},{"pos":[155,340],"content":"This method is similar to <xref:System.Threading.Monitor.Enter%2A>, but it will never block the current thread. If the thread cannot enter without blocking, the method returns `false,`.","nodes":[{"content":"This method is similar to <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph>, but it will never block the current thread.","pos":[0,111],"source":"This method is similar to <xref:System.Threading.Monitor.Enter%2A>, but it will never block the current thread."},{"content":"If the thread cannot enter without blocking, the method returns <ph id=\"ph1\">`false,`</ph>.","pos":[112,185],"source":" If the thread cannot enter without blocking, the method returns `false,`."}]},{"pos":[348,517],"content":"[!NOTE]\n Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For details, see the <xref:System.Threading.Monitor> article.","leadings":["","> "],"nodes":[{"content":" Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For details, see the <xref:System.Threading.Monitor> article.","pos":[8,167],"nodes":[{"content":"Use <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> to lock objects (that is, reference types), not value types.","pos":[1,97],"source":" Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types."},{"content":"For details, see the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> article.","pos":[98,159],"source":" For details, see the <xref:System.Threading.Monitor> article."}]}]},{"pos":[524,968],"content":"To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.","nodes":[{"content":"To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is <ph id=\"ph1\">`true`</ph>.","pos":[0,185],"source":"To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`."},{"content":"The following code fragment shows the pattern used to call this method.","pos":[186,257]},{"content":"Note that you should call <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> in a <ph id=\"ph2\">`finally`</ph> block to ensure that the calling thread releases its lock on the critical section if an exception occurs.","pos":[258,444],"source":" Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs."}]},{"pos":[975,1282],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Threading.Monitor.TryEnter#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Threading.Monitor.TryEnter#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]\n [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]"}],"pos":[67561,68856],"yaml":true,"extradata":"MT"},{"content":"The object on which to acquire the lock.","nodes":[{"pos":[0,40],"content":"The object on which to acquire the lock.","nodes":[{"content":"The object on which to acquire the lock.","pos":[0,40]}]}],"pos":[69414,69455],"yaml":true},{"content":"`true` if the current thread acquires the lock; otherwise, `false`.","nodes":[{"pos":[0,67],"content":"<ph id=\"ph1\">`true`</ph> if the current thread acquires the lock; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the current thread acquires the lock; otherwise, `false`."}],"pos":[69513,69583],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[69746,69788],"yaml":true},{"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock.","nodes":[{"pos":[0,90],"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock.","nodes":[{"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock.","pos":[0,90]}]}],"pos":[71217,71308],"yaml":true},{"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.  \n  \n When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue. The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object. All threads that call `Wait` remain in the waiting queue until they receive a signal from <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>, sent by the owner of the lock. If `Pulse` is sent, only the thread at the head of the waiting queue is affected. If `PulseAll` is sent, all threads that are waiting for the object are affected. When the signal is received, one or more threads leave the waiting queue and enter the ready queue. A thread in the ready queue is permitted to reacquire the lock.  \n  \n This method returns when the calling thread reacquires the lock on the object. Note that this method blocks indefinitely if the holder of the lock does not call `Pulse` or `PulseAll`.  \n  \n The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked `Enter` on the object and invokes `Exit` as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls `Enter` as many times as necessary to restore the saved `Enter` count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.  \n  \n Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.  \n  \n The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.  \n  \n The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.","nodes":[{"pos":[0,342],"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","nodes":[{"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","pos":[0,342],"nodes":[{"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.","pos":[0,152]},{"content":"The caller is blocked while waiting to reacquire the lock.","pos":[153,211]},{"content":"This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","pos":[212,342]}]}]},{"pos":[349,1104],"content":"When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue. The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object. All threads that call `Wait` remain in the waiting queue until they receive a signal from <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>, sent by the owner of the lock. If `Pulse` is sent, only the thread at the head of the waiting queue is affected. If `PulseAll` is sent, all threads that are waiting for the object are affected. When the signal is received, one or more threads leave the waiting queue and enter the ready queue. A thread in the ready queue is permitted to reacquire the lock.","nodes":[{"content":"When a thread calls <ph id=\"ph1\">`Wait`</ph>, it releases the lock on the object and enters the object's waiting queue.","pos":[0,101],"source":"When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue."},{"content":"The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.","pos":[102,218]},{"content":"All threads that call <ph id=\"ph1\">`Wait`</ph> remain in the waiting queue until they receive a signal from <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, sent by the owner of the lock.","pos":[219,428],"source":" All threads that call `Wait` remain in the waiting queue until they receive a signal from <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>, sent by the owner of the lock."},{"content":"If <ph id=\"ph1\">`Pulse`</ph> is sent, only the thread at the head of the waiting queue is affected.","pos":[429,510],"source":" If `Pulse` is sent, only the thread at the head of the waiting queue is affected."},{"content":"If <ph id=\"ph1\">`PulseAll`</ph> is sent, all threads that are waiting for the object are affected.","pos":[511,591],"source":" If `PulseAll` is sent, all threads that are waiting for the object are affected."},{"content":"When the signal is received, one or more threads leave the waiting queue and enter the ready queue.","pos":[592,691]},{"content":"A thread in the ready queue is permitted to reacquire the lock.","pos":[692,755]}]},{"pos":[1111,1294],"content":"This method returns when the calling thread reacquires the lock on the object. Note that this method blocks indefinitely if the holder of the lock does not call `Pulse` or `PulseAll`.","nodes":[{"content":"This method returns when the calling thread reacquires the lock on the object.","pos":[0,78]},{"content":"Note that this method blocks indefinitely if the holder of the lock does not call <ph id=\"ph1\">`Pulse`</ph> or <ph id=\"ph2\">`PulseAll`</ph>.","pos":[79,183],"source":" Note that this method blocks indefinitely if the holder of the lock does not call `Pulse` or `PulseAll`."}]},{"pos":[1301,1983],"content":"The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked `Enter` on the object and invokes `Exit` as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls `Enter` as many times as necessary to restore the saved `Enter` count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.","nodes":[{"content":"The caller executes <ph id=\"ph1\">`Wait`</ph> once, regardless of the number of times <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.","pos":[0,150],"source":"The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object."},{"content":"Conceptually, the <ph id=\"ph1\">`Wait`</ph> method stores the number of times the caller invoked <ph id=\"ph2\">`Enter`</ph> on the object and invokes <ph id=\"ph3\">`Exit`</ph> as many times as necessary to fully release the locked object.","pos":[151,332],"source":" Conceptually, the `Wait` method stores the number of times the caller invoked `Enter` on the object and invokes `Exit` as many times as necessary to fully release the locked object."},{"content":"The caller then blocks while waiting to reacquire the object.","pos":[333,394]},{"content":"When the caller reacquires the lock, the system calls <ph id=\"ph1\">`Enter`</ph> as many times as necessary to restore the saved <ph id=\"ph2\">`Enter`</ph> count for the caller.","pos":[395,534],"source":" When the caller reacquires the lock, the system calls `Enter` as many times as necessary to restore the saved `Enter` count for the caller."},{"content":"Calling <ph id=\"ph1\">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.","pos":[535,682],"source":" Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released."}]},{"pos":[1990,2342],"content":"Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.","nodes":[{"content":"Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.","pos":[0,352]}]},{"pos":[2349,2516],"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id=\"ph3\">`Wait`</ph> methods must be invoked from within a synchronized block of code.","source":"The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code."},{"pos":[2523,2694],"content":"The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.","nodes":[{"content":"The remarks for the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.","pos":[0,171],"source":"The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting."}]}],"pos":[71319,74028],"yaml":true,"extradata":"MT"},{"content":"The object on which to wait.","nodes":[{"pos":[0,28],"content":"The object on which to wait.","nodes":[{"content":"The object on which to wait.","pos":[0,28]}]}],"pos":[74164,74193],"yaml":true},{"content":"`true` if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired.","nodes":[{"pos":[0,151],"content":"`true` if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the call returned because the caller reacquired the lock for the specified object.","pos":[0,92],"source":"`true` if the call returned because the caller reacquired the lock for the specified object."},{"content":"This method does not return if the lock is not reacquired.","pos":[93,151]}]}],"pos":[74251,74405],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[74564,74606],"yaml":true},{"content":"The calling thread does not own the lock for the specified object.","nodes":[{"pos":[0,66],"content":"The calling thread does not own the lock for the specified object.","nodes":[{"content":"The calling thread does not own the lock for the specified object.","pos":[0,66]}]}],"pos":[74742,74809],"yaml":true},{"content":"The thread that invokes `Wait` is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.","nodes":[{"pos":[0,191],"content":"The thread that invokes `Wait` is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.","nodes":[{"content":"The thread that invokes <ph id=\"ph1\">`Wait`</ph> is later interrupted from the waiting state.","pos":[0,75],"source":"The thread that invokes `Wait` is later interrupted from the waiting state."},{"content":"This happens when another thread calls this thread's <ph id=\"ph1\">&lt;xref href=\"System.Threading.Thread.Interrupt\"&gt;&lt;/xref&gt;</ph> method.","pos":[76,191],"source":" This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method."}]}],"pos":[74941,75133],"yaml":true},{"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.","nodes":[{"pos":[0,169],"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.","nodes":[{"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.","pos":[0,169],"nodes":[{"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock.","pos":[0,90]},{"content":"If the specified time-out interval elapses, the thread enters the ready queue.","pos":[91,169]}]}]}],"pos":[76622,76792],"yaml":true},{"content":"This method does not return until it reacquires an exclusive lock on the `obj` parameter.  \n  \n The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.  \n  \n The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.  \n  \n When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue. The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object. The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>. However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.  \n  \n> [!NOTE]\n>  If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.  \n  \n The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.  \n  \n> [!NOTE]\n>  A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.  \n  \n The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.  \n  \n The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.","nodes":[{"pos":[0,89],"content":"This method does not return until it reacquires an exclusive lock on the <ph id=\"ph1\">`obj`</ph> parameter.","source":"This method does not return until it reacquires an exclusive lock on the `obj` parameter."},{"pos":[96,438],"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","nodes":[{"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","pos":[0,342],"nodes":[{"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.","pos":[0,152]},{"content":"The caller is blocked while waiting to reacquire the lock.","pos":[153,211]},{"content":"This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","pos":[212,342]}]}]},{"pos":[445,1128],"content":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.","nodes":[{"content":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.","pos":[0,683],"nodes":[{"content":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.","pos":[0,230],"source":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method."},{"content":"It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.","pos":[231,372]},{"content":"The thread can test the return value of the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out.","pos":[373,530],"source":" The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out."},{"content":"The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.","pos":[531,683],"source":" The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again."}]}]},{"pos":[1135,1881],"content":"When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue. The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object. The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>. However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.","nodes":[{"content":"When a thread calls <ph id=\"ph1\">`Wait`</ph>, it releases the lock on the object and enters the object's waiting queue.","pos":[0,101],"source":"When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue."},{"content":"The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.","pos":[102,218]},{"content":"The thread that invoked <ph id=\"ph1\">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.","pos":[219,487],"source":" The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>."},{"content":"However, if <ph id=\"ph1\">`millisecondsTimeout`</ph> elapses before another thread invokes this object's <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.","pos":[488,746],"source":" However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock."}]},{"pos":[1889,2309],"content":"[!NOTE]\n If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.","leadings":["","> "],"nodes":[{"content":" If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.","pos":[8,418],"nodes":[{"content":"If <ph id=\"ph1\">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> is specified for the <ph id=\"ph2\">`millisecondsTimeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.","pos":[1,255],"source":" If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>."},{"content":"If <ph id=\"ph1\">`millisecondsTimeout`</ph> equals 0, the thread that calls <ph id=\"ph2\">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.","pos":[256,410],"source":" If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock."}]}]},{"pos":[2316,3130],"content":"The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.","nodes":[{"content":"The caller executes <ph id=\"ph1\">`Wait`</ph> once, regardless of the number of times <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.","pos":[0,150],"source":"The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object."},{"content":"Conceptually, the <ph id=\"ph1\">`Wait`</ph> method stores the number of times the caller invoked <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.","pos":[151,398],"source":" Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object."},{"content":"The caller then blocks while waiting to reacquire the object.","pos":[399,460]},{"content":"When the caller reacquires the lock, the system calls <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.","pos":[461,666],"source":" When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller."},{"content":"Calling <ph id=\"ph1\">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.","pos":[667,814],"source":" Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released."}]},{"pos":[3138,3491],"content":"[!NOTE]\n A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.","leadings":["","> "],"nodes":[{"content":"A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.","pos":[9,351]}]},{"pos":[3498,3665],"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id=\"ph3\">`Wait`</ph> methods must be invoked from within a synchronized block of code.","source":"The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code."},{"pos":[3672,3843],"content":"The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.","nodes":[{"content":"The remarks for the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.","pos":[0,171],"source":"The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting."}]}],"pos":[76803,80667],"yaml":true,"extradata":"MT"},{"content":"The object on which to wait.","nodes":[{"pos":[0,28],"content":"The object on which to wait.","nodes":[{"content":"The object on which to wait.","pos":[0,28]}]}],"pos":[80828,80857],"yaml":true},{"content":"The number of milliseconds to wait before the thread enters the ready queue.","nodes":[{"pos":[0,76],"content":"The number of milliseconds to wait before the thread enters the ready queue.","nodes":[{"content":"The number of milliseconds to wait before the thread enters the ready queue.","pos":[0,76]}]}],"pos":[80931,81008],"yaml":true},{"content":"`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.","nodes":[{"pos":[0,194],"content":"`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the lock was reacquired before the specified time elapsed; <ph id=\"ph2\">`false`</ph> if the lock was reacquired after the specified time elapsed.","pos":[0,137],"source":"`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed."},{"content":"The method does not return until the lock is reacquired.","pos":[138,194]}]}],"pos":[81066,81263],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[81422,81464],"yaml":true},{"content":"The calling thread does not own the lock for the specified object.","nodes":[{"pos":[0,66],"content":"The calling thread does not own the lock for the specified object.","nodes":[{"content":"The calling thread does not own the lock for the specified object.","pos":[0,66]}]}],"pos":[81600,81667],"yaml":true},{"content":"The thread that invokes `Wait` is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.","nodes":[{"pos":[0,191],"content":"The thread that invokes `Wait` is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.","nodes":[{"content":"The thread that invokes <ph id=\"ph1\">`Wait`</ph> is later interrupted from the waiting state.","pos":[0,75],"source":"The thread that invokes `Wait` is later interrupted from the waiting state."},{"content":"This happens when another thread calls this thread's <ph id=\"ph1\">&lt;xref href=\"System.Threading.Thread.Interrupt\"&gt;&lt;/xref&gt;</ph> method.","pos":[76,191],"source":" This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method."}]}],"pos":[81799,81991],"yaml":true},{"content":"The value of the <code>millisecondsTimeout</code> parameter is negative, and is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref>.","nodes":[{"pos":[0,148],"content":"The value of the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">millisecondsTimeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is negative, and is not equal to <ph id=\"ph2\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph>.","source":"The value of the <code>millisecondsTimeout</code> parameter is negative, and is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref>."}],"pos":[82105,82254],"yaml":true},{"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.","nodes":[{"pos":[0,169],"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.","nodes":[{"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.","pos":[0,169],"nodes":[{"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock.","pos":[0,90]},{"content":"If the specified time-out interval elapses, the thread enters the ready queue.","pos":[91,169]}]}]}],"pos":[83761,83931],"yaml":true},{"content":"This method does not return until it reacquires an exclusive lock on the `obj` parameter.  \n  \n The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.  \n  \n The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.  \n  \n When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue. The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object. The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>. However, if `timeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.  \n  \n> [!NOTE]\n>  If a <xref:System.TimeSpan> representing â€“1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.  \n  \n The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.  \n  \n> [!NOTE]\n>  A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.  \n  \n The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.  \n  \n The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.","nodes":[{"pos":[0,89],"content":"This method does not return until it reacquires an exclusive lock on the <ph id=\"ph1\">`obj`</ph> parameter.","source":"This method does not return until it reacquires an exclusive lock on the `obj` parameter."},{"pos":[96,438],"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","nodes":[{"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","pos":[0,342],"nodes":[{"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.","pos":[0,152]},{"content":"The caller is blocked while waiting to reacquire the lock.","pos":[153,211]},{"content":"This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","pos":[212,342]}]}]},{"pos":[445,1128],"content":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.","nodes":[{"content":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.","pos":[0,683],"nodes":[{"content":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.","pos":[0,230],"source":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method."},{"content":"It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.","pos":[231,372]},{"content":"The thread can test the return value of the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out.","pos":[373,530],"source":" The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out."},{"content":"The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.","pos":[531,683],"source":" The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again."}]}]},{"pos":[1135,1869],"content":"When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue. The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object. The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>. However, if `timeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.","nodes":[{"content":"When a thread calls <ph id=\"ph1\">`Wait`</ph>, it releases the lock on the object and enters the object's waiting queue.","pos":[0,101],"source":"When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue."},{"content":"The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.","pos":[102,218]},{"content":"The thread that invoked <ph id=\"ph1\">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.","pos":[219,487],"source":" The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>."},{"content":"However, if <ph id=\"ph1\">`timeout`</ph> elapses before another thread invokes this object's <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.","pos":[488,734],"source":" However, if `timeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock."}]},{"pos":[1877,2294],"content":"[!NOTE]\n If a <xref:System.TimeSpan> representing â€“1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.","leadings":["","> "],"nodes":[{"content":" If a <xref:System.TimeSpan> representing â€“1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.","pos":[8,415],"nodes":[{"content":"If a <ph id=\"ph1\">&lt;xref:System.TimeSpan&gt;</ph> representing â€“1 millisecond is specified for the <ph id=\"ph2\">`timeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.","pos":[1,255],"source":" If a <xref:System.TimeSpan> representing â€“1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>."},{"content":"If <ph id=\"ph1\">`timeout`</ph> is 0 milliseconds, the thread that calls <ph id=\"ph2\">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.","pos":[256,407],"source":" If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock."}]}]},{"pos":[2301,3115],"content":"The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.","nodes":[{"content":"The caller executes <ph id=\"ph1\">`Wait`</ph> once, regardless of the number of times <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.","pos":[0,150],"source":"The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object."},{"content":"Conceptually, the <ph id=\"ph1\">`Wait`</ph> method stores the number of times the caller invoked <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.","pos":[151,398],"source":" Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object."},{"content":"The caller then blocks while waiting to reacquire the object.","pos":[399,460]},{"content":"When the caller reacquires the lock, the system calls <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.","pos":[461,666],"source":" When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller."},{"content":"Calling <ph id=\"ph1\">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.","pos":[667,814],"source":" Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released."}]},{"pos":[3123,3476],"content":"[!NOTE]\n A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.","leadings":["","> "],"nodes":[{"content":"A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.","pos":[9,351]}]},{"pos":[3483,3650],"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id=\"ph3\">`Wait`</ph> methods must be invoked from within a synchronized block of code.","source":"The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code."},{"pos":[3657,3828],"content":"The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.","nodes":[{"content":"The remarks for the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.","pos":[0,171],"source":"The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting."}]}],"pos":[83942,87791],"yaml":true,"extradata":"MT"},{"content":"The object on which to wait.","nodes":[{"pos":[0,28],"content":"The object on which to wait.","nodes":[{"content":"The object on which to wait.","pos":[0,28]}]}],"pos":[87945,87974],"yaml":true},{"content":"A <xref href=\"System.TimeSpan\"></xref> representing the amount of time to wait before the thread enters the ready queue.","nodes":[{"pos":[0,120],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> representing the amount of time to wait before the thread enters the ready queue.","source":"A <xref href=\"System.TimeSpan\"></xref> representing the amount of time to wait before the thread enters the ready queue."}],"pos":[88039,88160],"yaml":true},{"content":"`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.","nodes":[{"pos":[0,194],"content":"`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the lock was reacquired before the specified time elapsed; <ph id=\"ph2\">`false`</ph> if the lock was reacquired after the specified time elapsed.","pos":[0,137],"source":"`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed."},{"content":"The method does not return until the lock is reacquired.","pos":[138,194]}]}],"pos":[88218,88415],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[88574,88616],"yaml":true},{"content":"The calling thread does not own the lock for the specified object.","nodes":[{"pos":[0,66],"content":"The calling thread does not own the lock for the specified object.","nodes":[{"content":"The calling thread does not own the lock for the specified object.","pos":[0,66]}]}],"pos":[88752,88819],"yaml":true},{"content":"The thread that invokes `Wait` is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.","nodes":[{"pos":[0,191],"content":"The thread that invokes `Wait` is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.","nodes":[{"content":"The thread that invokes <ph id=\"ph1\">`Wait`</ph> is later interrupted from the waiting state.","pos":[0,75],"source":"The thread that invokes `Wait` is later interrupted from the waiting state."},{"content":"This happens when another thread calls this thread's <ph id=\"ph1\">&lt;xref href=\"System.Threading.Thread.Interrupt\"&gt;&lt;/xref&gt;</ph> method.","pos":[76,191],"source":" This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method."}]}],"pos":[88951,89143],"yaml":true},{"content":"The value of the <code>timeout</code> parameter in milliseconds is negative and does not represent <xref href=\"System.Threading.Timeout.Infinite\"></xref> (â€“1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,234],"content":"The value of the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter in milliseconds is negative and does not represent <ph id=\"ph2\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (â€“1 millisecond), or is greater than <ph id=\"ph3\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"The value of the <code>timeout</code> parameter in milliseconds is negative and does not represent <xref href=\"System.Threading.Timeout.Infinite\"></xref> (â€“1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[89257,89492],"yaml":true},{"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.","nodes":[{"pos":[0,330],"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.","nodes":[{"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.","pos":[0,330],"nodes":[{"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock.","pos":[0,90]},{"content":"If the specified time-out interval elapses, the thread enters the ready queue.","pos":[91,169]},{"content":"This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.","pos":[170,330]}]}]}],"pos":[91053,91384],"yaml":true},{"content":"This method does not return until it reacquires an exclusive lock on the `obj` parameter.  \n  \n The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.  \n  \n The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.  \n  \n When a thread calls `Wait`, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>. However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.  \n  \n> [!NOTE]\n>  If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.  \n  \n The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.  \n  \n> [!NOTE]\n>  A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.  \n  \n The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.  \n  \n The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.  \n  \n## Notes on Exiting the Context  \n The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method. It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.  \n  \n This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"pos":[0,89],"content":"This method does not return until it reacquires an exclusive lock on the <ph id=\"ph1\">`obj`</ph> parameter.","source":"This method does not return until it reacquires an exclusive lock on the `obj` parameter."},{"pos":[96,438],"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","nodes":[{"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","pos":[0,342],"nodes":[{"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.","pos":[0,152]},{"content":"The caller is blocked while waiting to reacquire the lock.","pos":[153,211]},{"content":"This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","pos":[212,342]}]}]},{"pos":[445,1128],"content":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.","nodes":[{"content":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.","pos":[0,683],"nodes":[{"content":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.","pos":[0,230],"source":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method."},{"content":"It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.","pos":[231,372]},{"content":"The thread can test the return value of the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out.","pos":[373,530],"source":" The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out."},{"content":"The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.","pos":[531,683],"source":" The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again."}]}]},{"pos":[1135,1849],"content":"When a thread calls `Wait`, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>. However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.","nodes":[{"content":"When a thread calls <ph id=\"ph1\">`Wait`</ph>, it releases the lock and enters the waiting queue.","pos":[0,78],"source":"When a thread calls `Wait`, it releases the lock and enters the waiting queue."},{"content":"At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.","pos":[79,186]},{"content":"The thread that invoked <ph id=\"ph1\">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.","pos":[187,455],"source":" The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>."},{"content":"However, if <ph id=\"ph1\">`millisecondsTimeout`</ph> elapses before another thread invokes this object's <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.","pos":[456,714],"source":" However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock."}]},{"pos":[1857,2277],"content":"[!NOTE]\n If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.","leadings":["","> "],"nodes":[{"content":" If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.","pos":[8,418],"nodes":[{"content":"If <ph id=\"ph1\">&lt;xref:System.Threading.Timeout.Infinite&gt;</ph> is specified for the <ph id=\"ph2\">`millisecondsTimeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.","pos":[1,255],"source":" If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>."},{"content":"If <ph id=\"ph1\">`millisecondsTimeout`</ph> equals 0, the thread that calls <ph id=\"ph2\">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.","pos":[256,410],"source":" If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock."}]}]},{"pos":[2284,3098],"content":"The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.","nodes":[{"content":"The caller executes <ph id=\"ph1\">`Wait`</ph> once, regardless of the number of times <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.","pos":[0,150],"source":"The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object."},{"content":"Conceptually, the <ph id=\"ph1\">`Wait`</ph> method stores the number of times the caller invoked <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.","pos":[151,398],"source":" Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object."},{"content":"The caller then blocks while waiting to reacquire the object.","pos":[399,460]},{"content":"When the caller reacquires the lock, the system calls <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.","pos":[461,666],"source":" When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller."},{"content":"Calling <ph id=\"ph1\">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.","pos":[667,814],"source":" Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released."}]},{"pos":[3106,3459],"content":"[!NOTE]\n A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.","leadings":["","> "],"nodes":[{"content":"A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.","pos":[9,351]}]},{"pos":[3466,3633],"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id=\"ph3\">`Wait`</ph> methods must be invoked from within a synchronized block of code.","source":"The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code."},{"pos":[3640,3811],"content":"The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.","nodes":[{"content":"The remarks for the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.","pos":[0,171],"source":"The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting."}]},{"pos":[3820,3848],"content":"Notes on Exiting the Context","linkify":"Notes on Exiting the Context","nodes":[{"content":"Notes on Exiting the Context","pos":[0,28]}]},{"pos":[3852,4390],"content":"The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.","nodes":[{"content":"The<ph id=\"ph1\">`exitContext`</ph> parameter has no effect unless the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method is called from inside a nondefault managed context.","pos":[0,150],"source":"The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context."},{"content":"This can happen if your thread is inside a call to an instance of a class derived from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>.","pos":[151,271],"source":" This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>."},{"content":"Even if you are currently executing a method on a class that is not derived from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id=\"ph3\">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.","pos":[272,538],"source":" Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain."}]},{"pos":[4397,4785],"content":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method. It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.","nodes":[{"content":"When your code is executing in a nondefault context, specifying <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method.","pos":[0,262],"source":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method."},{"content":"It returns to the original nondefault context after the call to the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method completes.","pos":[263,388],"source":" It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes."}]},{"pos":[4792,5492],"content":"This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"content":"This can be useful when the context-bound class has the <ph id=\"ph1\">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> attribute applied.","pos":[0,139],"source":"This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied."},{"content":"In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.","pos":[140,292]},{"content":"If code in the call stack of a member calls the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method and specifies <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.","pos":[293,556],"source":" If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.","pos":[557,700],"source":" When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain."}]}],"pos":[91395,96915],"yaml":true,"extradata":"MT"},{"content":"The object on which to wait.","nodes":[{"pos":[0,28],"content":"The object on which to wait.","nodes":[{"content":"The object on which to wait.","pos":[0,28]}]}],"pos":[97094,97123],"yaml":true},{"content":"The number of milliseconds to wait before the thread enters the ready queue.","nodes":[{"pos":[0,76],"content":"The number of milliseconds to wait before the thread enters the ready queue.","nodes":[{"content":"The number of milliseconds to wait before the thread enters the ready queue.","pos":[0,76]}]}],"pos":[97197,97274],"yaml":true},{"content":"`true` to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, `false`.","nodes":[{"pos":[0,139],"content":"<ph id=\"ph1\">`true`</ph> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, `false`."}],"pos":[97342,97484],"yaml":true},{"content":"`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.","nodes":[{"pos":[0,194],"content":"`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the lock was reacquired before the specified time elapsed; <ph id=\"ph2\">`false`</ph> if the lock was reacquired after the specified time elapsed.","pos":[0,137],"source":"`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed."},{"content":"The method does not return until the lock is reacquired.","pos":[138,194]}]}],"pos":[97542,97739],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[97898,97940],"yaml":true},{"content":"`Wait` is not invoked from within a synchronized block of code.","nodes":[{"pos":[0,63],"content":"<ph id=\"ph1\">`Wait`</ph> is not invoked from within a synchronized block of code.","source":"`Wait` is not invoked from within a synchronized block of code."}],"pos":[98076,98142],"yaml":true},{"content":"The thread that invokes `Wait` is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.","nodes":[{"pos":[0,191],"content":"The thread that invokes `Wait` is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.","nodes":[{"content":"The thread that invokes <ph id=\"ph1\">`Wait`</ph> is later interrupted from the waiting state.","pos":[0,75],"source":"The thread that invokes `Wait` is later interrupted from the waiting state."},{"content":"This happens when another thread calls this thread's <ph id=\"ph1\">&lt;xref href=\"System.Threading.Thread.Interrupt\"&gt;&lt;/xref&gt;</ph> method.","pos":[76,191],"source":" This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method."}]}],"pos":[98274,98466],"yaml":true},{"content":"The value of the <code>millisecondsTimeout</code> parameter is negative, and is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref>.","nodes":[{"pos":[0,148],"content":"The value of the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">millisecondsTimeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is negative, and is not equal to <ph id=\"ph2\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph>.","source":"The value of the <code>millisecondsTimeout</code> parameter is negative, and is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref>."}],"pos":[98580,98729],"yaml":true},{"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.","nodes":[{"pos":[0,295],"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.","nodes":[{"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.","pos":[0,295],"nodes":[{"content":"Releases the lock on an object and blocks the current thread until it reacquires the lock.","pos":[0,90]},{"content":"If the specified time-out interval elapses, the thread enters the ready queue.","pos":[91,169]},{"content":"Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.","pos":[170,295]}]}]}],"pos":[100021,100317],"yaml":true},{"content":"This method does not return until it reacquires an exclusive lock on the `obj` parameter.  \n  \n The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.  \n  \n The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.  \n  \n When a thread calls `Wait`, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>. However, if `timeout` milliseconds elapse before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.  \n  \n> [!NOTE]\n>  If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.  \n  \n The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.  \n  \n> [!NOTE]\n>  A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.  \n  \n The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.  \n  \n The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.  \n  \n## Notes on Exiting the Context  \n The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method. It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.  \n  \n This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"pos":[0,89],"content":"This method does not return until it reacquires an exclusive lock on the <ph id=\"ph1\">`obj`</ph> parameter.","source":"This method does not return until it reacquires an exclusive lock on the `obj` parameter."},{"pos":[96,438],"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","nodes":[{"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","pos":[0,342],"nodes":[{"content":"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.","pos":[0,152]},{"content":"The caller is blocked while waiting to reacquire the lock.","pos":[153,211]},{"content":"This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.","pos":[212,342]}]}]},{"pos":[445,1128],"content":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.","nodes":[{"content":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.","pos":[0,683],"nodes":[{"content":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method.","pos":[0,230],"source":"The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method."},{"content":"It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.","pos":[231,372]},{"content":"The thread can test the return value of the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method to determine whether it reacquired the lock prior to the time-out.","pos":[373,530],"source":" The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out."},{"content":"The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method again.","pos":[531,683],"source":" The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again."}]}]},{"pos":[1135,1849],"content":"When a thread calls `Wait`, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>. However, if `timeout` milliseconds elapse before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.","nodes":[{"content":"When a thread calls <ph id=\"ph1\">`Wait`</ph>, it releases the lock and enters the waiting queue.","pos":[0,78],"source":"When a thread calls `Wait`, it releases the lock and enters the waiting queue."},{"content":"At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.","pos":[79,186]},{"content":"The thread that invoked <ph id=\"ph1\">`Wait`</ph> remains in the waiting queue until either a thread that holds the lock invokes <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, or it is the next in the queue and a thread that holds the lock invokes <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>.","pos":[187,455],"source":" The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>."},{"content":"However, if <ph id=\"ph1\">`timeout`</ph> milliseconds elapse before another thread invokes this object's <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph> method, the original thread is moved to the ready queue in order to regain the lock.","pos":[456,714],"source":" However, if `timeout` milliseconds elapse before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock."}]},{"pos":[1857,2274],"content":"[!NOTE]\n If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.","leadings":["","> "],"nodes":[{"content":" If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.","pos":[8,415],"nodes":[{"content":"If a <ph id=\"ph1\">&lt;xref:System.TimeSpan&gt;</ph> representing -1 millisecond is specified for the <ph id=\"ph2\">`timeout`</ph> parameter, this method blocks indefinitely unless the holder of the lock calls <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>.","pos":[1,255],"source":" If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>."},{"content":"If <ph id=\"ph1\">`timeout`</ph> is 0 milliseconds, the thread that calls <ph id=\"ph2\">`Wait`</ph> releases the lock and then immediately enters the ready queue in order to regain the lock.","pos":[256,407],"source":" If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock."}]}]},{"pos":[2281,3095],"content":"The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.","nodes":[{"content":"The caller executes <ph id=\"ph1\">`Wait`</ph> once, regardless of the number of times <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> has been invoked for the specified object.","pos":[0,150],"source":"The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object."},{"content":"Conceptually, the <ph id=\"ph1\">`Wait`</ph> method stores the number of times the caller invoked <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> on the object and invokes <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Exit%2A&gt;</ph> as many times as necessary to fully release the locked object.","pos":[151,398],"source":" Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object."},{"content":"The caller then blocks while waiting to reacquire the object.","pos":[399,460]},{"content":"When the caller reacquires the lock, the system calls <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> as many times as necessary to restore the saved <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Enter%2A&gt;</ph> count for the caller.","pos":[461,666],"source":" When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller."},{"content":"Calling <ph id=\"ph1\">`Wait`</ph> releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.","pos":[667,814],"source":" Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released."}]},{"pos":[3103,3456],"content":"[!NOTE]\n A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.","leadings":["","> "],"nodes":[{"content":"A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.","pos":[9,351]}]},{"pos":[3463,3630],"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.PulseAll%2A&gt;</ph>, and <ph id=\"ph3\">`Wait`</ph> methods must be invoked from within a synchronized block of code.","source":"The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code."},{"pos":[3637,3808],"content":"The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.","nodes":[{"content":"The remarks for the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> method explain what happens if <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Pulse%2A&gt;</ph> is called when no threads are waiting.","pos":[0,171],"source":"The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting."}]},{"pos":[3817,3845],"content":"Notes on Exiting the Context","linkify":"Notes on Exiting the Context","nodes":[{"content":"Notes on Exiting the Context","pos":[0,28]}]},{"pos":[3849,4387],"content":"The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.","nodes":[{"content":"The<ph id=\"ph1\">`exitContext`</ph> parameter has no effect unless the <ph id=\"ph2\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method is called from inside a nondefault managed context.","pos":[0,150],"source":"The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context."},{"content":"This can happen if your thread is inside a call to an instance of a class derived from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>.","pos":[151,271],"source":" This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>."},{"content":"Even if you are currently executing a method on a class that is not derived from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id=\"ph3\">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.","pos":[272,538],"source":" Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain."}]},{"pos":[4394,4782],"content":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method. It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.","nodes":[{"content":"When your code is executing in a nondefault context, specifying <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id=\"ph3\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method.","pos":[0,262],"source":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method."},{"content":"It returns to the original nondefault context after the call to the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method completes.","pos":[263,388],"source":" It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes."}]},{"pos":[4789,5489],"content":"This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"content":"This can be useful when the context-bound class has the <ph id=\"ph1\">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> attribute applied.","pos":[0,139],"source":"This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied."},{"content":"In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.","pos":[140,292]},{"content":"If code in the call stack of a member calls the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method and specifies <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.","pos":[293,556],"source":" If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Threading.Monitor.Wait%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.","pos":[557,700],"source":" When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain."}]}],"pos":[100328,105845],"yaml":true,"extradata":"MT"},{"content":"The object on which to wait.","nodes":[{"pos":[0,28],"content":"The object on which to wait.","nodes":[{"content":"The object on which to wait.","pos":[0,28]}]}],"pos":[106017,106046],"yaml":true},{"content":"A <xref href=\"System.TimeSpan\"></xref> representing the amount of time to wait before the thread enters the ready queue.","nodes":[{"pos":[0,120],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> representing the amount of time to wait before the thread enters the ready queue.","source":"A <xref href=\"System.TimeSpan\"></xref> representing the amount of time to wait before the thread enters the ready queue."}],"pos":[106111,106232],"yaml":true},{"content":"`true` to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, `false`.","nodes":[{"pos":[0,139],"content":"<ph id=\"ph1\">`true`</ph> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, `false`."}],"pos":[106300,106442],"yaml":true},{"content":"`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.","nodes":[{"pos":[0,194],"content":"`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the lock was reacquired before the specified time elapsed; <ph id=\"ph2\">`false`</ph> if the lock was reacquired after the specified time elapsed.","pos":[0,137],"source":"`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed."},{"content":"The method does not return until the lock is reacquired.","pos":[138,194]}]}],"pos":[106500,106697],"yaml":true},{"content":"The <code>obj</code> parameter is `null`.","nodes":[{"pos":[0,41],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>obj</code> parameter is `null`."}],"pos":[106856,106898],"yaml":true},{"content":"`Wait` is not invoked from within a synchronized block of code.","nodes":[{"pos":[0,63],"content":"<ph id=\"ph1\">`Wait`</ph> is not invoked from within a synchronized block of code.","source":"`Wait` is not invoked from within a synchronized block of code."}],"pos":[107034,107100],"yaml":true},{"content":"The thread that invokes Wait is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.","nodes":[{"pos":[0,189],"content":"The thread that invokes Wait is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.","nodes":[{"content":"The thread that invokes Wait is later interrupted from the waiting state.","pos":[0,73]},{"content":"This happens when another thread calls this thread's <ph id=\"ph1\">&lt;xref href=\"System.Threading.Thread.Interrupt\"&gt;&lt;/xref&gt;</ph> method.","pos":[74,189],"source":" This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method."}]}],"pos":[107232,107422],"yaml":true},{"content":"The <code>timeout</code> parameter is negative and does not represent <xref href=\"System.Threading.Timeout.Infinite\"></xref> (â€“1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,205],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is negative and does not represent <ph id=\"ph2\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (â€“1 millisecond), or is greater than <ph id=\"ph3\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"The <code>timeout</code> parameter is negative and does not represent <xref href=\"System.Threading.Timeout.Infinite\"></xref> (â€“1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[107536,107742],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.Monitor\n  commentId: T:System.Threading.Monitor\n  id: Monitor\n  children:\n  - System.Threading.Monitor.Enter(System.Object)\n  - System.Threading.Monitor.Enter(System.Object,System.Boolean@)\n  - System.Threading.Monitor.Exit(System.Object)\n  - System.Threading.Monitor.IsEntered(System.Object)\n  - System.Threading.Monitor.Pulse(System.Object)\n  - System.Threading.Monitor.PulseAll(System.Object)\n  - System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)\n  - System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)\n  - System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)\n  - System.Threading.Monitor.TryEnter(System.Object,System.Int32)\n  - System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)\n  - System.Threading.Monitor.TryEnter(System.Object)\n  - System.Threading.Monitor.Wait(System.Object)\n  - System.Threading.Monitor.Wait(System.Object,System.Int32)\n  - System.Threading.Monitor.Wait(System.Object,System.TimeSpan)\n  - System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)\n  - System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)\n  langs:\n  - csharp\n  name: Monitor\n  nameWithType: Monitor\n  fullName: System.Threading.Monitor\n  type: Class\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Provides a mechanism that synchronizes access to objects.\n  remarks: \"The <xref:System.Threading.Monitor> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=fullName>, and <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> methods. Object locks provide the ability to restrict access to a block of code, commonly called a critical section. While a thread owns the lock for an object, no other thread can acquire that lock. You can also use the <xref:System.Threading.Monitor> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.  \\n  \\n In this article:  \\n  \\n [The Monitor class: An overview](#Overview)   \\n [The lock object](#Lock)   \\n [The critical section](#CriticalSection)   \\n [Pulse, PulseAll, and Wait](#Pulse)   \\n [Monitors and wait handles](#WaitHandles)  \\n  \\n<a name=\\\"Overview\\\"></a>   \\n## The Monitor class: An overview  \\n <xref:System.Threading.Monitor> has the following features:  \\n  \\n-   It is associated with an object on demand.  \\n  \\n-   It is unbound, which means it can be called directly from any context.  \\n  \\n-   An instance of the <xref:System.Threading.Monitor> class cannot be created; the methods of the <xref:System.Threading.Monitor> class are all static. Each method is passed the synchronized object that controls access to the critical section.  \\n  \\n> [!NOTE]\\n>  Use the <xref:System.Threading.Monitor> class to lock objects other than strings (that is, reference types other than <xref:System.String>), not value types. For details, see the overloads of the <xref:System.Threading.Monitor.Enter%2A> method and [The lock object](#Lock) section later in this article.  \\n  \\n The following table describes the actions that can be taken by threads that access synchronized objects:  \\n  \\n|Action|Description|  \\n|------------|-----------------|  \\n|<xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A>|Acquires a lock for an object. This action also marks the beginning of a critical section. No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.|  \\n|<xref:System.Threading.Monitor.Wait%2A>|Releases the lock on an object in order to permit other threads to lock and access the object. The calling thread waits while another thread accesses the object. Pulse signals are used to notify waiting threads about changes to an object's state.|  \\n|<xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A>|Sends a signal to one or more waiting threads. The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock. The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object. Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.|  \\n|<xref:System.Threading.Monitor.Exit%2A>|Releases the lock on an object. This action also marks the end of a critical section protected by the locked object.|  \\n  \\n Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], there are two sets of overloads for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.TryEnter%2A> methods. One set of overloads has a `ref` (in C#) or `ByRef` (in Visual Basic) <xref:System.Boolean> parameter that is atomically set to `true` if the lock is acquired, even if an exception is thrown when acquiring the lock. Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.  \\n  \\n<a name=\\\"Lock\\\"></a>   \\n## The lock object  \\n The Monitor class consists of `static` (in C#) or  `Shared` (in Visual Basic) methods that operate on an object that controls access to the critical section.  The following information is maintained for each synchronized object:  \\n  \\n-   A reference to the thread that currently holds the lock.  \\n  \\n-   A reference to a ready queue, which contains the threads that are ready to obtain the lock.  \\n  \\n-   A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.  \\n  \\n <xref:System.Threading.Monitor> locks objects (that is, reference types), not value types. While you can pass a value type to <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, it is boxed separately for each call. Since each call creates a separate object, <xref:System.Threading.Monitor.Enter%2A> never blocks, and the code it is supposedly protecting is not really synchronized. In addition, the object passed to <xref:System.Threading.Monitor.Exit%2A> is different from the object passed to <xref:System.Threading.Monitor.Enter%2A>, so <xref:System.Threading.Monitor> throws <xref:System.Threading.SynchronizationLockException> exception with the message \\\"Object synchronization method was called from an unsynchronized block of code.\\\"  \\n  \\n The following example illustrates this problem. It launches ten tasks, each of which just sleeps for 250 milliseconds. Each task then updates a counter variable, `nTasks`, which is intended to count the number of tasks that actually launched and executed. Because `nTasks` is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks. However, as the output from the example shows, each of the tasks throws a <xref:System.Threading.SynchronizationLockException> exception.  \\n  \\n [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]\\n [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  \\n  \\n Each task throws a <xref:System.Threading.SynchronizationLockException> exception because the `nTasks` variable is boxed before the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> method in each task. In other words, each method call is passed a separate variable that is independent of the others. `nTasks` is boxed again in the call to the <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> method. Once again, this creates ten new boxed variables, which are independent of each other, `nTasks`, and the ten boxed variables created in the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=fullName> method. The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.  \\n  \\n Although you can box a value type variable before calling <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this. Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.  \\n  \\n [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]\\n [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  \\n  \\n When selecting an object on which to synchronize, you should lock only on private or internal objects. Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.  \\n  \\n Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.  \\n  \\n<a name=\\\"CriticalSection\\\"></a>   \\n## The critical section  \\n Use the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods to mark the beginning and end of a critical section.  \\n  \\n> [!NOTE]\\n>  The functionality provided by the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods is identical to that provided by the [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic, except that the language constructs wrap the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=fullName> method overload and the <xref:System.Threading.Monitor.Exit%2A?displayProperty=fullName> method in a `try`â€¦`finally` block to ensure that the monitor is released.  \\n  \\n If the critical section is a set of contiguous instructions, then the lock acquired by the <xref:System.Threading.Monitor.Enter%2A> method guarantees that only a single thread can execute the enclosed code with the locked object. In this case, we recommend that you place that code in a `try` block and place the call to the <xref:System.Threading.Monitor.Exit%2A> method in a `finally` block. This ensures that the lock is released even if an exception occurs. The following code fragment illustrates this pattern.  \\n  \\n [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]\\n [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  \\n  \\n This facility is typically used to synchronize access to a static or instance method of a class.  \\n  \\n If a critical section spans an entire method, the locking facility can be achieved by placing the <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=fullName> on the method, and specifying the <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> value in the constructor of <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=fullName>. When you use this attribute, the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> method calls are not needed. The following code fragment illustrates this pattern:  \\n  \\n [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]\\n [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  \\n  \\n Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <xref:System.Threading.Monitor> class, the C# [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement, or the Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement inside of the method instead of the attribute.  \\n  \\n While it is possible for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.  \\n  \\n<a name=\\\"Pulse\\\"></a>   \\n## Pulse, PulseAll, and Wait  \\n Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <xref:System.Threading.Monitor.Wait%2A?displayProperty=fullName>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=fullName>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=fullName> methods.  \\n  \\n <xref:System.Threading.Monitor.Wait%2A> releases the lock if it is held, allows a waiting thread or threads to obtain the lock and enter the critical section,   and waits to be notified by a call to the <xref:System.Threading.Monitor.Pulse%2A?displayProperty=fullName> or <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=fullName> method. When <xref:System.Threading.Monitor.Wait%2A> is notified, it returns and obtains the lock again.  \\n  \\n Both <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.PulseAll%2A> signal for the next thread in the wait queue to proceed.  \\n  \\n<a name=\\\"WaitHandles\\\"></a>   \\n## Monitors and wait handles  \\n It is important to note the distinction between the use of the <xref:System.Threading.Monitor> class and <xref:System.Threading.WaitHandle> objects.  \\n  \\n-   The <xref:System.Threading.Monitor> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.  \\n  \\n-   <xref:System.Threading.WaitHandle> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.\"\n  example:\n  - \"The following example uses the <xref:System.Threading.Monitor> class to synchronize access to a single instance of a random number generator represented by the <xref:System.Random> class. The example creates ten tasks, each of which executes asynchronously on a thread pool thread. Each task generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum. After all tasks have executed, these two values are then used to calculate the overall mean.  \\n  \\n [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]\\n [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  \\n  \\n Because they can be accessed from any task running on a thread pool thread, access to the variables `total` and `n` must also be synchronized. The <xref:System.Threading.Interlocked.Add%2A?displayProperty=fullName> method is used for this purpose.  \\n  \\n The following example demonstrates the combined use of the <xref:System.Threading.Monitor> class (implemented with the `lock` or `SyncLock` language construct), the <xref:System.Threading.Interlocked> class, and the <xref:System.Threading.AutoResetEvent> class. It defines two `internal` (in C#) or `Friend` (in Visual Basic) classes, `SyncResource` and `UnSyncResource`, that respectively provide synchronized and unsynchronized access to a resource. To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=fullName> property is even, the method calls <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> to introduce a delay of 2,000 milliseconds. Note that, because the `SyncResource` class is not public, none of the client code takes a lock on the synchronized resource; the internal class itself takes the lock. This prevents malicious code from taking a lock on a public object.  \\n  \\n [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]\\n [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  \\n  \\n The example defines a variable, `numOps`, that defines the number of threads that will attempt to access the resource. The application thread calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=fullName> method for synchronized and unsynchronized access five times each. The <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=fullName> method has a single parameter, a delegate that accepts no parameters and returns no value. For synchronized access, it invokes the `SyncUpdateResource` method; for unsynchronized access, it invokes the `UnSyncUpdateResource` method. After each set of method calls, the application thread calls the [AutoResetEvent.WaitOne](https://msdn.microsoft.com/library/58195swd.aspx) method so that it blocks until the <xref:System.Threading.AutoResetEvent> instance is signaled.  \\n  \\n Each call to the `SyncUpdateResource` method calls the internal `SyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=fullName> method to decrement the `numOps` counter. The <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=fullName> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread's decremented value has been stored in the variable. When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the `SyncUpdateResource` method calls the [EventWaitHandle.Set](https://msdn.microsoft.com/library/system.threading.eventwaithandle.set.aspx) method, which signals the main thread to continue execution.  \\n  \\n Each call to the `UnSyncUpdateResource` method calls the internal `UnSyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=fullName> method to decrement the `numOps` counter. Once again, the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=fullName> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread's decremented value has been assigned to the variable. When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the `UnSyncUpdateResource` method calls the [EventWaitHandle.Set](https://msdn.microsoft.com/library/system.threading.eventwaithandle.set.aspx) method, which signals the main thread to continue execution.  \\n  \\n As the output from  the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor. On the other hand, without the lock, the `UnSyncResource.Access` method is called in the order in which threads reach it.\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public static class Monitor\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.Enter(System.Object)\n  commentId: M:System.Threading.Monitor.Enter(System.Object)\n  id: Enter(System.Object)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: Enter(Object)\n  nameWithType: Monitor.Enter(Object)\n  fullName: Monitor.Enter(Object)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Acquires an exclusive lock on the specified object.\n  remarks: \"Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the parameter. If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object. It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.  \\n  \\n Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. When you pass a value type variable to `Enter`, it is boxed as an object. If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block. In this case, the code that `Monitor` is supposedly protecting is not protected. Furthermore, when you pass the variable to `Exit`, still another separate object is created. Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>. For more information, see the conceptual topic [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).  \\n  \\n <xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object. A <xref:System.Threading.ThreadInterruptedException> will be thrown.  \\n  \\n Use a C# `try`â€¦`finally` block (`Try`â€¦`Finally` in Visual Basic) to ensure that you release the monitor, or use the C# `lock` statement (`SyncLock` statement in Visual Basic), which wraps the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods in a `try`â€¦`finally` block.\"\n  example:\n  - \"The following example demonstrates how to use the `Enter` method.  \\n  \\n [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]\\n [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]\\n [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]\"\n  syntax:\n    content: public static void Enter (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object on which to acquire the monitor lock.\n  overload: System.Threading.Monitor.Enter*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.Enter(System.Object,System.Boolean@)\n  commentId: M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)\n  id: Enter(System.Object,System.Boolean@)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: Enter(Object, Boolean)\n  nameWithType: Monitor.Enter(Object, Boolean)\n  fullName: Monitor.Enter(Object, Boolean)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.\n  remarks: \"Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the `obj` parameter. If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object. It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.  \\n  \\n If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends. This allows the program to determine, in all cases, whether it is necessary to release the lock. If this method returns without throwing an exception, the variable specified for the `lockTaken` parameter is always `true`, and there is no need to test it.  \\n  \\n Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. When you pass a value type variable to `Enter`, it is boxed as an object. If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block. In this case, the code that `Monitor` is supposedly protecting is not protected. Furthermore, when you pass the variable to `Exit`, another separate object is created. Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>. For more information, see the conceptual topic [Monitors](http://msdn.microsoft.com/library/33fe4aef-b44b-42fd-9e72-c908e39e75db).  \\n  \\n <xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object. A <xref:System.Threading.ThreadInterruptedException> will be thrown.\"\n  example:\n  - \"The following code shows the basic pattern for using the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> method overload. This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.  \\n  \\n [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]\\n [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]\"\n  syntax:\n    content: public static void Enter (object obj, ref bool lockTaken);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object on which to wait.\n    - id: lockTaken\n      type: System.Boolean\n      description: \"The result of the attempt to acquire the lock, passed by reference. The input must be `false`. The output is `true` if the lock is acquired; otherwise, the output is `false`. The output is set even if an exception occurs during the attempt to acquire the lock.  \\n  \\n Note   If no exception occurs, the output of this method is always `true`.\"\n  overload: System.Threading.Monitor.Enter*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The input to <code>lockTaken</code> is `true`.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.Exit(System.Object)\n  commentId: M:System.Threading.Monitor.Exit(System.Object)\n  id: Exit(System.Object)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: Exit(Object)\n  nameWithType: Monitor.Exit(Object)\n  fullName: Monitor.Exit(Object)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Releases an exclusive lock on the specified object.\n  remarks: \"The calling thread must own the lock on the `obj` parameter. If the calling thread owns the lock on the specified object, and has made an equal number of `Exit` and <xref:System.Threading.Monitor.Enter%2A> calls for the object, then the lock is released. If the calling thread has not invoked `Exit` as many times as `Enter`, the lock is not released.  \\n  \\n If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock. If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls `Exit`. To move one or more waiting threads into the ready queue, call <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> before invoking `Exit`.\"\n  example:\n  - \"The following example demonstrates how to use the `Exit` method.  \\n  \\n [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]\\n [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]\\n [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]\"\n  syntax:\n    content: public static void Exit (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object on which to release the lock.\n  overload: System.Threading.Monitor.Exit*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: The current thread does not own the lock for the specified object.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.IsEntered(System.Object)\n  commentId: M:System.Threading.Monitor.IsEntered(System.Object)\n  id: IsEntered(System.Object)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: IsEntered(Object)\n  nameWithType: Monitor.IsEntered(Object)\n  fullName: Monitor.IsEntered(Object)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Determines whether the current thread holds the lock on the specified object.\n  remarks: \"This method works only for locks that are acquired by using the methods of the <xref:System.Threading.Monitor> class, or by using the C# `lock` statement or the Visual Basic `SyncLock` statement, which are implemented with <xref:System.Threading.Monitor>.  \\n  \\n Use this method with diagnostic tools, such as the <xref:System.Diagnostics.Debug.Assert%2A> method and the <xref:System.Diagnostics.Contracts.Contract> class, to debug locking issues that involve the <xref:System.Threading.Monitor>class.\"\n  syntax:\n    content: public static bool IsEntered (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object to test.\n    return:\n      type: System.Boolean\n      description: '`true` if the current thread holds the lock on <code>obj</code>; otherwise, `false`.'\n  overload: System.Threading.Monitor.IsEntered*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>obj</code> is `null`.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.Pulse(System.Object)\n  commentId: M:System.Threading.Monitor.Pulse(System.Object)\n  id: Pulse(System.Object)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: Pulse(Object)\n  nameWithType: Monitor.Pulse(Object)\n  fullName: Monitor.Pulse(Object)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Notifies a thread in the waiting queue of a change in the locked object's state.\n  remarks: \"Only the current owner of the lock can signal a waiting object using `Pulse`.  \\n  \\n The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock. Upon receiving the pulse, the waiting thread is moved to the ready queue. When the thread that invoked `Pulse` releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.  \\n  \\n> [!IMPORTANT]\\n>  The <xref:System.Threading.Monitor> class does not maintain state indicating that the <xref:System.Threading.Monitor.Pulse%2A> method has been called. Thus, if you call <xref:System.Threading.Monitor.Pulse%2A> when no threads are waiting, the next thread that calls <xref:System.Threading.Monitor.Wait%2A> blocks as if <xref:System.Threading.Monitor.Pulse%2A> had never been called. If two threads are using <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.Wait%2A> to interact, this could result in a deadlock. Contrast this with the behavior of the <xref:System.Threading.AutoResetEvent> class: If you signal an <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, and there are no threads waiting, the <xref:System.Threading.AutoResetEvent> remains in a signaled state until a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>. The <xref:System.Threading.AutoResetEvent> releases that thread and returns to the unsignaled state.  \\n  \\n Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.  \\n  \\n The `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.  \\n  \\n To signal multiple threads, use the <xref:System.Threading.Monitor.PulseAll%2A> method.\"\n  syntax:\n    content: public static void Pulse (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object a thread is waiting for.\n  overload: System.Threading.Monitor.Pulse*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: The calling thread does not own the lock for the specified object.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.PulseAll(System.Object)\n  commentId: M:System.Threading.Monitor.PulseAll(System.Object)\n  id: PulseAll(System.Object)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: PulseAll(Object)\n  nameWithType: Monitor.PulseAll(Object)\n  fullName: Monitor.PulseAll(Object)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Notifies all waiting threads of a change in the object's state.\n  remarks: \"The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object. After the signal is sent, the waiting threads are moved to the ready queue. When the thread that invoked `PulseAll` releases the lock, the next thread in the ready queue acquires the lock.  \\n  \\n Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.  \\n  \\n The <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.  \\n  \\n The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.  \\n  \\n To signal a single thread, use the `Pulse` method.\"\n  syntax:\n    content: public static void PulseAll (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object that sends the pulse.\n  overload: System.Threading.Monitor.PulseAll*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: The calling thread does not own the lock for the specified object.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)\n  commentId: M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)\n  id: TryEnter(System.Object,System.TimeSpan,System.Boolean@)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: TryEnter(Object, TimeSpan, Boolean)\n  nameWithType: Monitor.TryEnter(Object, TimeSpan, Boolean)\n  fullName: Monitor.TryEnter(Object, TimeSpan, Boolean)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.\n  remarks: \"If the value of the `timeout` parameter converted to milliseconds equals â€“1, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>. If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  \\n  \\n If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends. This allows the program to determine, in all cases, whether it is necessary to release the lock.  \\n  \\n> [!NOTE]\\n>  Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For more information, see the <xref:System.Threading.Monitor> class topic.  \\n  \\n To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.  \\n  \\n [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]\\n [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]\"\n  syntax:\n    content: public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object on which to acquire the lock.\n    - id: timeout\n      type: System.TimeSpan\n      description: The amount of time to wait for the lock. A value of â€“1 millisecond specifies an infinite wait.\n    - id: lockTaken\n      type: System.Boolean\n      description: The result of the attempt to acquire the lock, passed by reference. The input must be `false`. The output is `true` if the lock is acquired; otherwise, the output is `false`. The output is set even if an exception occurs during the attempt to acquire the lock.\n  overload: System.Threading.Monitor.TryEnter*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The input to <code>lockTaken</code> is `true`.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The value of <code>timeout</code> in milliseconds is negative and is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (â€“1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\"></xref>.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)\n  commentId: M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)\n  id: TryEnter(System.Object,System.Int32,System.Boolean@)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: TryEnter(Object, Int32, Boolean)\n  nameWithType: Monitor.TryEnter(Object, Int32, Boolean)\n  fullName: Monitor.TryEnter(Object, Int32, Boolean)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.\n  remarks: \"If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>. If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.  \\n  \\n If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends. This allows the program to determine, in all cases, whether it is necessary to release the lock.  \\n  \\n> [!NOTE]\\n>  Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For more information, see the <xref:System.Threading.Monitor> class topic.  \\n  \\n To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.  \\n  \\n [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]\\n [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]\"\n  example:\n  - \"The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload. This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.  \\n  \\n [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]\\n [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]\"\n  syntax:\n    content: public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object on which to acquire the lock.\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait for the lock.\n    - id: lockTaken\n      type: System.Boolean\n      description: The result of the attempt to acquire the lock, passed by reference. The input must be `false`. The output is `true` if the lock is acquired; otherwise, the output is `false`. The output is set even if an exception occurs during the attempt to acquire the lock.\n  overload: System.Threading.Monitor.TryEnter*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The input to <code>lockTaken</code> is `true`.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is negative, and not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref>.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)\n  commentId: M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)\n  id: TryEnter(System.Object,System.TimeSpan)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: TryEnter(Object, TimeSpan)\n  nameWithType: Monitor.TryEnter(Object, TimeSpan)\n  fullName: Monitor.TryEnter(Object, TimeSpan)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.\n  remarks: \"If the value of the `timeout` parameter converted to milliseconds equals â€“1, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>. If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.  \\n  \\n> [!NOTE]\\n>  Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For details, see the <xref:System.Threading.Monitor> class topic.  \\n  \\n To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.  \\n  \\n [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]\\n [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]\"\n  syntax:\n    content: public static bool TryEnter (object obj, TimeSpan timeout);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object on which to acquire the lock.\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> representing the amount of time to wait for the lock. A value of â€“1 millisecond specifies an infinite wait.\n    return:\n      type: System.Boolean\n      description: '`true` if the current thread acquires the lock; otherwise, `false`.'\n  overload: System.Threading.Monitor.TryEnter*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The value of <code>timeout</code> in milliseconds is negative and is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (â€“1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\"></xref>.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.TryEnter(System.Object,System.Int32)\n  commentId: M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)\n  id: TryEnter(System.Object,System.Int32)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: TryEnter(Object, Int32)\n  nameWithType: Monitor.TryEnter(Object, Int32)\n  fullName: Monitor.TryEnter(Object, Int32)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.\n  remarks: \"If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>. If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.  \\n  \\n> [!NOTE]\\n>  Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For details, see the <xref:System.Threading.Monitor> article.  \\n  \\n To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.  \\n  \\n [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]\\n [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]\"\n  syntax:\n    content: public static bool TryEnter (object obj, int millisecondsTimeout);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object on which to acquire the lock.\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait for the lock.\n    return:\n      type: System.Boolean\n      description: '`true` if the current thread acquires the lock; otherwise, `false`.'\n  overload: System.Threading.Monitor.TryEnter*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is negative, and not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref>.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)\n  commentId: M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)\n  id: TryEnter(System.Object,System.Boolean@)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: TryEnter(Object, Boolean)\n  nameWithType: Monitor.TryEnter(Object, Boolean)\n  fullName: Monitor.TryEnter(Object, Boolean)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.\n  remarks: \"If successful, this method acquires an exclusive lock on the `obj` parameter. This method returns immediately, whether or not the lock is available.  \\n  \\n If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends. This allows the program to determine, in all cases, whether it is necessary to release the lock.  \\n  \\n This method is similar to <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, but it will never block the current thread. If the thread cannot enter without blocking, the `lockTaken` argument is set to `false` when the method returns.  \\n  \\n> [!NOTE]\\n>  Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For more information, see the <xref:System.Threading.Monitor> article.  \\n  \\n To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.  \\n  \\n [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]\\n [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]\"\n  example:\n  - \"The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload. This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.  \\n  \\n [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]\\n [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]\"\n  syntax:\n    content: public static void TryEnter (object obj, ref bool lockTaken);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object on which to acquire the lock.\n    - id: lockTaken\n      type: System.Boolean\n      description: The result of the attempt to acquire the lock, passed by reference. The input must be `false`. The output is `true` if the lock is acquired; otherwise, the output is `false`. The output is set even if an exception occurs during the attempt to acquire the lock.\n  overload: System.Threading.Monitor.TryEnter*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The input to <code>lockTaken</code> is `true`.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.TryEnter(System.Object)\n  commentId: M:System.Threading.Monitor.TryEnter(System.Object)\n  id: TryEnter(System.Object)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: TryEnter(Object)\n  nameWithType: Monitor.TryEnter(Object)\n  fullName: Monitor.TryEnter(Object)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Attempts to acquire an exclusive lock on the specified object.\n  remarks: \"If successful, this method acquires an exclusive lock on the `obj` parameter. This method returns immediately, whether or not the lock is available.  \\n  \\n This method is similar to <xref:System.Threading.Monitor.Enter%2A>, but it will never block the current thread. If the thread cannot enter without blocking, the method returns `false,`.  \\n  \\n> [!NOTE]\\n>  Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types. For details, see the <xref:System.Threading.Monitor> article.  \\n  \\n To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`. The following code fragment shows the pattern used to call this method. Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.  \\n  \\n [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]\\n [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]\"\n  example:\n  - \"The following code example demonstrates how to use the `TryEnter` method.  \\n  \\n [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]\\n [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]\\n [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]\"\n  syntax:\n    content: public static bool TryEnter (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object on which to acquire the lock.\n    return:\n      type: System.Boolean\n      description: '`true` if the current thread acquires the lock; otherwise, `false`.'\n  overload: System.Threading.Monitor.TryEnter*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.Wait(System.Object)\n  commentId: M:System.Threading.Monitor.Wait(System.Object)\n  id: Wait(System.Object)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: Wait(Object)\n  nameWithType: Monitor.Wait(Object)\n  fullName: Monitor.Wait(Object)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Releases the lock on an object and blocks the current thread until it reacquires the lock.\n  remarks: \"The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.  \\n  \\n When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue. The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object. All threads that call `Wait` remain in the waiting queue until they receive a signal from <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>, sent by the owner of the lock. If `Pulse` is sent, only the thread at the head of the waiting queue is affected. If `PulseAll` is sent, all threads that are waiting for the object are affected. When the signal is received, one or more threads leave the waiting queue and enter the ready queue. A thread in the ready queue is permitted to reacquire the lock.  \\n  \\n This method returns when the calling thread reacquires the lock on the object. Note that this method blocks indefinitely if the holder of the lock does not call `Pulse` or `PulseAll`.  \\n  \\n The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked `Enter` on the object and invokes `Exit` as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls `Enter` as many times as necessary to restore the saved `Enter` count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.  \\n  \\n Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.  \\n  \\n The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.  \\n  \\n The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.\"\n  syntax:\n    content: public static bool Wait (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object on which to wait.\n    return:\n      type: System.Boolean\n      description: '`true` if the call returned because the caller reacquired the lock for the specified object. This method does not return if the lock is not reacquired.'\n  overload: System.Threading.Monitor.Wait*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: The calling thread does not own the lock for the specified object.\n  - type: System.Threading.ThreadInterruptedException\n    commentId: T:System.Threading.ThreadInterruptedException\n    description: The thread that invokes `Wait` is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.Wait(System.Object,System.Int32)\n  commentId: M:System.Threading.Monitor.Wait(System.Object,System.Int32)\n  id: Wait(System.Object,System.Int32)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: Wait(Object, Int32)\n  nameWithType: Monitor.Wait(Object, Int32)\n  fullName: Monitor.Wait(Object, Int32)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.\n  remarks: \"This method does not return until it reacquires an exclusive lock on the `obj` parameter.  \\n  \\n The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.  \\n  \\n The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.  \\n  \\n When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue. The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object. The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>. However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.  \\n  \\n> [!NOTE]\\n>  If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.  \\n  \\n The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.  \\n  \\n> [!NOTE]\\n>  A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.  \\n  \\n The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.  \\n  \\n The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.\"\n  syntax:\n    content: public static bool Wait (object obj, int millisecondsTimeout);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object on which to wait.\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait before the thread enters the ready queue.\n    return:\n      type: System.Boolean\n      description: '`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.'\n  overload: System.Threading.Monitor.Wait*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: The calling thread does not own the lock for the specified object.\n  - type: System.Threading.ThreadInterruptedException\n    commentId: T:System.Threading.ThreadInterruptedException\n    description: The thread that invokes `Wait` is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The value of the <code>millisecondsTimeout</code> parameter is negative, and is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref>.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.Wait(System.Object,System.TimeSpan)\n  commentId: M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)\n  id: Wait(System.Object,System.TimeSpan)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: Wait(Object, TimeSpan)\n  nameWithType: Monitor.Wait(Object, TimeSpan)\n  fullName: Monitor.Wait(Object, TimeSpan)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue.\n  remarks: \"This method does not return until it reacquires an exclusive lock on the `obj` parameter.  \\n  \\n The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.  \\n  \\n The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.  \\n  \\n When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue. The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object. The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>. However, if `timeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.  \\n  \\n> [!NOTE]\\n>  If a <xref:System.TimeSpan> representing â€“1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.  \\n  \\n The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.  \\n  \\n> [!NOTE]\\n>  A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.  \\n  \\n The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.  \\n  \\n The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.\"\n  syntax:\n    content: public static bool Wait (object obj, TimeSpan timeout);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object on which to wait.\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> representing the amount of time to wait before the thread enters the ready queue.\n    return:\n      type: System.Boolean\n      description: '`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.'\n  overload: System.Threading.Monitor.Wait*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: The calling thread does not own the lock for the specified object.\n  - type: System.Threading.ThreadInterruptedException\n    commentId: T:System.Threading.ThreadInterruptedException\n    description: The thread that invokes `Wait` is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The value of the <code>timeout</code> parameter in milliseconds is negative and does not represent <xref href=\"System.Threading.Timeout.Infinite\"></xref> (â€“1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\"></xref>.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)\n  commentId: M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)\n  id: Wait(System.Object,System.Int32,System.Boolean)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: Wait(Object, Int32, Boolean)\n  nameWithType: Monitor.Wait(Object, Int32, Boolean)\n  fullName: Monitor.Wait(Object, Int32, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading\n  namespace: System.Threading\n  summary: Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.\n  remarks: \"This method does not return until it reacquires an exclusive lock on the `obj` parameter.  \\n  \\n The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.  \\n  \\n The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.  \\n  \\n When a thread calls `Wait`, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>. However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.  \\n  \\n> [!NOTE]\\n>  If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.  \\n  \\n The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.  \\n  \\n> [!NOTE]\\n>  A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.  \\n  \\n The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.  \\n  \\n The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.  \\n  \\n## Notes on Exiting the Context  \\n The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \\n  \\n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method. It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.  \\n  \\n This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.\"\n  syntax:\n    content: public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object on which to wait.\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait before the thread enters the ready queue.\n    - id: exitContext\n      type: System.Boolean\n      description: '`true` to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, `false`.'\n    return:\n      type: System.Boolean\n      description: '`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.'\n  overload: System.Threading.Monitor.Wait*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: '`Wait` is not invoked from within a synchronized block of code.'\n  - type: System.Threading.ThreadInterruptedException\n    commentId: T:System.Threading.ThreadInterruptedException\n    description: The thread that invokes `Wait` is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The value of the <code>millisecondsTimeout</code> parameter is negative, and is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref>.\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)\n  commentId: M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)\n  id: Wait(System.Object,System.TimeSpan,System.Boolean)\n  parent: System.Threading.Monitor\n  langs:\n  - csharp\n  name: Wait(Object, TimeSpan, Boolean)\n  nameWithType: Monitor.Wait(Object, TimeSpan, Boolean)\n  fullName: Monitor.Wait(Object, TimeSpan, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading\n  namespace: System.Threading\n  summary: Releases the lock on an object and blocks the current thread until it reacquires the lock. If the specified time-out interval elapses, the thread enters the ready queue. Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.\n  remarks: \"This method does not return until it reacquires an exclusive lock on the `obj` parameter.  \\n  \\n The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it. The caller is blocked while waiting to reacquire the lock. This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.  \\n  \\n The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method. It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner. The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.  \\n  \\n When a thread calls `Wait`, it releases the lock and enters the waiting queue. At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock. The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>. However, if `timeout` milliseconds elapse before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.  \\n  \\n> [!NOTE]\\n>  If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>. If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.  \\n  \\n The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object. Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object. The caller then blocks while waiting to reacquire the object. When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller. Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.  \\n  \\n> [!NOTE]\\n>  A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.  \\n  \\n The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.  \\n  \\n The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.  \\n  \\n## Notes on Exiting the Context  \\n The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \\n  \\n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method. It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.  \\n  \\n This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.\"\n  syntax:\n    content: public static bool Wait (object obj, TimeSpan timeout, bool exitContext);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object on which to wait.\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> representing the amount of time to wait before the thread enters the ready queue.\n    - id: exitContext\n      type: System.Boolean\n      description: '`true` to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, `false`.'\n    return:\n      type: System.Boolean\n      description: '`true` if the lock was reacquired before the specified time elapsed; `false` if the lock was reacquired after the specified time elapsed. The method does not return until the lock is reacquired.'\n  overload: System.Threading.Monitor.Wait*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>obj</code> parameter is `null`.\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: '`Wait` is not invoked from within a synchronized block of code.'\n  - type: System.Threading.ThreadInterruptedException\n    commentId: T:System.Threading.ThreadInterruptedException\n    description: The thread that invokes Wait is later interrupted from the waiting state. This happens when another thread calls this thread's <xref href=\"System.Threading.Thread.Interrupt\"></xref> method.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The <code>timeout</code> parameter is negative and does not represent <xref href=\"System.Threading.Timeout.Infinite\"></xref> (â€“1 millisecond), or is greater than <xref href=\"System.Int32.MaxValue\"></xref>.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.ArgumentException\n  parent: System\n  isExternal: false\n  name: ArgumentException\n  nameWithType: ArgumentException\n  fullName: System.ArgumentException\n- uid: System.Threading.SynchronizationLockException\n  parent: System.Threading\n  isExternal: false\n  name: SynchronizationLockException\n  nameWithType: SynchronizationLockException\n  fullName: System.Threading.SynchronizationLockException\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.Threading.ThreadInterruptedException\n  parent: System.Threading\n  isExternal: false\n  name: ThreadInterruptedException\n  nameWithType: ThreadInterruptedException\n  fullName: System.Threading.ThreadInterruptedException\n- uid: System.Threading.Monitor.Enter(System.Object)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: Enter(Object)\n  nameWithType: Monitor.Enter(Object)\n  fullName: Monitor.Enter(Object)\n- uid: System.Threading.Monitor.Enter(System.Object,System.Boolean@)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: Enter(Object, Boolean)\n  nameWithType: Monitor.Enter(Object, Boolean)\n  fullName: Monitor.Enter(Object, Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Threading.Monitor.Exit(System.Object)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: Exit(Object)\n  nameWithType: Monitor.Exit(Object)\n  fullName: Monitor.Exit(Object)\n- uid: System.Threading.Monitor.IsEntered(System.Object)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: IsEntered(Object)\n  nameWithType: Monitor.IsEntered(Object)\n  fullName: Monitor.IsEntered(Object)\n- uid: System.Threading.Monitor.Pulse(System.Object)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: Pulse(Object)\n  nameWithType: Monitor.Pulse(Object)\n  fullName: Monitor.Pulse(Object)\n- uid: System.Threading.Monitor.PulseAll(System.Object)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: PulseAll(Object)\n  nameWithType: Monitor.PulseAll(Object)\n  fullName: Monitor.PulseAll(Object)\n- uid: System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: TryEnter(Object, TimeSpan, Boolean)\n  nameWithType: Monitor.TryEnter(Object, TimeSpan, Boolean)\n  fullName: Monitor.TryEnter(Object, TimeSpan, Boolean)\n- uid: System.TimeSpan\n  parent: System\n  isExternal: false\n  name: TimeSpan\n  nameWithType: TimeSpan\n  fullName: System.TimeSpan\n- uid: System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: TryEnter(Object, Int32, Boolean)\n  nameWithType: Monitor.TryEnter(Object, Int32, Boolean)\n  fullName: Monitor.TryEnter(Object, Int32, Boolean)\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: TryEnter(Object, TimeSpan)\n  nameWithType: Monitor.TryEnter(Object, TimeSpan)\n  fullName: Monitor.TryEnter(Object, TimeSpan)\n- uid: System.Threading.Monitor.TryEnter(System.Object,System.Int32)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: TryEnter(Object, Int32)\n  nameWithType: Monitor.TryEnter(Object, Int32)\n  fullName: Monitor.TryEnter(Object, Int32)\n- uid: System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: TryEnter(Object, Boolean)\n  nameWithType: Monitor.TryEnter(Object, Boolean)\n  fullName: Monitor.TryEnter(Object, Boolean)\n- uid: System.Threading.Monitor.TryEnter(System.Object)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: TryEnter(Object)\n  nameWithType: Monitor.TryEnter(Object)\n  fullName: Monitor.TryEnter(Object)\n- uid: System.Threading.Monitor.Wait(System.Object)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: Wait(Object)\n  nameWithType: Monitor.Wait(Object)\n  fullName: Monitor.Wait(Object)\n- uid: System.Threading.Monitor.Wait(System.Object,System.Int32)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: Wait(Object, Int32)\n  nameWithType: Monitor.Wait(Object, Int32)\n  fullName: Monitor.Wait(Object, Int32)\n- uid: System.Threading.Monitor.Wait(System.Object,System.TimeSpan)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: Wait(Object, TimeSpan)\n  nameWithType: Monitor.Wait(Object, TimeSpan)\n  fullName: Monitor.Wait(Object, TimeSpan)\n- uid: System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: Wait(Object, Int32, Boolean)\n  nameWithType: Monitor.Wait(Object, Int32, Boolean)\n  fullName: Monitor.Wait(Object, Int32, Boolean)\n- uid: System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: Wait(Object, TimeSpan, Boolean)\n  nameWithType: Monitor.Wait(Object, TimeSpan, Boolean)\n  fullName: Monitor.Wait(Object, TimeSpan, Boolean)\n- uid: System.Threading.Monitor.Enter*\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: Enter\n  nameWithType: Monitor.Enter\n  fullName: Monitor.Enter\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n- uid: System.Threading.Monitor.Exit*\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: Exit\n  nameWithType: Monitor.Exit\n  fullName: Monitor.Exit\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n- uid: System.Threading.Monitor.IsEntered*\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: IsEntered\n  nameWithType: Monitor.IsEntered\n  fullName: Monitor.IsEntered\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n- uid: System.Threading.Monitor.Pulse*\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: Pulse\n  nameWithType: Monitor.Pulse\n  fullName: Monitor.Pulse\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n- uid: System.Threading.Monitor.PulseAll*\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: PulseAll\n  nameWithType: Monitor.PulseAll\n  fullName: Monitor.PulseAll\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n- uid: System.Threading.Monitor.TryEnter*\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: TryEnter\n  nameWithType: Monitor.TryEnter\n  fullName: Monitor.TryEnter\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n- uid: System.Threading.Monitor.Wait*\n  parent: System.Threading.Monitor\n  isExternal: false\n  name: Wait\n  nameWithType: Monitor.Wait\n  fullName: Monitor.Wait\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Monitor.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n"}