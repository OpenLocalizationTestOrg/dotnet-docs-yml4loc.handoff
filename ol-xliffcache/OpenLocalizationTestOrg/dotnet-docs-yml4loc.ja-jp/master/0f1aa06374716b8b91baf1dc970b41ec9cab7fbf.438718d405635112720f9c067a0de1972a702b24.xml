{"nodes":[{"content":"Defines the interface that a channel must implement to receive a message.","nodes":[{"pos":[0,73],"content":"Defines the interface that a channel must implement to receive a message.","nodes":[{"content":"Defines the interface that a channel must implement to receive a message.","pos":[0,73]}]}],"pos":[1518,1592],"yaml":true},{"content":"The <xref:System.ServiceModel.Channels.IInputChannel> contract includes synchronous and asynchronous variants of receive, try-to-receive and wait-for-a-message functionality.  \n  \n The pull model is used typically with an <xref:System.ServiceModel.Channels.IInputChannel> to receive messages: you call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> (to \"pull\" a message out of the channel) and then wait for a message to arrive. An alternative usage pattern is to call <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> or <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>, and then call <xref:System.ServiceModel.Channels.IInputChannel.Receive%28System.TimeSpan%29>. This approach is common for transactional usages where you start the transaction between the calls to <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> and <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.  \n  \n An <xref:System.ServiceModel.Channels.IInputChannel> is not necessarily bound to a single sender. Other channels and channel interfaces can provide a correlation between particular senders and an <xref:System.ServiceModel.Channels.IInputChannel>, but the base contract makes no such restriction. An implementation can create a new <xref:System.ServiceModel.Channels.IInputChannel> for each message or reuse the same <xref:System.ServiceModel.Channels.IInputChannel> for multiple messages and senders.","nodes":[{"pos":[0,174],"content":"The <xref:System.ServiceModel.Channels.IInputChannel> contract includes synchronous and asynchronous variants of receive, try-to-receive and wait-for-a-message functionality.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel&gt;</ph> contract includes synchronous and asynchronous variants of receive, try-to-receive and wait-for-a-message functionality.","pos":[0,174],"source":"The <xref:System.ServiceModel.Channels.IInputChannel> contract includes synchronous and asynchronous variants of receive, try-to-receive and wait-for-a-message functionality."}]},{"pos":[181,1094],"content":"The pull model is used typically with an <xref:System.ServiceModel.Channels.IInputChannel> to receive messages: you call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> (to \"pull\" a message out of the channel) and then wait for a message to arrive. An alternative usage pattern is to call <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> or <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>, and then call <xref:System.ServiceModel.Channels.IInputChannel.Receive%28System.TimeSpan%29>. This approach is common for transactional usages where you start the transaction between the calls to <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> and <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.","nodes":[{"content":"The pull model is used typically with an <xref:System.ServiceModel.Channels.IInputChannel> to receive messages: you call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> (to \"pull\" a message out of the channel) and then wait for a message to arrive. An alternative usage pattern is to call <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> or <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>, and then call <xref:System.ServiceModel.Channels.IInputChannel.Receive%28System.TimeSpan%29>. This approach is common for transactional usages where you start the transaction between the calls to <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> and <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.","pos":[0,913],"nodes":[{"content":"The pull model is used typically with an <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel&gt;</ph> to receive messages: you call <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph> (to \"pull\" a message out of the channel) and then wait for a message to arrive.","pos":[0,261],"source":"The pull model is used typically with an <xref:System.ServiceModel.Channels.IInputChannel> to receive messages: you call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> (to \"pull\" a message out of the channel) and then wait for a message to arrive."},{"content":"An alternative usage pattern is to call <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29&gt;</ph>, and then call <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%28System.TimeSpan%29&gt;</ph>.","pos":[262,659],"source":" An alternative usage pattern is to call <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> or <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>, and then call <xref:System.ServiceModel.Channels.IInputChannel.Receive%28System.TimeSpan%29>."},{"content":"This approach is common for transactional usages where you start the transaction between the calls to <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph>.","pos":[660,913],"source":" This approach is common for transactional usages where you start the transaction between the calls to <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> and <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>."}]}]},{"pos":[1101,1601],"content":"An <xref:System.ServiceModel.Channels.IInputChannel> is not necessarily bound to a single sender. Other channels and channel interfaces can provide a correlation between particular senders and an <xref:System.ServiceModel.Channels.IInputChannel>, but the base contract makes no such restriction. An implementation can create a new <xref:System.ServiceModel.Channels.IInputChannel> for each message or reuse the same <xref:System.ServiceModel.Channels.IInputChannel> for multiple messages and senders.","nodes":[{"content":"An <xref:System.ServiceModel.Channels.IInputChannel> is not necessarily bound to a single sender. Other channels and channel interfaces can provide a correlation between particular senders and an <xref:System.ServiceModel.Channels.IInputChannel>, but the base contract makes no such restriction. An implementation can create a new <xref:System.ServiceModel.Channels.IInputChannel> for each message or reuse the same <xref:System.ServiceModel.Channels.IInputChannel> for multiple messages and senders.","pos":[0,500],"nodes":[{"content":"An <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel&gt;</ph> is not necessarily bound to a single sender.","pos":[0,97],"source":"An <xref:System.ServiceModel.Channels.IInputChannel> is not necessarily bound to a single sender."},{"content":"Other channels and channel interfaces can provide a correlation between particular senders and an <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel&gt;</ph>, but the base contract makes no such restriction.","pos":[98,295],"source":" Other channels and channel interfaces can provide a correlation between particular senders and an <xref:System.ServiceModel.Channels.IInputChannel>, but the base contract makes no such restriction."},{"content":"An implementation can create a new <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel&gt;</ph> for each message or reuse the same <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IInputChannel&gt;</ph> for multiple messages and senders.","pos":[296,500],"source":" An implementation can create a new <xref:System.ServiceModel.Channels.IInputChannel> for each message or reuse the same <xref:System.ServiceModel.Channels.IInputChannel> for multiple messages and senders."}]}]}],"pos":[1603,3213],"yaml":true,"extradata":"MT"},{"content":"Begins an asynchronous operation to receive a message that has a state object associated with it.","nodes":[{"pos":[0,97],"content":"Begins an asynchronous operation to receive a message that has a state object associated with it.","nodes":[{"content":"Begins an asynchronous operation to receive a message that has a state object associated with it.","pos":[0,97]}]}],"pos":[4759,4857],"yaml":true},{"content":"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received. Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until the request message is received or the interval of time specified by the `timeout` has been exceeded. The asynchronous operation is available with or without an explicit timeout.  \n  \n This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until a message becomes available in the channel.","nodes":[{"pos":[0,526],"content":"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received. Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until the request message is received or the interval of time specified by the `timeout` has been exceeded. The asynchronous operation is available with or without an explicit timeout.","nodes":[{"content":"Use the asynchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A&gt;</ph> method when you want the application processing to continue without waiting for the request to be received.","pos":[0,194],"source":"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received."},{"content":"Use the synchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph> method when it is acceptable for the current thread to be blocked until the request message is received or the interval of time specified by the <ph id=\"ph2\">`timeout`</ph> has been exceeded.","pos":[195,449],"source":" Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until the request message is received or the interval of time specified by the `timeout` has been exceeded."},{"content":"The asynchronous operation is available with or without an explicit timeout.","pos":[450,526]}]},{"pos":[533,723],"content":"This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until a message becomes available in the channel.","nodes":[{"content":"This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until a message becomes available in the channel.","pos":[0,190],"nodes":[{"content":"This method receives notification, through a callback, of the identity of the event handler for the operation.","pos":[0,110]},{"content":"The operation is not complete until a message becomes available in the channel.","pos":[111,190]}]}]}],"pos":[4868,5596],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous operation completion.","nodes":[{"pos":[0,127],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate that receives the notification of the asynchronous operation completion.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous operation completion."}],"pos":[6010,6138],"yaml":true},{"content":"An object, specified by the application, that contains state information associated with the asynchronous operation.","nodes":[{"pos":[0,116],"content":"An object, specified by the application, that contains state information associated with the asynchronous operation.","nodes":[{"content":"An object, specified by the application, that contains state information associated with the asynchronous operation.","pos":[0,116]}]}],"pos":[6199,6316],"yaml":true},{"content":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous message reception.","nodes":[{"pos":[0,96],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous message reception.","source":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous message reception."}],"pos":[6379,6476],"yaml":true},{"content":"Begins an asynchronous operation to receive a message that has a specified time out and state object associated with it.","nodes":[{"pos":[0,120],"content":"Begins an asynchronous operation to receive a message that has a specified time out and state object associated with it.","nodes":[{"content":"Begins an asynchronous operation to receive a message that has a specified time out and state object associated with it.","pos":[0,120]}]}],"pos":[7914,8035],"yaml":true},{"content":"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received. Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until the request message is received or the interval of time specified by the `timeout` has been exceeded. The asynchronous operation is available with or without an explicit timeout.  \n  \n The operation is not complete until either a message becomes available in the channel or the time out occurs.","nodes":[{"pos":[0,526],"content":"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received. Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until the request message is received or the interval of time specified by the `timeout` has been exceeded. The asynchronous operation is available with or without an explicit timeout.","nodes":[{"content":"Use the asynchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A&gt;</ph> method when you want the application processing to continue without waiting for the request to be received.","pos":[0,194],"source":"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received."},{"content":"Use the synchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph> method when it is acceptable for the current thread to be blocked until the request message is received or the interval of time specified by the <ph id=\"ph2\">`timeout`</ph> has been exceeded.","pos":[195,449],"source":" Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until the request message is received or the interval of time specified by the `timeout` has been exceeded."},{"content":"The asynchronous operation is available with or without an explicit timeout.","pos":[450,526]}]},{"pos":[533,642],"content":"The operation is not complete until either a message becomes available in the channel or the time out occurs.","nodes":[{"content":"The operation is not complete until either a message becomes available in the channel or the time out occurs.","pos":[0,109]}]}],"pos":[8046,8693],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for a message to become available.","nodes":[{"pos":[0,119],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that specifies the interval of time to wait for a message to become available.","source":"The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for a message to become available."}],"pos":[9119,9239],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous operation completion.","nodes":[{"pos":[0,127],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate that receives the notification of the asynchronous operation completion.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous operation completion."}],"pos":[9310,9438],"yaml":true},{"content":"An object, specified by the application, that contains state information associated with the asynchronous operation.","nodes":[{"pos":[0,116],"content":"An object, specified by the application, that contains state information associated with the asynchronous operation.","nodes":[{"content":"An object, specified by the application, that contains state information associated with the asynchronous operation.","pos":[0,116]}]}],"pos":[9499,9616],"yaml":true},{"content":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous receive operation.","nodes":[{"pos":[0,96],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous receive operation.","source":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous receive operation."}],"pos":[9679,9776],"yaml":true},{"content":"The specified <code>timeout</code> is exceeded before the operation is completed.","nodes":[{"pos":[0,81],"content":"The specified <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is exceeded before the operation is completed.","source":"The specified <code>timeout</code> is exceeded before the operation is completed."}],"pos":[9951,10033],"yaml":true},{"content":"The timeout specified is less than zero.","nodes":[{"pos":[0,40],"content":"The timeout specified is less than zero.","nodes":[{"content":"The timeout specified is less than zero.","pos":[0,40]}]}],"pos":[10147,10188],"yaml":true},{"content":"Begins an asynchronous operation to receive a message that has a specified time out and state object associated with it.","nodes":[{"pos":[0,120],"content":"Begins an asynchronous operation to receive a message that has a specified time out and state object associated with it.","nodes":[{"content":"Begins an asynchronous operation to receive a message that has a specified time out and state object associated with it.","pos":[0,120]}]}],"pos":[11558,11679],"yaml":true},{"content":"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method when you want the application processing to continue without waiting. Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> method when it is acceptable for the current thread to be blocked while it replies to the request message or until the timeout interval is exceeded.  \n  \n The operation is not complete until either a message becomes available in the channel or the timeout occurs.  \n  \n If you are going to handle timeouts and not just re-throw or wrap the <xref:System.TimeoutException>, then you should call <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> instead of <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>.  \n  \n If you are not going to treat timeouts specially then just call <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>, otherwise you lose error information.","nodes":[{"pos":[0,516],"content":"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method when you want the application processing to continue without waiting. Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> method when it is acceptable for the current thread to be blocked while it replies to the request message or until the timeout interval is exceeded.","nodes":[{"content":"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method when you want the application processing to continue without waiting. Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> method when it is acceptable for the current thread to be blocked while it replies to the request message or until the timeout interval is exceeded.","pos":[0,516],"nodes":[{"content":"Use the asynchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29&gt;</ph> method when you want the application processing to continue without waiting.","pos":[0,223],"source":"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method when you want the application processing to continue without waiting."},{"content":"Use the synchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29&gt;</ph> method when it is acceptable for the current thread to be blocked while it replies to the request message or until the timeout interval is exceeded.","pos":[224,516],"source":" Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> method when it is acceptable for the current thread to be blocked while it replies to the request message or until the timeout interval is exceeded."}]}]},{"pos":[523,631],"content":"The operation is not complete until either a message becomes available in the channel or the timeout occurs.","nodes":[{"content":"The operation is not complete until either a message becomes available in the channel or the timeout occurs.","pos":[0,108]}]},{"pos":[638,964],"content":"If you are going to handle timeouts and not just re-throw or wrap the <xref:System.TimeoutException>, then you should call <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> instead of <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>.","nodes":[{"content":"If you are going to handle timeouts and not just re-throw or wrap the <ph id=\"ph1\">&lt;xref:System.TimeoutException&gt;</ph>, then you should call <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29&gt;</ph> instead of <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A&gt;</ph>.","pos":[0,326],"source":"If you are going to handle timeouts and not just re-throw or wrap the <xref:System.TimeoutException>, then you should call <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> instead of <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>."}]},{"pos":[971,1139],"content":"If you are not going to treat timeouts specially then just call <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>, otherwise you lose error information.","nodes":[{"content":"If you are not going to treat timeouts specially then just call <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A&gt;</ph>, otherwise you lose error information.","pos":[0,168],"source":"If you are not going to treat timeouts specially then just call <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>, otherwise you lose error information."}]}],"pos":[11690,12838],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for a message to become available.","nodes":[{"pos":[0,119],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that specifies the interval of time to wait for a message to become available.","source":"The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for a message to become available."}],"pos":[13267,13387],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous operation completion.","nodes":[{"pos":[0,127],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate that receives the notification of the asynchronous operation completion.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous operation completion."}],"pos":[13458,13586],"yaml":true},{"content":"An object, specified by the application, that contains state information associated with the asynchronous operation.","nodes":[{"pos":[0,116],"content":"An object, specified by the application, that contains state information associated with the asynchronous operation.","nodes":[{"content":"An object, specified by the application, that contains state information associated with the asynchronous operation.","pos":[0,116]}]}],"pos":[13647,13764],"yaml":true},{"content":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous receive operation.","nodes":[{"pos":[0,96],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous receive operation.","source":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous receive operation."}],"pos":[13827,13924],"yaml":true},{"content":"The specified <code>timeout</code> is exceeded before the operation is completed.","nodes":[{"pos":[0,81],"content":"The specified <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is exceeded before the operation is completed.","source":"The specified <code>timeout</code> is exceeded before the operation is completed."}],"pos":[14102,14184],"yaml":true},{"content":"The timeout specified is less than zero.","nodes":[{"pos":[0,40],"content":"The timeout specified is less than zero.","nodes":[{"content":"The timeout specified is less than zero.","pos":[0,40]}]}],"pos":[14298,14339],"yaml":true},{"content":"Begins an asynchronous wait-for-a-message-to-arrive operation that has a specified time out and state object associated with it.","nodes":[{"pos":[0,128],"content":"Begins an asynchronous wait-for-a-message-to-arrive operation that has a specified time out and state object associated with it.","nodes":[{"content":"Begins an asynchronous wait-for-a-message-to-arrive operation that has a specified time out and state object associated with it.","pos":[0,128]}]}],"pos":[15733,15862],"yaml":true},{"content":"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method if you need the application processing to continue without waiting for the message to arrive. Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> method when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread is blocked up to the specified `timeout`.  \n  \n This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the channel or the time out occurs.","nodes":[{"pos":[0,529],"content":"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method if you need the application processing to continue without waiting for the message to arrive. Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> method when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread is blocked up to the specified `timeout`.","nodes":[{"content":"Use the asynchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29&gt;</ph> method if you need the application processing to continue without waiting for the message to arrive.","pos":[0,251],"source":"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method if you need the application processing to continue without waiting for the message to arrive."},{"content":"Use the synchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29&gt;</ph> method when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.","pos":[252,476],"source":" Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> method when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue."},{"content":"The thread is blocked up to the specified <ph id=\"ph1\">`timeout`</ph>.","pos":[477,529],"source":" The thread is blocked up to the specified `timeout`."}]},{"pos":[536,756],"content":"This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the channel or the time out occurs.","nodes":[{"content":"This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the channel or the time out occurs.","pos":[0,220],"nodes":[{"content":"This method receives notification, through a callback, of the identity of the event handler for the operation.","pos":[0,110]},{"content":"The operation is not complete until either a message becomes available in the channel or the time out occurs.","pos":[111,220]}]}]}],"pos":[15873,16634],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for a message to become available.","nodes":[{"pos":[0,119],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that specifies the interval of time to wait for a message to become available.","source":"The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for a message to become available."}],"pos":[17067,17187],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous operation completion.","nodes":[{"pos":[0,127],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate that receives the notification of the asynchronous operation completion.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous operation completion."}],"pos":[17258,17386],"yaml":true},{"content":"An object, specified by the application, that contains state information associated with the asynchronous operation.","nodes":[{"pos":[0,116],"content":"An object, specified by the application, that contains state information associated with the asynchronous operation.","nodes":[{"content":"An object, specified by the application, that contains state information associated with the asynchronous operation.","pos":[0,116]}]}],"pos":[17447,17564],"yaml":true},{"content":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous operation to wait for a message to arrive.","nodes":[{"pos":[0,120],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous operation to wait for a message to arrive.","source":"The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous operation to wait for a message to arrive."}],"pos":[17627,17748],"yaml":true},{"content":"The specified <code>timeout</code> is exceeded before the operation is completed.","nodes":[{"pos":[0,81],"content":"The specified <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is exceeded before the operation is completed.","source":"The specified <code>timeout</code> is exceeded before the operation is completed."}],"pos":[17930,18012],"yaml":true},{"content":"The timeout specified is less than zero.","nodes":[{"pos":[0,40],"content":"The timeout specified is less than zero.","nodes":[{"content":"The timeout specified is less than zero.","pos":[0,40]}]}],"pos":[18126,18167],"yaml":true},{"content":"Completes an asynchronous operation to receive a message.","nodes":[{"pos":[0,57],"content":"Completes an asynchronous operation to receive a message.","nodes":[{"content":"Completes an asynchronous operation to receive a message.","pos":[0,57]}]}],"pos":[19357,19415],"yaml":true},{"content":"The <xref href=\"System.IAsyncResult\"></xref> returned by a call to one of the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginReceive*\"></xref> methods.","nodes":[{"pos":[0,164],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> returned by a call to one of the <ph id=\"ph2\">&lt;xref href=\"System.ServiceModel.Channels.IInputChannel.BeginReceive*\"&gt;&lt;/xref&gt;</ph> methods.","source":"The <xref href=\"System.IAsyncResult\"></xref> returned by a call to one of the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginReceive*\"></xref> methods."}],"pos":[19845,20010],"yaml":true},{"content":"The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received.","nodes":[{"pos":[0,71],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.ServiceModel.Channels.Message\"&gt;&lt;/xref&gt;</ph> received.","source":"The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received."}],"pos":[20090,20162],"yaml":true},{"content":"Completes the specified asynchronous operation to receive a message.","nodes":[{"pos":[0,68],"content":"Completes the specified asynchronous operation to receive a message.","nodes":[{"content":"Completes the specified asynchronous operation to receive a message.","pos":[0,68]}]}],"pos":[21595,21664],"yaml":true},{"content":"The <xref href=\"System.IAsyncResult\"></xref> returned by a call to the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)\"></xref> method.","nodes":[{"pos":[0,210],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> returned by a call to the <ph id=\"ph2\">&lt;xref href=\"System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph> method.","source":"The <xref href=\"System.IAsyncResult\"></xref> returned by a call to the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)\"></xref> method."}],"pos":[22115,22326],"yaml":true},{"content":"The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received.","nodes":[{"pos":[0,71],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.ServiceModel.Channels.Message\"&gt;&lt;/xref&gt;</ph> received.","source":"The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received."}],"pos":[22412,22484],"yaml":true},{"content":"`true` if a message is received before the specified interval of time elapses; otherwise `false`.","nodes":[{"pos":[0,97],"content":"<ph id=\"ph1\">`true`</ph> if a message is received before the specified interval of time elapses; otherwise <ph id=\"ph2\">`false`</ph>.","source":"`true` if a message is received before the specified interval of time elapses; otherwise `false`."}],"pos":[22542,22642],"yaml":true},{"content":"Completes the specified asynchronous wait-for-a-message operation.","nodes":[{"pos":[0,66],"content":"Completes the specified asynchronous wait-for-a-message operation.","nodes":[{"content":"Completes the specified asynchronous wait-for-a-message operation.","pos":[0,66]}]}],"pos":[23961,24028],"yaml":true},{"content":"The <xref href=\"System.IAsyncResult\"></xref> that identifies the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)\"></xref> operation to finish, and from which to retrieve an end result.","nodes":[{"pos":[0,263],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that identifies the <ph id=\"ph2\">&lt;xref href=\"System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph> operation to finish, and from which to retrieve an end result.","source":"The <xref href=\"System.IAsyncResult\"></xref> that identifies the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)\"></xref> operation to finish, and from which to retrieve an end result."}],"pos":[24433,24697],"yaml":true},{"content":"`true` if a message has arrived before the <code>timeout</code> has been exceeded; otherwise `false`.","nodes":[{"pos":[0,101],"content":"<ph id=\"ph1\">`true`</ph> if a message has arrived before the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> has been exceeded; otherwise <ph id=\"ph3\">`false`</ph>.","source":"`true` if a message has arrived before the <code>timeout</code> has been exceeded; otherwise `false`."}],"pos":[24755,24859],"yaml":true},{"content":"Gets the address on which the input channel receives messages.","nodes":[{"pos":[0,62],"content":"Gets the address on which the input channel receives messages.","nodes":[{"content":"Gets the address on which the input channel receives messages.","pos":[0,62]}]}],"pos":[26049,26112],"yaml":true},{"content":"If this input channel does not have a standalone address (for example, it is the input-side of a client-initiated TCP channel), then this property is `null`.  \n  \n This property can be used by higher-level channels for correlation purposes. For example, if a higher-level channel implements request-reply on top of a <xref:System.ServiceModel.Channels.IDuplexChannel>, it can use the <xref:System.ServiceModel.Channels.IInputChannel.LocalAddress%2A> property in the WS-Addressing ReplyTo header.","nodes":[{"pos":[0,157],"content":"If this input channel does not have a standalone address (for example, it is the input-side of a client-initiated TCP channel), then this property is <ph id=\"ph1\">`null`</ph>.","source":"If this input channel does not have a standalone address (for example, it is the input-side of a client-initiated TCP channel), then this property is `null`."},{"pos":[164,495],"content":"This property can be used by higher-level channels for correlation purposes. For example, if a higher-level channel implements request-reply on top of a <xref:System.ServiceModel.Channels.IDuplexChannel>, it can use the <xref:System.ServiceModel.Channels.IInputChannel.LocalAddress%2A> property in the WS-Addressing ReplyTo header.","nodes":[{"content":"This property can be used by higher-level channels for correlation purposes. For example, if a higher-level channel implements request-reply on top of a <xref:System.ServiceModel.Channels.IDuplexChannel>, it can use the <xref:System.ServiceModel.Channels.IInputChannel.LocalAddress%2A> property in the WS-Addressing ReplyTo header.","pos":[0,331],"nodes":[{"content":"This property can be used by higher-level channels for correlation purposes.","pos":[0,76]},{"content":"For example, if a higher-level channel implements request-reply on top of a <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IDuplexChannel&gt;</ph>, it can use the <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IInputChannel.LocalAddress%2A&gt;</ph> property in the WS-Addressing ReplyTo header.","pos":[77,331],"source":" For example, if a higher-level channel implements request-reply on top of a <xref:System.ServiceModel.Channels.IDuplexChannel>, it can use the <xref:System.ServiceModel.Channels.IInputChannel.LocalAddress%2A> property in the WS-Addressing ReplyTo header."}]}]}],"pos":[26123,26623],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.ServiceModel.EndpointAddress\"></xref> on which the input channel receives messages.","nodes":[{"pos":[0,106],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.ServiceModel.EndpointAddress\"&gt;&lt;/xref&gt;</ph> on which the input channel receives messages.","source":"The <xref href=\"System.ServiceModel.EndpointAddress\"></xref> on which the input channel receives messages."}],"pos":[27023,27130],"yaml":true},{"content":"Returns the message received, if one is available. If a message is not available, blocks for a default interval of time.","nodes":[{"pos":[0,120],"content":"Returns the message received, if one is available. If a message is not available, blocks for a default interval of time.","nodes":[{"content":"Returns the message received, if one is available. If a message is not available, blocks for a default interval of time.","pos":[0,120],"nodes":[{"content":"Returns the message received, if one is available.","pos":[0,50]},{"content":"If a message is not available, blocks for a default interval of time.","pos":[51,120]}]}]}],"pos":[28289,28410],"yaml":true},{"content":"Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until it receives the request message or exceeds the interval of time specified by `timeout`. Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received.  \n  \n The synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> operation is available with or without an explicit timeout.  \n  \n If a message is not available, it blocks until one is available or until the timeout is exceeded.  \n  \n <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> call can complete for each message received.","nodes":[{"pos":[0,435],"content":"Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until it receives the request message or exceeds the interval of time specified by `timeout`. Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received.","nodes":[{"content":"Use the synchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph> method when it is acceptable for the current thread to be blocked until it receives the request message or exceeds the interval of time specified by <ph id=\"ph2\">`timeout`</ph>.","pos":[0,240],"source":"Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until it receives the request message or exceeds the interval of time specified by `timeout`."},{"content":"Use the asynchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A&gt;</ph> method when you want the application processing to continue without waiting for the request to be received.","pos":[241,435],"source":" Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received."}]},{"pos":[442,578],"content":"The synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> operation is available with or without an explicit timeout.","nodes":[{"content":"The synchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph> operation is available with or without an explicit timeout.","pos":[0,136],"source":"The synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> operation is available with or without an explicit timeout."}]},{"pos":[585,682],"content":"If a message is not available, it blocks until one is available or until the timeout is exceeded.","nodes":[{"content":"If a message is not available, it blocks until one is available or until the timeout is exceeded.","pos":[0,97]}]},{"pos":[689,910],"content":"<xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> call can complete for each message received.","nodes":[{"content":"<xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> call can complete for each message received.","pos":[0,221],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph> can be called multiple times or concurrently.","pos":[0,106],"source":"<xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> can be called multiple times or concurrently."},{"content":"Only one <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph> call can complete for each message received.","pos":[107,221],"source":" Only one <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> call can complete for each message received."}]}]}],"pos":[28421,29340],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received.","nodes":[{"pos":[0,71],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.ServiceModel.Channels.Message\"&gt;&lt;/xref&gt;</ph> received.","source":"The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received."}],"pos":[29749,29821],"yaml":true},{"content":"Returns the message received, if one is available. If a message is not available, blocks for a specified interval of time.","nodes":[{"pos":[0,122],"content":"Returns the message received, if one is available. If a message is not available, blocks for a specified interval of time.","nodes":[{"content":"Returns the message received, if one is available. If a message is not available, blocks for a specified interval of time.","pos":[0,122],"nodes":[{"content":"Returns the message received, if one is available.","pos":[0,50]},{"content":"If a message is not available, blocks for a specified interval of time.","pos":[51,122]}]}]}],"pos":[31050,31173],"yaml":true},{"content":"Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until it receives the request message or exceeds the interval of time specified by `timeout`. Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received.  \n  \n The synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> operation is available with or without an explicit timeout.  \n  \n If a message is not available, it blocks until one is available or until the timeout is exceeded.  \n  \n <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> call can complete for each message received.","nodes":[{"pos":[0,435],"content":"Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until it receives the request message or exceeds the interval of time specified by `timeout`. Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received.","nodes":[{"content":"Use the synchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph> method when it is acceptable for the current thread to be blocked until it receives the request message or exceeds the interval of time specified by <ph id=\"ph2\">`timeout`</ph>.","pos":[0,240],"source":"Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until it receives the request message or exceeds the interval of time specified by `timeout`."},{"content":"Use the asynchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A&gt;</ph> method when you want the application processing to continue without waiting for the request to be received.","pos":[241,435],"source":" Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received."}]},{"pos":[442,578],"content":"The synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> operation is available with or without an explicit timeout.","nodes":[{"content":"The synchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph> operation is available with or without an explicit timeout.","pos":[0,136],"source":"The synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> operation is available with or without an explicit timeout."}]},{"pos":[585,682],"content":"If a message is not available, it blocks until one is available or until the timeout is exceeded.","nodes":[{"content":"If a message is not available, it blocks until one is available or until the timeout is exceeded.","pos":[0,97]}]},{"pos":[689,910],"content":"<xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> call can complete for each message received.","nodes":[{"content":"<xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> call can complete for each message received.","pos":[0,221],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph> can be called multiple times or concurrently.","pos":[0,106],"source":"<xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> can be called multiple times or concurrently."},{"content":"Only one <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph> call can complete for each message received.","pos":[107,221],"source":" Only one <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> call can complete for each message received."}]}]}],"pos":[31184,32103],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.TimeSpan\"></xref> that specifies how long the receive operation has to complete before timing out and throwing a <xref href=\"System.TimeoutException\"></xref>.","nodes":[{"pos":[0,181],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that specifies how long the receive operation has to complete before timing out and throwing a <ph id=\"ph2\">&lt;xref href=\"System.TimeoutException\"&gt;&lt;/xref&gt;</ph>.","source":"The <xref href=\"System.TimeSpan\"></xref> that specifies how long the receive operation has to complete before timing out and throwing a <xref href=\"System.TimeoutException\"></xref>."}],"pos":[32510,32692],"yaml":true},{"content":"The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received.","nodes":[{"pos":[0,71],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.ServiceModel.Channels.Message\"&gt;&lt;/xref&gt;</ph> received.","source":"The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received."}],"pos":[32772,32844],"yaml":true},{"content":"The specified <code>timeout</code> is exceeded before the operation is completed.","nodes":[{"pos":[0,81],"content":"The specified <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is exceeded before the operation is completed.","source":"The specified <code>timeout</code> is exceeded before the operation is completed."}],"pos":[33014,33096],"yaml":true},{"content":"The timeout specified is less than zero.","nodes":[{"pos":[0,40],"content":"The timeout specified is less than zero.","nodes":[{"content":"The timeout specified is less than zero.","pos":[0,40]}]}],"pos":[33210,33251],"yaml":true},{"content":"Tries to receive a message within a specified interval of time.","nodes":[{"pos":[0,63],"content":"Tries to receive a message within a specified interval of time.","nodes":[{"content":"Tries to receive a message within a specified interval of time.","pos":[0,63]}]}],"pos":[34558,34622],"yaml":true},{"content":"If you are going to handle timeouts and not just re-throw or wrap the <xref:System.TimeoutException>, then you should call <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> instead of <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.  \n  \n If you are not going to treat timeouts specially then just call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>, otherwise you will lose error information.","nodes":[{"pos":[0,319],"content":"If you are going to handle timeouts and not just re-throw or wrap the <xref:System.TimeoutException>, then you should call <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> instead of <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.","nodes":[{"content":"If you are going to handle timeouts and not just re-throw or wrap the <ph id=\"ph1\">&lt;xref:System.TimeoutException&gt;</ph>, then you should call <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29&gt;</ph> instead of <ph id=\"ph3\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph>.","pos":[0,319],"source":"If you are going to handle timeouts and not just re-throw or wrap the <xref:System.TimeoutException>, then you should call <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> instead of <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>."}]},{"pos":[326,494],"content":"If you are not going to treat timeouts specially then just call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>, otherwise you will lose error information.","nodes":[{"content":"If you are not going to treat timeouts specially then just call <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph>, otherwise you will lose error information.","pos":[0,168],"source":"If you are not going to treat timeouts specially then just call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>, otherwise you will lose error information."}]}],"pos":[34633,35132],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.IAsyncResult\"></xref> returned by a call to one of the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginReceive*\"></xref> methods.","nodes":[{"pos":[0,164],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> returned by a call to one of the <ph id=\"ph2\">&lt;xref href=\"System.ServiceModel.Channels.IInputChannel.BeginReceive*\"&gt;&lt;/xref&gt;</ph> methods.","source":"The <xref href=\"System.IAsyncResult\"></xref> returned by a call to one of the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginReceive*\"></xref> methods."}],"pos":[35560,35725],"yaml":true},{"content":"The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received.","nodes":[{"pos":[0,71],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.ServiceModel.Channels.Message\"&gt;&lt;/xref&gt;</ph> received.","source":"The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received."}],"pos":[35811,35883],"yaml":true},{"content":"`true` if a message is received before the <code>timeout</code> has been exceeded; otherwise `false`.","nodes":[{"pos":[0,101],"content":"<ph id=\"ph1\">`true`</ph> if a message is received before the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> has been exceeded; otherwise <ph id=\"ph3\">`false`</ph>.","source":"`true` if a message is received before the <code>timeout</code> has been exceeded; otherwise `false`."}],"pos":[35941,36045],"yaml":true},{"content":"The specified <code>timeout</code> is exceeded before the operation is completed.","nodes":[{"pos":[0,81],"content":"The specified <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is exceeded before the operation is completed.","source":"The specified <code>timeout</code> is exceeded before the operation is completed."}],"pos":[36218,36300],"yaml":true},{"content":"The timeout specified is less than zero.","nodes":[{"pos":[0,40],"content":"The timeout specified is less than zero.","nodes":[{"content":"The timeout specified is less than zero.","pos":[0,40]}]}],"pos":[36414,36455],"yaml":true},{"content":"Returns a value that indicates whether a message has arrived within a specified interval of time.","nodes":[{"pos":[0,97],"content":"Returns a value that indicates whether a message has arrived within a specified interval of time.","nodes":[{"content":"Returns a value that indicates whether a message has arrived within a specified interval of time.","pos":[0,97]}]}],"pos":[37645,37743],"yaml":true},{"content":"Calling <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> does not result in a message being received or processed in any other way.  \n  \n The <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> method exists primarily for transacted scenarios where the user wants to receive the message using a transaction. When using just <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> normally for this, the user must create the transaction and then call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> and hope the message arrives before the transaction times out, which may not be possible.  \n  \n Instead, the user can call <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> with whatever time out they want (even infinite), then when a message arrives they can open the transaction, call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> and be confident that they can get the message back before the transaction expires.  \n  \n This method is synchronous, so it blocks the current thread until a message is available or the time out occurs. Use <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread is blocked up to the specified `timeout`. If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method.","nodes":[{"pos":[0,168],"content":"Calling <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> does not result in a message being received or processed in any other way.","nodes":[{"content":"Calling <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29&gt;</ph> does not result in a message being received or processed in any other way.","pos":[0,168],"source":"Calling <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> does not result in a message being received or processed in any other way."}]},{"pos":[175,676],"content":"The <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> method exists primarily for transacted scenarios where the user wants to receive the message using a transaction. When using just <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> normally for this, the user must create the transaction and then call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> and hope the message arrives before the transaction times out, which may not be possible.","nodes":[{"content":"The <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> method exists primarily for transacted scenarios where the user wants to receive the message using a transaction. When using just <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> normally for this, the user must create the transaction and then call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> and hope the message arrives before the transaction times out, which may not be possible.","pos":[0,501],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29&gt;</ph> method exists primarily for transacted scenarios where the user wants to receive the message using a transaction.","pos":[0,203],"source":"The <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> method exists primarily for transacted scenarios where the user wants to receive the message using a transaction."},{"content":"When using just <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph> normally for this, the user must create the transaction and then call <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph> and hope the message arrives before the transaction times out, which may not be possible.","pos":[204,501],"source":" When using just <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> normally for this, the user must create the transaction and then call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> and hope the message arrives before the transaction times out, which may not be possible."}]}]},{"pos":[683,1054],"content":"Instead, the user can call <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> with whatever time out they want (even infinite), then when a message arrives they can open the transaction, call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> and be confident that they can get the message back before the transaction expires.","nodes":[{"content":"Instead, the user can call <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29&gt;</ph> with whatever time out they want (even infinite), then when a message arrives they can open the transaction, call <ph id=\"ph2\">&lt;xref:System.ServiceModel.Channels.IInputChannel.Receive%2A&gt;</ph> and be confident that they can get the message back before the transaction expires.","pos":[0,371],"source":"Instead, the user can call <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> with whatever time out they want (even infinite), then when a message arrives they can open the transaction, call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> and be confident that they can get the message back before the transaction expires."}]},{"pos":[1061,1655],"content":"This method is synchronous, so it blocks the current thread until a message is available or the time out occurs. Use <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread is blocked up to the specified `timeout`. If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method.","nodes":[{"content":"This method is synchronous, so it blocks the current thread until a message is available or the time out occurs.","pos":[0,112]},{"content":"Use <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29&gt;</ph> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue.","pos":[113,314],"source":" Use <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue."},{"content":"The thread is blocked up to the specified <ph id=\"ph1\">`timeout`</ph>.","pos":[315,367],"source":" The thread is blocked up to the specified `timeout`."},{"content":"If you need the application processing to continue without waiting, use the asynchronous <ph id=\"ph1\">&lt;xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29&gt;</ph> method.","pos":[368,594],"source":" If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method."}]}],"pos":[37754,39418],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.TimeSpan\"></xref> specifies the maximum interval of time to wait for a message to arrive before timing out.","nodes":[{"pos":[0,130],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> specifies the maximum interval of time to wait for a message to arrive before timing out.","source":"The <xref href=\"System.TimeSpan\"></xref> specifies the maximum interval of time to wait for a message to arrive before timing out."}],"pos":[39800,39931],"yaml":true},{"content":"`true` if a message has arrived before the <code>timeout</code> has been exceeded; otherwise `false`.","nodes":[{"pos":[0,101],"content":"<ph id=\"ph1\">`true`</ph> if a message has arrived before the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> has been exceeded; otherwise <ph id=\"ph3\">`false`</ph>.","source":"`true` if a message has arrived before the <code>timeout</code> has been exceeded; otherwise `false`."}],"pos":[39989,40093],"yaml":true},{"content":"The specified <code>timeout</code> is exceeded before the operation is completed.","nodes":[{"pos":[0,81],"content":"The specified <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is exceeded before the operation is completed.","source":"The specified <code>timeout</code> is exceeded before the operation is completed."}],"pos":[40270,40352],"yaml":true},{"content":"The timeout specified is less than zero.","nodes":[{"pos":[0,40],"content":"The timeout specified is less than zero.","nodes":[{"content":"The timeout specified is less than zero.","pos":[0,40]}]}],"pos":[40466,40507],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.ServiceModel.Channels.IInputChannel\n  commentId: T:System.ServiceModel.Channels.IInputChannel\n  id: IInputChannel\n  children:\n  - System.ServiceModel.Channels.IInputChannel.BeginReceive(System.AsyncCallback,System.Object)\n  - System.ServiceModel.Channels.IInputChannel.BeginReceive(System.TimeSpan,System.AsyncCallback,System.Object)\n  - System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)\n  - System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)\n  - System.ServiceModel.Channels.IInputChannel.EndReceive(System.IAsyncResult)\n  - System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)\n  - System.ServiceModel.Channels.IInputChannel.EndWaitForMessage(System.IAsyncResult)\n  - System.ServiceModel.Channels.IInputChannel.LocalAddress\n  - System.ServiceModel.Channels.IInputChannel.Receive\n  - System.ServiceModel.Channels.IInputChannel.Receive(System.TimeSpan)\n  - System.ServiceModel.Channels.IInputChannel.TryReceive(System.TimeSpan,System.ServiceModel.Channels.Message@)\n  - System.ServiceModel.Channels.IInputChannel.WaitForMessage(System.TimeSpan)\n  langs:\n  - csharp\n  name: IInputChannel\n  nameWithType: IInputChannel\n  fullName: System.ServiceModel.Channels.IInputChannel\n  type: Interface\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Defines the interface that a channel must implement to receive a message.\n  remarks: \"The <xref:System.ServiceModel.Channels.IInputChannel> contract includes synchronous and asynchronous variants of receive, try-to-receive and wait-for-a-message functionality.  \\n  \\n The pull model is used typically with an <xref:System.ServiceModel.Channels.IInputChannel> to receive messages: you call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> (to \\\"pull\\\" a message out of the channel) and then wait for a message to arrive. An alternative usage pattern is to call <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> or <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29>, and then call <xref:System.ServiceModel.Channels.IInputChannel.Receive%28System.TimeSpan%29>. This approach is common for transactional usages where you start the transaction between the calls to <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> and <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.  \\n  \\n An <xref:System.ServiceModel.Channels.IInputChannel> is not necessarily bound to a single sender. Other channels and channel interfaces can provide a correlation between particular senders and an <xref:System.ServiceModel.Channels.IInputChannel>, but the base contract makes no such restriction. An implementation can create a new <xref:System.ServiceModel.Channels.IInputChannel> for each message or reuse the same <xref:System.ServiceModel.Channels.IInputChannel> for multiple messages and senders.\"\n  syntax:\n    content: 'public interface IInputChannel : System.ServiceModel.Channels.IChannel'\n  derivedClasses:\n  - System.ServiceModel.Channels.IDuplexChannel\n  - System.ServiceModel.Channels.IInputSessionChannel\n  implements:\n  - System.ServiceModel.Channels.IChannel\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IInputChannel.BeginReceive(System.AsyncCallback,System.Object)\n  commentId: M:System.ServiceModel.Channels.IInputChannel.BeginReceive(System.AsyncCallback,System.Object)\n  id: BeginReceive(System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IInputChannel\n  langs:\n  - csharp\n  name: BeginReceive(AsyncCallback, Object)\n  nameWithType: IInputChannel.BeginReceive(AsyncCallback, Object)\n  fullName: IInputChannel.BeginReceive(AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Begins an asynchronous operation to receive a message that has a state object associated with it.\n  remarks: \"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received. Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until the request message is received or the interval of time specified by the `timeout` has been exceeded. The asynchronous operation is available with or without an explicit timeout.  \\n  \\n This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until a message becomes available in the channel.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#15](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#15)]\"\n  syntax:\n    content: public IAsyncResult BeginReceive (AsyncCallback callback, object state);\n    parameters:\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous operation completion.\n    - id: state\n      type: System.Object\n      description: An object, specified by the application, that contains state information associated with the asynchronous operation.\n    return:\n      type: System.IAsyncResult\n      description: The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous message reception.\n  overload: System.ServiceModel.Channels.IInputChannel.BeginReceive*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IInputChannel.BeginReceive(System.TimeSpan,System.AsyncCallback,System.Object)\n  commentId: M:System.ServiceModel.Channels.IInputChannel.BeginReceive(System.TimeSpan,System.AsyncCallback,System.Object)\n  id: BeginReceive(System.TimeSpan,System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IInputChannel\n  langs:\n  - csharp\n  name: BeginReceive(TimeSpan, AsyncCallback, Object)\n  nameWithType: IInputChannel.BeginReceive(TimeSpan, AsyncCallback, Object)\n  fullName: IInputChannel.BeginReceive(TimeSpan, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Begins an asynchronous operation to receive a message that has a specified time out and state object associated with it.\n  remarks: \"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received. Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until the request message is received or the interval of time specified by the `timeout` has been exceeded. The asynchronous operation is available with or without an explicit timeout.  \\n  \\n The operation is not complete until either a message becomes available in the channel or the time out occurs.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#16](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#16)]\"\n  syntax:\n    content: public IAsyncResult BeginReceive (TimeSpan timeout, AsyncCallback callback, object state);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for a message to become available.\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous operation completion.\n    - id: state\n      type: System.Object\n      description: An object, specified by the application, that contains state information associated with the asynchronous operation.\n    return:\n      type: System.IAsyncResult\n      description: The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous receive operation.\n  overload: System.ServiceModel.Channels.IInputChannel.BeginReceive*\n  exceptions:\n  - type: System.TimeoutException\n    commentId: T:System.TimeoutException\n    description: The specified <code>timeout</code> is exceeded before the operation is completed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The timeout specified is less than zero.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)\n  commentId: M:System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)\n  id: BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IInputChannel\n  langs:\n  - csharp\n  name: BeginTryReceive(TimeSpan, AsyncCallback, Object)\n  nameWithType: IInputChannel.BeginTryReceive(TimeSpan, AsyncCallback, Object)\n  fullName: IInputChannel.BeginTryReceive(TimeSpan, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Begins an asynchronous operation to receive a message that has a specified time out and state object associated with it.\n  remarks: \"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method when you want the application processing to continue without waiting. Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> method when it is acceptable for the current thread to be blocked while it replies to the request message or until the timeout interval is exceeded.  \\n  \\n The operation is not complete until either a message becomes available in the channel or the timeout occurs.  \\n  \\n If you are going to handle timeouts and not just re-throw or wrap the <xref:System.TimeoutException>, then you should call <xref:System.ServiceModel.Channels.IInputChannel.BeginTryReceive%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> instead of <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>.  \\n  \\n If you are not going to treat timeouts specially then just call <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A>, otherwise you lose error information.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#19](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#19)]\"\n  syntax:\n    content: public IAsyncResult BeginTryReceive (TimeSpan timeout, AsyncCallback callback, object state);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for a message to become available.\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous operation completion.\n    - id: state\n      type: System.Object\n      description: An object, specified by the application, that contains state information associated with the asynchronous operation.\n    return:\n      type: System.IAsyncResult\n      description: The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous receive operation.\n  overload: System.ServiceModel.Channels.IInputChannel.BeginTryReceive*\n  exceptions:\n  - type: System.TimeoutException\n    commentId: T:System.TimeoutException\n    description: The specified <code>timeout</code> is exceeded before the operation is completed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The timeout specified is less than zero.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)\n  commentId: M:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)\n  id: BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IInputChannel\n  langs:\n  - csharp\n  name: BeginWaitForMessage(TimeSpan, AsyncCallback, Object)\n  nameWithType: IInputChannel.BeginWaitForMessage(TimeSpan, AsyncCallback, Object)\n  fullName: IInputChannel.BeginWaitForMessage(TimeSpan, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Begins an asynchronous wait-for-a-message-to-arrive operation that has a specified time out and state object associated with it.\n  remarks: \"Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method if you need the application processing to continue without waiting for the message to arrive. Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> method when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread is blocked up to the specified `timeout`.  \\n  \\n This method receives notification, through a callback, of the identity of the event handler for the operation. The operation is not complete until either a message becomes available in the channel or the time out occurs.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#22](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#22)]\"\n  syntax:\n    content: public IAsyncResult BeginWaitForMessage (TimeSpan timeout, AsyncCallback callback, object state);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The <xref href=\"System.TimeSpan\"></xref> that specifies the interval of time to wait for a message to become available.\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate that receives the notification of the asynchronous operation completion.\n    - id: state\n      type: System.Object\n      description: An object, specified by the application, that contains state information associated with the asynchronous operation.\n    return:\n      type: System.IAsyncResult\n      description: The <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous operation to wait for a message to arrive.\n  overload: System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage*\n  exceptions:\n  - type: System.TimeoutException\n    commentId: T:System.TimeoutException\n    description: The specified <code>timeout</code> is exceeded before the operation is completed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The timeout specified is less than zero.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IInputChannel.EndReceive(System.IAsyncResult)\n  commentId: M:System.ServiceModel.Channels.IInputChannel.EndReceive(System.IAsyncResult)\n  id: EndReceive(System.IAsyncResult)\n  parent: System.ServiceModel.Channels.IInputChannel\n  langs:\n  - csharp\n  name: EndReceive(IAsyncResult)\n  nameWithType: IInputChannel.EndReceive(IAsyncResult)\n  fullName: IInputChannel.EndReceive(IAsyncResult)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Completes an asynchronous operation to receive a message.\n  remarks: ''\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#17](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#17)]\"\n  syntax:\n    content: public System.ServiceModel.Channels.Message EndReceive (IAsyncResult result);\n    parameters:\n    - id: result\n      type: System.IAsyncResult\n      description: The <xref href=\"System.IAsyncResult\"></xref> returned by a call to one of the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginReceive*\"></xref> methods.\n    return:\n      type: System.ServiceModel.Channels.Message\n      description: The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received.\n  overload: System.ServiceModel.Channels.IInputChannel.EndReceive*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)\n  commentId: M:System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)\n  id: EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)\n  parent: System.ServiceModel.Channels.IInputChannel\n  langs:\n  - csharp\n  name: EndTryReceive(IAsyncResult, Message)\n  nameWithType: IInputChannel.EndTryReceive(IAsyncResult, Message)\n  fullName: IInputChannel.EndTryReceive(IAsyncResult, Message)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Completes the specified asynchronous operation to receive a message.\n  remarks: ''\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#20](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#20)]\"\n  syntax:\n    content: public bool EndTryReceive (IAsyncResult result, out System.ServiceModel.Channels.Message message);\n    parameters:\n    - id: result\n      type: System.IAsyncResult\n      description: The <xref href=\"System.IAsyncResult\"></xref> returned by a call to the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)\"></xref> method.\n    - id: message\n      type: System.ServiceModel.Channels.Message\n      description: The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received.\n    return:\n      type: System.Boolean\n      description: '`true` if a message is received before the specified interval of time elapses; otherwise `false`.'\n  overload: System.ServiceModel.Channels.IInputChannel.EndTryReceive*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IInputChannel.EndWaitForMessage(System.IAsyncResult)\n  commentId: M:System.ServiceModel.Channels.IInputChannel.EndWaitForMessage(System.IAsyncResult)\n  id: EndWaitForMessage(System.IAsyncResult)\n  parent: System.ServiceModel.Channels.IInputChannel\n  langs:\n  - csharp\n  name: EndWaitForMessage(IAsyncResult)\n  nameWithType: IInputChannel.EndWaitForMessage(IAsyncResult)\n  fullName: IInputChannel.EndWaitForMessage(IAsyncResult)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Completes the specified asynchronous wait-for-a-message operation.\n  remarks: ''\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#23](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#23)]\"\n  syntax:\n    content: public bool EndWaitForMessage (IAsyncResult result);\n    parameters:\n    - id: result\n      type: System.IAsyncResult\n      description: The <xref href=\"System.IAsyncResult\"></xref> that identifies the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)\"></xref> operation to finish, and from which to retrieve an end result.\n    return:\n      type: System.Boolean\n      description: '`true` if a message has arrived before the <code>timeout</code> has been exceeded; otherwise `false`.'\n  overload: System.ServiceModel.Channels.IInputChannel.EndWaitForMessage*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IInputChannel.LocalAddress\n  commentId: P:System.ServiceModel.Channels.IInputChannel.LocalAddress\n  id: LocalAddress\n  parent: System.ServiceModel.Channels.IInputChannel\n  langs:\n  - csharp\n  name: LocalAddress\n  nameWithType: IInputChannel.LocalAddress\n  fullName: IInputChannel.LocalAddress\n  type: Property\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Gets the address on which the input channel receives messages.\n  remarks: \"If this input channel does not have a standalone address (for example, it is the input-side of a client-initiated TCP channel), then this property is `null`.  \\n  \\n This property can be used by higher-level channels for correlation purposes. For example, if a higher-level channel implements request-reply on top of a <xref:System.ServiceModel.Channels.IDuplexChannel>, it can use the <xref:System.ServiceModel.Channels.IInputChannel.LocalAddress%2A> property in the WS-Addressing ReplyTo header.\"\n  example:\n  - \"The following code illustrates how to implement this property:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#12](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#12)]\"\n  syntax:\n    content: public System.ServiceModel.EndpointAddress LocalAddress { get; }\n    return:\n      type: System.ServiceModel.EndpointAddress\n      description: The <xref href=\"System.ServiceModel.EndpointAddress\"></xref> on which the input channel receives messages.\n  overload: System.ServiceModel.Channels.IInputChannel.LocalAddress*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IInputChannel.Receive\n  commentId: M:System.ServiceModel.Channels.IInputChannel.Receive\n  id: Receive\n  parent: System.ServiceModel.Channels.IInputChannel\n  langs:\n  - csharp\n  name: Receive()\n  nameWithType: IInputChannel.Receive()\n  fullName: IInputChannel.Receive()\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Returns the message received, if one is available. If a message is not available, blocks for a default interval of time.\n  remarks: \"Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until it receives the request message or exceeds the interval of time specified by `timeout`. Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received.  \\n  \\n The synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> operation is available with or without an explicit timeout.  \\n  \\n If a message is not available, it blocks until one is available or until the timeout is exceeded.  \\n  \\n <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> call can complete for each message received.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#13](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#13)]\"\n  syntax:\n    content: public System.ServiceModel.Channels.Message Receive ();\n    parameters: []\n    return:\n      type: System.ServiceModel.Channels.Message\n      description: The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received.\n  overload: System.ServiceModel.Channels.IInputChannel.Receive*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IInputChannel.Receive(System.TimeSpan)\n  commentId: M:System.ServiceModel.Channels.IInputChannel.Receive(System.TimeSpan)\n  id: Receive(System.TimeSpan)\n  parent: System.ServiceModel.Channels.IInputChannel\n  langs:\n  - csharp\n  name: Receive(TimeSpan)\n  nameWithType: IInputChannel.Receive(TimeSpan)\n  fullName: IInputChannel.Receive(TimeSpan)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Returns the message received, if one is available. If a message is not available, blocks for a specified interval of time.\n  remarks: \"Use the synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> method when it is acceptable for the current thread to be blocked until it receives the request message or exceeds the interval of time specified by `timeout`. Use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginReceive%2A> method when you want the application processing to continue without waiting for the request to be received.  \\n  \\n The synchronous <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> operation is available with or without an explicit timeout.  \\n  \\n If a message is not available, it blocks until one is available or until the timeout is exceeded.  \\n  \\n <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> can be called multiple times or concurrently. Only one <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> call can complete for each message received.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#14](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#14)]\"\n  syntax:\n    content: public System.ServiceModel.Channels.Message Receive (TimeSpan timeout);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The <xref href=\"System.TimeSpan\"></xref> that specifies how long the receive operation has to complete before timing out and throwing a <xref href=\"System.TimeoutException\"></xref>.\n    return:\n      type: System.ServiceModel.Channels.Message\n      description: The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received.\n  overload: System.ServiceModel.Channels.IInputChannel.Receive*\n  exceptions:\n  - type: System.TimeoutException\n    commentId: T:System.TimeoutException\n    description: The specified <code>timeout</code> is exceeded before the operation is completed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The timeout specified is less than zero.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IInputChannel.TryReceive(System.TimeSpan,System.ServiceModel.Channels.Message@)\n  commentId: M:System.ServiceModel.Channels.IInputChannel.TryReceive(System.TimeSpan,System.ServiceModel.Channels.Message@)\n  id: TryReceive(System.TimeSpan,System.ServiceModel.Channels.Message@)\n  parent: System.ServiceModel.Channels.IInputChannel\n  langs:\n  - csharp\n  name: TryReceive(TimeSpan, Message)\n  nameWithType: IInputChannel.TryReceive(TimeSpan, Message)\n  fullName: IInputChannel.TryReceive(TimeSpan, Message)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Tries to receive a message within a specified interval of time.\n  remarks: \"If you are going to handle timeouts and not just re-throw or wrap the <xref:System.TimeoutException>, then you should call <xref:System.ServiceModel.Channels.IInputChannel.TryReceive%28System.TimeSpan%2CSystem.ServiceModel.Channels.Message%40%29> instead of <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>.  \\n  \\n If you are not going to treat timeouts specially then just call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A>, otherwise you will lose error information.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#18](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#18)]\"\n  syntax:\n    content: public bool TryReceive (TimeSpan timeout, out System.ServiceModel.Channels.Message message);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The <xref href=\"System.IAsyncResult\"></xref> returned by a call to one of the <xref href=\"System.ServiceModel.Channels.IInputChannel.BeginReceive*\"></xref> methods.\n    - id: message\n      type: System.ServiceModel.Channels.Message\n      description: The <xref href=\"System.ServiceModel.Channels.Message\"></xref> received.\n    return:\n      type: System.Boolean\n      description: '`true` if a message is received before the <code>timeout</code> has been exceeded; otherwise `false`.'\n  overload: System.ServiceModel.Channels.IInputChannel.TryReceive*\n  exceptions:\n  - type: System.TimeoutException\n    commentId: T:System.TimeoutException\n    description: The specified <code>timeout</code> is exceeded before the operation is completed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The timeout specified is less than zero.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\n- uid: System.ServiceModel.Channels.IInputChannel.WaitForMessage(System.TimeSpan)\n  commentId: M:System.ServiceModel.Channels.IInputChannel.WaitForMessage(System.TimeSpan)\n  id: WaitForMessage(System.TimeSpan)\n  parent: System.ServiceModel.Channels.IInputChannel\n  langs:\n  - csharp\n  name: WaitForMessage(TimeSpan)\n  nameWithType: IInputChannel.WaitForMessage(TimeSpan)\n  fullName: IInputChannel.WaitForMessage(TimeSpan)\n  type: Method\n  assemblies:\n  - System.ServiceModel\n  namespace: System.ServiceModel.Channels\n  summary: Returns a value that indicates whether a message has arrived within a specified interval of time.\n  remarks: \"Calling <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> does not result in a message being received or processed in any other way.  \\n  \\n The <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> method exists primarily for transacted scenarios where the user wants to receive the message using a transaction. When using just <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> normally for this, the user must create the transaction and then call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> and hope the message arrives before the transaction times out, which may not be possible.  \\n  \\n Instead, the user can call <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> with whatever time out they want (even infinite), then when a message arrives they can open the transaction, call <xref:System.ServiceModel.Channels.IInputChannel.Receive%2A> and be confident that they can get the message back before the transaction expires.  \\n  \\n This method is synchronous, so it blocks the current thread until a message is available or the time out occurs. Use <xref:System.ServiceModel.Channels.IInputChannel.WaitForMessage%28System.TimeSpan%29> when it is acceptable for the current thread to be blocked while it waits for a message to arrive in the queue. The thread is blocked up to the specified `timeout`. If you need the application processing to continue without waiting, use the asynchronous <xref:System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage%28System.TimeSpan%2CSystem.AsyncCallback%2CSystem.Object%29> method.\"\n  example:\n  - \"The following code illustrates how to implement this method:  \\n  \\n [!code-csharp[S_UE_MessageInterceptor#21](~/samples/snippets/csharp/VS_Snippets_CFX/s_ue_messageinterceptor/cs/interceptingduplexchannel.cs#21)]\"\n  syntax:\n    content: public bool WaitForMessage (TimeSpan timeout);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The <xref href=\"System.TimeSpan\"></xref> specifies the maximum interval of time to wait for a message to arrive before timing out.\n    return:\n      type: System.Boolean\n      description: '`true` if a message has arrived before the <code>timeout</code> has been exceeded; otherwise `false`.'\n  overload: System.ServiceModel.Channels.IInputChannel.WaitForMessage*\n  exceptions:\n  - type: System.TimeoutException\n    commentId: T:System.TimeoutException\n    description: The specified <code>timeout</code> is exceeded before the operation is completed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The timeout specified is less than zero.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n  ms.technology:\n  - dotnet-standard\n  author: Erikre\n  ms.author: erikre\n  manager: erikre\nreferences:\n- uid: System.TimeoutException\n  parent: System\n  isExternal: false\n  name: TimeoutException\n  nameWithType: TimeoutException\n  fullName: System.TimeoutException\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.ServiceModel.Channels.IInputChannel.BeginReceive(System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: BeginReceive(AsyncCallback, Object)\n  nameWithType: IInputChannel.BeginReceive(AsyncCallback, Object)\n  fullName: IInputChannel.BeginReceive(AsyncCallback, Object)\n- uid: System.IAsyncResult\n  parent: System\n  isExternal: false\n  name: IAsyncResult\n  nameWithType: IAsyncResult\n  fullName: System.IAsyncResult\n- uid: System.AsyncCallback\n  parent: System\n  isExternal: false\n  name: AsyncCallback\n  nameWithType: AsyncCallback\n  fullName: System.AsyncCallback\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.ServiceModel.Channels.IInputChannel.BeginReceive(System.TimeSpan,System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: BeginReceive(TimeSpan, AsyncCallback, Object)\n  nameWithType: IInputChannel.BeginReceive(TimeSpan, AsyncCallback, Object)\n  fullName: IInputChannel.BeginReceive(TimeSpan, AsyncCallback, Object)\n- uid: System.TimeSpan\n  parent: System\n  isExternal: false\n  name: TimeSpan\n  nameWithType: TimeSpan\n  fullName: System.TimeSpan\n- uid: System.ServiceModel.Channels.IInputChannel.BeginTryReceive(System.TimeSpan,System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: BeginTryReceive(TimeSpan, AsyncCallback, Object)\n  nameWithType: IInputChannel.BeginTryReceive(TimeSpan, AsyncCallback, Object)\n  fullName: IInputChannel.BeginTryReceive(TimeSpan, AsyncCallback, Object)\n- uid: System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage(System.TimeSpan,System.AsyncCallback,System.Object)\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: BeginWaitForMessage(TimeSpan, AsyncCallback, Object)\n  nameWithType: IInputChannel.BeginWaitForMessage(TimeSpan, AsyncCallback, Object)\n  fullName: IInputChannel.BeginWaitForMessage(TimeSpan, AsyncCallback, Object)\n- uid: System.ServiceModel.Channels.IInputChannel.EndReceive(System.IAsyncResult)\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: EndReceive(IAsyncResult)\n  nameWithType: IInputChannel.EndReceive(IAsyncResult)\n  fullName: IInputChannel.EndReceive(IAsyncResult)\n- uid: System.ServiceModel.Channels.Message\n  parent: System.ServiceModel.Channels\n  isExternal: false\n  name: Message\n  nameWithType: Message\n  fullName: System.ServiceModel.Channels.Message\n- uid: System.ServiceModel.Channels.IInputChannel.EndTryReceive(System.IAsyncResult,System.ServiceModel.Channels.Message@)\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: EndTryReceive(IAsyncResult, Message)\n  nameWithType: IInputChannel.EndTryReceive(IAsyncResult, Message)\n  fullName: IInputChannel.EndTryReceive(IAsyncResult, Message)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.ServiceModel.Channels.IInputChannel.EndWaitForMessage(System.IAsyncResult)\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: EndWaitForMessage(IAsyncResult)\n  nameWithType: IInputChannel.EndWaitForMessage(IAsyncResult)\n  fullName: IInputChannel.EndWaitForMessage(IAsyncResult)\n- uid: System.ServiceModel.Channels.IInputChannel.LocalAddress\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: LocalAddress\n  nameWithType: IInputChannel.LocalAddress\n  fullName: IInputChannel.LocalAddress\n- uid: System.ServiceModel.EndpointAddress\n  parent: System.ServiceModel\n  isExternal: false\n  name: EndpointAddress\n  nameWithType: EndpointAddress\n  fullName: System.ServiceModel.EndpointAddress\n- uid: System.ServiceModel.Channels.IInputChannel.Receive\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: Receive()\n  nameWithType: IInputChannel.Receive()\n  fullName: IInputChannel.Receive()\n- uid: System.ServiceModel.Channels.IInputChannel.Receive(System.TimeSpan)\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: Receive(TimeSpan)\n  nameWithType: IInputChannel.Receive(TimeSpan)\n  fullName: IInputChannel.Receive(TimeSpan)\n- uid: System.ServiceModel.Channels.IInputChannel.TryReceive(System.TimeSpan,System.ServiceModel.Channels.Message@)\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: TryReceive(TimeSpan, Message)\n  nameWithType: IInputChannel.TryReceive(TimeSpan, Message)\n  fullName: IInputChannel.TryReceive(TimeSpan, Message)\n- uid: System.ServiceModel.Channels.IInputChannel.WaitForMessage(System.TimeSpan)\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: WaitForMessage(TimeSpan)\n  nameWithType: IInputChannel.WaitForMessage(TimeSpan)\n  fullName: IInputChannel.WaitForMessage(TimeSpan)\n- uid: System.ServiceModel.Channels.IInputChannel.BeginReceive*\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: BeginReceive\n  nameWithType: IInputChannel.BeginReceive\n  fullName: IInputChannel.BeginReceive\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n- uid: System.ServiceModel.Channels.IInputChannel.Receive*\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: Receive\n  nameWithType: IInputChannel.Receive\n  fullName: IInputChannel.Receive\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n- uid: System.ServiceModel.Channels.IInputChannel.BeginTryReceive*\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: BeginTryReceive\n  nameWithType: IInputChannel.BeginTryReceive\n  fullName: IInputChannel.BeginTryReceive\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n- uid: System.ServiceModel.Channels.IInputChannel.BeginWaitForMessage*\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: BeginWaitForMessage\n  nameWithType: IInputChannel.BeginWaitForMessage\n  fullName: IInputChannel.BeginWaitForMessage\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n- uid: System.ServiceModel.Channels.IInputChannel.EndReceive*\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: EndReceive\n  nameWithType: IInputChannel.EndReceive\n  fullName: IInputChannel.EndReceive\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n- uid: System.ServiceModel.Channels.IInputChannel.EndTryReceive*\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: EndTryReceive\n  nameWithType: IInputChannel.EndTryReceive\n  fullName: IInputChannel.EndTryReceive\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n- uid: System.ServiceModel.Channels.IInputChannel.EndWaitForMessage*\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: EndWaitForMessage\n  nameWithType: IInputChannel.EndWaitForMessage\n  fullName: IInputChannel.EndWaitForMessage\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n- uid: System.ServiceModel.Channels.IInputChannel.LocalAddress*\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: LocalAddress\n  nameWithType: IInputChannel.LocalAddress\n  fullName: IInputChannel.LocalAddress\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n- uid: System.ServiceModel.Channels.IInputChannel.TryReceive*\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: TryReceive\n  nameWithType: IInputChannel.TryReceive\n  fullName: IInputChannel.TryReceive\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n- uid: System.ServiceModel.Channels.IInputChannel.WaitForMessage*\n  parent: System.ServiceModel.Channels.IInputChannel\n  isExternal: false\n  name: WaitForMessage\n  nameWithType: IInputChannel.WaitForMessage\n  fullName: IInputChannel.WaitForMessage\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.ServiceModel.Channels/IInputChannel.xml\n- uid: System.ServiceModel.Channels.IChannel\n  parent: System.ServiceModel.Channels\n  isExternal: false\n  name: IChannel\n  nameWithType: IChannel\n  fullName: System.ServiceModel.Channels.IChannel\n"}