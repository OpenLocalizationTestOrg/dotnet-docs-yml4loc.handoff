{"nodes":[{"content":"Provides an internal interface for accessing the arguments of multiple tree nodes (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression, and InexExpression).  You should not use this API.  It is only public due to DLL refactoring and exists only for internal performance optimizations.  \n  \n This enables two optimizations which reduce the size of expression trees.  The first enables the tree nodes to hold onto an IList<T> instead of a ReadOnlyCollection.  IList<T> saves the cost of allocating the ReadOnlyCollection for each node.  The second enables creating specialized subclasses that hold onto a specific number of arguments (for example, Block2, Block3, Block4).  Therefore, these nodes avoid allocating both a ReadOnlyCollection and an array for storing their elements, saving 32 bytes per node.  \n  \n The expression tree nodes continue to expose the original LINQ properties of ReadOnlyCollections.  The nodes do this by re-using a field for storing both the array or an element that would normally be stored in the array.  \n  \n For the array case, the collection is typed to IList<T> instead of ReadOnlyCollection<T>.  When the node is initially constructed it is an array.  When the compiler accesses the members it uses this interface.  Accessing array elements promotes the array to a ReadOnlyCollection.  \n  \n For the object case we store the first argument in a field typed to object.  When the node is initially constructed, the field holds the Expression.  The compiler accesses arguments through this interface, and the accessor for the first argument uses Expression.ReturnObject to return the object that handles the Expression or ReadOnlyCollection case.  When the user accesses the ReadOnlyCollection, then the object field is updated to hold directly onto the ReadOnlyCollection.  \n  \n It is important that the Expressions consistently return the same ReadOnlyCollection.  Otherwise, the re-writer tree walker will break.  It is a breaking change from LINQ v1 to return different ReadOnlyCollections form the same Expression node.  Currently users can rely on object identity to tell if the node has changed.  Storing the ReadOnlyCollection in an overloaded field both reduces memory usage and maintains compatibility for the public API.","nodes":[{"pos":[0,322],"content":"Provides an internal interface for accessing the arguments of multiple tree nodes (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression, and InexExpression).  You should not use this API.  It is only public due to DLL refactoring and exists only for internal performance optimizations.","nodes":[{"content":"Provides an internal interface for accessing the arguments of multiple tree nodes (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression, and InexExpression).  You should not use this API.  It is only public due to DLL refactoring and exists only for internal performance optimizations.","pos":[0,322],"nodes":[{"content":"Provides an internal interface for accessing the arguments of multiple tree nodes (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression, and InexExpression).","pos":[0,194]},{"content":"You should not use this API.","pos":[196,224]},{"content":"It is only public due to DLL refactoring and exists only for internal performance optimizations.","pos":[226,322]}]}]},{"pos":[329,842],"content":"This enables two optimizations which reduce the size of expression trees.  The first enables the tree nodes to hold onto an IList<T> instead of a ReadOnlyCollection.  IList<T> saves the cost of allocating the ReadOnlyCollection for each node.  The second enables creating specialized subclasses that hold onto a specific number of arguments (for example, Block2, Block3, Block4).  Therefore, these nodes avoid allocating both a ReadOnlyCollection and an array for storing their elements, saving 32 bytes per node.","nodes":[{"content":"This enables two optimizations which reduce the size of expression trees.","pos":[0,73]},{"content":"The first enables the tree nodes to hold onto an IList<ph id=\"ph1\">&lt;T&gt;</ph> instead of a ReadOnlyCollection.","pos":[75,165],"source":"  The first enables the tree nodes to hold onto an IList<T> instead of a ReadOnlyCollection."},{"content":"IList<ph id=\"ph1\">&lt;T&gt;</ph> saves the cost of allocating the ReadOnlyCollection for each node.","pos":[167,242],"source":"  IList<T> saves the cost of allocating the ReadOnlyCollection for each node."},{"content":"The second enables creating specialized subclasses that hold onto a specific number of arguments (for example, Block2, Block3, Block4).","pos":[244,379]},{"content":"Therefore, these nodes avoid allocating both a ReadOnlyCollection and an array for storing their elements, saving 32 bytes per node.","pos":[381,513]}]},{"pos":[849,1070],"content":"The expression tree nodes continue to expose the original LINQ properties of ReadOnlyCollections.  The nodes do this by re-using a field for storing both the array or an element that would normally be stored in the array.","nodes":[{"content":"The expression tree nodes continue to expose the original LINQ properties of ReadOnlyCollections.  The nodes do this by re-using a field for storing both the array or an element that would normally be stored in the array.","pos":[0,221],"nodes":[{"content":"The expression tree nodes continue to expose the original LINQ properties of ReadOnlyCollections.","pos":[0,97]},{"content":"The nodes do this by re-using a field for storing both the array or an element that would normally be stored in the array.","pos":[99,221]}]}]},{"pos":[1077,1356],"content":"For the array case, the collection is typed to IList<T> instead of ReadOnlyCollection<T>.  When the node is initially constructed it is an array.  When the compiler accesses the members it uses this interface.  Accessing array elements promotes the array to a ReadOnlyCollection.","nodes":[{"content":"For the array case, the collection is typed to IList<ph id=\"ph1\">&lt;T&gt;</ph> instead of ReadOnlyCollection<ph id=\"ph2\">&lt;T&gt;</ph>.","pos":[0,89],"source":"For the array case, the collection is typed to IList<T> instead of ReadOnlyCollection<T>."},{"content":"When the node is initially constructed it is an array.","pos":[91,145]},{"content":"When the compiler accesses the members it uses this interface.","pos":[147,209]},{"content":"Accessing array elements promotes the array to a ReadOnlyCollection.","pos":[211,279]}]},{"pos":[1363,1841],"content":"For the object case we store the first argument in a field typed to object.  When the node is initially constructed, the field holds the Expression.  The compiler accesses arguments through this interface, and the accessor for the first argument uses Expression.ReturnObject to return the object that handles the Expression or ReadOnlyCollection case.  When the user accesses the ReadOnlyCollection, then the object field is updated to hold directly onto the ReadOnlyCollection.","nodes":[{"content":"For the object case we store the first argument in a field typed to object.  When the node is initially constructed, the field holds the Expression.  The compiler accesses arguments through this interface, and the accessor for the first argument uses Expression.ReturnObject to return the object that handles the Expression or ReadOnlyCollection case.  When the user accesses the ReadOnlyCollection, then the object field is updated to hold directly onto the ReadOnlyCollection.","pos":[0,478],"nodes":[{"content":"For the object case we store the first argument in a field typed to object.","pos":[0,75]},{"content":"When the node is initially constructed, the field holds the Expression.","pos":[77,148]},{"content":"The compiler accesses arguments through this interface, and the accessor for the first argument uses Expression.ReturnObject to return the object that handles the Expression or ReadOnlyCollection case.","pos":[150,351]},{"content":"When the user accesses the ReadOnlyCollection, then the object field is updated to hold directly onto the ReadOnlyCollection.","pos":[353,478]}]}]},{"pos":[1848,2299],"content":"It is important that the Expressions consistently return the same ReadOnlyCollection.  Otherwise, the re-writer tree walker will break.  It is a breaking change from LINQ v1 to return different ReadOnlyCollections form the same Expression node.  Currently users can rely on object identity to tell if the node has changed.  Storing the ReadOnlyCollection in an overloaded field both reduces memory usage and maintains compatibility for the public API.","nodes":[{"content":"It is important that the Expressions consistently return the same ReadOnlyCollection.  Otherwise, the re-writer tree walker will break.  It is a breaking change from LINQ v1 to return different ReadOnlyCollections form the same Expression node.  Currently users can rely on object identity to tell if the node has changed.  Storing the ReadOnlyCollection in an overloaded field both reduces memory usage and maintains compatibility for the public API.","pos":[0,451],"nodes":[{"content":"It is important that the Expressions consistently return the same ReadOnlyCollection.","pos":[0,85]},{"content":"Otherwise, the re-writer tree walker will break.","pos":[87,135]},{"content":"It is a breaking change from LINQ v1 to return different ReadOnlyCollections form the same Expression node.","pos":[137,244]},{"content":"Currently users can rely on object identity to tell if the node has changed.","pos":[246,322]},{"content":"Storing the ReadOnlyCollection in an overloaded field both reduces memory usage and maintains compatibility for the public API.","pos":[324,451]}]}]}],"pos":[584,2896],"yaml":true},{"content":"Returns the number of arguments to the expression tree node.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.","nodes":[{"pos":[0,196],"content":"Returns the number of arguments to the expression tree node.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.","nodes":[{"content":"Returns the number of arguments to the expression tree node.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.","pos":[0,196],"nodes":[{"content":"Returns the number of arguments to the expression tree node.","pos":[0,60]},{"content":"You should not use this type.","pos":[62,91]},{"content":"It is only public due to assembly refactoring, and it is used internally for performance optimizations.","pos":[93,196]}]}]}],"pos":[4506,4703],"yaml":true},{"content":"The number of arguments to the expression tree node as <xref href=\"System.Int32\"></xref>.","nodes":[{"pos":[0,89],"content":"The number of arguments to the expression tree node as <ph id=\"ph1\">&lt;xref href=\"System.Int32\"&gt;&lt;/xref&gt;</ph>.","source":"The number of arguments to the expression tree node as <xref href=\"System.Int32\"></xref>."}],"pos":[4816,4906],"yaml":true},{"content":"Returns the argument at index, throwing if index is out of bounds.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.","nodes":[{"pos":[0,202],"content":"Returns the argument at index, throwing if index is out of bounds.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.","nodes":[{"content":"Returns the argument at index, throwing if index is out of bounds.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.","pos":[0,202],"nodes":[{"content":"Returns the argument at index, throwing if index is out of bounds.","pos":[0,66]},{"content":"You should not use this type.","pos":[68,97]},{"content":"It is only public due to assembly refactoring, and it is used internally for performance optimizations.","pos":[99,202]}]}]}],"pos":[6309,6512],"yaml":true},{"content":"The index of the argument.","nodes":[{"pos":[0,26],"content":"The index of the argument.","nodes":[{"content":"The index of the argument.","pos":[0,26]}]}],"pos":[6678,6705],"yaml":true},{"content":"The argument at index, throwing if index is out of bounds as <xref href=\"System.Linq.Expressions.Expression\"></xref>.","nodes":[{"pos":[0,117],"content":"The argument at index, throwing if index is out of bounds as <ph id=\"ph1\">&lt;xref href=\"System.Linq.Expressions.Expression\"&gt;&lt;/xref&gt;</ph>.","source":"The argument at index, throwing if index is out of bounds as <xref href=\"System.Linq.Expressions.Expression\"></xref>."}],"pos":[6783,6901],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Linq.Expressions.IArgumentProvider\n  commentId: T:System.Linq.Expressions.IArgumentProvider\n  id: IArgumentProvider\n  children:\n  - System.Linq.Expressions.IArgumentProvider.ArgumentCount\n  - System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)\n  langs:\n  - csharp\n  name: IArgumentProvider\n  nameWithType: IArgumentProvider\n  fullName: System.Linq.Expressions.IArgumentProvider\n  type: Interface\n  assemblies:\n  - System.Linq.Expressions\n  - System.Core\n  - netstandard\n  namespace: System.Linq.Expressions\n  summary: \"Provides an internal interface for accessing the arguments of multiple tree nodes (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression, and InexExpression).  You should not use this API.  It is only public due to DLL refactoring and exists only for internal performance optimizations.  \\n  \\n This enables two optimizations which reduce the size of expression trees.  The first enables the tree nodes to hold onto an IList<T> instead of a ReadOnlyCollection.  IList<T> saves the cost of allocating the ReadOnlyCollection for each node.  The second enables creating specialized subclasses that hold onto a specific number of arguments (for example, Block2, Block3, Block4).  Therefore, these nodes avoid allocating both a ReadOnlyCollection and an array for storing their elements, saving 32 bytes per node.  \\n  \\n The expression tree nodes continue to expose the original LINQ properties of ReadOnlyCollections.  The nodes do this by re-using a field for storing both the array or an element that would normally be stored in the array.  \\n  \\n For the array case, the collection is typed to IList<T> instead of ReadOnlyCollection<T>.  When the node is initially constructed it is an array.  When the compiler accesses the members it uses this interface.  Accessing array elements promotes the array to a ReadOnlyCollection.  \\n  \\n For the object case we store the first argument in a field typed to object.  When the node is initially constructed, the field holds the Expression.  The compiler accesses arguments through this interface, and the accessor for the first argument uses Expression.ReturnObject to return the object that handles the Expression or ReadOnlyCollection case.  When the user accesses the ReadOnlyCollection, then the object field is updated to hold directly onto the ReadOnlyCollection.  \\n  \\n It is important that the Expressions consistently return the same ReadOnlyCollection.  Otherwise, the re-writer tree walker will break.  It is a breaking change from LINQ v1 to return different ReadOnlyCollections form the same Expression node.  Currently users can rely on object identity to tell if the node has changed.  Storing the ReadOnlyCollection in an overloaded field both reduces memory usage and maintains compatibility for the public API.\"\n  syntax:\n    content: public interface IArgumentProvider\n  derivedClasses:\n  - System.Linq.Expressions.ElementInit\n  - System.Linq.Expressions.IDynamicExpression\n  - System.Linq.Expressions.IndexExpression\n  - System.Linq.Expressions.InvocationExpression\n  - System.Linq.Expressions.MethodCallExpression\n  - System.Linq.Expressions.NewExpression\n  implements: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Linq.Expressions/IArgumentProvider.xml\n  ms.technology:\n  - dotnet-standard\n  ms.author: billchi\n  manager: ghogen\n- uid: System.Linq.Expressions.IArgumentProvider.ArgumentCount\n  commentId: P:System.Linq.Expressions.IArgumentProvider.ArgumentCount\n  id: ArgumentCount\n  parent: System.Linq.Expressions.IArgumentProvider\n  langs:\n  - csharp\n  name: ArgumentCount\n  nameWithType: IArgumentProvider.ArgumentCount\n  fullName: IArgumentProvider.ArgumentCount\n  type: Property\n  assemblies:\n  - System.Linq.Expressions\n  - System.Core\n  - netstandard\n  namespace: System.Linq.Expressions\n  summary: Returns the number of arguments to the expression tree node.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.\n  syntax:\n    content: public int ArgumentCount { get; }\n    return:\n      type: System.Int32\n      description: The number of arguments to the expression tree node as <xref href=\"System.Int32\"></xref>.\n  overload: System.Linq.Expressions.IArgumentProvider.ArgumentCount*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Linq.Expressions/IArgumentProvider.xml\n  ms.technology:\n  - dotnet-standard\n  author: BillWagner\n  ms.author: wiwagn\n  manager: wpickett\n- uid: System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)\n  commentId: M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)\n  id: GetArgument(System.Int32)\n  parent: System.Linq.Expressions.IArgumentProvider\n  langs:\n  - csharp\n  name: GetArgument(Int32)\n  nameWithType: IArgumentProvider.GetArgument(Int32)\n  fullName: IArgumentProvider.GetArgument(Int32)\n  type: Method\n  assemblies:\n  - System.Linq.Expressions\n  - System.Core\n  - netstandard\n  namespace: System.Linq.Expressions\n  summary: Returns the argument at index, throwing if index is out of bounds.  You should not use this type.  It is only public due to assembly refactoring, and it is used internally for performance optimizations.\n  syntax:\n    content: public System.Linq.Expressions.Expression GetArgument (int index);\n    parameters:\n    - id: index\n      type: System.Int32\n      description: The index of the argument.\n    return:\n      type: System.Linq.Expressions.Expression\n      description: The argument at index, throwing if index is out of bounds as <xref href=\"System.Linq.Expressions.Expression\"></xref>.\n  overload: System.Linq.Expressions.IArgumentProvider.GetArgument*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Linq.Expressions/IArgumentProvider.xml\n  ms.technology:\n  - dotnet-standard\n  ms.author: billchi\n  manager: ghogen\nreferences:\n- uid: System.Linq.Expressions.IArgumentProvider.ArgumentCount\n  parent: System.Linq.Expressions.IArgumentProvider\n  isExternal: false\n  name: ArgumentCount\n  nameWithType: IArgumentProvider.ArgumentCount\n  fullName: IArgumentProvider.ArgumentCount\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)\n  parent: System.Linq.Expressions.IArgumentProvider\n  isExternal: false\n  name: GetArgument(Int32)\n  nameWithType: IArgumentProvider.GetArgument(Int32)\n  fullName: IArgumentProvider.GetArgument(Int32)\n- uid: System.Linq.Expressions.Expression\n  parent: System.Linq.Expressions\n  isExternal: false\n  name: Expression\n  nameWithType: Expression\n  fullName: System.Linq.Expressions.Expression\n- uid: System.Linq.Expressions.IArgumentProvider.ArgumentCount*\n  parent: System.Linq.Expressions.IArgumentProvider\n  isExternal: false\n  name: ArgumentCount\n  nameWithType: IArgumentProvider.ArgumentCount\n  fullName: IArgumentProvider.ArgumentCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Linq.Expressions/IArgumentProvider.xml\n- uid: System.Linq.Expressions.IArgumentProvider.GetArgument*\n  parent: System.Linq.Expressions.IArgumentProvider\n  isExternal: false\n  name: GetArgument\n  nameWithType: IArgumentProvider.GetArgument\n  fullName: IArgumentProvider.GetArgument\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Linq.Expressions/IArgumentProvider.xml\n"}