{"nodes":[{"content":"Implements the Berkeley sockets interface.","nodes":[{"pos":[0,42],"content":"Implements the Berkeley sockets interface.","nodes":[{"content":"Implements the Berkeley sockets interface.","pos":[0,42]}]}],"pos":[12103,12146],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications. The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.  \n  \n The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods. For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.  \n  \n If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.  \n  \n-   If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method. The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host. Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method. Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number. Use a port number of zero if you want the underlying service provider to assign a free port for you. If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method. To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.  \n  \n-   If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all. Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams. Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.  \n  \n To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.  \n  \n-   If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host. Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously. Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.  \n  \n-   If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>and<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams.  \n  \n If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.  \n  \n When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>. After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.  \n  \n The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method. Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.  \n  \n> [!NOTE]\n>  If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>. These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.","nodes":[{"pos":[0,336],"content":"The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications. The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications. The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.","pos":[0,336],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class provides a rich set of methods and properties for network communications.","pos":[0,116],"source":"The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> enumeration.","pos":[117,336],"source":" The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration."}]}]},{"pos":[343,674],"content":"The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods. For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods. For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.","pos":[0,331],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class follows the .NET Framework naming pattern for asynchronous methods.","pos":[0,110],"source":"The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods."},{"content":"For example, the synchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method corresponds to the asynchronous <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> methods.","pos":[111,331],"source":" For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods."}]}]},{"pos":[681,821],"content":"If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.","nodes":[{"content":"If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.","pos":[0,140]}]},{"pos":[831,1874],"content":"If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method. The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host. Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method. Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number. Use a port number of zero if you want the underlying service provider to assign a free port for you. If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method. To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.","nodes":[{"content":"If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method. The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host. Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method. Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number. Use a port number of zero if you want the underlying service provider to assign a free port for you. If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method. To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.","pos":[0,1043],"nodes":[{"content":"If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method.","pos":[0,160],"source":"If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method processes any incoming connection requests and returns a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you can use to communicate data with the remote host.","pos":[161,363],"source":" The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host."},{"content":"Use this returned <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.","pos":[364,522],"source":" Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method."},{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method prior to calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method if you want to specify the local IP address and port number.","pos":[523,711],"source":" Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number."},{"content":"Use a port number of zero if you want the underlying service provider to assign a free port for you.","pos":[712,812]},{"content":"If you want to connect to a listening host, call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.","pos":[813,917],"source":" If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method."},{"content":"To communicate data, call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.","pos":[918,1043],"source":" To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method."}]}]},{"pos":[1884,2181],"content":"If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all. Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams. Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.","nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all. Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams. Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.","pos":[0,297],"nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.","pos":[0,105]},{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method to accept any incoming datagrams.","pos":[106,203],"source":" Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method to send datagrams to a remote host.","pos":[204,297],"source":" Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host."}]}]},{"pos":[2188,2333],"content":"To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.","nodes":[{"content":"To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.","pos":[0,145]}]},{"pos":[2343,2988],"content":"If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host. Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously. Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.","nodes":[{"content":"If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host. Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously. Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.","pos":[0,645],"nodes":[{"content":"If you are using a connection-oriented protocol such as TCP, use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> methods to connect with a listening host.","pos":[0,245],"source":"If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> methods to communicate data asynchronously.","pos":[246,494],"source":" Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously."},{"content":"Incoming connection requests can be processed using <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>.","pos":[495,645],"source":" Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>."}]}]},{"pos":[2998,3314],"content":"If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>and<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams.","nodes":[{"content":"If you are using a connectionless protocol such as UDP, you can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> to send datagrams, and <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>and<ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> to receive datagrams.","pos":[0,316],"source":"If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>and<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams."}]},{"pos":[3321,3454],"content":"If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.","nodes":[{"content":"If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.","pos":[0,133]}]},{"pos":[3461,3816],"content":"When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>. After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.","nodes":[{"content":"When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>. After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.","pos":[0,355],"nodes":[{"content":"When you are finished sending and receiving data, use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method to disable the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,158],"source":"When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>."},{"content":"After calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to release all resources associated with the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[159,355],"source":" After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>."}]}]},{"pos":[3823,4091],"content":"The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method. Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method. Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.","pos":[0,268],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class allows you to configure your <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> using the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.","pos":[0,174],"source":"The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method."},{"content":"Retrieve these settings using the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.","pos":[175,268],"source":" Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method."}]}]},{"pos":[4099,4449],"content":"[!NOTE]\n If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>. These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.","leadings":["","> "],"nodes":[{"content":" If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>. These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.","pos":[8,348],"nodes":[{"content":"If you are writing a relatively simple application and do not require maximum performance, consider using <ph id=\"ph1\">&lt;xref:System.Net.Sockets.TcpClient&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.TcpListener&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Net.Sockets.UdpClient&gt;</ph>.","pos":[1,223],"source":" If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>."},{"content":"These classes provide a simpler and more user-friendly interface to <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> communications.","pos":[224,340],"source":" These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications."}]}]}],"pos":[12157,16632],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Net.Sockets.Socket\"></xref> class using the specified value returned from <xref href=\"System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)\"></xref>.","nodes":[{"pos":[0,206],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> class using the specified value returned from <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)\"&gt;&lt;/xref&gt;</ph>.","source":"Initializes a new instance of the <xref href=\"System.Net.Sockets.Socket\"></xref> class using the specified value returned from <xref href=\"System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)\"></xref>."}],"pos":[20892,21099],"yaml":true},{"content":"If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket. This practice is strongly discouraged.","nodes":[{"pos":[0,281],"content":"If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket. This practice is strongly discouraged.","nodes":[{"content":"If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket. This practice is strongly discouraged.","pos":[0,281],"nodes":[{"content":"If you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>s with the same underlying socket.","pos":[0,242],"source":"If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket."},{"content":"This practice is strongly discouraged.","pos":[243,281]}]}]}],"pos":[21110,21392],"yaml":true,"extradata":"MT"},{"content":"The socket information returned by <xref href=\"System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)\"></xref>.","nodes":[{"pos":[0,114],"content":"The socket information returned by <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)\"&gt;&lt;/xref&gt;</ph>.","source":"The socket information returned by <xref href=\"System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)\"></xref>."}],"pos":[21599,21714],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Net.Sockets.Socket\"></xref> class using the specified socket type and protocol.","nodes":[{"pos":[0,132],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> class using the specified socket type and protocol.","source":"Initializes a new instance of the <xref href=\"System.Net.Sockets.Socket\"></xref> class using the specified socket type and protocol."}],"pos":[23059,23192],"yaml":true},{"content":"The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>. The two parameters are not independent. Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol. If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.  \n  \n> [!NOTE]\n>  If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,509],"content":"The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>. The two parameters are not independent. Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol. If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"The <ph id=\"ph1\">`socketType`</ph> parameter specifies the type of the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class and the <ph id=\"ph3\">`protocolType`</ph> parameter specifies the protocol used by <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,189],"source":"The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>."},{"content":"The two parameters are not independent.","pos":[190,229]},{"content":"Often the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type is implicit in the protocol.","pos":[230,306],"source":" Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol."},{"content":"If the combination of <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type and protocol type results in an invalid <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, this constructor throws a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[307,509],"source":" If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>."}]},{"pos":[517,895],"content":"[!NOTE]\n If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,376],"nodes":[{"content":"If this constructor throws a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,204],"source":" If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[205,368]}]}]},{"pos":[903,1128],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[23203,24340],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Net.Sockets.SocketType\"></xref> values.","nodes":[{"pos":[0,69],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketType\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketType\"></xref> values."}],"pos":[24565,24635],"yaml":true},{"content":"One of the <xref href=\"System.Net.Sockets.ProtocolType\"></xref> values.","nodes":[{"pos":[0,71],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.ProtocolType\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.ProtocolType\"></xref> values."}],"pos":[24721,24793],"yaml":true},{"content":"The combination of  <code>socketType</code> and <code>protocolType</code> results in an invalid socket.","nodes":[{"pos":[0,103],"content":"The combination of  <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">socketType</ph><ept id=\"p1\">&lt;/code&gt;</ept> and <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">protocolType</ph><ept id=\"p2\">&lt;/code&gt;</ept> results in an invalid socket.","source":"The combination of  <code>socketType</code> and <code>protocolType</code> results in an invalid socket."}],"pos":[24966,25070],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Net.Sockets.Socket\"></xref> class using the specified address family, socket type and protocol.","nodes":[{"pos":[0,148],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> class using the specified address family, socket type and protocol.","source":"Initializes a new instance of the <xref href=\"System.Net.Sockets.Socket\"></xref> class using the specified address family, socket type and protocol."}],"pos":[26681,26830],"yaml":true},{"content":"The `addressFamily` parameter specifies the addressing scheme that the<xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>. The three parameters are not independent. Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol. If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.  \n  \n> [!NOTE]\n>  If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,718],"content":"The `addressFamily` parameter specifies the addressing scheme that the<xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>. The three parameters are not independent. Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol. If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"The <ph id=\"ph1\">`addressFamily`</ph> parameter specifies the addressing scheme that the<ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class uses, the <ph id=\"ph3\">`socketType`</ph> parameter specifies the type of the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class, and the <ph id=\"ph5\">`protocolType`</ph> parameter specifies the protocol used by <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,305],"source":"The `addressFamily` parameter specifies the addressing scheme that the<xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>."},{"content":"The three parameters are not independent.","pos":[306,347]},{"content":"Some address families restrict which protocols can be used with them, and often the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type is implicit in the protocol.","pos":[348,498],"source":" Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol."},{"content":"If the combination of address family, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type, and protocol type results in an invalid <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, this constructor throws a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[499,718],"source":" If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>."}]},{"pos":[726,1104],"content":"[!NOTE]\n If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,376],"nodes":[{"content":"If this constructor throws a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,204],"source":" If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[205,368]}]}]},{"pos":[1112,1337],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[26841,28187],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Net.Sockets.AddressFamily\"></xref> values.","nodes":[{"pos":[0,72],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.AddressFamily\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.AddressFamily\"></xref> values."}],"pos":[28968,29041],"yaml":true},{"content":"One of the <xref href=\"System.Net.Sockets.SocketType\"></xref> values.","nodes":[{"pos":[0,69],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketType\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketType\"></xref> values."}],"pos":[29123,29193],"yaml":true},{"content":"One of the <xref href=\"System.Net.Sockets.ProtocolType\"></xref> values.","nodes":[{"pos":[0,71],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.ProtocolType\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.ProtocolType\"></xref> values."}],"pos":[29279,29351],"yaml":true},{"content":"The combination of <code>addressFamily</code>, <code>socketType</code>, and <code>protocolType</code> results in an invalid socket.","nodes":[{"pos":[0,131],"content":"The combination of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">addressFamily</ph><ept id=\"p1\">&lt;/code&gt;</ept>, <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">socketType</ph><ept id=\"p2\">&lt;/code&gt;</ept>, and <bpt id=\"p3\">&lt;code&gt;</bpt><ph id=\"ph3\">protocolType</ph><ept id=\"p3\">&lt;/code&gt;</ept> results in an invalid socket.","source":"The combination of <code>addressFamily</code>, <code>socketType</code>, and <code>protocolType</code> results in an invalid socket."}],"pos":[29524,29656],"yaml":true},{"content":"Creates a new <xref href=\"System.Net.Sockets.Socket\"></xref> for a newly created connection.","nodes":[{"pos":[0,92],"content":"Creates a new <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> for a newly created connection.","source":"Creates a new <xref href=\"System.Net.Sockets.Socket\"></xref> for a newly created connection."}],"pos":[30858,30951],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.  \n  \n In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued. Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.  \n  \n If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,552],"content":"<xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.","nodes":[{"content":"<xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.","pos":[0,552],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,230],"source":"<xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>."},{"content":"You cannot use this returned <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.","pos":[231,356],"source":" You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue."},{"content":"However, you can call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> method of the returned <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to identify the remote host's network address and port number.","pos":[357,552],"source":" However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number."}]}]},{"pos":[559,818],"content":"In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued. Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.","nodes":[{"content":"In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued. Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.","pos":[0,259],"nodes":[{"content":"In blocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> blocks until an incoming connection attempt is queued.","pos":[0,115],"source":"In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued."},{"content":"Once a connection is accepted, the original <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> continues queuing incoming connection requests until you close it.","pos":[116,259],"source":" Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it."}]}]},{"pos":[825,1393],"content":"If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","nodes":[{"content":"If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[0,568],"nodes":[{"content":"If you call this method using a non-blocking <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and no connection requests are queued, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> throws a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[0,212],"source":"If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>."},{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[213,404],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[405,568]}]}]},{"pos":[1401,1609],"content":"[!NOTE]\n Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.","leadings":["","> "],"nodes":[{"content":"Before calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method, you must first call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.","pos":[9,206],"source":" Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests."}]},{"pos":[1617,1842],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[30962,32817],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Net.Sockets.Socket\"></xref> for a newly created connection.","nodes":[{"pos":[0,80],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> for a newly created connection.","source":"A <xref href=\"System.Net.Sockets.Socket\"></xref> for a newly created connection."}],"pos":[33510,33591],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[33765,33821],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[33927,33995],"yaml":true},{"content":"The accepting socket is not listening for connections. You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.Accept\"></xref>.","nodes":[{"pos":[0,283],"content":"The accepting socket is not listening for connections. You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.Accept\"></xref>.","nodes":[{"content":"The accepting socket is not listening for connections.","pos":[0,54]},{"content":"You must call <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"&gt;&lt;/xref&gt;</ph> and <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"&gt;&lt;/xref&gt;</ph> before calling <ph id=\"ph3\">&lt;xref href=\"System.Net.Sockets.Socket.Accept\"&gt;&lt;/xref&gt;</ph>.","pos":[55,283],"source":" You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.Accept\"></xref>."}]}],"pos":[34105,34389],"yaml":true},{"content":"Begins an asynchronous operation to accept an incoming connection attempt.","nodes":[{"pos":[0,74],"content":"Begins an asynchronous operation to accept an incoming connection attempt.","nodes":[{"content":"Begins an asynchronous operation to accept an incoming connection attempt.","pos":[0,74]}]}],"pos":[35804,35879],"yaml":true},{"content":"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.  \n  \n To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.  \n  \n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required:  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \n  \n The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> property.  \n  \n If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> property.  \n  \n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \n  \n Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds. In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the maximum number of bytes of data to receive in the buffer. These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=fullName> method. Part of the buffer passed in will be consumed internally for use by the the underlying Winsock AcceptEx call. This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> instance provided. The amount of the buffer used internally varies based on the address family of the socket. The minimum buffer size required is 288 bytes. If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received. If a timeout occurs, the connection is reset. So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.  \n  \n The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful.  \n  \n The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>. This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence). Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.","nodes":[{"pos":[0,469],"content":"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.","nodes":[{"content":"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.","pos":[0,469],"nodes":[{"content":"Connection-oriented protocols can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method to asynchronously process incoming connection attempts.","pos":[0,152],"source":"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts."},{"content":"Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.","pos":[153,272]},{"content":"Before calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method, you must call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.","pos":[273,469],"source":" Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests."}]}]},{"pos":[476,712],"content":"To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.","nodes":[{"content":"To be notified of completion, you must create a callback method that implements the EventHandler<ph id=\"ph1\">\\&lt;</ph>SocketAsyncEventArgs&gt; delegate and hook it to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName&gt;</ph> event.","pos":[0,236],"source":"To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event."}]},{"pos":[719,854],"content":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required:","nodes":[{"content":"The following properties and events on the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required:","pos":[0,135],"source":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required:"}]},{"pos":[864,945],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>","nodes":[]},{"pos":[952,1230],"content":"The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> property.","nodes":[{"content":"The caller can optionally specify an existing <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to use for the incoming connection by specifying the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to use with the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName&gt;</ph> property.","pos":[0,278],"source":"The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> property."}]},{"pos":[1237,1730],"content":"If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> property.","nodes":[{"content":"If the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName&gt;</ph> property is null, a new <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is constructed with the same <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.AddressFamily%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph>, and <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> as the current <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and set as the <ph id=\"ph7\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName&gt;</ph> property.","pos":[0,493],"source":"If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> property."}]},{"pos":[1737,2176],"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","nodes":[{"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[0,439],"nodes":[{"content":"The caller may set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.","pos":[0,292],"source":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method."},{"content":"If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[293,439]}]}]},{"pos":[2183,3758],"content":"Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds. In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the maximum number of bytes of data to receive in the buffer. These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=fullName> method. Part of the buffer passed in will be consumed internally for use by the the underlying Winsock AcceptEx call. This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> instance provided. The amount of the buffer used internally varies based on the address family of the socket. The minimum buffer size required is 288 bytes. If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received. If a timeout occurs, the connection is reset. So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.","nodes":[{"content":"Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds. In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the maximum number of bytes of data to receive in the buffer. These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=fullName> method. Part of the buffer passed in will be consumed internally for use by the the underlying Winsock AcceptEx call. This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> instance provided. The amount of the buffer used internally varies based on the address family of the socket. The minimum buffer size required is 288 bytes. If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received. If a timeout occurs, the connection is reset. So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.","pos":[0,1575],"nodes":[{"content":"Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.","pos":[0,172],"source":"Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds."},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> property needs to be set to the buffer containing the data to receive and the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> property needs to be set to the maximum number of bytes of data to receive in the buffer.","pos":[173,521],"source":" In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the maximum number of bytes of data to receive in the buffer."},{"content":"These properties can be set using the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=fullName&gt;</ph> method.","pos":[522,652],"source":" These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=fullName> method."},{"content":"Part of the buffer passed in will be consumed internally for use by the the underlying Winsock AcceptEx call.","pos":[653,762]},{"content":"This means that the amount of data returned will always be less than the value of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> property on the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> instance provided.","pos":[763,1036],"source":" This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> instance provided."},{"content":"The amount of the buffer used internally varies based on the address family of the socket.","pos":[1037,1127]},{"content":"The minimum buffer size required is 288 bytes.","pos":[1128,1174]},{"content":"If a larger buffer size is specified, then the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.","pos":[1175,1397],"source":" If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received."},{"content":"If a timeout occurs, the connection is reset.","pos":[1398,1443]},{"content":"So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.","pos":[1444,1575]}]}]},{"pos":[3765,4004],"content":"The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful.","nodes":[{"content":"The completion callback method should examine the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName&gt;</ph> property to determine if the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> operation was successful.","pos":[0,239],"source":"The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful."}]},{"pos":[4011,4576],"content":"The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>. This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence). Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.","nodes":[{"content":"The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>. This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence). Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.","pos":[0,565],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName&gt;</ph> event can occur in some cases when no connection has been accepted and cause the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName&gt;</ph> property to be set to <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketError.ConnectionReset&gt;</ph>.","pos":[0,330],"source":"The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>."},{"content":"This can occur as a result of port scanning using a half-open SYN type scan (a SYN -&gt; SYN-ACK -&gt; RST sequence).","pos":[331,442],"source":" This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence)."},{"content":"Applications using the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method should be prepared to handle this condition.","pos":[443,565],"source":" Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition."}]}]}],"pos":[35890,40488],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.","source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation."}],"pos":[40679,40798],"yaml":true},{"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \n  \n Returns `false` if the I/O operation completed synchronously. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"pos":[0,209],"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`true`</ph> if the I/O operation is pending.","pos":[0,47],"source":"Returns `true` if the I/O operation is pending."},{"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.","pos":[48,209],"source":" The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation."}]},{"pos":[216,560],"content":"Returns `false` if the I/O operation completed synchronously. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`false`</ph> if the I/O operation completed synchronously.","pos":[0,61],"source":"Returns `false` if the I/O operation completed synchronously."},{"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">e</ph><ept id=\"p2\">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","pos":[62,344],"source":" The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation."}]}],"pos":[40856,41425],"yaml":true},{"content":"An argument is not valid. This exception occurs if the buffer provided is not large enough. The buffer must be at least 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes.  \n  \n This exception also occurs if multiple buffers are specified, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> property is not null.","nodes":[{"pos":[0,161],"content":"An argument is not valid. This exception occurs if the buffer provided is not large enough. The buffer must be at least 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes.","nodes":[{"content":"An argument is not valid. This exception occurs if the buffer provided is not large enough. The buffer must be at least 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes.","pos":[0,161],"nodes":[{"content":"An argument is not valid.","pos":[0,25]},{"content":"This exception occurs if the buffer provided is not large enough.","pos":[26,91]},{"content":"The buffer must be at least 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes.","pos":[92,161]}]}]},{"pos":[168,327],"content":"This exception also occurs if multiple buffers are specified, the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"&gt;&lt;/xref&gt;</ph> property is not null.","source":"This exception also occurs if multiple buffers are specified, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> property is not null."}],"pos":[41584,41918],"yaml":true},{"content":"An argument is out of range. The exception occurs if the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\"></xref> is less than 0.","nodes":[{"pos":[0,139],"content":"An argument is out of range. The exception occurs if the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\"></xref> is less than 0.","nodes":[{"content":"An argument is out of range.","pos":[0,28]},{"content":"The exception occurs if the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\"&gt;&lt;/xref&gt;</ph> is less than 0.","pos":[29,139],"source":" The exception occurs if the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\"></xref> is less than 0."}]}],"pos":[42032,42172],"yaml":true},{"content":"An invalid operation was requested. This exception occurs if the accepting <xref href=\"System.Net.Sockets.Socket\"></xref> is not listening for connections or the accepted socket is bound.  \n  \n You must call the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> method before calling the <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\"></xref> method.  \n  \n This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <code>e</code> parameter.","nodes":[{"pos":[0,187],"content":"An invalid operation was requested. This exception occurs if the accepting <xref href=\"System.Net.Sockets.Socket\"></xref> is not listening for connections or the accepted socket is bound.","nodes":[{"content":"An invalid operation was requested.","pos":[0,35]},{"content":"This exception occurs if the accepting <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is not listening for connections or the accepted socket is bound.","pos":[36,187],"source":" This exception occurs if the accepting <xref href=\"System.Net.Sockets.Socket\"></xref> is not listening for connections or the accepted socket is bound."}]},{"pos":[194,490],"content":"You must call the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"&gt;&lt;/xref&gt;</ph> and <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"&gt;&lt;/xref&gt;</ph> method before calling the <ph id=\"ph3\">&lt;xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\"&gt;&lt;/xref&gt;</ph> method.","source":"You must call the <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> method before calling the <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\"></xref> method."},{"pos":[497,650],"content":"This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <code>e</code> parameter."}],"pos":[42282,42947],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[43061,43117],"yaml":true},{"content":"Windows XP or later is required for this method.","nodes":[{"pos":[0,48],"content":"Windows XP or later is required for this method.","nodes":[{"content":"Windows XP or later is required for this method.","pos":[0,48]}]}],"pos":[43219,43268],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[43374,43442],"yaml":true},{"content":"Gets the address family of the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,78],"content":"Gets the address family of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Gets the address family of the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[44682,44761],"yaml":true},{"content":"The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use. This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.","nodes":[{"pos":[0,239],"content":"The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use. This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.","nodes":[{"content":"The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use. This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.","pos":[0,239],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> specifies the addressing scheme that an instance of the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class can use.","pos":[0,147],"source":"The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use."},{"content":"This property is read-only and is set when the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created.","pos":[148,239],"source":" This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created."}]}]}],"pos":[44772,45012],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Net.Sockets.AddressFamily\"></xref> values.","nodes":[{"pos":[0,72],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.AddressFamily\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.AddressFamily\"></xref> values."}],"pos":[45753,45826],"yaml":true},{"content":"Gets the amount of data that has been received from the network and is available to be read.","nodes":[{"pos":[0,92],"content":"Gets the amount of data that has been received from the network and is available to be read.","nodes":[{"content":"Gets the amount of data that has been received from the network and is available to be read.","pos":[0,92]}]}],"pos":[47112,47205],"yaml":true},{"content":"If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>. The available data is the total amount of data queued in the network buffer for reading. If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.  \n  \n If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,424],"content":"If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>. The available data is the total amount of data queued in the network buffer for reading. If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.","nodes":[{"content":"If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>. The available data is the total amount of data queued in the network buffer for reading. If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.","pos":[0,424],"nodes":[{"content":"If you are using a non-blocking <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is a good way to determine whether data is queued for reading, before calling <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.","pos":[0,234],"source":"If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>."},{"content":"The available data is the total amount of data queued in the network buffer for reading.","pos":[235,323]},{"content":"If no data is queued in the network buffer, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> returns 0.","pos":[324,424],"source":" If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0."}]}]},{"pos":[431,943],"content":"If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","nodes":[{"content":"If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[0,512],"nodes":[{"content":"If the remote host shuts down or closes the connection, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> can throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[0,156],"source":"If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[157,348],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[349,512]}]}]},{"pos":[951,1176],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[47216,48400],"yaml":true,"extradata":"MT"},{"content":"The number of bytes of data received from the network and available to be read.","nodes":[{"pos":[0,79],"content":"The number of bytes of data received from the network and available to be read.","nodes":[{"content":"The number of bytes of data received from the network and available to be read.","pos":[0,79]}]}],"pos":[48899,48979],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[49156,49212],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[49318,49386],"yaml":true},{"content":"Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.","nodes":[{"pos":[0,166],"content":"Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.","nodes":[{"content":"Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.","pos":[0,166]}]}],"pos":[50951,51118],"yaml":true},{"content":"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. This overload allows you to specify the accepted socket in the `acceptSocket` parameter. If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.  \n  \n Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.  \n  \n You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.  \n  \n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.  \n  \n <xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.  \n  \n The system may also use the calling thread to invoke the callback method. In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously.  \n  \n For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \n  \n To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.  \n  \n> [!NOTE]\n>  You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,586],"content":"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. This overload allows you to specify the accepted socket in the `acceptSocket` parameter. If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.","nodes":[{"content":"Connection-oriented protocols can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.","pos":[0,152],"source":"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts."},{"content":"Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.","pos":[153,272]},{"content":"This overload allows you to specify the accepted socket in the <ph id=\"ph1\">`acceptSocket`</ph> parameter.","pos":[273,361],"source":" This overload allows you to specify the accepted socket in the `acceptSocket` parameter."},{"content":"If this parameter is <ph id=\"ph1\">`null`</ph>, the accepted socket is created by the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.","pos":[362,484],"source":" If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method."},{"content":"You can specify the number of bytes to accept in the initial transfer in the <ph id=\"ph1\">`receiveSize`</ph> parameter.","pos":[485,586],"source":" You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter."}]},{"pos":[593,789],"content":"Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.","nodes":[{"content":"Before calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.","pos":[0,196],"source":"Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests."}]},{"pos":[796,1425],"content":"You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.","nodes":[{"content":"You must create a callback method that implements the <ph id=\"ph1\">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.","pos":[0,171],"source":"You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method."},{"content":"To do this, at the very minimum, you must pass the listening <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id=\"ph3\">`state`</ph> parameter.","pos":[172,354],"source":" To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter."},{"content":"If your callback needs more information, you can create a small class to hold the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.","pos":[355,505],"source":" If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information."},{"content":"Pass an instance of this class to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id=\"ph2\">`state`</ph> parameter.","pos":[506,629],"source":" Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter."}]},{"pos":[1432,1785],"content":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.","nodes":[{"content":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.","pos":[0,353],"nodes":[{"content":"Your callback method should invoke the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.","pos":[0,92],"source":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method."},{"content":"When your application calls <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.","pos":[93,353],"source":" When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved."}]}]},{"pos":[1792,2419],"content":"<xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.","nodes":[{"content":"<xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.","pos":[0,627],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> returns a new <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object that you can use to send and receive data with the remote host.","pos":[0,163],"source":"<xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host."},{"content":"You cannot use this returned <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.","pos":[164,289],"source":" You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue."},{"content":"If you want the original thread to block after you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph>.","pos":[290,481],"source":" If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>."},{"content":"Call the Set method on a <ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.","pos":[482,627],"source":" Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing."}]}]},{"pos":[2426,2734],"content":"The system may also use the calling thread to invoke the callback method. In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously.","nodes":[{"content":"The system may also use the calling thread to invoke the callback method. In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously.","pos":[0,308],"nodes":[{"content":"The system may also use the calling thread to invoke the callback method.","pos":[0,73]},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>method completed synchronously.","pos":[74,308],"source":" In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously."}]}]},{"pos":[2741,2918],"content":"For additional information on writing callback methods, see <bpt id=\"p1\">[</bpt>Marshaling a Delegate as a Callback Method<ept id=\"p1\">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.","source":"For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)."},{"pos":[2925,3447],"content":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.","nodes":[{"content":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.","pos":[0,522],"nodes":[{"content":"To cancel a pending call to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,131],"source":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>method is called while an asynchronous operation is in progress, the callback provided to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.","pos":[132,341],"source":" When the <xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called."},{"content":"A subsequent call to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>method will throw an <ph id=\"ph2\">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.","pos":[343,522],"source":"  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled."}]}]},{"pos":[3455,3660],"content":"[!NOTE]\n You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.","leadings":["","> "],"nodes":[{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to identify the remote host's network address and port number.","pos":[9,203],"source":" You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number."}]},{"pos":[3668,4034],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[4042,4267],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[4275,4709],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[51129,55867],"yaml":true,"extradata":"MT"},{"content":"The accepted <xref href=\"System.Net.Sockets.Socket\"></xref> object. This value may be `null`.","nodes":[{"pos":[0,93],"content":"The accepted <xref href=\"System.Net.Sockets.Socket\"></xref> object. This value may be `null`.","nodes":[{"content":"The accepted <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object.","pos":[0,67],"source":"The accepted <xref href=\"System.Net.Sockets.Socket\"></xref> object."},{"content":"This value may be <ph id=\"ph1\">`null`</ph>.","pos":[68,93],"source":" This value may be `null`."}]}],"pos":[56919,57013],"yaml":true},{"content":"The maximum number of bytes to receive.","nodes":[{"pos":[0,39],"content":"The maximum number of bytes to receive.","nodes":[{"content":"The maximum number of bytes to receive.","pos":[0,39]}]}],"pos":[57079,57119],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate.","nodes":[{"pos":[0,55],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate."}],"pos":[57190,57246],"yaml":true},{"content":"An object that contains state information for this request.","nodes":[{"pos":[0,59],"content":"An object that contains state information for this request.","nodes":[{"content":"An object that contains state information for this request.","pos":[0,59]}]}],"pos":[57307,57367],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> object that references the asynchronous <xref href=\"System.Net.Sockets.Socket\"></xref> object creation.","nodes":[{"pos":[0,147],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> object that references the asynchronous <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object creation.","source":"An <xref href=\"System.IAsyncResult\"></xref> object that references the asynchronous <xref href=\"System.Net.Sockets.Socket\"></xref> object creation."}],"pos":[57430,57578],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed."}],"pos":[57749,57824],"yaml":true},{"content":"Windows NT is required for this method.","nodes":[{"pos":[0,39],"content":"Windows NT is required for this method.","nodes":[{"content":"Windows NT is required for this method.","pos":[0,39]}]}],"pos":[57926,57966],"yaml":true},{"content":"The accepting socket is not listening for connections. You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>.  \n  \n -or-  \n  \n The accepted socket is bound.","nodes":[{"pos":[0,324],"content":"The accepting socket is not listening for connections. You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>.","nodes":[{"content":"The accepting socket is not listening for connections.","pos":[0,54]},{"content":"You must call <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"&gt;&lt;/xref&gt;</ph> and <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"&gt;&lt;/xref&gt;</ph> before calling <ph id=\"ph3\">&lt;xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph>.","pos":[55,324],"source":" You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>."}]},{"pos":[331,335],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[342,371],"content":"The accepted socket is bound.","nodes":[{"content":"The accepted socket is bound.","pos":[0,29]}]}],"pos":[58076,58460],"yaml":true},{"content":"<code>receiveSize</code> is less than 0.","nodes":[{"pos":[0,40],"content":"<ph id=\"ph1\">&lt;code&gt;receiveSize&lt;/code&gt;</ph> is less than 0.","source":"<code>receiveSize</code> is less than 0."}],"pos":[58574,58615],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[58729,58785],"yaml":true},{"content":"Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.","nodes":[{"pos":[0,142],"content":"Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.","nodes":[{"content":"Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.","pos":[0,142]}]}],"pos":[60064,60207],"yaml":true},{"content":"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts. Accepting connections asynchronously enables you to send and receive data within a separate execution thread. This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.  \n  \n Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.  \n  \n You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.  \n  \n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.  \n  \n <xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.  \n  \n The system may also use the calling thread to invoke the callback method. In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously.  \n  \n For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \n  \n To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.  When the <xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.  \n  \n> [!NOTE]\n>  You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,384],"content":"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts. Accepting connections asynchronously enables you to send and receive data within a separate execution thread. This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.","nodes":[{"content":"Connection-oriented protocols can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.","pos":[0,152],"source":"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts."},{"content":"Accepting connections asynchronously enables you to send and receive data within a separate execution thread.","pos":[153,262]},{"content":"This overload allows you to specify the number of bytes to accept in the initial transfer in the <ph id=\"ph1\">`receiveSize`</ph> parameter.","pos":[263,384],"source":" This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter."}]},{"pos":[391,587],"content":"Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.","nodes":[{"content":"Before calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.","pos":[0,196],"source":"Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests."}]},{"pos":[594,1223],"content":"You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.","nodes":[{"content":"You must create a callback method that implements the <ph id=\"ph1\">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.","pos":[0,171],"source":"You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method."},{"content":"To do this, at the very minimum, you must pass the listening <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id=\"ph3\">`state`</ph> parameter.","pos":[172,354],"source":" To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter."},{"content":"If your callback needs more information, you can create a small class to hold the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.","pos":[355,505],"source":" If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information."},{"content":"Pass an instance of this class to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id=\"ph2\">`state`</ph> parameter.","pos":[506,629],"source":" Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter."}]},{"pos":[1230,1583],"content":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.","nodes":[{"content":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.","pos":[0,353],"nodes":[{"content":"Your callback method should invoke the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.","pos":[0,92],"source":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method."},{"content":"When your application calls <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.","pos":[93,353],"source":" When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved."}]}]},{"pos":[1590,2210],"content":"<xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.","nodes":[{"content":"<xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.","pos":[0,620],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> returns a new <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you can use to send and receive data with the remote host.","pos":[0,156],"source":"<xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host."},{"content":"You cannot use this returned <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.","pos":[157,282],"source":" You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue."},{"content":"If you want the original thread to block after you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph>.","pos":[283,474],"source":" If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>."},{"content":"Call the Set method on a <ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.","pos":[475,620],"source":" Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing."}]}]},{"pos":[2217,2525],"content":"The system may also use the calling thread to invoke the callback method. In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously.","nodes":[{"content":"The system may also use the calling thread to invoke the callback method. In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously.","pos":[0,308],"nodes":[{"content":"The system may also use the calling thread to invoke the callback method.","pos":[0,73]},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>method completed synchronously.","pos":[74,308],"source":" In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously."}]}]},{"pos":[2532,2708],"content":"For additional information on writing callback methods see <bpt id=\"p1\">[</bpt>Marshaling a Delegate as a Callback Method<ept id=\"p1\">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.","source":"For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)."},{"pos":[2715,3238],"content":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.  When the <xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.","nodes":[{"content":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.  When the <xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.","pos":[0,523],"nodes":[{"content":"To cancel a pending call to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,131],"source":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>method is called while an asynchronous operation is in progress, the callback provided to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.","pos":[133,342],"source":"  When the <xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called."},{"content":"A subsequent call to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>method will throw an <ph id=\"ph2\">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.","pos":[344,523],"source":"  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled."}]}]},{"pos":[3246,3456],"content":"[!NOTE]\n You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.","leadings":["","> "],"nodes":[{"content":"You can call use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to identify the remote host's network address and port number.","pos":[9,208],"source":" You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number."}]},{"pos":[3464,3830],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3838,4063],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[4071,4505],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[60218,64752],"yaml":true,"extradata":"MT"},{"content":"The number of bytes to accept from the sender.","nodes":[{"pos":[0,46],"content":"The number of bytes to accept from the sender.","nodes":[{"content":"The number of bytes to accept from the sender.","pos":[0,46]}]}],"pos":[65604,65651],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate.","nodes":[{"pos":[0,55],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate."}],"pos":[65722,65778],"yaml":true},{"content":"An object that contains state information for this request.","nodes":[{"pos":[0,59],"content":"An object that contains state information for this request.","nodes":[{"content":"An object that contains state information for this request.","pos":[0,59]}]}],"pos":[65839,65899],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous <xref href=\"System.Net.Sockets.Socket\"></xref> creation.","nodes":[{"pos":[0,133],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> creation.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous <xref href=\"System.Net.Sockets.Socket\"></xref> creation."}],"pos":[65962,66096],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed."}],"pos":[66267,66342],"yaml":true},{"content":"Windows NT is required for this method.","nodes":[{"pos":[0,39],"content":"Windows NT is required for this method.","nodes":[{"content":"Windows NT is required for this method.","pos":[0,39]}]}],"pos":[66444,66484],"yaml":true},{"content":"The accepting socket is not listening for connections. You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>.  \n  \n -or-  \n  \n The accepted socket is bound.","nodes":[{"pos":[0,324],"content":"The accepting socket is not listening for connections. You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>.","nodes":[{"content":"The accepting socket is not listening for connections.","pos":[0,54]},{"content":"You must call <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"&gt;&lt;/xref&gt;</ph> and <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"&gt;&lt;/xref&gt;</ph> before calling <ph id=\"ph3\">&lt;xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph>.","pos":[55,324],"source":" You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>."}]},{"pos":[331,335],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[342,371],"content":"The accepted socket is bound.","nodes":[{"content":"The accepted socket is bound.","pos":[0,29]}]}],"pos":[66594,66978],"yaml":true},{"content":"<code>receiveSize</code> is less than 0.","nodes":[{"pos":[0,40],"content":"<ph id=\"ph1\">&lt;code&gt;receiveSize&lt;/code&gt;</ph> is less than 0.","source":"<code>receiveSize</code> is less than 0."}],"pos":[67092,67133],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[67247,67303],"yaml":true},{"content":"Begins an asynchronous operation to accept an incoming connection attempt.","nodes":[{"pos":[0,74],"content":"Begins an asynchronous operation to accept an incoming connection attempt.","nodes":[{"content":"Begins an asynchronous operation to accept an incoming connection attempt.","pos":[0,74]}]}],"pos":[68522,68597],"yaml":true},{"content":"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.  \n  \n You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.  \n  \n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved. <xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.  \n  \n The system may also use the calling thread to invoke the callback method. In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously.  \n  \n For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \n  \n To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>. When the<xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.  \n  \n> [!NOTE]\n>  You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,469],"content":"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.","nodes":[{"content":"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.","pos":[0,469],"nodes":[{"content":"Connection-oriented protocols can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.","pos":[0,152],"source":"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts."},{"content":"Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.","pos":[153,272]},{"content":"Before calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.","pos":[273,469],"source":" Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests."}]}]},{"pos":[476,1105],"content":"You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.","nodes":[{"content":"You must create a callback method that implements the <ph id=\"ph1\">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.","pos":[0,171],"source":"You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method."},{"content":"To do this, at the very minimum, you must pass the listening <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id=\"ph3\">`state`</ph> parameter.","pos":[172,354],"source":" To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter."},{"content":"If your callback needs more information, you can create a small class to hold the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.","pos":[355,505],"source":" If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information."},{"content":"Pass an instance of this class to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id=\"ph2\">`state`</ph> parameter.","pos":[506,629],"source":" Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter."}]},{"pos":[1112,2097],"content":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved. <xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.","nodes":[{"content":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved. <xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.","pos":[0,985],"nodes":[{"content":"Your callback method should invoke the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.","pos":[0,92],"source":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method."},{"content":"When your application calls <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.","pos":[93,353],"source":" When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> will return a new <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object that you can use to send and receive data with the remote host.","pos":[354,521],"source":" <xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host."},{"content":"You cannot use this returned <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.","pos":[522,647],"source":" You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue."},{"content":"If you want the original thread to block after you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph>.","pos":[648,839],"source":" If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>."},{"content":"Call the Set method on a <ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.","pos":[840,985],"source":" Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing."}]}]},{"pos":[2104,2412],"content":"The system may also use the calling thread to invoke the callback method. In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously.","nodes":[{"content":"The system may also use the calling thread to invoke the callback method. In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously.","pos":[0,308],"nodes":[{"content":"The system may also use the calling thread to invoke the callback method.","pos":[0,73]},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>method completed synchronously.","pos":[74,308],"source":" In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously."}]}]},{"pos":[2419,2595],"content":"For additional information on writing callback methods see <bpt id=\"p1\">[</bpt>Marshaling a Delegate as a Callback Method<ept id=\"p1\">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.","source":"For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)."},{"pos":[2602,3123],"content":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>. When the<xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.","nodes":[{"content":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>. When the<xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.","pos":[0,521],"nodes":[{"content":"To cancel a pending call to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,131],"source":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>."},{"content":"When the<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>method is called while an asynchronous operation is in progress, the callback provided to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.","pos":[132,340],"source":" When the<xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called."},{"content":"A subsequent call to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>method will throw an <ph id=\"ph2\">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.","pos":[342,521],"source":"  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled."}]}]},{"pos":[3131,3329],"content":"[!NOTE]\n You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.","leadings":["","> "],"nodes":[{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to identify the remote host's network address and port number.","pos":[9,196],"source":" You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number."}]},{"pos":[3337,3691],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.","pos":[8,352],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.","pos":[193,344]}]}]},{"pos":[3699,3924],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[3932,4366],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[68608,72999],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate.","nodes":[{"pos":[0,55],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate."}],"pos":[73692,73748],"yaml":true},{"content":"An object that contains state information for this request.","nodes":[{"pos":[0,59],"content":"An object that contains state information for this request.","nodes":[{"content":"An object that contains state information for this request.","pos":[0,59]}]}],"pos":[73809,73869],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous <xref href=\"System.Net.Sockets.Socket\"></xref> creation.","nodes":[{"pos":[0,133],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> creation.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous <xref href=\"System.Net.Sockets.Socket\"></xref> creation."}],"pos":[73932,74066],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed."}],"pos":[74237,74312],"yaml":true},{"content":"Windows NT is required for this method.","nodes":[{"pos":[0,39],"content":"Windows NT is required for this method.","nodes":[{"content":"Windows NT is required for this method.","pos":[0,39]}]}],"pos":[74414,74454],"yaml":true},{"content":"The accepting socket is not listening for connections. You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>.  \n  \n -or-  \n  \n The accepted socket is bound.","nodes":[{"pos":[0,324],"content":"The accepting socket is not listening for connections. You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>.","nodes":[{"content":"The accepting socket is not listening for connections.","pos":[0,54]},{"content":"You must call <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"&gt;&lt;/xref&gt;</ph> and <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"&gt;&lt;/xref&gt;</ph> before calling <ph id=\"ph3\">&lt;xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph>.","pos":[55,324],"source":" You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>."}]},{"pos":[331,335],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[342,371],"content":"The accepted socket is bound.","nodes":[{"content":"The accepted socket is bound.","pos":[0,29]}]}],"pos":[74564,74948],"yaml":true},{"content":"<code>receiveSize</code> is less than 0.","nodes":[{"pos":[0,40],"content":"<ph id=\"ph1\">&lt;code&gt;receiveSize&lt;/code&gt;</ph> is less than 0.","source":"<code>receiveSize</code> is less than 0."}],"pos":[75062,75103],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[75217,75273],"yaml":true},{"content":"Begins an asynchronous request for a remote host connection.","nodes":[{"pos":[0,60],"content":"Begins an asynchronous request for a remote host connection.","nodes":[{"content":"Begins an asynchronous request for a remote host connection.","pos":[0,60]}]}],"pos":[76588,76649],"yaml":true},{"content":"If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host. Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.  \n  \n You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method. At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter.  \n  \n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \n  \n If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`. If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.  \n  \n To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,457],"content":"If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host. Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.","nodes":[{"content":"If you are using a connection-oriented protocol, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method starts an asynchronous request for a connection to the <ph id=\"ph2\">`remoteEP`</ph> parameter.","pos":[0,185],"source":"If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter."},{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> establishes a default remote host.","pos":[186,313],"source":" If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host."},{"content":"Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.","pos":[314,457]}]},{"pos":[464,1067],"content":"You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method. At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter.","nodes":[{"content":"You can create a callback method that implements the <ph id=\"ph1\">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method.","pos":[0,171],"source":"You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method."},{"content":"At the very minimum, you must pass the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> through the <ph id=\"ph3\">`state`</ph> parameter.","pos":[172,326],"source":" At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter."},{"content":"If your callback needs more information, you can create a small class to hold the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and the other required information.","pos":[327,478],"source":" If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information."},{"content":"Pass an instance of this class to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method through the <ph id=\"ph2\">`state`</ph> parameter.","pos":[479,603],"source":" Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter."}]},{"pos":[1074,1970],"content":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).","nodes":[{"content":"Your callback method should invoke the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.","pos":[0,93],"source":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method."},{"content":"When your application calls <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> until the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connects successfully or throws an exception.","pos":[94,405],"source":" When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception."},{"content":"If you want the original thread to block after you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, use <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.","pos":[406,573],"source":" If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>."},{"content":"Call the Set method on a <ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.","pos":[574,719],"source":" Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing."},{"content":"For additional information on writing callback methods see <bpt id=\"p1\">[</bpt>Marshaling a Delegate as a Callback Method<ept id=\"p1\">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.","pos":[720,896],"source":" For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)."}]},{"pos":[1977,2740],"content":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`. If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not have to call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> before sending and receiving data.","pos":[0,163],"source":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> to communicate with a remote host.","pos":[164,315],"source":" You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host."},{"content":"If you do call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.","pos":[316,474],"source":" If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded."},{"content":"If you wish to set your default remote host to a broadcast address, you must first call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id=\"ph2\">`true`</ph>.","pos":[475,643],"source":" If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`."},{"content":"If you cannot, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[644,763],"source":" If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]},{"pos":[2747,3410],"content":"If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.","nodes":[{"content":"If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.","pos":[0,663],"nodes":[{"content":"If you are using a connection-oriented protocol and do not call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.","pos":[0,273],"source":"If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number."},{"content":"If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.","pos":[274,518],"source":" If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method."},{"content":"If you want to change the default remote host, call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method again with the desired endpoint.","pos":[519,663],"source":" If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint."}]}]},{"pos":[3417,3944],"content":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.","nodes":[{"content":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.","pos":[0,527],"nodes":[{"content":"To cancel a pending call to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,132],"source":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.","pos":[133,344],"source":" When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called."},{"content":"A subsequent call to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id=\"ph2\">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.","pos":[346,527],"source":"  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled."}]}]},{"pos":[3952,4318],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[4326,4567],"content":"[!NOTE]\n If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider.","leadings":["","> "],"nodes":[{"content":" If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider.","pos":[8,239],"nodes":[{"content":"If this socket has previously been disconnected, then <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.","pos":[1,182],"source":" If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete."},{"content":"This is a limitation of the underlying provider.","pos":[183,231]}]}]},{"pos":[4575,4800],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[4808,5242],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[76660,81927],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate.","nodes":[{"pos":[0,55],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate."}],"pos":[82712,82768],"yaml":true},{"content":"An object that contains state information for this request.","nodes":[{"pos":[0,59],"content":"An object that contains state information for this request.","nodes":[{"content":"An object that contains state information for this request.","pos":[0,59]}]}],"pos":[82829,82889],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous connection.","nodes":[{"pos":[0,88],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous connection.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous connection."}],"pos":[82952,83041],"yaml":true},{"content":"<code>remoteEP</code> is `null`.","nodes":[{"pos":[0,32],"content":"<ph id=\"ph1\">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>remoteEP</code> is `null`."}],"pos":[83209,83242],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[83356,83412],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[83518,83586],"yaml":true},{"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"pos":[0,87],"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"content":"A caller higher in the call stack does not have permission for the requested operation.","pos":[0,87]}]}],"pos":[83698,83786],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.","nodes":[{"pos":[0,125],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"&gt;&lt;/xref&gt;</ph>ing.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing."}],"pos":[83896,84022],"yaml":true},{"content":"Begins an asynchronous request for a remote host connection. The host is specified by an <xref href=\"System.Net.IPAddress\"></xref> and a port number.","nodes":[{"pos":[0,149],"content":"Begins an asynchronous request for a remote host connection. The host is specified by an <xref href=\"System.Net.IPAddress\"></xref> and a port number.","nodes":[{"content":"Begins an asynchronous request for a remote host connection.","pos":[0,60]},{"content":"The host is specified by an <ph id=\"ph1\">&lt;xref href=\"System.Net.IPAddress\"&gt;&lt;/xref&gt;</ph> and a port number.","pos":[61,149],"source":" The host is specified by an <xref href=\"System.Net.IPAddress\"></xref> and a port number."}]}],"pos":[85403,85553],"yaml":true},{"content":"The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method. Typically, the method is invoked by the `requestCallback` delegate.  \n  \n This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.  \n  \n To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.  \n  \n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <xref:System.Net.EndPoint> that is used must be different.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,231],"content":"The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method. Typically, the method is invoked by the `requestCallback` delegate.","nodes":[{"content":"The asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.","pos":[0,163],"source":"The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method."},{"content":"Typically, the method is invoked by the <ph id=\"ph1\">`requestCallback`</ph> delegate.","pos":[164,231],"source":" Typically, the method is invoked by the `requestCallback` delegate."}]},{"pos":[238,467],"content":"This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.","nodes":[{"content":"This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.","pos":[0,229],"nodes":[{"content":"This method does not block until the operation is complete.","pos":[0,59]},{"content":"To block until the operation is complete, use one of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>.","pos":[60,229],"source":" To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>."}]}]},{"pos":[474,1001],"content":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.","nodes":[{"content":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.","pos":[0,527],"nodes":[{"content":"To cancel a pending call to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,132],"source":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.","pos":[133,344],"source":" When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called."},{"content":"A subsequent call to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id=\"ph2\">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.","pos":[346,527],"source":"  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled."}]}]},{"pos":[1008,1226],"content":"For detailed information about using the asynchronous programming model, see <bpt id=\"p1\">[</bpt>Calling Synchronous Methods Asynchronously<ept id=\"p1\">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>","source":"For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)"},{"pos":[1234,1600],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1608,1917],"content":"[!NOTE]\n If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <xref:System.Net.EndPoint> that is used must be different.","leadings":["","> "],"nodes":[{"content":" If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <xref:System.Net.EndPoint> that is used must be different.","pos":[8,307],"nodes":[{"content":"If this socket has previously been disconnected, then <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.","pos":[1,182],"source":" If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete."},{"content":"This is a limitation of the underlying provider.","pos":[183,231]},{"content":"Also the <ph id=\"ph1\">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.","pos":[232,299],"source":" Also the <xref:System.Net.EndPoint> that is used must be different."}]}]},{"pos":[1925,2150],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[2158,2592],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[85564,88177],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Net.IPAddress\"></xref> of the remote host.","nodes":[{"pos":[0,65],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.IPAddress\"&gt;&lt;/xref&gt;</ph> of the remote host.","source":"The <xref href=\"System.Net.IPAddress\"></xref> of the remote host."}],"pos":[89161,89227],"yaml":true},{"content":"The port number of the remote host.","nodes":[{"pos":[0,35],"content":"The port number of the remote host.","nodes":[{"content":"The port number of the remote host.","pos":[0,35]}]}],"pos":[89286,89322],"yaml":true},{"content":"A user-defined object that contains information about the connect operation. This object is passed to the <code>requestCallback</code> delegate when the operation is complete.","nodes":[{"pos":[0,175],"content":"A user-defined object that contains information about the connect operation. This object is passed to the <code>requestCallback</code> delegate when the operation is complete.","nodes":[{"content":"A user-defined object that contains information about the connect operation.","pos":[0,76]},{"content":"This object is passed to the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">requestCallback</ph><ept id=\"p1\">&lt;/code&gt;</ept> delegate when the operation is complete.","pos":[77,175],"source":" This object is passed to the <code>requestCallback</code> delegate when the operation is complete."}]}],"pos":[89464,89640],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous connection.","nodes":[{"pos":[0,88],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous connection.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous connection."}],"pos":[89703,89792],"yaml":true},{"content":"<code>address</code> is `null`.","nodes":[{"pos":[0,31],"content":"<code>address</code> is `null`.","nodes":[{"content":"is <ph id=\"ph1\">`null`</ph>.","pos":[21,31],"source":" is `null`."}]}],"pos":[89960,89992],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[90106,90162],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[90268,90336],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is not in the socket family.","nodes":[{"pos":[0,79],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is not in the socket family.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is not in the socket family."}],"pos":[90438,90518],"yaml":true},{"content":"The port number is not valid.","nodes":[{"pos":[0,29],"content":"The port number is not valid.","nodes":[{"content":"The port number is not valid.","pos":[0,29]}]}],"pos":[90632,90662],"yaml":true},{"content":"The length of <code>address</code> is zero.","nodes":[{"pos":[0,43],"content":"The length of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">address</ph><ept id=\"p1\">&lt;/code&gt;</ept> is zero.","source":"The length of <code>address</code> is zero."}],"pos":[90756,90800],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.","nodes":[{"pos":[0,125],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"&gt;&lt;/xref&gt;</ph>ing.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing."}],"pos":[90910,91036],"yaml":true},{"content":"Begins an asynchronous request for a remote host connection. The host is specified by an <xref href=\"System.Net.IPAddress\"></xref> array and a port number.","nodes":[{"pos":[0,155],"content":"Begins an asynchronous request for a remote host connection. The host is specified by an <xref href=\"System.Net.IPAddress\"></xref> array and a port number.","nodes":[{"content":"Begins an asynchronous request for a remote host connection.","pos":[0,60]},{"content":"The host is specified by an <ph id=\"ph1\">&lt;xref href=\"System.Net.IPAddress\"&gt;&lt;/xref&gt;</ph> array and a port number.","pos":[61,155],"source":" The host is specified by an <xref href=\"System.Net.IPAddress\"></xref> array and a port number."}]}],"pos":[92429,92585],"yaml":true},{"content":"The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method. Typically, the method is invoked by the `requestCallback` delegate.  \n  \n This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.  \n  \n To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.  \n  \n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <xref:System.Net.EndPoint> that is used must be different.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,231],"content":"The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method. Typically, the method is invoked by the `requestCallback` delegate.","nodes":[{"content":"The asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.","pos":[0,163],"source":"The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method."},{"content":"Typically, the method is invoked by the <ph id=\"ph1\">`requestCallback`</ph> delegate.","pos":[164,231],"source":" Typically, the method is invoked by the `requestCallback` delegate."}]},{"pos":[238,416],"content":"This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.","nodes":[{"content":"This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.","pos":[0,178],"nodes":[{"content":"This method does not block until the operation is complete.","pos":[0,59]},{"content":"To block until the operation is complete, use one of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads.","pos":[60,178],"source":" To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads."}]}]},{"pos":[423,950],"content":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.","nodes":[{"content":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.","pos":[0,527],"nodes":[{"content":"To cancel a pending call to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,132],"source":"To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.","pos":[133,344],"source":" When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called."},{"content":"A subsequent call to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id=\"ph2\">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.","pos":[346,527],"source":"  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled."}]}]},{"pos":[957,1176],"content":"For detailed information about using the asynchronous programming model, see <bpt id=\"p1\">[</bpt>Calling Synchronous Methods Asynchronously<ept id=\"p1\">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.","source":"For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)."},{"pos":[1184,1550],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1558,1867],"content":"[!NOTE]\n If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <xref:System.Net.EndPoint> that is used must be different.","leadings":["","> "],"nodes":[{"content":" If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <xref:System.Net.EndPoint> that is used must be different.","pos":[8,307],"nodes":[{"content":"If this socket has previously been disconnected, then <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.","pos":[1,182],"source":" If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete."},{"content":"This is a limitation of the underlying provider.","pos":[183,231]},{"content":"Also the <ph id=\"ph1\">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.","pos":[232,299],"source":" Also the <xref:System.Net.EndPoint> that is used must be different."}]}]},{"pos":[1875,2100],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[2108,2542],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[92596,95159],"yaml":true,"extradata":"MT"},{"content":"At least one <xref href=\"System.Net.IPAddress\"></xref>, designating the remote host.","nodes":[{"pos":[0,84],"content":"At least one <ph id=\"ph1\">&lt;xref href=\"System.Net.IPAddress\"&gt;&lt;/xref&gt;</ph>, designating the remote host.","source":"At least one <xref href=\"System.Net.IPAddress\"></xref>, designating the remote host."}],"pos":[96151,96236],"yaml":true},{"content":"The port number of the remote host.","nodes":[{"pos":[0,35],"content":"The port number of the remote host.","nodes":[{"content":"The port number of the remote host.","pos":[0,35]}]}],"pos":[96295,96331],"yaml":true},{"content":"A user-defined object that contains information about the connect operation. This object is passed to the <code>requestCallback</code> delegate when the operation is complete.","nodes":[{"pos":[0,175],"content":"A user-defined object that contains information about the connect operation. This object is passed to the <code>requestCallback</code> delegate when the operation is complete.","nodes":[{"content":"A user-defined object that contains information about the connect operation.","pos":[0,76]},{"content":"This object is passed to the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">requestCallback</ph><ept id=\"p1\">&lt;/code&gt;</ept> delegate when the operation is complete.","pos":[77,175],"source":" This object is passed to the <code>requestCallback</code> delegate when the operation is complete."}]}],"pos":[96473,96649],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous connections.","nodes":[{"pos":[0,89],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous connections.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous connections."}],"pos":[96712,96802],"yaml":true},{"content":"<code>addresses</code> is `null`.","nodes":[{"pos":[0,33],"content":"<ph id=\"ph1\">&lt;code&gt;addresses&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>addresses</code> is `null`."}],"pos":[96970,97004],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[97118,97174],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[97280,97348],"yaml":true},{"content":"This method is valid for sockets that use <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref>.","nodes":[{"pos":[0,181],"content":"This method is valid for sockets that use <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"&gt;&lt;/xref&gt;</ph>.","source":"This method is valid for sockets that use <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref>."}],"pos":[97450,97632],"yaml":true},{"content":"The port number is not valid.","nodes":[{"pos":[0,29],"content":"The port number is not valid.","nodes":[{"content":"The port number is not valid.","pos":[0,29]}]}],"pos":[97746,97776],"yaml":true},{"content":"The length of <code>address</code> is zero.","nodes":[{"pos":[0,43],"content":"The length of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">address</ph><ept id=\"p1\">&lt;/code&gt;</ept> is zero.","source":"The length of <code>address</code> is zero."}],"pos":[97870,97914],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.","nodes":[{"pos":[0,125],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"&gt;&lt;/xref&gt;</ph>ing.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing."}],"pos":[98024,98150],"yaml":true},{"content":"Begins an asynchronous request for a remote host connection. The host is specified by a host name and a port number.","nodes":[{"pos":[0,116],"content":"Begins an asynchronous request for a remote host connection. The host is specified by a host name and a port number.","nodes":[{"content":"Begins an asynchronous request for a remote host connection. The host is specified by a host name and a port number.","pos":[0,116],"nodes":[{"content":"Begins an asynchronous request for a remote host connection.","pos":[0,60]},{"content":"The host is specified by a host name and a port number.","pos":[61,116]}]}]}],"pos":[99501,99618],"yaml":true},{"content":"The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method. Typically, the method is invoked by the `requestCallback` delegate.  \n  \n This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.  \n  \n To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.  \n  \n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <xref:System.Net.EndPoint> that is used must be different.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,231],"content":"The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method. Typically, the method is invoked by the `requestCallback` delegate.","nodes":[{"content":"The asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.","pos":[0,163],"source":"The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method."},{"content":"Typically, the method is invoked by the <ph id=\"ph1\">`requestCallback`</ph> delegate.","pos":[164,231],"source":" Typically, the method is invoked by the `requestCallback` delegate."}]},{"pos":[238,416],"content":"This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.","nodes":[{"content":"This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.","pos":[0,178],"nodes":[{"content":"This method does not block until the operation is complete.","pos":[0,59]},{"content":"To block until the operation is complete, use one of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads.","pos":[60,178],"source":" To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads."}]}]},{"pos":[423,951],"content":"To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.","nodes":[{"content":"To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.","pos":[0,528],"nodes":[{"content":"To cancel a pending call to the  <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,133],"source":"To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.","pos":[134,345],"source":" When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called."},{"content":"A subsequent call to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id=\"ph2\">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.","pos":[347,528],"source":"  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled."}]}]},{"pos":[958,1176],"content":"For detailed information about using the asynchronous programming model, see <bpt id=\"p1\">[</bpt>Calling Synchronous Methods Asynchronously<ept id=\"p1\">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>","source":"For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)"},{"pos":[1184,1550],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1558,1867],"content":"[!NOTE]\n If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <xref:System.Net.EndPoint> that is used must be different.","leadings":["","> "],"nodes":[{"content":" If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <xref:System.Net.EndPoint> that is used must be different.","pos":[8,307],"nodes":[{"content":"If this socket has previously been disconnected, then <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.","pos":[1,182],"source":" If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete."},{"content":"This is a limitation of the underlying provider.","pos":[183,231]},{"content":"Also the <ph id=\"ph1\">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.","pos":[232,299],"source":" Also the <xref:System.Net.EndPoint> that is used must be different."}]}]},{"pos":[1875,2100],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[2108,2542],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[99629,102192],"yaml":true,"extradata":"MT"},{"content":"The name of the remote host.","nodes":[{"pos":[0,28],"content":"The name of the remote host.","nodes":[{"content":"The name of the remote host.","pos":[0,28]}]}],"pos":[103149,103178],"yaml":true},{"content":"The port number of the remote host.","nodes":[{"pos":[0,35],"content":"The port number of the remote host.","nodes":[{"content":"The port number of the remote host.","pos":[0,35]}]}],"pos":[103237,103273],"yaml":true},{"content":"A user-defined object that contains information about the connect operation. This object is passed to the <code>requestCallback</code> delegate when the operation is complete.","nodes":[{"pos":[0,175],"content":"A user-defined object that contains information about the connect operation. This object is passed to the <code>requestCallback</code> delegate when the operation is complete.","nodes":[{"content":"A user-defined object that contains information about the connect operation.","pos":[0,76]},{"content":"This object is passed to the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">requestCallback</ph><ept id=\"p1\">&lt;/code&gt;</ept> delegate when the operation is complete.","pos":[77,175],"source":" This object is passed to the <code>requestCallback</code> delegate when the operation is complete."}]}],"pos":[103415,103591],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous connection.","nodes":[{"pos":[0,88],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous connection.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous connection."}],"pos":[103654,103743],"yaml":true},{"content":"<code>host</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;host&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>host</code> is `null`."}],"pos":[103911,103940],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[104046,104114],"yaml":true},{"content":"This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families.","nodes":[{"pos":[0,188],"content":"This method is valid for sockets in the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"&gt;&lt;/xref&gt;</ph> families.","source":"This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families."}],"pos":[104216,104405],"yaml":true},{"content":"The port number is not valid.","nodes":[{"pos":[0,29],"content":"The port number is not valid.","nodes":[{"content":"The port number is not valid.","pos":[0,29]}]}],"pos":[104519,104549],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.","nodes":[{"pos":[0,125],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"&gt;&lt;/xref&gt;</ph>ing.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing."}],"pos":[104659,104785],"yaml":true},{"content":"Begins an asynchronous request to disconnect from a remote endpoint.","nodes":[{"pos":[0,68],"content":"Begins an asynchronous request to disconnect from a remote endpoint.","nodes":[{"content":"Begins an asynchronous request to disconnect from a remote endpoint.","pos":[0,68]}]}],"pos":[106100,106169],"yaml":true},{"content":"If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint. If `reuseSocket` is `true`, you can reuse the socket.  \n  \n The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method. The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete. For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,226],"content":"If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint. If `reuseSocket` is `true`, you can reuse the socket.","nodes":[{"content":"If you are using a connection-oriented protocol, you can call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> method to request a disconnect from a remote endpoint.","pos":[0,172],"source":"If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint."},{"content":"If <ph id=\"ph1\">`reuseSocket`</ph> is <ph id=\"ph2\">`true`</ph>, you can reuse the socket.","pos":[173,226],"source":" If `reuseSocket` is `true`, you can reuse the socket."}]},{"pos":[233,647],"content":"The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method. The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete. For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> method uses a separate thread to invoke the specified callback method.","pos":[0,126],"source":"The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> method blocks until the pending disconnect is complete.","pos":[127,236],"source":" The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete."},{"content":"For additional information on writing callback methods, see <bpt id=\"p1\">[</bpt>Marshaling a Delegate as a Callback Method<ept id=\"p1\">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.","pos":[237,414],"source":" For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)."}]},{"pos":[655,1031],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,374],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,202],"source":" If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[203,366]}]}]},{"pos":[1039,1264],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[106180,107455],"yaml":true,"extradata":"MT"},{"content":"`true` if this socket can be reused after the connection is closed; otherwise, `false`.","nodes":[{"pos":[0,87],"content":"<ph id=\"ph1\">`true`</ph> if this socket can be reused after the connection is closed; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if this socket can be reused after the connection is closed; otherwise, `false`."}],"pos":[108439,108529],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate.","nodes":[{"pos":[0,55],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate."}],"pos":[108600,108656],"yaml":true},{"content":"An object that contains state information for this request.","nodes":[{"pos":[0,59],"content":"An object that contains state information for this request.","nodes":[{"content":"An object that contains state information for this request.","pos":[0,59]}]}],"pos":[108717,108777],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> object that references the asynchronous operation.","nodes":[{"pos":[0,94],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> object that references the asynchronous operation.","source":"An <xref href=\"System.IAsyncResult\"></xref> object that references the asynchronous operation."}],"pos":[108840,108935],"yaml":true},{"content":"The operating system is Windows 2000 or earlier, and this method requires Windows XP.","nodes":[{"pos":[0,85],"content":"The operating system is Windows 2000 or earlier, and this method requires Windows XP.","nodes":[{"content":"The operating system is Windows 2000 or earlier, and this method requires Windows XP.","pos":[0,85]}]}],"pos":[109106,109192],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed."}],"pos":[109298,109373],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[109487,109543],"yaml":true},{"content":"Begins to asynchronously receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,102],"content":"Begins to asynchronously receive data from a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Begins to asynchronously receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[111221,111324],"yaml":true},{"content":"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method. Typically, the method is invoked by the `callback` delegate.  \n  \n This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.  \n  \n To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.  \n  \n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \n  \n> [!NOTE]\n>  `state` is an instantiation of a user-defined class.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,224],"content":"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method. Typically, the method is invoked by the `callback` delegate.","nodes":[{"content":"The asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.","pos":[0,163],"source":"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method."},{"content":"Typically, the method is invoked by the <ph id=\"ph1\">`callback`</ph> delegate.","pos":[164,224],"source":" Typically, the method is invoked by the `callback` delegate."}]},{"pos":[231,409],"content":"This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.","nodes":[{"content":"This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.","pos":[0,178],"nodes":[{"content":"This method does not block until the operation is complete.","pos":[0,59]},{"content":"To block until the operation is complete, use one of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.","pos":[60,178],"source":" To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads."}]}]},{"pos":[416,544],"content":"To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.","nodes":[{"content":"To cancel a pending <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.","pos":[0,128],"source":"To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method."}]},{"pos":[551,770],"content":"For detailed information about using the asynchronous programming model, see <bpt id=\"p1\">[</bpt>Calling Synchronous Methods Asynchronously<ept id=\"p1\">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.","source":"For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)."},{"pos":[778,1144],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1152,1328],"content":"[!NOTE]\n All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","leadings":["","> "],"nodes":[{"content":" All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[8,174],"nodes":[{"content":"All I/O initiated by a given thread is canceled when that thread exits.","pos":[1,72]},{"content":"A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[73,166]}]}]},{"pos":[1336,1399],"content":"[!NOTE]\n `state` is an instantiation of a user-defined class.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> `state`</ph> is an instantiation of a user-defined class.","pos":[8,61],"source":" `state` is an instantiation of a user-defined class."}]},{"pos":[1407,1632],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[1640,2074],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[111335,113433],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.","nodes":[{"pos":[0,101],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data."}],"pos":[113724,113826],"yaml":true},{"content":"The location in <code>buffer</code> to store the received data.","nodes":[{"pos":[0,63],"content":"The location in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">buffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> to store the received data.","source":"The location in <code>buffer</code> to store the received data."}],"pos":[113887,113951],"yaml":true},{"content":"The number of bytes to receive.","nodes":[{"pos":[0,31],"content":"The number of bytes to receive.","nodes":[{"content":"The number of bytes to receive.","pos":[0,31]}]}],"pos":[114010,114042],"yaml":true},{"content":"An <xref href=\"System.AsyncCallback\"></xref> delegate that references the method to invoke when the operation is complete.","nodes":[{"pos":[0,122],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate that references the method to invoke when the operation is complete.","source":"An <xref href=\"System.AsyncCallback\"></xref> delegate that references the method to invoke when the operation is complete."}],"pos":[114285,114408],"yaml":true},{"content":"A user-defined object that contains information about the receive operation. This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete.","nodes":[{"pos":[0,225],"content":"A user-defined object that contains information about the receive operation. This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete.","nodes":[{"content":"A user-defined object that contains information about the receive operation.","pos":[0,76]},{"content":"This object is passed to the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> delegate when the operation is complete.","pos":[77,225],"source":" This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete."}]}],"pos":[114469,114695],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read.","nodes":[{"pos":[0,82],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous read.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read."}],"pos":[114758,114841],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[115009,115040],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[115154,115210],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,63],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"<xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[115316,115380],"yaml":true},{"content":"<code>offset</code> is less than 0.  \n  \n -or-  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n -or-  \n  \n <code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.","source":"<code>offset</code> is less than 0."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,123],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>offset</code> is greater than the length of <code>buffer</code>."},{"pos":[130,134],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[141,174],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[181,185],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[192,313],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id=\"ph3\">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.","source":"<code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter."}],"pos":[115494,115822],"yaml":true},{"content":"Begins to asynchronously receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,102],"content":"Begins to asynchronously receive data from a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Begins to asynchronously receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[117365,117468],"yaml":true},{"content":"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method. Typically, the method is invoked by the `callback` delegate.  \n  \n This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.  \n  \n To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.  \n  \n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \n  \n> [!NOTE]\n>  `state` is an instantiation of a user-defined class.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,224],"content":"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method. Typically, the method is invoked by the `callback` delegate.","nodes":[{"content":"The asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.","pos":[0,163],"source":"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method."},{"content":"Typically, the method is invoked by the <ph id=\"ph1\">`callback`</ph> delegate.","pos":[164,224],"source":" Typically, the method is invoked by the `callback` delegate."}]},{"pos":[231,409],"content":"This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.","nodes":[{"content":"This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.","pos":[0,178],"nodes":[{"content":"This method does not block until the operation is complete.","pos":[0,59]},{"content":"To block until the operation is complete, use one of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.","pos":[60,178],"source":" To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads."}]}]},{"pos":[416,544],"content":"To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.","nodes":[{"content":"To cancel a pending <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.","pos":[0,128],"source":"To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method."}]},{"pos":[551,770],"content":"For detailed information about using the asynchronous programming model, see <bpt id=\"p1\">[</bpt>Calling Synchronous Methods Asynchronously<ept id=\"p1\">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.","source":"For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)."},{"pos":[778,1144],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1152,1328],"content":"[!NOTE]\n All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","leadings":["","> "],"nodes":[{"content":" All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[8,174],"nodes":[{"content":"All I/O initiated by a given thread is canceled when that thread exits.","pos":[1,72]},{"content":"A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[73,166]}]}]},{"pos":[1336,1399],"content":"[!NOTE]\n `state` is an instantiation of a user-defined class.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> `state`</ph> is an instantiation of a user-defined class.","pos":[8,61],"source":" `state` is an instantiation of a user-defined class."}]},{"pos":[1407,1632],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[1640,2074],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[117479,119577],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.","nodes":[{"pos":[0,101],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data."}],"pos":[121196,121298],"yaml":true},{"content":"The zero-based position in the <code>buffer</code> parameter at which to store the received data.","nodes":[{"pos":[0,97],"content":"The zero-based position in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">buffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter at which to store the received data.","source":"The zero-based position in the <code>buffer</code> parameter at which to store the received data."}],"pos":[121359,121457],"yaml":true},{"content":"The number of bytes to receive.","nodes":[{"pos":[0,31],"content":"The number of bytes to receive.","nodes":[{"content":"The number of bytes to receive.","pos":[0,31]}]}],"pos":[121516,121548],"yaml":true},{"content":"An <xref href=\"System.AsyncCallback\"></xref> delegate that references the method to invoke when the operation is complete.","nodes":[{"pos":[0,122],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate that references the method to invoke when the operation is complete.","source":"An <xref href=\"System.AsyncCallback\"></xref> delegate that references the method to invoke when the operation is complete."}],"pos":[121706,121829],"yaml":true},{"content":"A user-defined object that contains information about the receive operation. This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete.","nodes":[{"pos":[0,225],"content":"A user-defined object that contains information about the receive operation. This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete.","nodes":[{"content":"A user-defined object that contains information about the receive operation.","pos":[0,76]},{"content":"This object is passed to the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> delegate when the operation is complete.","pos":[77,225],"source":" This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete."}]}],"pos":[121890,122116],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read.","nodes":[{"pos":[0,82],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous read.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read."}],"pos":[122179,122262],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[122430,122461],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[122575,122631],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,63],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"<xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[122737,122801],"yaml":true},{"content":"<code>offset</code> is less than 0.  \n  \n -or-  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n -or-  \n  \n <code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.","source":"<code>offset</code> is less than 0."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,123],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>offset</code> is greater than the length of <code>buffer</code>."},{"pos":[130,134],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[141,174],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[181,185],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[192,313],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id=\"ph3\">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.","source":"<code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter."}],"pos":[122915,123243],"yaml":true},{"content":"Begins to asynchronously receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,102],"content":"Begins to asynchronously receive data from a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Begins to asynchronously receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[124882,124985],"yaml":true},{"content":"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method. Typically, the method is invoked by the `callback` delegate.  \n  \n This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.  \n  \n To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.  \n  \n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \n  \n> [!NOTE]\n>  `state` is an instantiation of a user-defined class.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,224],"content":"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method. Typically, the method is invoked by the `callback` delegate.","nodes":[{"content":"The asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.","pos":[0,163],"source":"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method."},{"content":"Typically, the method is invoked by the <ph id=\"ph1\">`callback`</ph> delegate.","pos":[164,224],"source":" Typically, the method is invoked by the `callback` delegate."}]},{"pos":[231,409],"content":"This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.","nodes":[{"content":"This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.","pos":[0,178],"nodes":[{"content":"This method does not block until the operation is complete.","pos":[0,59]},{"content":"To block until the operation is complete, use one of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.","pos":[60,178],"source":" To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads."}]}]},{"pos":[416,544],"content":"To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.","nodes":[{"content":"To cancel a pending <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.","pos":[0,128],"source":"To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method."}]},{"pos":[551,770],"content":"For detailed information about using the asynchronous programming model, see <bpt id=\"p1\">[</bpt>Calling Synchronous Methods Asynchronously<ept id=\"p1\">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.","source":"For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)."},{"pos":[778,1144],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1152,1328],"content":"[!NOTE]\n All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","leadings":["","> "],"nodes":[{"content":" All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[8,174],"nodes":[{"content":"All I/O initiated by a given thread is canceled when that thread exits.","pos":[1,72]},{"content":"A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[73,166]}]}]},{"pos":[1336,1399],"content":"[!NOTE]\n `state` is an instantiation of a user-defined class.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> `state`</ph> is an instantiation of a user-defined class.","pos":[8,61],"source":" `state` is an instantiation of a user-defined class."}]},{"pos":[1407,1632],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[1640,2074],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[124996,127094],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.","nodes":[{"pos":[0,101],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data."}],"pos":[127473,127575],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[127659,127748],"yaml":true},{"content":"An <xref href=\"System.AsyncCallback\"></xref> delegate that references the method to invoke when the operation is complete.","nodes":[{"pos":[0,122],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate that references the method to invoke when the operation is complete.","source":"An <xref href=\"System.AsyncCallback\"></xref> delegate that references the method to invoke when the operation is complete."}],"pos":[127819,127942],"yaml":true},{"content":"A user-defined object that contains information about the receive operation. This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete.","nodes":[{"pos":[0,225],"content":"A user-defined object that contains information about the receive operation. This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete.","nodes":[{"content":"A user-defined object that contains information about the receive operation.","pos":[0,76]},{"content":"This object is passed to the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> delegate when the operation is complete.","pos":[77,225],"source":" This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete."}]}],"pos":[128003,128229],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read.","nodes":[{"pos":[0,82],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous read.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read."}],"pos":[128292,128375],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[128543,128574],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[128688,128744],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,63],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"<xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[128850,128914],"yaml":true},{"content":"Begins to asynchronously receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,102],"content":"Begins to asynchronously receive data from a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Begins to asynchronously receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[130741,130844],"yaml":true},{"content":"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method. Typically, the method is invoked by the `callback` delegate.  \n  \n This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.  \n  \n To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.  \n  \n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \n  \n> [!NOTE]\n>  `state` is an instantiation of a user-defined class.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket>methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,224],"content":"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method. Typically, the method is invoked by the `callback` delegate.","nodes":[{"content":"The asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.","pos":[0,163],"source":"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method."},{"content":"Typically, the method is invoked by the <ph id=\"ph1\">`callback`</ph> delegate.","pos":[164,224],"source":" Typically, the method is invoked by the `callback` delegate."}]},{"pos":[231,409],"content":"This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.","nodes":[{"content":"This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.","pos":[0,178],"nodes":[{"content":"This method does not block until the operation is complete.","pos":[0,59]},{"content":"To block until the operation is complete, use one of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.","pos":[60,178],"source":" To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads."}]}]},{"pos":[416,544],"content":"To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.","nodes":[{"content":"To cancel a pending <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.","pos":[0,128],"source":"To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method."}]},{"pos":[551,770],"content":"For detailed information about using the asynchronous programming model, see <bpt id=\"p1\">[</bpt>Calling Synchronous Methods Asynchronously<ept id=\"p1\">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.","source":"For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)."},{"pos":[778,1144],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1152,1328],"content":"[!NOTE]\n All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","leadings":["","> "],"nodes":[{"content":" All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[8,174],"nodes":[{"content":"All I/O initiated by a given thread is canceled when that thread exits.","pos":[1,72]},{"content":"A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[73,166]}]}]},{"pos":[1336,1399],"content":"[!NOTE]\n `state` is an instantiation of a user-defined class.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> `state`</ph> is an instantiation of a user-defined class.","pos":[8,61],"source":" `state` is an instantiation of a user-defined class."}]},{"pos":[1407,1632],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[1640,2073],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket>methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket>methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,431],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>methods.","pos":[1,165],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket>methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[166,423],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[130855,132952],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.","nodes":[{"pos":[0,101],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data."}],"pos":[133377,133479],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[133563,133652],"yaml":true},{"content":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.","nodes":[{"pos":[0,90],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketError\"&gt;&lt;/xref&gt;</ph> object that stores the socket error.","source":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error."}],"pos":[133734,133825],"yaml":true},{"content":"An <xref href=\"System.AsyncCallback\"></xref> delegate that references the method to invoke when the operation is complete.","nodes":[{"pos":[0,122],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate that references the method to invoke when the operation is complete.","source":"An <xref href=\"System.AsyncCallback\"></xref> delegate that references the method to invoke when the operation is complete."}],"pos":[133896,134019],"yaml":true},{"content":"A user-defined object that contains information about the receive operation. This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete.","nodes":[{"pos":[0,225],"content":"A user-defined object that contains information about the receive operation. This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete.","nodes":[{"content":"A user-defined object that contains information about the receive operation.","pos":[0,76]},{"content":"This object is passed to the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> delegate when the operation is complete.","pos":[77,225],"source":" This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete."}]}],"pos":[134080,134306],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read.","nodes":[{"pos":[0,82],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous read.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read."}],"pos":[134369,134452],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[134620,134651],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[134765,134821],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,63],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"<xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[134927,134991],"yaml":true},{"content":"Begins to asynchronously receive data from a specified network device.","nodes":[{"pos":[0,70],"content":"Begins to asynchronously receive data from a specified network device.","nodes":[{"content":"Begins to asynchronously receive data from a specified network device.","pos":[0,70]}]}],"pos":[136704,136775],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host. Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.  \n  \n You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter.  \n  \n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \n  \n> [!NOTE]\n>  Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent. For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts. In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer.  \n  \n To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.  \n  \n Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.  \n  \n With connection-oriented sockets, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.  \n  \n To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,284],"content":"The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host. Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host. Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.","pos":[0,284],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method starts asynchronously reading connectionless datagrams from a remote host.","pos":[0,138],"source":"The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host."},{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method gives you the ability to receive data within a separate execution thread.","pos":[139,284],"source":" Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread."}]}]},{"pos":[291,903],"content":"You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter.","nodes":[{"content":"You can create a callback method that implements the <ph id=\"ph1\">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.","pos":[0,175],"source":"You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method."},{"content":"To do this, at the very minimum, your <ph id=\"ph1\">`state`</ph> parameter must contain the connected or default <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.","pos":[176,332],"source":" To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication."},{"content":"If your callback needs more information, you can create a small class to hold the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.","pos":[333,483],"source":" If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information."},{"content":"Pass an instance of this class to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method through the <ph id=\"ph2\">`state`</ph> parameter.","pos":[484,612],"source":" Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter."}]},{"pos":[910,1835],"content":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).","nodes":[{"content":"Your callback method should invoke the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method.","pos":[0,97],"source":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method."},{"content":"When your application calls <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and it will block on <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> until the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> reads data or throws an exception.","pos":[98,409],"source":" When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception."},{"content":"If you want the original thread to block after you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method, use <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph>.","pos":[410,606],"source":" If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>."},{"content":"Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.","pos":[607,747]},{"content":"For additional information on writing callback methods, see <bpt id=\"p1\">[</bpt>Marshaling a Delegate as a Callback Method<ept id=\"p1\">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.","pos":[748,925],"source":" For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)."}]},{"pos":[1843,2175],"content":"[!NOTE]\n Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.","leadings":["","> "],"nodes":[{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, or <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will throw a <ph id=\"ph5\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[9,330],"source":" Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]},{"pos":[2182,3230],"content":"This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent. For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts. In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer.","nodes":[{"content":"This method reads data into the <ph id=\"ph1\">`buffer`</ph> parameter, and captures the remote host endpoint from which the data is sent.","pos":[0,118],"source":"This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent."},{"content":"For information on how to retrieve this endpoint, refer to <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.","pos":[119,229],"source":" For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>."},{"content":"This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.","pos":[230,361]},{"content":"In these cases, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.","pos":[362,508],"source":" In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer."},{"content":"If the datagram you receive is larger than the size of <ph id=\"ph1\">`buffer`</ph>, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method will fill <ph id=\"ph3\">`buffer`</ph> with as much of the message as is possible, and throw a <ph id=\"ph4\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[509,755],"source":" If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are using an unreliable protocol, the excess data will be lost.","pos":[756,826]},{"content":"If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method with a large enough buffer.","pos":[827,1048],"source":" If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer."}]},{"pos":[3237,4131],"content":"To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.","nodes":[{"content":"To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method and then call the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method with the <ph id=\"ph4\">`optionLevel`</ph> parameter set to <ph id=\"ph5\">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph> or <ph id=\"ph6\">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6&gt;</ph> as appropriate, the <ph id=\"ph7\">`optionName`</ph> parameter set to <ph id=\"ph8\">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>, and the <ph id=\"ph9\">`optionValue`</ph> parameter to enable this option before calling the <ph id=\"ph10\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.","pos":[0,677],"source":"To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method."},{"content":"Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.","pos":[678,894],"source":" Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method."}]},{"pos":[4138,5179],"content":"Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.","nodes":[{"content":"Although <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.","pos":[0,155],"source":"Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well."},{"content":"If you choose to do so, you must first either establish a remote host connection by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph><ph id=\"ph2\"> / </ph><ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method or accept an incoming connection request by calling the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.","pos":[156,511],"source":" If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method."},{"content":"If you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method before establishing or accepting a connection, you will get a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[512,692],"source":" If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>."},{"content":"You can also establish a default remote host for a connectionless protocol prior to calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.","pos":[693,849],"source":" You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method."},{"content":"In either of these cases, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method will ignore the <ph id=\"ph2\">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.","pos":[850,1041],"source":" In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host."}]},{"pos":[5186,5372],"content":"With connection-oriented sockets, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will read as much data as is available up to the number of bytes specified by the <ph id=\"ph2\">`size`</ph> parameter.","source":"With connection-oriented sockets, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter."},{"pos":[5379,5511],"content":"To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.","nodes":[{"content":"To cancel a pending <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.","pos":[0,132],"source":"To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method."}]},{"pos":[5519,5885],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[5893,6118],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[6126,6560],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[136786,143375],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.","nodes":[{"pos":[0,101],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data."}],"pos":[144198,144300],"yaml":true},{"content":"The zero-based position in the <code>buffer</code> parameter at which to store the data.","nodes":[{"pos":[0,88],"content":"The zero-based position in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">buffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter at which to store the data.","source":"The zero-based position in the <code>buffer</code> parameter at which to store the data."}],"pos":[144361,144450],"yaml":true},{"content":"The number of bytes to receive.","nodes":[{"pos":[0,31],"content":"The number of bytes to receive.","nodes":[{"content":"The number of bytes to receive.","pos":[0,31]}]}],"pos":[144509,144541],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate.","nodes":[{"pos":[0,55],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate."}],"pos":[144772,144828],"yaml":true},{"content":"An object that contains state information for this request.","nodes":[{"pos":[0,59],"content":"An object that contains state information for this request.","nodes":[{"content":"An object that contains state information for this request.","pos":[0,59]}]}],"pos":[144889,144949],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read.","nodes":[{"pos":[0,82],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous read.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read."}],"pos":[145012,145095],"yaml":true},{"content":"<code>buffer</code> is `null`.  \n  \n -or-  \n  \n <code>remoteEP</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."},{"pos":[37,41],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[48,80],"content":"<ph id=\"ph1\">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>remoteEP</code> is `null`."}],"pos":[145267,145354],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[145468,145524],"yaml":true},{"content":"<code>offset</code> is less than 0.  \n  \n -or-  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n -or-  \n  \n <code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.","source":"<code>offset</code> is less than 0."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,123],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>offset</code> is greater than the length of <code>buffer</code>."},{"pos":[130,134],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[141,174],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[181,185],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[192,313],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id=\"ph3\">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.","source":"<code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter."}],"pos":[145638,145966],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[146072,146140],"yaml":true},{"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"pos":[0,87],"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"content":"A caller higher in the call stack does not have permission for the requested operation.","pos":[0,87]}]}],"pos":[146252,146340],"yaml":true},{"content":"Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint and packet information..","nodes":[{"pos":[0,240],"content":"Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>, and stores the endpoint and packet information..","source":"Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint and packet information.."}],"pos":[148042,148283],"yaml":true},{"content":"The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method. Typically, the method is invoked by the `asyncCallback` delegate.  \n  \n This method does not block until the operation completes. To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.  \n  \n To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.  \n  \n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  \n  \n This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet. For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,199],"content":"The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method. Typically, the method is invoked by the `asyncCallback` delegate.","nodes":[{"content":"The asynchronous receive operation must be completed by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A&gt;</ph> method.","pos":[0,133],"source":"The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method."},{"content":"Typically, the method is invoked by the <ph id=\"ph1\">`asyncCallback`</ph> delegate.","pos":[134,199],"source":" Typically, the method is invoked by the `asyncCallback` delegate."}]},{"pos":[206,374],"content":"This method does not block until the operation completes. To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.","nodes":[{"content":"This method does not block until the operation completes. To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.","pos":[0,168],"nodes":[{"content":"This method does not block until the operation completes.","pos":[0,57]},{"content":"To block until the operation completes, use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.","pos":[58,168],"source":" To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method."}]}]},{"pos":[381,520],"content":"To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.","nodes":[{"content":"To cancel a pending <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A&gt;</ph>, call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.","pos":[0,139],"source":"To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method."}]},{"pos":[527,745],"content":"For detailed information about using the asynchronous programming model, see <bpt id=\"p1\">[</bpt>Calling Synchronous Methods Asynchronously<ept id=\"p1\">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>","source":"For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)"},{"pos":[752,1163],"content":"This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet. For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.","nodes":[{"content":"This method reads data into the <ph id=\"ph1\">`buffer`</ph> parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.","pos":[0,168],"source":"This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet."},{"content":"For information on how to retrieve this endpoint, refer to <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.","pos":[169,279],"source":" For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>."},{"content":"This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.","pos":[280,411]}]},{"pos":[1171,1537],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1545,1770],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[1778,2212],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[148294,150526],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.","nodes":[{"pos":[0,101],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data."}],"pos":[150860,150962],"yaml":true},{"content":"The zero-based position in the <code>buffer</code> parameter at which to store the data.","nodes":[{"pos":[0,88],"content":"The zero-based position in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">buffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter at which to store the data.","source":"The zero-based position in the <code>buffer</code> parameter at which to store the data."}],"pos":[151023,151112],"yaml":true},{"content":"The number of bytes to receive.","nodes":[{"pos":[0,31],"content":"The number of bytes to receive.","nodes":[{"content":"The number of bytes to receive.","pos":[0,31]}]}],"pos":[151171,151203],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[151287,151376],"yaml":true},{"content":"An <xref href=\"System.Net.EndPoint\"></xref> that represents the source of the data.","nodes":[{"pos":[0,83],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph> that represents the source of the data.","source":"An <xref href=\"System.Net.EndPoint\"></xref> that represents the source of the data."}],"pos":[151446,151530],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate.","nodes":[{"pos":[0,55],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate."}],"pos":[151601,151657],"yaml":true},{"content":"An object that contains state information for this request.","nodes":[{"pos":[0,59],"content":"An object that contains state information for this request.","nodes":[{"content":"An object that contains state information for this request.","pos":[0,59]}]}],"pos":[151718,151778],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read.","nodes":[{"pos":[0,82],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous read.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read."}],"pos":[151841,151924],"yaml":true},{"content":"<code>buffer</code> is `null`.  \n  \n -or-  \n  \n <code>remoteEP</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."},{"pos":[37,41],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[48,80],"content":"<ph id=\"ph1\">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>remoteEP</code> is `null`."}],"pos":[152103,152190],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[152304,152360],"yaml":true},{"content":"<code>offset</code> is less than 0.  \n  \n -or-  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n -or-  \n  \n <code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.","source":"<code>offset</code> is less than 0."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,123],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>offset</code> is greater than the length of <code>buffer</code>."},{"pos":[130,134],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[141,174],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[181,185],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[192,313],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id=\"ph3\">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.","source":"<code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter."}],"pos":[152474,152802],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[152908,152976],"yaml":true},{"content":"The operating system is Windows 2000 or earlier, and this method requires Windows XP.","nodes":[{"pos":[0,85],"content":"The operating system is Windows 2000 or earlier, and this method requires Windows XP.","nodes":[{"content":"The operating system is Windows 2000 or earlier, and this method requires Windows XP.","pos":[0,85]}]}],"pos":[153078,153164],"yaml":true},{"content":"Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,88],"content":"Sends data asynchronously to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[154825,154914],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.  \n  \n You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.  \n  \n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \n  \n Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \n  \n> [!NOTE]\n>  `state` is an instantiation of a user-defined class.  \n  \n> [!NOTE]\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,752],"content":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.","pos":[0,752],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.","pos":[0,330],"source":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.","pos":[331,616],"source":" <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>."},{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.","pos":[617,752],"source":" Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread."}]}]},{"pos":[759,1370],"content":"You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.","nodes":[{"content":"You can create a callback method that implements the <ph id=\"ph1\">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.","pos":[0,168],"source":"You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method."},{"content":"To do this, at the very minimum, your <ph id=\"ph1\">`state`</ph> parameter must contain the connected or default <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.","pos":[169,325],"source":" To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication."},{"content":"If your callback needs more information, you can create a small class or structure to hold the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.","pos":[326,489],"source":" If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information."},{"content":"Pass an instance of this class to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id=\"ph2\">`state`</ph> parameter.","pos":[490,611],"source":" Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter."}]},{"pos":[1377,2306],"content":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).","nodes":[{"content":"Your callback method should invoke the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.","pos":[0,90],"source":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method."},{"content":"When your application calls <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.","pos":[91,410],"source":" When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception."},{"content":"If you want the original thread to block after you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph> method.","pos":[411,611],"source":" If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method."},{"content":"Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.","pos":[612,752]},{"content":"For additional information on writing callback methods see <bpt id=\"p1\">[</bpt>Marshaling a Delegate as a Callback Method<ept id=\"p1\">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.","pos":[753,929],"source":" For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)."}]},{"pos":[2313,3487],"content":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.","pos":[0,1174],"nodes":[{"content":"Although intended for connection-oriented protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.","pos":[0,311],"source":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host."},{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.","pos":[312,468],"source":" If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>."},{"content":"It is okay to use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[469,638],"source":" It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"You can also change the default remote host prior to calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.","pos":[639,868],"source":" You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>."},{"content":"With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.","pos":[869,1026]},{"content":"If it does, the datagram will not be sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[1027,1174],"source":" If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]}]},{"pos":[3494,3642],"content":"If you specify the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id=\"ph2\">`socketflags`</ph> parameter, the data you are sending will not be routed.","source":"If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed."},{"pos":[3650,4016],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[4024,4200],"content":"[!NOTE]\n All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","leadings":["","> "],"nodes":[{"content":" All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[8,174],"nodes":[{"content":"All I/O initiated by a given thread is canceled when that thread exits.","pos":[1,72]},{"content":"A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[73,166]}]}]},{"pos":[4208,4271],"content":"[!NOTE]\n `state` is an instantiation of a user-defined class.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> `state`</ph> is an instantiation of a user-defined class.","pos":[8,61],"source":" `state` is an instantiation of a user-defined class."}]},{"pos":[4279,4552],"content":"[!NOTE]\n The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","leadings":["","> "],"nodes":[{"content":" The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[8,271],"nodes":[{"content":"The successful completion of a send does not indicate that the data was successfully delivered.","pos":[1,96]},{"content":"If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[97,263]}]}]},{"pos":[4560,4785],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[4793,5227],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[154925,160181],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to send.","nodes":[{"pos":[0,81],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to send.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to send."}],"pos":[160512,160594],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[160678,160767],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate.","nodes":[{"pos":[0,55],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate."}],"pos":[160838,160894],"yaml":true},{"content":"An object that contains state information for this request.","nodes":[{"pos":[0,59],"content":"An object that contains state information for this request.","nodes":[{"content":"An object that contains state information for this request.","pos":[0,59]}]}],"pos":[160955,161015],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send.","nodes":[{"pos":[0,82],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous send.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send."}],"pos":[161078,161161],"yaml":true},{"content":"<code>buffers</code> is `null`.","nodes":[{"pos":[0,31],"content":"<ph id=\"ph1\">&lt;code&gt;buffers&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffers</code> is `null`."}],"pos":[161326,161358],"yaml":true},{"content":"<code>buffers</code> is empty.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffers&lt;/code&gt;</ph> is empty.","source":"<code>buffers</code> is empty."}],"pos":[161452,161483],"yaml":true},{"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"pos":[0,82],"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"content":"An error occurred when attempting to access the socket. See remarks section below.","pos":[0,82],"nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]},{"content":"See remarks section below.","pos":[56,82]}]}]}],"pos":[161597,161680],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[161786,161854],"yaml":true},{"content":"Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,88],"content":"Sends data asynchronously to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[163610,163699],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.  \n  \n You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.  \n  \n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \n  \n Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \n  \n> [!NOTE]\n>  `state` is an instantiation of a user-defined class.  \n  \n> [!NOTE]\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,752],"content":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.","pos":[0,752],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.","pos":[0,330],"source":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.","pos":[331,616],"source":" <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>."},{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.","pos":[617,752],"source":" Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread."}]}]},{"pos":[759,1370],"content":"You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.","nodes":[{"content":"You can create a callback method that implements the <ph id=\"ph1\">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.","pos":[0,168],"source":"You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method."},{"content":"To do this, at the very minimum, your <ph id=\"ph1\">`state`</ph> parameter must contain the connected or default <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.","pos":[169,325],"source":" To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication."},{"content":"If your callback needs more information, you can create a small class or structure to hold the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.","pos":[326,489],"source":" If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information."},{"content":"Pass an instance of this class to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id=\"ph2\">`state`</ph> parameter.","pos":[490,611],"source":" Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter."}]},{"pos":[1377,2311],"content":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).","nodes":[{"content":"Your callback method should invoke the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.","pos":[0,90],"source":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method."},{"content":"When your application calls <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.","pos":[91,410],"source":" When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception."},{"content":"If you want the original thread to block after you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph> method.","pos":[411,611],"source":" If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method."},{"content":"Call the Set method on a <ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.","pos":[612,757],"source":" Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing."},{"content":"For additional information on writing callback methods see <bpt id=\"p1\">[</bpt>Marshaling a Delegate as a Callback Method<ept id=\"p1\">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.","pos":[758,934],"source":" For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)."}]},{"pos":[2318,3492],"content":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.","pos":[0,1174],"nodes":[{"content":"Although intended for connection-oriented protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.","pos":[0,311],"source":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host."},{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.","pos":[312,468],"source":" If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>."},{"content":"It is okay to use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[469,638],"source":" It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"You can also change the default remote host prior to calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.","pos":[639,868],"source":" You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>."},{"content":"With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.","pos":[869,1026]},{"content":"If it does, the datagram will not be sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[1027,1174],"source":" If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]}]},{"pos":[3499,3647],"content":"If you specify the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id=\"ph2\">`socketflags`</ph> parameter, the data you are sending will not be routed.","source":"If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed."},{"pos":[3655,4021],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[4029,4205],"content":"[!NOTE]\n All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","leadings":["","> "],"nodes":[{"content":" All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[8,174],"nodes":[{"content":"All I/O initiated by a given thread is canceled when that thread exits.","pos":[1,72]},{"content":"A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[73,166]}]}]},{"pos":[4213,4276],"content":"[!NOTE]\n `state` is an instantiation of a user-defined class.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> `state`</ph> is an instantiation of a user-defined class.","pos":[8,61],"source":" `state` is an instantiation of a user-defined class."}]},{"pos":[4284,4557],"content":"[!NOTE]\n The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","leadings":["","> "],"nodes":[{"content":" The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[8,271],"nodes":[{"content":"The successful completion of a send does not indicate that the data was successfully delivered.","pos":[1,96]},{"content":"If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[97,263]}]}]},{"pos":[4565,4790],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[4798,5232],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[163710,168971],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to send.","nodes":[{"pos":[0,81],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to send.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to send."}],"pos":[169393,169475],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[169559,169648],"yaml":true},{"content":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.","nodes":[{"pos":[0,90],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketError\"&gt;&lt;/xref&gt;</ph> object that stores the socket error.","source":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error."}],"pos":[169730,169821],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate.","nodes":[{"pos":[0,55],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate."}],"pos":[169892,169948],"yaml":true},{"content":"An object that contains state information for this request.","nodes":[{"pos":[0,59],"content":"An object that contains state information for this request.","nodes":[{"content":"An object that contains state information for this request.","pos":[0,59]}]}],"pos":[170009,170069],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send.","nodes":[{"pos":[0,82],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous send.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send."}],"pos":[170132,170215],"yaml":true},{"content":"<code>buffers</code> is `null`.","nodes":[{"pos":[0,31],"content":"<ph id=\"ph1\">&lt;code&gt;buffers&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffers</code> is `null`."}],"pos":[170380,170412],"yaml":true},{"content":"<code>buffers</code> is empty.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffers&lt;/code&gt;</ph> is empty.","source":"<code>buffers</code> is empty."}],"pos":[170506,170537],"yaml":true},{"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"pos":[0,82],"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"content":"An error occurred when attempting to access the socket. See remarks section below.","pos":[0,82],"nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]},{"content":"See remarks section below.","pos":[56,82]}]}]}],"pos":[170651,170734],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[170840,170908],"yaml":true},{"content":"Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,88],"content":"Sends data asynchronously to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[172486,172575],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.  \n  \n You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.  \n  \n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \n  \n Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \n  \n> [!NOTE]\n>  `state` is an instantiation of a user-defined class.  \n  \n> [!NOTE]\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,752],"content":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.","pos":[0,752],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.","pos":[0,330],"source":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.","pos":[331,616],"source":" <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>."},{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.","pos":[617,752],"source":" Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread."}]}]},{"pos":[759,1370],"content":"You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.","nodes":[{"content":"You can create a callback method that implements the <ph id=\"ph1\">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.","pos":[0,168],"source":"You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method."},{"content":"To do this, at the very minimum, your <ph id=\"ph1\">`state`</ph> parameter must contain the connected or default <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.","pos":[169,325],"source":" To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication."},{"content":"If your callback needs more information, you can create a small class or structure to hold the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.","pos":[326,489],"source":" If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information."},{"content":"Pass an instance of this class to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id=\"ph2\">`state`</ph> parameter.","pos":[490,611],"source":" Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter."}]},{"pos":[1377,2306],"content":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).","nodes":[{"content":"Your callback method should invoke the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.","pos":[0,90],"source":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method."},{"content":"When your application calls <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.","pos":[91,410],"source":" When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception."},{"content":"If you want the original thread to block after you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph> method.","pos":[411,611],"source":" If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method."},{"content":"Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.","pos":[612,752]},{"content":"For additional information on writing callback methods see <bpt id=\"p1\">[</bpt>Marshaling a Delegate as a Callback Method<ept id=\"p1\">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.","pos":[753,929],"source":" For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)."}]},{"pos":[2313,3487],"content":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.","pos":[0,1174],"nodes":[{"content":"Although intended for connection-oriented protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.","pos":[0,311],"source":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host."},{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.","pos":[312,468],"source":" If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>."},{"content":"It is okay to use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[469,638],"source":" It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"You can also change the default remote host prior to calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.","pos":[639,868],"source":" You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>."},{"content":"With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.","pos":[869,1026]},{"content":"If it does, the datagram will not be sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[1027,1174],"source":" If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]}]},{"pos":[3494,3642],"content":"If you specify the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id=\"ph2\">`socketflags`</ph> parameter, the data you are sending will not be routed.","source":"If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed."},{"pos":[3650,4016],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[4024,4200],"content":"[!NOTE]\n All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","leadings":["","> "],"nodes":[{"content":" All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[8,174],"nodes":[{"content":"All I/O initiated by a given thread is canceled when that thread exits.","pos":[1,72]},{"content":"A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[73,166]}]}]},{"pos":[4208,4271],"content":"[!NOTE]\n `state` is an instantiation of a user-defined class.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> `state`</ph> is an instantiation of a user-defined class.","pos":[8,61],"source":" `state` is an instantiation of a user-defined class."}]},{"pos":[4279,4552],"content":"[!NOTE]\n The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","leadings":["","> "],"nodes":[{"content":" The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[8,271],"nodes":[{"content":"The successful completion of a send does not indicate that the data was successfully delivered.","pos":[1,96]},{"content":"If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[97,263]}]}]},{"pos":[4560,4785],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[4793,5227],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[172586,177842],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to send.","nodes":[{"pos":[0,81],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to send.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to send."}],"pos":[178600,178682],"yaml":true},{"content":"The zero-based position in the <code>buffer</code> parameter at which to begin sending data.","nodes":[{"pos":[0,92],"content":"The zero-based position in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">buffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter at which to begin sending data.","source":"The zero-based position in the <code>buffer</code> parameter at which to begin sending data."}],"pos":[178743,178836],"yaml":true},{"content":"The number of bytes to send.","nodes":[{"pos":[0,28],"content":"The number of bytes to send.","nodes":[{"content":"The number of bytes to send.","pos":[0,28]}]}],"pos":[178895,178924],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate.","nodes":[{"pos":[0,55],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate."}],"pos":[179082,179138],"yaml":true},{"content":"An object that contains state information for this request.","nodes":[{"pos":[0,59],"content":"An object that contains state information for this request.","nodes":[{"content":"An object that contains state information for this request.","pos":[0,59]}]}],"pos":[179199,179259],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send.","nodes":[{"pos":[0,82],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous send.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send."}],"pos":[179322,179405],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[179570,179601],"yaml":true},{"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"pos":[0,82],"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"content":"An error occurred when attempting to access the socket. See remarks section below.","pos":[0,82],"nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]},{"content":"See remarks section below.","pos":[56,82]}]}]}],"pos":[179715,179798],"yaml":true},{"content":"<code>offset</code> is less than 0.  \n  \n -or-  \n  \n <code>offset</code> is less than the length of <code>buffer</code>.  \n  \n -or-  \n  \n <code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.","source":"<code>offset</code> is less than 0."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,120],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>offset</code> is less than the length of <code>buffer</code>."},{"pos":[127,131],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[138,171],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[178,182],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[189,310],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id=\"ph3\">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.","source":"<code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter."}],"pos":[179912,180237],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[180343,180411],"yaml":true},{"content":"Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,88],"content":"Sends data asynchronously to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[182071,182160],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.  \n  \n You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.  \n  \n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \n  \n Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \n  \n> [!NOTE]\n>  `state` is an instantiation of a user-defined class.  \n  \n> [!NOTE]\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,752],"content":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.","pos":[0,752],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.","pos":[0,330],"source":"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.","pos":[331,616],"source":" <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>."},{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.","pos":[617,752],"source":" Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread."}]}]},{"pos":[759,1370],"content":"You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.","nodes":[{"content":"You can create a callback method that implements the <ph id=\"ph1\">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.","pos":[0,168],"source":"You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method."},{"content":"To do this, at the very minimum, your <ph id=\"ph1\">`state`</ph> parameter must contain the connected or default <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.","pos":[169,325],"source":" To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication."},{"content":"If your callback needs more information, you can create a small class or structure to hold the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.","pos":[326,489],"source":" If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information."},{"content":"Pass an instance of this class to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id=\"ph2\">`state`</ph> parameter.","pos":[490,611],"source":" Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter."}]},{"pos":[1377,2306],"content":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).","nodes":[{"content":"Your callback method should invoke the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.","pos":[0,90],"source":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method."},{"content":"When your application calls <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.","pos":[91,410],"source":" When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception."},{"content":"If you want the original thread to block after you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph> method.","pos":[411,611],"source":" If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method."},{"content":"Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.","pos":[612,752]},{"content":"For additional information on writing callback methods see <bpt id=\"p1\">[</bpt>Marshaling a Delegate as a Callback Method<ept id=\"p1\">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.","pos":[753,929],"source":" For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)."}]},{"pos":[2313,3487],"content":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.","pos":[0,1174],"nodes":[{"content":"Although intended for connection-oriented protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.","pos":[0,311],"source":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host."},{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.","pos":[312,468],"source":" If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>."},{"content":"It is okay to use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[469,638],"source":" It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"You can also change the default remote host prior to calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.","pos":[639,868],"source":" You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>."},{"content":"With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.","pos":[869,1026]},{"content":"If it does, the datagram will not be sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[1027,1174],"source":" If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]}]},{"pos":[3494,3642],"content":"If you specify the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id=\"ph2\">`socketflags`</ph> parameter, the data you are sending will not be routed.","source":"If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed."},{"pos":[3650,4016],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[4024,4200],"content":"[!NOTE]\n All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","leadings":["","> "],"nodes":[{"content":" All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[8,174],"nodes":[{"content":"All I/O initiated by a given thread is canceled when that thread exits.","pos":[1,72]},{"content":"A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[73,166]}]}]},{"pos":[4208,4271],"content":"[!NOTE]\n `state` is an instantiation of a user-defined class.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> `state`</ph> is an instantiation of a user-defined class.","pos":[8,61],"source":" `state` is an instantiation of a user-defined class."}]},{"pos":[4279,4552],"content":"[!NOTE]\n The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","leadings":["","> "],"nodes":[{"content":" The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[8,271],"nodes":[{"content":"The successful completion of a send does not indicate that the data was successfully delivered.","pos":[1,96]},{"content":"If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[97,263]}]}]},{"pos":[4560,4785],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[4793,5227],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[182171,187427],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to send.","nodes":[{"pos":[0,81],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to send.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to send."}],"pos":[187725,187807],"yaml":true},{"content":"The zero-based position in the <code>buffer</code> parameter at which to begin sending data.","nodes":[{"pos":[0,92],"content":"The zero-based position in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">buffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter at which to begin sending data.","source":"The zero-based position in the <code>buffer</code> parameter at which to begin sending data."}],"pos":[187868,187961],"yaml":true},{"content":"The number of bytes to send.","nodes":[{"pos":[0,28],"content":"The number of bytes to send.","nodes":[{"content":"The number of bytes to send.","pos":[0,28]}]}],"pos":[188020,188049],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[188133,188222],"yaml":true},{"content":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.","nodes":[{"pos":[0,90],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketError\"&gt;&lt;/xref&gt;</ph> object that stores the socket error.","source":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error."}],"pos":[188304,188395],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate.","nodes":[{"pos":[0,55],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate."}],"pos":[188466,188522],"yaml":true},{"content":"An object that contains state information for this request.","nodes":[{"pos":[0,59],"content":"An object that contains state information for this request.","nodes":[{"content":"An object that contains state information for this request.","pos":[0,59]}]}],"pos":[188583,188643],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send.","nodes":[{"pos":[0,82],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous send.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send."}],"pos":[188706,188789],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[188954,188985],"yaml":true},{"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"pos":[0,82],"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"content":"An error occurred when attempting to access the socket. See remarks section below.","pos":[0,82],"nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]},{"content":"See remarks section below.","pos":[56,82]}]}]}],"pos":[189099,189182],"yaml":true},{"content":"<code>offset</code> is less than 0.  \n  \n -or-  \n  \n <code>offset</code> is less than the length of <code>buffer</code>.  \n  \n -or-  \n  \n <code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.","source":"<code>offset</code> is less than 0."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,120],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>offset</code> is less than the length of <code>buffer</code>."},{"pos":[127,131],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[138,171],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[178,182],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[189,310],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id=\"ph3\">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.","source":"<code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter."}],"pos":[189296,189621],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[189727,189795],"yaml":true},{"content":"Sends the file <code>fileName</code> to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object using the <xref href=\"System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread\"></xref> flag.","nodes":[{"pos":[0,204],"content":"Sends the file <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">fileName</ph><ept id=\"p1\">&lt;/code&gt;</ept> to a connected <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object using the <ph id=\"ph3\">&lt;xref href=\"System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread\"&gt;&lt;/xref&gt;</ph> flag.","source":"Sends the file <code>fileName</code> to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object using the <xref href=\"System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread\"></xref> flag."}],"pos":[191092,191297],"yaml":true},{"content":"This overload sends the file `fileName` to the connected socket. If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards (\"..\\\\\\myfile.txt\") and UNC share names (\"\\\\\\\\\\\\\\shared directory\\\\\\myfile.txt\") are supported. If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.  \n  \n This method uses the `TransmitFile` function found in the Windows Sockets 2 API. For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.  \n  \n The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.  \n  \n To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter. To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication. If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.  \n  \n Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \n  \n Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,419],"content":"This overload sends the file `fileName` to the connected socket. If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards (\"..\\\\\\myfile.txt\") and UNC share names (\"\\\\\\\\\\\\\\shared directory\\\\\\myfile.txt\") are supported. If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.","nodes":[{"content":"This overload sends the file <ph id=\"ph1\">`fileName`</ph> to the connected socket.","pos":[0,64],"source":"This overload sends the file `fileName` to the connected socket."},{"content":"If <ph id=\"ph1\">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.","pos":[65,223],"source":" If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified."},{"content":"Wildcards (\"..<ph id=\"ph1\">\\\\</ph>\\myfile.txt\") and UNC share names (\"<ph id=\"ph2\">\\\\</ph><ph id=\"ph3\">\\\\</ph><ph id=\"ph4\">\\\\</ph>\\shared directory<ph id=\"ph5\">\\\\</ph>\\myfile.txt\") are supported.","pos":[224,329],"source":" Wildcards (\"..\\\\\\myfile.txt\") and UNC share names (\"\\\\\\\\\\\\\\shared directory\\\\\\myfile.txt\") are supported."},{"content":"If the file is not found, the exception <ph id=\"ph1\">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.","pos":[330,419],"source":" If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown."}]},{"pos":[426,635],"content":"This method uses the `TransmitFile` function found in the Windows Sockets 2 API. For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.","nodes":[{"content":"This method uses the <ph id=\"ph1\">`TransmitFile`</ph> function found in the Windows Sockets 2 API.","pos":[0,80],"source":"This method uses the `TransmitFile` function found in the Windows Sockets 2 API."},{"content":"For more information about the <ph id=\"ph1\">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.","pos":[81,209],"source":" For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library."}]},{"pos":[642,1394],"content":"The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.","pos":[0,752],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>,<ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> methods.","pos":[0,334],"source":"The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws an exception if you do not first call <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.","pos":[335,620],"source":" <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>."},{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method enables you to send a file within a separate execution thread.","pos":[621,752],"source":" Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread."}]}]},{"pos":[1401,1965],"content":"To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter. To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication. If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.","nodes":[{"content":"To complete the operation, you can create a callback method that is invoked by the <ph id=\"ph1\">&lt;xref:System.AsyncCallback&gt;</ph> delegate parameter.","pos":[0,130],"source":"To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter."},{"content":"To do this, at the very minimum, the <ph id=\"ph1\">`state`</ph> parameter must contain the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object being used for communication.","pos":[131,272],"source":" To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication."},{"content":"If your callback needs more information, you can create a class or structure to hold the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.","pos":[273,430],"source":" If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information."},{"content":"Pass an instance of this custom object to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method through the <ph id=\"ph2\">`state`</ph> parameter.","pos":[431,564],"source":" Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter."}]},{"pos":[1972,2547],"content":"Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).","nodes":[{"content":"Your callback method must invoke the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method.","pos":[0,92],"source":"Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method."},{"content":"When your application calls <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, the system uses a separate thread to execute the specified callback method, and blocks on <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> until the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the entire file or throws an exception.","pos":[93,398],"source":" When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception."},{"content":"For additional information on writing callback methods see <bpt id=\"p1\">[</bpt>Marshaling a Delegate as a Callback Method<ept id=\"p1\">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.","pos":[399,575],"source":" For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)."}]},{"pos":[2554,3173],"content":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.","nodes":[{"content":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.","pos":[0,619],"nodes":[{"content":"Although intended for connection-oriented protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.","pos":[0,315],"source":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host."},{"content":"With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.","pos":[316,466]},{"content":"If it does, the datagram is not sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.","pos":[467,619],"source":" If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception."}]}]},{"pos":[3181,3557],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,374],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,202],"source":" If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[203,366]}]}]},{"pos":[3565,3790],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[3798,4232],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[191308,195579],"yaml":true,"extradata":"MT"},{"content":"A string that contains the path and name of the file to send. This parameter can be `null`.","nodes":[{"pos":[0,91],"content":"A string that contains the path and name of the file to send. This parameter can be `null`.","nodes":[{"content":"A string that contains the path and name of the file to send.","pos":[0,61]},{"content":"This parameter can be <ph id=\"ph1\">`null`</ph>.","pos":[62,91],"source":" This parameter can be `null`."}]}],"pos":[196343,196435],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate.","nodes":[{"pos":[0,55],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate."}],"pos":[196506,196562],"yaml":true},{"content":"An object that contains state information for this request.","nodes":[{"pos":[0,59],"content":"An object that contains state information for this request.","nodes":[{"content":"An object that contains state information for this request.","pos":[0,59]}]}],"pos":[196623,196683],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> object that represents the asynchronous send.","nodes":[{"pos":[0,89],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> object that represents the asynchronous send.","source":"An <xref href=\"System.IAsyncResult\"></xref> object that represents the asynchronous send."}],"pos":[196746,196836],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed."}],"pos":[197009,197084],"yaml":true},{"content":"The socket is not connected to a remote host.","nodes":[{"pos":[0,45],"content":"The socket is not connected to a remote host.","nodes":[{"content":"The socket is not connected to a remote host.","pos":[0,45]}]}],"pos":[197186,197232],"yaml":true},{"content":"The file <code>fileName</code> was not found.","nodes":[{"pos":[0,45],"content":"The file <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">fileName</ph><ept id=\"p1\">&lt;/code&gt;</ept> was not found.","source":"The file <code>fileName</code> was not found."}],"pos":[197340,197386],"yaml":true},{"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"pos":[0,82],"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"content":"An error occurred when attempting to access the socket. See remarks section below.","pos":[0,82],"nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]},{"content":"See remarks section below.","pos":[56,82]}]}]}],"pos":[197500,197583],"yaml":true},{"content":"Sends a file and buffers of data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object.","nodes":[{"pos":[0,117],"content":"Sends a file and buffers of data asynchronously to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object.","source":"Sends a file and buffers of data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object."}],"pos":[199192,199310],"yaml":true},{"content":"This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values. The `preBuffer` parameter contains any data you want to precede the file. `postBuffer` contains data you want to follow the file. If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards (\"..\\\\\\myfile.txt\") and UNC share names (\"\\\\\\\\\\\\\\shared directory\\\\\\myfile.txt\") are supported. If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.  \n  \n The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer. For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.  \n  \n This method uses the `TransmitFile` function found in the Windows Sockets 2 API. For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.  \n  \n The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.  \n  \n To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter. To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication. If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this custom object to the<xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.  \n  \n Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \n  \n Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,628],"content":"This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values. The `preBuffer` parameter contains any data you want to precede the file. `postBuffer` contains data you want to follow the file. If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards (\"..\\\\\\myfile.txt\") and UNC share names (\"\\\\\\\\\\\\\\shared directory\\\\\\myfile.txt\") are supported. If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.","nodes":[{"content":"This overload requires the name of the file you want to send and a bitwise combination of <ph id=\"ph1\">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> values.","pos":[0,143],"source":"This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values."},{"content":"The <ph id=\"ph1\">`preBuffer`</ph> parameter contains any data you want to precede the file.","pos":[144,217],"source":" The `preBuffer` parameter contains any data you want to precede the file."},{"content":"<ph id=\"ph1\">`postBuffer`</ph> contains data you want to follow the file.","pos":[218,273],"source":"`postBuffer` contains data you want to follow the file."},{"content":"If <ph id=\"ph1\">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.","pos":[274,432],"source":" If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified."},{"content":"Wildcards (\"..<ph id=\"ph1\">\\\\</ph>\\myfile.txt\") and UNC share names (\"<ph id=\"ph2\">\\\\</ph><ph id=\"ph3\">\\\\</ph><ph id=\"ph4\">\\\\</ph>\\shared directory<ph id=\"ph5\">\\\\</ph>\\myfile.txt\") are supported.","pos":[433,538],"source":" Wildcards (\"..\\\\\\myfile.txt\") and UNC share names (\"\\\\\\\\\\\\\\shared directory\\\\\\myfile.txt\") are supported."},{"content":"If the file is not found, the exception <ph id=\"ph1\">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.","pos":[539,628],"source":" If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown."}]},{"pos":[635,859],"content":"The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer. For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.","nodes":[{"content":"The <ph id=\"ph1\">`flags`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.","pos":[0,119],"source":"The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer."},{"content":"For more information about how to use this parameter, see <ph id=\"ph1\">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.","pos":[120,224],"source":" For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>."}]},{"pos":[866,1075],"content":"This method uses the `TransmitFile` function found in the Windows Sockets 2 API. For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.","nodes":[{"content":"This method uses the <ph id=\"ph1\">`TransmitFile`</ph> function found in the Windows Sockets 2 API.","pos":[0,80],"source":"This method uses the `TransmitFile` function found in the Windows Sockets 2 API."},{"content":"For more information about the <ph id=\"ph1\">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.","pos":[81,209],"source":" For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library."}]},{"pos":[1082,1845],"content":"The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.","pos":[0,763],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> methods.","pos":[0,335],"source":"The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws an exception if you do not first call <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.","pos":[336,621],"source":" <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>."},{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method gives you the ability to send a file within a separate execution thread.","pos":[622,763],"source":" Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread."}]}]},{"pos":[1852,2415],"content":"To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter. To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication. If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this custom object to the<xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.","nodes":[{"content":"To complete the operation, you can create a callback method that is invoked by the <ph id=\"ph1\">&lt;xref:System.AsyncCallback&gt;</ph> delegate parameter.","pos":[0,130],"source":"To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter."},{"content":"To do this, at the very minimum, the <ph id=\"ph1\">`state`</ph> parameter must contain the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object being used for communication.","pos":[131,272],"source":" To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication."},{"content":"If your callback needs more information, you can create a class or structure to hold the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.","pos":[273,430],"source":" If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information."},{"content":"Pass an instance of this custom object to the<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method through the <ph id=\"ph2\">`state`</ph> parameter.","pos":[431,563],"source":" Pass an instance of this custom object to the<xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter."}]},{"pos":[2422,2997],"content":"Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).","nodes":[{"content":"Your callback method must invoke the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method.","pos":[0,92],"source":"Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method."},{"content":"When your application calls <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, the system uses a separate thread to execute the specified callback method, and blocks on <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> until the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the entire file or throws an exception.","pos":[93,398],"source":" When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception."},{"content":"For additional information on writing callback methods see <bpt id=\"p1\">[</bpt>Marshaling a Delegate as a Callback Method<ept id=\"p1\">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.","pos":[399,575],"source":" For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)."}]},{"pos":[3004,3628],"content":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.","nodes":[{"content":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.","pos":[0,624],"nodes":[{"content":"Although intended for connection-oriented protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.","pos":[0,315],"source":"Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host."},{"content":"With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.","pos":[316,471]},{"content":"If it does, the datagram is not sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.","pos":[472,624],"source":" If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception."}]}]},{"pos":[3636,4012],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,374],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,202],"source":" If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[203,366]}]}]},{"pos":[4020,4245],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[4253,4687],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[199321,204049],"yaml":true,"extradata":"MT"},{"content":"A string that contains the path and name of the file to be sent. This parameter can be `null`.","nodes":[{"pos":[0,94],"content":"A string that contains the path and name of the file to be sent. This parameter can be `null`.","nodes":[{"content":"A string that contains the path and name of the file to be sent.","pos":[0,64]},{"content":"This parameter can be <ph id=\"ph1\">`null`</ph>.","pos":[65,94],"source":" This parameter can be `null`."}]}],"pos":[205071,205166],"yaml":true},{"content":"A <xref href=\"System.Byte\"></xref> array that contains data to be sent before the file is sent. This parameter can be `null`.","nodes":[{"pos":[0,125],"content":"A <xref href=\"System.Byte\"></xref> array that contains data to be sent before the file is sent. This parameter can be `null`.","nodes":[{"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> array that contains data to be sent before the file is sent.","pos":[0,95],"source":"A <xref href=\"System.Byte\"></xref> array that contains data to be sent before the file is sent."},{"content":"This parameter can be <ph id=\"ph1\">`null`</ph>.","pos":[96,125],"source":" This parameter can be `null`."}]}],"pos":[205231,205357],"yaml":true},{"content":"A <xref href=\"System.Byte\"></xref> array that contains data to be sent after the file is sent. This parameter can be `null`.","nodes":[{"pos":[0,124],"content":"A <xref href=\"System.Byte\"></xref> array that contains data to be sent after the file is sent. This parameter can be `null`.","nodes":[{"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> array that contains data to be sent after the file is sent.","pos":[0,94],"source":"A <xref href=\"System.Byte\"></xref> array that contains data to be sent after the file is sent."},{"content":"This parameter can be <ph id=\"ph1\">`null`</ph>.","pos":[95,124],"source":" This parameter can be `null`."}]}],"pos":[205423,205548],"yaml":true},{"content":"A bitwise combination of <xref href=\"System.Net.Sockets.TransmitFileOptions\"></xref> values.","nodes":[{"pos":[0,92],"content":"A bitwise combination of <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.TransmitFileOptions\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of <xref href=\"System.Net.Sockets.TransmitFileOptions\"></xref> values."}],"pos":[205634,205727],"yaml":true},{"content":"An <xref href=\"System.AsyncCallback\"></xref> delegate to be invoked when this operation completes. This parameter can be `null`.","nodes":[{"pos":[0,128],"content":"An <xref href=\"System.AsyncCallback\"></xref> delegate to be invoked when this operation completes. This parameter can be `null`.","nodes":[{"content":"An <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate to be invoked when this operation completes.","pos":[0,98],"source":"An <xref href=\"System.AsyncCallback\"></xref> delegate to be invoked when this operation completes."},{"content":"This parameter can be <ph id=\"ph1\">`null`</ph>.","pos":[99,128],"source":" This parameter can be `null`."}]}],"pos":[205798,205927],"yaml":true},{"content":"A user-defined object that contains state information for this request. This parameter can be `null`.","nodes":[{"pos":[0,101],"content":"A user-defined object that contains state information for this request. This parameter can be `null`.","nodes":[{"content":"A user-defined object that contains state information for this request.","pos":[0,71]},{"content":"This parameter can be <ph id=\"ph1\">`null`</ph>.","pos":[72,101],"source":" This parameter can be `null`."}]}],"pos":[205988,206090],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> object that represents the asynchronous operation.","nodes":[{"pos":[0,94],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> object that represents the asynchronous operation.","source":"An <xref href=\"System.IAsyncResult\"></xref> object that represents the asynchronous operation."}],"pos":[206153,206248],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed."}],"pos":[206421,206496],"yaml":true},{"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"pos":[0,82],"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"content":"An error occurred when attempting to access the socket. See remarks section below.","pos":[0,82],"nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]},{"content":"See remarks section below.","pos":[56,82]}]}]}],"pos":[206610,206693],"yaml":true},{"content":"The operating system is not Windows NT or later.  \n  \n \\- or -  \n  \n The socket is not connected to a remote host.","nodes":[{"pos":[0,48],"content":"The operating system is not Windows NT or later.","nodes":[{"content":"The operating system is not Windows NT or later.","pos":[0,48]}]},{"pos":[55,62],"content":"\\- or -","nodes":[{"content":"<ph id=\"ph1\">\\-</ph> or -","pos":[0,7],"source":"\\- or -"}]},{"pos":[69,114],"content":"The socket is not connected to a remote host.","nodes":[{"content":"The socket is not connected to a remote host.","pos":[0,45]}]}],"pos":[206795,206917],"yaml":true},{"content":"The file <code>fileName</code> was not found.","nodes":[{"pos":[0,45],"content":"The file <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">fileName</ph><ept id=\"p1\">&lt;/code&gt;</ept> was not found.","source":"The file <code>fileName</code> was not found."}],"pos":[207025,207071],"yaml":true},{"content":"Sends data asynchronously to a specific remote host.","nodes":[{"pos":[0,52],"content":"Sends data asynchronously to a specific remote host.","nodes":[{"content":"Sends data asynchronously to a specific remote host.","pos":[0,52]}]}],"pos":[208698,208751],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter. Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread. Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols.  \n  \n You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter.  \n  \n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \n  \n If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.  \n  \n If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method. In this case, the underlying service provider will assign the most appropriate local network address and port number. Use a port number of zero if you want the underlying service provider to select a free port. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes.  \n  \n If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. -You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","nodes":[{"pos":[0,454],"content":"The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter. Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread. Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method starts an asynchronous send operation to the remote host specified in the <ph id=\"ph2\">`remoteEP`</ph> parameter.","pos":[0,154],"source":"The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter."},{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.","pos":[155,292],"source":" Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread."},{"content":"Although intended for connectionless protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> works with both connectionless and connection-oriented protocols.","pos":[293,454],"source":" Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols."}]},{"pos":[461,1064],"content":"You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter.","nodes":[{"content":"You can create a callback method that implements the <ph id=\"ph1\">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method.","pos":[0,170],"source":"You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method."},{"content":"To do this, at the very minimum, your <ph id=\"ph1\">`state`</ph> parameter must contain the connected or default <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.","pos":[171,327],"source":" To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication."},{"content":"If your callback needs more information, you can create a small class to hold the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and the other required information.","pos":[328,479],"source":" If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information."},{"content":"Pass an instance of this class to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method through the <ph id=\"ph2\">`state`</ph> parameter.","pos":[480,603],"source":" Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter."}]},{"pos":[1071,2011],"content":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).","nodes":[{"content":"Your callback method should invoke the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method.","pos":[0,92],"source":"Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method."},{"content":"When your application calls <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> until the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.","pos":[93,416],"source":" When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception."},{"content":"If you want the original thread to block after you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method, use the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName&gt;</ph> method.","pos":[417,619],"source":" If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method."},{"content":"Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.","pos":[620,760]},{"content":"For additional information about writing callback methods see <bpt id=\"p1\">[</bpt>Marshaling a Delegate as a Callback Method<ept id=\"p1\">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.","pos":[761,940],"source":" For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)."}]},{"pos":[2018,2745],"content":"If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.","nodes":[{"content":"If you are using a connection-oriented protocol, you must first call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> will throw a <ph id=\"ph6\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[0,377],"source":"If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> will ignore the <ph id=\"ph2\">`remoteEP`</ph> parameter and send data to the <ph id=\"ph3\">&lt;xref:System.Net.EndPoint&gt;</ph> established in the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id=\"ph7\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.","pos":[378,727],"source":" <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method."}]},{"pos":[2752,3946],"content":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method. In this case, the underlying service provider will assign the most appropriate local network address and port number. Use a port number of zero if you want the underlying service provider to select a free port. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes.","nodes":[{"content":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method prior to calling <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.","pos":[0,267],"source":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>."},{"content":"You only need to do this if you intend to call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.","pos":[268,372],"source":" You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method."},{"content":"If you do call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method prior to calling <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id=\"ph4\">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.","pos":[373,658],"source":" If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only."},{"content":"You are also not required to call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.","pos":[659,745],"source":" You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method."},{"content":"In this case, the underlying service provider will assign the most appropriate local network address and port number.","pos":[746,863]},{"content":"Use a port number of zero if you want the underlying service provider to select a free port.","pos":[864,956]},{"content":"If you need to identify the assigned local network address and port number, you can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method successfully completes.","pos":[957,1194],"source":" If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes."}]},{"pos":[3953,4458],"content":"If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. -You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. -You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.","pos":[0,505],"nodes":[{"content":"If you want to send data to a broadcast address, you must first call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>.","pos":[0,229],"source":"If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>."},{"content":"-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.","pos":[230,357]},{"content":"If it does, the datagram will not be sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[358,505],"source":" If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]}]},{"pos":[4465,4613],"content":"If you specify the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id=\"ph2\">`socketflags`</ph> parameter, the data you are sending will not be routed.","source":"If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed."},{"pos":[4621,4987],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[4995,5220],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[5228,5662],"content":"[!NOTE]\n The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","leadings":["","> "],"nodes":[{"content":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[8,432],"nodes":[{"content":"The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.","pos":[1,166],"source":" The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods."},{"content":"After the first use of a particular context (a specific asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.","pos":[167,424],"source":" After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement."}]}]}],"pos":[208762,214448],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to send.","nodes":[{"pos":[0,81],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to send.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to send."}],"pos":[215243,215325],"yaml":true},{"content":"The zero-based position in <code>buffer</code> at which to begin sending data.","nodes":[{"pos":[0,78],"content":"The zero-based position in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">buffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> at which to begin sending data.","source":"The zero-based position in <code>buffer</code> at which to begin sending data."}],"pos":[215386,215465],"yaml":true},{"content":"The number of bytes to send.","nodes":[{"pos":[0,28],"content":"The number of bytes to send.","nodes":[{"content":"The number of bytes to send.","pos":[0,28]}]}],"pos":[215524,215553],"yaml":true},{"content":"The <xref href=\"System.AsyncCallback\"></xref> delegate.","nodes":[{"pos":[0,55],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.AsyncCallback\"&gt;&lt;/xref&gt;</ph> delegate.","source":"The <xref href=\"System.AsyncCallback\"></xref> delegate."}],"pos":[215784,215840],"yaml":true},{"content":"An object that contains state information for this request.","nodes":[{"pos":[0,59],"content":"An object that contains state information for this request.","nodes":[{"content":"An object that contains state information for this request.","pos":[0,59]}]}],"pos":[215901,215961],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send.","nodes":[{"pos":[0,82],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that references the asynchronous send.","source":"An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send."}],"pos":[216024,216107],"yaml":true},{"content":"<code>buffer</code> is `null`.  \n  \n -or-  \n  \n <code>remoteEP</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."},{"pos":[37,41],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[48,80],"content":"<ph id=\"ph1\">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>remoteEP</code> is `null`."}],"pos":[216274,216361],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[216475,216531],"yaml":true},{"content":"<code>offset</code> is less than 0.  \n  \n -or-  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n -or-  \n  \n <code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.","source":"<code>offset</code> is less than 0."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,123],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>offset</code> is greater than the length of <code>buffer</code>."},{"pos":[130,134],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[141,174],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[181,185],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[192,313],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id=\"ph3\">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.","source":"<code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter."}],"pos":[216645,216973],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[217079,217147],"yaml":true},{"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"pos":[0,87],"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"content":"A caller higher in the call stack does not have permission for the requested operation.","pos":[0,87]}]}],"pos":[217259,217347],"yaml":true},{"content":"Associates a <xref href=\"System.Net.Sockets.Socket\"></xref> with a local endpoint.","nodes":[{"pos":[0,82],"content":"Associates a <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> with a local endpoint.","source":"Associates a <xref href=\"System.Net.Sockets.Socket\"></xref> with a local endpoint."}],"pos":[218440,218523],"yaml":true},{"content":"Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint. You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method. You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint. You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.  \n  \n Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data. If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=fullName> as the address parameter, and the underlying service provider will assign the most appropriate network address. This might help simplify your application if you have multiple network interfaces. If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number. In this case, the service provider will assign an available port number between 1024 and 5000.  \n  \n If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method. If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.  \n  \n If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method.  \n  \n> [!NOTE]\n>  If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number.  \n  \n> [!NOTE]\n>  You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,536],"content":"Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint. You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method. You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint. You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.","nodes":[{"content":"Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint. You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method. You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint. You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.","pos":[0,536],"nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method if you need to use a specific local endpoint.","pos":[0,101],"source":"Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint."},{"content":"You must call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before you can call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method.","pos":[102,231],"source":" You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method."},{"content":"You do not need to call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before using the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method unless you need to use a specific local endpoint.","pos":[232,414],"source":" You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method on both connectionless and connection-oriented protocols.","pos":[415,536],"source":" You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols."}]}]},{"pos":[543,1276],"content":"Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data. If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=fullName> as the address parameter, and the underlying service provider will assign the most appropriate network address. This might help simplify your application if you have multiple network interfaces. If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number. In this case, the service provider will assign an available port number between 1024 and 5000.","nodes":[{"content":"Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data. If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=fullName> as the address parameter, and the underlying service provider will assign the most appropriate network address. This might help simplify your application if you have multiple network interfaces. If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number. In this case, the service provider will assign an available port number between 1024 and 5000.","pos":[0,733],"nodes":[{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>, you must first create the local <ph id=\"ph2\">&lt;xref:System.Net.IPEndPoint&gt;</ph> from which you intend to communicate data.","pos":[0,160],"source":"Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data."},{"content":"If you do not care which local address is assigned, you can create an <ph id=\"ph1\">&lt;xref:System.Net.IPEndPoint&gt;</ph> using <ph id=\"ph2\">&lt;xref:System.Net.IPAddress.Any?displayProperty=fullName&gt;</ph> as the address parameter, and the underlying service provider will assign the most appropriate network address.","pos":[161,434],"source":" If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=fullName> as the address parameter, and the underlying service provider will assign the most appropriate network address."},{"content":"This might help simplify your application if you have multiple network interfaces.","pos":[435,517]},{"content":"If you do not care which local port is used, you can create an <ph id=\"ph1\">&lt;xref:System.Net.IPEndPoint&gt;</ph> using 0 for the port number.","pos":[518,638],"source":" If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number."},{"content":"In this case, the service provider will assign an available port number between 1024 and 5000.","pos":[639,733]}]}]},{"pos":[1283,1884],"content":"If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method. If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.","nodes":[{"content":"If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method. If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.","pos":[0,601],"nodes":[{"content":"If you use the above approach, you can discover what local network address and port number has been assigned by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>.","pos":[0,174],"source":"If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>."},{"content":"If you are using a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> will not return the locally assigned network address until after you have made a call to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.","pos":[175,468],"source":" If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method."},{"content":"If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.","pos":[469,601]}]}]},{"pos":[1891,2228],"content":"If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method.","nodes":[{"content":"If a UDP socket wants to receive interface information on received packets,  the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method should be explicitly called with the socket option set to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> immediately after calling the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.","pos":[0,337],"source":"If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method."}]},{"pos":[2236,2388],"content":"[!NOTE]\n If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number.","leadings":["","> "],"nodes":[{"content":"If you intend to receive multicast datagrams, you must call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method with a multicast port number.","pos":[9,150],"source":" If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number."}]},{"pos":[2396,2588],"content":"[!NOTE]\n You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.","leadings":["","> "],"nodes":[{"content":"You must call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method if you intend to receive connectionless datagrams using the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.","pos":[9,190],"source":" You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method."}]},{"pos":[2596,3027],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,429],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, use the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,257],"source":" If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[258,421]}]}]},{"pos":[3035,3260],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[218534,221815],"yaml":true,"extradata":"MT"},{"content":"The local <xref href=\"System.Net.EndPoint\"></xref> to associate with the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,120],"content":"The local <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph> to associate with the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"The local <xref href=\"System.Net.EndPoint\"></xref> to associate with the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[222512,222633],"yaml":true},{"content":"<code>localEP</code> is `null`.","nodes":[{"pos":[0,31],"content":"<ph id=\"ph1\">&lt;code&gt;localEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>localEP</code> is `null`."}],"pos":[222793,222825],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[222939,222995],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[223101,223169],"yaml":true},{"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"pos":[0,87],"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"content":"A caller higher in the call stack does not have permission for the requested operation.","pos":[0,87]}]}],"pos":[223281,223369],"yaml":true},{"content":"Gets or sets a value that indicates whether the <xref href=\"System.Net.Sockets.Socket\"></xref> is in blocking mode.","nodes":[{"pos":[0,115],"content":"Gets or sets a value that indicates whether the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is in blocking mode.","source":"Gets or sets a value that indicates whether the <xref href=\"System.Net.Sockets.Socket\"></xref> is in blocking mode."}],"pos":[224579,224695],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode.  \n  \n If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes. If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`. The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods. If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,131],"content":"The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property indicates whether a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is in blocking mode.","pos":[0,131],"source":"The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode."}]},{"pos":[138,708],"content":"If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes. If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`. The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods. If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class.","nodes":[{"content":"If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.","pos":[0,171]},{"content":"If you want execution to continue even though the requested operation is not complete, change the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id=\"ph2\">`false`</ph>.","pos":[172,335],"source":" If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property has no effect on asynchronous methods.","pos":[336,432],"source":" The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods."},{"content":"If you are sending and receiving data asynchronously and want to block execution, use the <ph id=\"ph1\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> class.","pos":[433,570],"source":" If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class."}]},{"pos":[716,1082],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1090,1315],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[224706,226032],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> will block; otherwise, `false`. The default is `true`.","nodes":[{"pos":[0,115],"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> will block; otherwise, `false`. The default is `true`.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> will block; otherwise, <ph id=\"ph3\">`false`</ph>.","pos":[0,92],"source":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> will block; otherwise, `false`."},{"content":"The default is <ph id=\"ph1\">`true`</ph>.","pos":[93,115],"source":" The default is `true`."}]}],"pos":[226148,226266],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[226442,226498],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[226604,226672],"yaml":true},{"content":"Cancels an asynchronous request for a remote host connection.","nodes":[{"pos":[0,61],"content":"Cancels an asynchronous request for a remote host connection.","nodes":[{"content":"Cancels an asynchronous request for a remote host connection.","pos":[0,61]}]}],"pos":[228129,228191],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection.","nodes":[{"pos":[0,127],"content":"The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.CancelConnectAsync%2A&gt;</ph> method cancels an asynchronous request for a remote host connection.","pos":[0,127],"source":"The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection."}]}],"pos":[228202,228330],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object used to request the connection to the remote host by calling one of the <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\"></xref> methods.","nodes":[{"pos":[0,315],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object used to request the connection to the remote host by calling one of the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\"&gt;&lt;/xref&gt;</ph> methods.","source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object used to request the connection to the remote host by calling one of the <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\"></xref> methods."}],"pos":[228535,228851],"yaml":true},{"content":"The <code>e</code> parameter cannot be null and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null.","nodes":[{"pos":[0,143],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter cannot be null and the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"&gt;&lt;/xref&gt;</ph> cannot be null.","source":"The <code>e</code> parameter cannot be null and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null."}],"pos":[229025,229169],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[229283,229339],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[229445,229513],"yaml":true},{"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"pos":[0,87],"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"content":"A caller higher in the call stack does not have permission for the requested operation.","pos":[0,87]}]}],"pos":[229625,229713],"yaml":true},{"content":"Closes the <xref href=\"System.Net.Sockets.Socket\"></xref> connection and releases all associated resources with a specified timeout to allow queued data to be sent.","nodes":[{"pos":[0,164],"content":"Closes the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> connection and releases all associated resources with a specified timeout to allow queued data to be sent.","source":"Closes the <xref href=\"System.Net.Sockets.Socket\"></xref> connection and releases all associated resources with a specified timeout to allow queued data to be sent."}],"pos":[230966,231131],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>. Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.  \n  \n For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>. This ensures that all data is sent and received on the connected socket before it is closed.  \n  \n If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval. <xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires. If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.  \n  \n> [!NOTE]\n>  To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period. Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,281],"content":"The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>. Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method closes the remote host connection and releases all managed and unmanaged resources associated with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,189],"source":"The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>."},{"content":"Upon closing, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is set to <ph id=\"ph2\">`false`</ph>.","pos":[190,281],"source":" Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`."}]},{"pos":[288,550],"content":"For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>. This ensures that all data is sent and received on the connected socket before it is closed.","nodes":[{"content":"For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>. This ensures that all data is sent and received on the connected socket before it is closed.","pos":[0,262],"nodes":[{"content":"For connection-oriented protocols, it is recommended that you call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>.","pos":[0,169],"source":"For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>."},{"content":"This ensures that all data is sent and received on the connected socket before it is closed.","pos":[170,262]}]}]},{"pos":[557,1241],"content":"If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval. <xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires. If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.","nodes":[{"content":"If you need to call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> without first calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can ensure that data queued for outgoing transmission will be sent by setting the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> option to <ph id=\"ph4\">`false`</ph> and specifying a non-zero time-out interval.","pos":[0,332],"source":"If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> will then block until this data is sent or until the specified time-out expires.","pos":[333,455],"source":" <xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires."},{"content":"If you set <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id=\"ph2\">`false`</ph> and specify a zero time-out interval, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.","pos":[456,684],"source":" If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data."}]},{"pos":[1249,1744],"content":"[!NOTE]\n To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period. Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.","leadings":["","> "],"nodes":[{"content":" To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period. Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.","pos":[8,493],"nodes":[{"content":"To set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to <ph id=\"ph2\">`false`</ph>, create a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, set the enabled property to <ph id=\"ph4\">`true`</ph>, and set the <ph id=\"ph5\">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property to the desired time-out period.","pos":[1,282],"source":" To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period."},{"content":"Use this <ph id=\"ph1\">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> along with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to call the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.","pos":[283,485],"source":" Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method."}]}]},{"pos":[1752,1977],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[231142,233132],"yaml":true,"extradata":"MT"},{"content":"Wait up to <code>timeout</code> seconds to send any remaining data, then close the socket.","nodes":[{"pos":[0,90],"content":"Wait up to <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> seconds to send any remaining data, then close the socket.","source":"Wait up to <code>timeout</code> seconds to send any remaining data, then close the socket."}],"pos":[233798,233889],"yaml":true},{"content":"Closes the <xref href=\"System.Net.Sockets.Socket\"></xref> connection and releases all associated resources.","nodes":[{"pos":[0,107],"content":"Closes the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> connection and releases all associated resources.","source":"Closes the <xref href=\"System.Net.Sockets.Socket\"></xref> connection and releases all associated resources."}],"pos":[234963,235071],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>. Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.  \n  \n For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method. This ensures that all data is sent and received on the connected socket before it is closed.  \n  \n If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval. <xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires. If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.  \n  \n> [!NOTE]\n>  To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period. Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,281],"content":"The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>. Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method closes the remote host connection and releases all managed and unmanaged resources associated with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,189],"source":"The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>."},{"content":"Upon closing, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is set to <ph id=\"ph2\">`false`</ph>.","pos":[190,281],"source":" Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`."}]},{"pos":[288,561],"content":"For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method. This ensures that all data is sent and received on the connected socket before it is closed.","nodes":[{"content":"For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method. This ensures that all data is sent and received on the connected socket before it is closed.","pos":[0,273],"nodes":[{"content":"For connection-oriented protocols, it is recommended that you call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.","pos":[0,180],"source":"For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method."},{"content":"This ensures that all data is sent and received on the connected socket before it is closed.","pos":[181,273]}]}]},{"pos":[568,1284],"content":"If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval. <xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires. If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.","nodes":[{"content":"If you need to call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> without first calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can ensure that data queued for outgoing transmission will be sent by setting the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option to <ph id=\"ph5\">`false`</ph> and specifying a non-zero time-out interval.","pos":[0,364],"source":"If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> will then block until this data is sent or until the specified time-out expires.","pos":[365,487],"source":" <xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires."},{"content":"If you set <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id=\"ph2\">`false`</ph> and specify a zero time-out interval, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.","pos":[488,716],"source":" If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data."}]},{"pos":[1292,1787],"content":"[!NOTE]\n To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period. Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.","leadings":["","> "],"nodes":[{"content":" To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period. Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.","pos":[8,493],"nodes":[{"content":"To set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to <ph id=\"ph2\">`false`</ph>, create a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, set the enabled property to <ph id=\"ph4\">`true`</ph>, and set the <ph id=\"ph5\">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property to the desired time out period.","pos":[1,282],"source":" To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period."},{"content":"Use this <ph id=\"ph1\">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> along with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to call the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.","pos":[283,485],"source":" Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method."}]}]},{"pos":[1795,2020],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[235082,237115],"yaml":true,"extradata":"MT"},{"content":"Establishes a connection to a remote host.","nodes":[{"pos":[0,42],"content":"Establishes a connection to a remote host.","nodes":[{"content":"Establishes a connection to a remote host.","pos":[0,42]}]}],"pos":[238865,238908],"yaml":true},{"content":"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.  \n  \n If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully. Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.  \n  \n> [!NOTE]\n>  If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.  \n  \n> [!NOTE]\n>  If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,635],"content":"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.","nodes":[{"content":"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.","pos":[0,635],"nodes":[{"content":"If you are using a connection-oriented protocol such as TCP, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.","pos":[0,255],"source":"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint."},{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.","pos":[256,378],"source":" If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host."},{"content":"After you call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, you can send data to the remote device with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.","pos":[379,635],"source":" After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method."}]}]},{"pos":[642,1818],"content":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[0,1176],"nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not have to call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.","pos":[0,158],"source":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.","pos":[159,314],"source":" You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host."},{"content":"If you do call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.","pos":[315,468],"source":" If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded."},{"content":"If you want to set your default remote host to a broadcast address, you must first call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id=\"ph4\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[469,820],"source":" If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[821,1012],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[1013,1176]}]}]},{"pos":[1825,2996],"content":"The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully. Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id=\"ph3\">`false`</ph> prior to calling <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[0,225],"source":"The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.","pos":[226,456],"source":" If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection."},{"content":"Connectionless protocols will not throw an exception because they simply establish a default remote host.","pos":[457,562]},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> to obtain the specific error code.","pos":[563,689],"source":" You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[690,853]},{"content":"If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.","pos":[854,1036],"source":" If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.","pos":[1037,1171],"source":" Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting."}]},{"pos":[3004,3565],"content":"[!NOTE]\n If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.","leadings":["","> "],"nodes":[{"content":" If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.","pos":[8,559],"nodes":[{"content":"If you are using a connection-oriented protocol and did not call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.","pos":[1,253],"source":" If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number."},{"content":"If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.","pos":[254,422]},{"content":"If you want to change the default remote host, call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.","pos":[423,551],"source":" If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint."}]}]},{"pos":[3573,3838],"content":"[!NOTE]\n If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.","leadings":["","> "],"nodes":[{"content":" If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.","pos":[8,263],"nodes":[{"content":"If the socket has been previously disconnected, then you cannot use this method to restore the connection.","pos":[1,107]},{"content":"Use one of the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.","pos":[108,206],"source":" Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect."},{"content":"This is a limitation of the underlying provider.","pos":[207,255]}]}]},{"pos":[3846,4071],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[238919,243006],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Net.EndPoint\"></xref> that represents the remote device.","nodes":[{"pos":[0,78],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph> that represents the remote device.","source":"An <xref href=\"System.Net.EndPoint\"></xref> that represents the remote device."}],"pos":[243713,243792],"yaml":true},{"content":"<code>remoteEP</code> is `null`.","nodes":[{"pos":[0,32],"content":"<ph id=\"ph1\">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>remoteEP</code> is `null`."}],"pos":[243955,243988],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[244102,244158],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[244264,244332],"yaml":true},{"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"pos":[0,87],"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"content":"A caller higher in the call stack does not have permission for the requested operation.","pos":[0,87]}]}],"pos":[244444,244532],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.","nodes":[{"pos":[0,125],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"&gt;&lt;/xref&gt;</ph>ing.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing."}],"pos":[244642,244768],"yaml":true},{"content":"Establishes a connection to a remote host. The host is specified by an IP address and a port number.","nodes":[{"pos":[0,100],"content":"Establishes a connection to a remote host. The host is specified by an IP address and a port number.","nodes":[{"content":"Establishes a connection to a remote host. The host is specified by an IP address and a port number.","pos":[0,100],"nodes":[{"content":"Establishes a connection to a remote host.","pos":[0,42]},{"content":"The host is specified by an IP address and a port number.","pos":[43,100]}]}]}],"pos":[246129,246230],"yaml":true},{"content":"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.  \n  \n If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully. Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.  \n  \n> [!NOTE]\n>  If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.  \n  \n> [!NOTE]\n>  If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,634],"content":"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.","nodes":[{"content":"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.","pos":[0,634],"nodes":[{"content":"If you are using a connection-oriented protocol such as TCP, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.","pos":[0,255],"source":"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint."},{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.","pos":[256,378],"source":" If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host."},{"content":"After you call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.","pos":[379,634],"source":" After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method."}]}]},{"pos":[641,1816],"content":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[0,1175],"nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not have to call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.","pos":[0,158],"source":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.","pos":[159,314],"source":" You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host."},{"content":"If you do call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.","pos":[315,467],"source":" If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded."},{"content":"If you want to set your default remote host to a broadcast address, you must first call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id=\"ph4\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[468,819],"source":" If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[820,1011],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[1012,1175]}]}]},{"pos":[1823,2990],"content":"<xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully. Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id=\"ph3\">`false`</ph> prior to calling <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[0,221],"source":"<xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.","pos":[222,452],"source":" If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection."},{"content":"Connectionless protocols will not throw an exception because they simply establish a default remote host.","pos":[453,558]},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> to obtain the specific error code.","pos":[559,685],"source":" You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[686,849]},{"content":"If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.","pos":[850,1032],"source":" If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.","pos":[1033,1167],"source":" Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting."}]},{"pos":[2998,3559],"content":"[!NOTE]\n If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.","leadings":["","> "],"nodes":[{"content":" If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.","pos":[8,559],"nodes":[{"content":"If you are using a connection-oriented protocol and did not call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.","pos":[1,253],"source":" If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number."},{"content":"If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.","pos":[254,422]},{"content":"If you want to change the default remote host, call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.","pos":[423,551],"source":" If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint."}]}]},{"pos":[3567,3832],"content":"[!NOTE]\n If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.","leadings":["","> "],"nodes":[{"content":" If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.","pos":[8,263],"nodes":[{"content":"If the socket has been previously disconnected, then you cannot use this method to restore the connection.","pos":[1,107]},{"content":"Use one of the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.","pos":[108,206],"source":" Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect."},{"content":"This is a limitation of the underlying provider.","pos":[207,255]}]}]},{"pos":[3840,4065],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[246241,250322],"yaml":true,"extradata":"MT"},{"content":"The IP address of the remote host.","nodes":[{"pos":[0,34],"content":"The IP address of the remote host.","nodes":[{"content":"The IP address of the remote host.","pos":[0,34]}]}],"pos":[250937,250972],"yaml":true},{"content":"The port number of the remote host.","nodes":[{"pos":[0,35],"content":"The port number of the remote host.","nodes":[{"content":"The port number of the remote host.","pos":[0,35]}]}],"pos":[251031,251067],"yaml":true},{"content":"<code>address</code> is `null`.","nodes":[{"pos":[0,31],"content":"<code>address</code> is `null`.","nodes":[{"content":"is <ph id=\"ph1\">`null`</ph>.","pos":[21,31],"source":" is `null`."}]}],"pos":[251230,251262],"yaml":true},{"content":"The port number is not valid.","nodes":[{"pos":[0,29],"content":"The port number is not valid.","nodes":[{"content":"The port number is not valid.","pos":[0,29]}]}],"pos":[251376,251406],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[251520,251576],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[251682,251750],"yaml":true},{"content":"This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families.","nodes":[{"pos":[0,188],"content":"This method is valid for sockets in the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"&gt;&lt;/xref&gt;</ph> families.","source":"This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families."}],"pos":[251852,252041],"yaml":true},{"content":"The length of <code>address</code> is zero.","nodes":[{"pos":[0,43],"content":"The length of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">address</ph><ept id=\"p1\">&lt;/code&gt;</ept> is zero.","source":"The length of <code>address</code> is zero."}],"pos":[252135,252179],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.","nodes":[{"pos":[0,125],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"&gt;&lt;/xref&gt;</ph>ing.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing."}],"pos":[252289,252415],"yaml":true},{"content":"Establishes a connection to a remote host. The host is specified by an array of IP addresses and a port number.","nodes":[{"pos":[0,111],"content":"Establishes a connection to a remote host. The host is specified by an array of IP addresses and a port number.","nodes":[{"content":"Establishes a connection to a remote host. The host is specified by an array of IP addresses and a port number.","pos":[0,111],"nodes":[{"content":"Establishes a connection to a remote host.","pos":[0,42]},{"content":"The host is specified by an array of IP addresses and a port number.","pos":[43,111]}]}]}],"pos":[253788,253900],"yaml":true},{"content":"This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host. If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.  \n  \n If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully. Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.  \n  \n> [!NOTE]\n>  If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.  \n  \n> [!NOTE]\n>  If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,793],"content":"This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host. If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.","nodes":[{"content":"This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host. If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.","pos":[0,793],"nodes":[{"content":"This method is typically used immediately after a call to <ph id=\"ph1\">&lt;xref:System.Net.Dns.GetHostAddresses%2A&gt;</ph>, which can return multiple IP addresses for a single host.","pos":[0,158],"source":"This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host."},{"content":"If you are using a connection-oriented protocol such as TCP, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.","pos":[159,414],"source":" If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint."},{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.","pos":[415,537],"source":" If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host."},{"content":"After you call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.","pos":[538,793],"source":" After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method."}]}]},{"pos":[800,1975],"content":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[0,1175],"nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not have to call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.","pos":[0,158],"source":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.","pos":[159,314],"source":" You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host."},{"content":"If you do call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.","pos":[315,467],"source":" If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded."},{"content":"If you want to set your default remote host to a broadcast address, you must first call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id=\"ph4\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[468,819],"source":" If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[820,1011],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[1012,1175]}]}]},{"pos":[1982,3149],"content":"<xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully. Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id=\"ph3\">`false`</ph> prior to calling <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[0,221],"source":"<xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.","pos":[222,452],"source":" If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection."},{"content":"Connectionless protocols will not throw an exception because they simply establish a default remote host.","pos":[453,558]},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> to obtain the specific error code.","pos":[559,685],"source":" You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[686,849]},{"content":"If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.","pos":[850,1032],"source":" If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.","pos":[1033,1167],"source":" Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting."}]},{"pos":[3157,3718],"content":"[!NOTE]\n If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.","leadings":["","> "],"nodes":[{"content":" If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.","pos":[8,559],"nodes":[{"content":"If you are using a connection-oriented protocol and did not call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.","pos":[1,253],"source":" If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number."},{"content":"If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.","pos":[254,422]},{"content":"If you want to change the default remote host, call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.","pos":[423,551],"source":" If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint."}]}]},{"pos":[3726,3991],"content":"[!NOTE]\n If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.","leadings":["","> "],"nodes":[{"content":" If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.","pos":[8,263],"nodes":[{"content":"If the socket has been previously disconnected, then you cannot use this method to restore the connection.","pos":[1,107]},{"content":"Use one of the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.","pos":[108,206],"source":" Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect."},{"content":"This is a limitation of the underlying provider.","pos":[207,255]}]}]},{"pos":[3999,4224],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[253911,258151],"yaml":true,"extradata":"MT"},{"content":"The IP addresses of the remote host.","nodes":[{"pos":[0,36],"content":"The IP addresses of the remote host.","nodes":[{"content":"The IP addresses of the remote host.","pos":[0,36]}]}],"pos":[258774,258811],"yaml":true},{"content":"The port number of the remote host.","nodes":[{"pos":[0,35],"content":"The port number of the remote host.","nodes":[{"content":"The port number of the remote host.","pos":[0,35]}]}],"pos":[258870,258906],"yaml":true},{"content":"<code>addresses</code> is `null`.","nodes":[{"pos":[0,33],"content":"<ph id=\"ph1\">&lt;code&gt;addresses&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>addresses</code> is `null`."}],"pos":[259069,259103],"yaml":true},{"content":"The port number is not valid.","nodes":[{"pos":[0,29],"content":"The port number is not valid.","nodes":[{"content":"The port number is not valid.","pos":[0,29]}]}],"pos":[259217,259247],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[259361,259417],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[259523,259591],"yaml":true},{"content":"This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families.","nodes":[{"pos":[0,188],"content":"This method is valid for sockets in the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"&gt;&lt;/xref&gt;</ph> families.","source":"This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families."}],"pos":[259693,259882],"yaml":true},{"content":"The length of <code>address</code> is zero.","nodes":[{"pos":[0,43],"content":"The length of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">address</ph><ept id=\"p1\">&lt;/code&gt;</ept> is zero.","source":"The length of <code>address</code> is zero."}],"pos":[259976,260020],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.","nodes":[{"pos":[0,125],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"&gt;&lt;/xref&gt;</ph>ing.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing."}],"pos":[260130,260256],"yaml":true},{"content":"Establishes a connection to a remote host. The host is specified by a host name and a port number.","nodes":[{"pos":[0,98],"content":"Establishes a connection to a remote host. The host is specified by a host name and a port number.","nodes":[{"content":"Establishes a connection to a remote host. The host is specified by a host name and a port number.","pos":[0,98],"nodes":[{"content":"Establishes a connection to a remote host.","pos":[0,42]},{"content":"The host is specified by a host name and a port number.","pos":[43,98]}]}]}],"pos":[261587,261686],"yaml":true},{"content":"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.  \n  \n If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully. Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.  \n  \n If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address. This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.  \n  \n> [!NOTE]\n>  If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.  \n  \n> [!NOTE]\n>  If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,630],"content":"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.","nodes":[{"content":"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.","pos":[0,630],"nodes":[{"content":"If you are using a connection-oriented protocol such as TCP, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote host.","pos":[0,251],"source":"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host."},{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.","pos":[252,374],"source":" If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host."},{"content":"After you call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.","pos":[375,630],"source":" After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method."}]}]},{"pos":[637,1812],"content":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[0,1175],"nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not have to call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.","pos":[0,158],"source":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.","pos":[159,314],"source":" You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host."},{"content":"If you do call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.","pos":[315,467],"source":" If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded."},{"content":"If you want to set your default remote host to a broadcast address, you must first call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id=\"ph4\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[468,819],"source":" If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[820,1011],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[1012,1175]}]}]},{"pos":[1819,2986],"content":"<xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully. Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id=\"ph3\">`false`</ph> prior to calling <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[0,221],"source":"<xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.","pos":[222,452],"source":" If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection."},{"content":"Connectionless protocols will not throw an exception because they simply establish a default remote host.","pos":[453,558]},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> to obtain the specific error code.","pos":[559,685],"source":" You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[686,849]},{"content":"If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.","pos":[850,1032],"source":" If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.","pos":[1033,1167],"source":" Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting."}]},{"pos":[2993,3387],"content":"If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address. This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.","nodes":[{"content":"If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address. This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.","pos":[0,394],"nodes":[{"content":"If IPv6 is enabled and the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29&gt;</ph> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.","pos":[0,270],"source":"If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address."},{"content":"This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.","pos":[271,394]}]}]},{"pos":[3395,3956],"content":"[!NOTE]\n If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.","leadings":["","> "],"nodes":[{"content":" If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.","pos":[8,559],"nodes":[{"content":"If you are using a connection-oriented protocol and did not call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.","pos":[1,253],"source":" If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number."},{"content":"If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.","pos":[254,422]},{"content":"If you want to change the default remote host, call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.","pos":[423,551],"source":" If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint."}]}]},{"pos":[3964,4229],"content":"[!NOTE]\n If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.","leadings":["","> "],"nodes":[{"content":" If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.","pos":[8,263],"nodes":[{"content":"If the socket has been previously disconnected, then you cannot use this method to restore the connection.","pos":[1,107]},{"content":"Use one of the asynchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.","pos":[108,206],"source":" Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect."},{"content":"This is a limitation of the underlying provider.","pos":[207,255]}]}]},{"pos":[4237,4462],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[261697,266177],"yaml":true,"extradata":"MT"},{"content":"The name of the remote host.","nodes":[{"pos":[0,28],"content":"The name of the remote host.","nodes":[{"content":"The name of the remote host.","pos":[0,28]}]}],"pos":[266765,266794],"yaml":true},{"content":"The port number of the remote host.","nodes":[{"pos":[0,35],"content":"The port number of the remote host.","nodes":[{"content":"The port number of the remote host.","pos":[0,35]}]}],"pos":[266853,266889],"yaml":true},{"content":"<code>host</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;host&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>host</code> is `null`."}],"pos":[267052,267081],"yaml":true},{"content":"The port number is not valid.","nodes":[{"pos":[0,29],"content":"The port number is not valid.","nodes":[{"content":"The port number is not valid.","pos":[0,29]}]}],"pos":[267195,267225],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[267339,267395],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[267501,267569],"yaml":true},{"content":"This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families.","nodes":[{"pos":[0,188],"content":"This method is valid for sockets in the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"&gt;&lt;/xref&gt;</ph> families.","source":"This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families."}],"pos":[267671,267860],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.","nodes":[{"pos":[0,125],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"&gt;&lt;/xref&gt;</ph>ing.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing."}],"pos":[267970,268096],"yaml":true},{"content":"Begins an asynchronous request for a connection to a remote host.","nodes":[{"pos":[0,65],"content":"Begins an asynchronous request for a connection to a remote host.","nodes":[{"content":"Begins an asynchronous request for a connection to a remote host.","pos":[0,65]}]}],"pos":[269517,269583],"yaml":true},{"content":"If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.  \n  \n To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.  \n  \n The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.  \n  \n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \n  \n If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.  \n  \n If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`. If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required:  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  \n  \n Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds. In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the number of bytes of data to send from the buffer. Once a connection is established, this buffer of data is sent.  \n  \n If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.  \n  \n If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.  \n  \n The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> are not the same address family.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","nodes":[{"pos":[0,304],"content":"If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.","nodes":[{"content":"If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.","pos":[0,304],"nodes":[{"content":"If you are using a connection-oriented protocol, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method starts an asynchronous request for a connection to the remote host.","pos":[0,176],"source":"If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host."},{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> establishes a default remote host.","pos":[177,304],"source":" If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host."}]}]},{"pos":[311,559],"content":"To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.","nodes":[{"content":"To be notified of completion, you must create a callback method that implements the EventHandler<ph id=\"ph1\">\\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName&gt;</ph> event.","pos":[0,248],"source":"To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event."}]},{"pos":[566,758],"content":"The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.","nodes":[{"content":"The caller must set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> property to the <ph id=\"ph2\">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host to connect to.","pos":[0,192],"source":"The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to."}]},{"pos":[765,1205],"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","nodes":[{"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[0,440],"nodes":[{"content":"The caller may set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.","pos":[0,293],"source":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method."},{"content":"If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[294,440]}]}]},{"pos":[1212,1831],"content":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.","nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.","pos":[0,619],"nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not have to call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> before sending and receiving data.","pos":[0,163],"source":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> to communicate with a remote host.","pos":[164,315],"source":" You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host."},{"content":"If you do call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.","pos":[316,474],"source":" If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded."},{"content":"If you want to change the default remote host, call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method again with the desired endpoint.","pos":[475,619],"source":" If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint."}]}]},{"pos":[1838,2142],"content":"If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`. If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"If you wish to set the default remote host to a broadcast address, you must first call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id=\"ph2\">`true`</ph>.","pos":[0,167],"source":"If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`."},{"content":"If this is not done, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[168,304],"source":" If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>."}]},{"pos":[2149,2284],"content":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required:","nodes":[{"content":"The following properties and events on the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required:","pos":[0,135],"source":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required:"}]},{"pos":[2294,2375],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>","nodes":[]},{"pos":[2385,2474],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>","nodes":[]},{"pos":[2481,3037],"content":"Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds. In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the number of bytes of data to send from the buffer. Once a connection is established, this buffer of data is sent.","nodes":[{"content":"Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds. In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the number of bytes of data to send from the buffer. Once a connection is established, this buffer of data is sent.","pos":[0,556],"nodes":[{"content":"Optionally, a buffer may be provided which will atomically be sent on the socket after the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.","pos":[0,156],"source":"Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds."},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> property needs to be set to the buffer containing the data to send and the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> property needs to be set to the number of bytes of data to send from the buffer.","pos":[157,493],"source":" In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the number of bytes of data to send from the buffer."},{"content":"Once a connection is established, this buffer of data is sent.","pos":[494,556]}]}]},{"pos":[3044,3317],"content":"If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.","nodes":[{"content":"If you are using a connection-oriented protocol and do not call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.","pos":[0,273],"source":"If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number."}]},{"pos":[3324,3573],"content":"If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.","nodes":[{"content":"If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> methods.","pos":[0,249],"source":"If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods."}]},{"pos":[3580,3875],"content":"The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> are not the same address family.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method throws <ph id=\"ph2\">&lt;xref:System.NotSupportedException&gt;</ph> if the address family of the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> are not the same address family.","pos":[0,295],"source":"The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> are not the same address family."}]},{"pos":[3883,4274],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,389],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling this method, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,217],"source":" If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[218,381]}]}]}],"pos":[269594,273899],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.","source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation."}],"pos":[274091,274210],"yaml":true},{"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \n  \n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"pos":[0,209],"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`true`</ph> if the I/O operation is pending.","pos":[0,47],"source":"Returns `true` if the I/O operation is pending."},{"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.","pos":[48,209],"source":" The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation."}]},{"pos":[216,574],"content":"Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`false`</ph> if the I/O operation completed synchronously.","pos":[0,61],"source":"Returns `false` if the I/O operation completed synchronously."},{"content":"In this case, The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">e</ph><ept id=\"p2\">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","pos":[62,358],"source":" In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation."}]}],"pos":[274268,274851],"yaml":true},{"content":"An argument is not valid. This exception occurs if multiple buffers are specified, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> property is not null.","nodes":[{"pos":[0,180],"content":"An argument is not valid. This exception occurs if multiple buffers are specified, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> property is not null.","nodes":[{"content":"An argument is not valid.","pos":[0,25]},{"content":"This exception occurs if multiple buffers are specified, the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"&gt;&lt;/xref&gt;</ph> property is not null.","pos":[26,180],"source":" This exception occurs if multiple buffers are specified, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> property is not null."}]}],"pos":[275011,275192],"yaml":true},{"content":"The <code>e</code> parameter cannot be null and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null.","nodes":[{"pos":[0,143],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter cannot be null and the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"&gt;&lt;/xref&gt;</ph> cannot be null.","source":"The <code>e</code> parameter cannot be null and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null."}],"pos":[275294,275438],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is listening or a socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.","nodes":[{"pos":[0,230],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is listening or a socket operation was already in progress using the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph3\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is listening or a socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter."}],"pos":[275548,275779],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[275893,275949],"yaml":true},{"content":"Windows XP or later is required for this method. This exception also occurs if the local endpoint and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> are not the same address family.","nodes":[{"pos":[0,214],"content":"Windows XP or later is required for this method. This exception also occurs if the local endpoint and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> are not the same address family.","nodes":[{"content":"Windows XP or later is required for this method.","pos":[0,48]},{"content":"This exception also occurs if the local endpoint and the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"&gt;&lt;/xref&gt;</ph> are not the same address family.","pos":[49,214],"source":" This exception also occurs if the local endpoint and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> are not the same address family."}]}],"pos":[276051,276266],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[276372,276440],"yaml":true},{"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"pos":[0,87],"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"content":"A caller higher in the call stack does not have permission for the requested operation.","pos":[0,87]}]}],"pos":[276552,276640],"yaml":true},{"content":"Begins an asynchronous request for a connection to a remote host.","nodes":[{"pos":[0,65],"content":"Begins an asynchronous request for a connection to a remote host.","nodes":[{"content":"Begins an asynchronous request for a connection to a remote host.","pos":[0,65]}]}],"pos":[278325,278391],"yaml":true},{"content":"If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters.  \n  \n To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.  \n  \n The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.  \n  \n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \n  \n If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.  \n  \n If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`. If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required:  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  \n  \n Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds. In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the number of bytes of data to send from the buffer. Once a connection is established, this buffer of data is sent.  \n  \n If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.  \n  \n If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.  \n  \n The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> are not the same address family.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","nodes":[{"pos":[0,459],"content":"If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters.","nodes":[{"content":"If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.","pos":[0,271]},{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> establishes a default remote host specified by the <ph id=\"ph2\">`socketType`</ph> and <ph id=\"ph3\">`protocolType`</ph> parameters.","pos":[272,459],"source":" If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters."}]},{"pos":[466,714],"content":"To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.","nodes":[{"content":"To be notified of completion, you must create a callback method that implements the EventHandler<ph id=\"ph1\">\\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName&gt;</ph> event.","pos":[0,248],"source":"To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event."}]},{"pos":[721,913],"content":"The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.","nodes":[{"content":"The caller must set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> property to the <ph id=\"ph2\">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host to connect to.","pos":[0,192],"source":"The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to."}]},{"pos":[920,1360],"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","nodes":[{"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[0,440],"nodes":[{"content":"The caller may set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.","pos":[0,293],"source":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method."},{"content":"If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[294,440]}]}]},{"pos":[1367,1986],"content":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.","nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.","pos":[0,619],"nodes":[{"content":"If you are using a connectionless protocol such as UDP, you do not have to call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> before sending and receiving data.","pos":[0,163],"source":"If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> to communicate with a remote host.","pos":[164,315],"source":" You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host."},{"content":"If you do call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.","pos":[316,474],"source":" If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded."},{"content":"If you want to change the default remote host, call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method again with the desired endpoint.","pos":[475,619],"source":" If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint."}]}]},{"pos":[1993,2297],"content":"If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`. If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"If you wish to set the default remote host to a broadcast address, you must first call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id=\"ph2\">`true`</ph>.","pos":[0,167],"source":"If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`."},{"content":"If this is not done, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[168,304],"source":" If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>."}]},{"pos":[2304,2439],"content":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required:","nodes":[{"content":"The following properties and events on the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required:","pos":[0,135],"source":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required:"}]},{"pos":[2449,2530],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>","nodes":[]},{"pos":[2540,2629],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>","nodes":[]},{"pos":[2636,3192],"content":"Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds. In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the number of bytes of data to send from the buffer. Once a connection is established, this buffer of data is sent.","nodes":[{"content":"Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds. In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the number of bytes of data to send from the buffer. Once a connection is established, this buffer of data is sent.","pos":[0,556],"nodes":[{"content":"Optionally, a buffer may be provided which will atomically be sent on the socket after the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.","pos":[0,156],"source":"Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds."},{"content":"In this case, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> property needs to be set to the buffer containing the data to send and the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> property needs to be set to the number of bytes of data to send from the buffer.","pos":[157,493],"source":" In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the number of bytes of data to send from the buffer."},{"content":"Once a connection is established, this buffer of data is sent.","pos":[494,556]}]}]},{"pos":[3199,3472],"content":"If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.","nodes":[{"content":"If you are using a connection-oriented protocol and do not call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.","pos":[0,273],"source":"If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number."}]},{"pos":[3479,3728],"content":"If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.","nodes":[{"content":"If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> methods.","pos":[0,249],"source":"If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods."}]},{"pos":[3735,4030],"content":"The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> are not the same address family.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method throws <ph id=\"ph2\">&lt;xref:System.NotSupportedException&gt;</ph> if the address family of the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> are not the same address family.","pos":[0,295],"source":"The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> are not the same address family."}]},{"pos":[4038,4429],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,389],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling this method, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,217],"source":" If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[218,381]}]}]}],"pos":[278402,282862],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Net.Sockets.SocketType\"></xref> values.","nodes":[{"pos":[0,69],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketType\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketType\"></xref> values."}],"pos":[283148,283218],"yaml":true},{"content":"One of the <xref href=\"System.Net.Sockets.ProtocolType\"></xref> values.","nodes":[{"pos":[0,71],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.ProtocolType\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.ProtocolType\"></xref> values."}],"pos":[283304,283376],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.","source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation."}],"pos":[283459,283578],"yaml":true},{"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \n  \n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"pos":[0,209],"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`true`</ph> if the I/O operation is pending.","pos":[0,47],"source":"Returns `true` if the I/O operation is pending."},{"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.","pos":[48,209],"source":" The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation."}]},{"pos":[216,574],"content":"Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`false`</ph> if the I/O operation completed synchronously.","pos":[0,61],"source":"Returns `false` if the I/O operation completed synchronously."},{"content":"In this case, The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">e</ph><ept id=\"p2\">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","pos":[62,358],"source":" In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation."}]}],"pos":[283636,284219],"yaml":true},{"content":"An argument is not valid. This exception occurs if multiple buffers are specified, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> property is not null.","nodes":[{"pos":[0,180],"content":"An argument is not valid. This exception occurs if multiple buffers are specified, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> property is not null.","nodes":[{"content":"An argument is not valid.","pos":[0,25]},{"content":"This exception occurs if multiple buffers are specified, the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"&gt;&lt;/xref&gt;</ph> property is not null.","pos":[26,180],"source":" This exception occurs if multiple buffers are specified, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> property is not null."}]}],"pos":[284379,284560],"yaml":true},{"content":"The <code>e</code> parameter cannot be null and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null.","nodes":[{"pos":[0,143],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter cannot be null and the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"&gt;&lt;/xref&gt;</ph> cannot be null.","source":"The <code>e</code> parameter cannot be null and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null."}],"pos":[284662,284806],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is listening or a socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.","nodes":[{"pos":[0,230],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is listening or a socket operation was already in progress using the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph3\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is listening or a socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter."}],"pos":[284916,285147],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[285261,285317],"yaml":true},{"content":"Windows XP or later is required for this method. This exception also occurs if the local endpoint and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> are not the same address family.","nodes":[{"pos":[0,214],"content":"Windows XP or later is required for this method. This exception also occurs if the local endpoint and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> are not the same address family.","nodes":[{"content":"Windows XP or later is required for this method.","pos":[0,48]},{"content":"This exception also occurs if the local endpoint and the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"&gt;&lt;/xref&gt;</ph> are not the same address family.","pos":[49,214],"source":" This exception also occurs if the local endpoint and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> are not the same address family."}]}],"pos":[285419,285634],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[285740,285808],"yaml":true},{"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"pos":[0,87],"content":"A caller higher in the call stack does not have permission for the requested operation.","nodes":[{"content":"A caller higher in the call stack does not have permission for the requested operation.","pos":[0,87]}]}],"pos":[285920,286008],"yaml":true},{"content":"Gets a value that indicates whether a <xref href=\"System.Net.Sockets.Socket\"></xref> is connected to a remote host as of the last <xref href=\"System.Net.Sockets.Socket.Send*\"></xref> or <xref href=\"System.Net.Sockets.Socket.Receive*\"></xref> operation.","nodes":[{"pos":[0,252],"content":"Gets a value that indicates whether a <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is connected to a remote host as of the last <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Send*\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph3\">&lt;xref href=\"System.Net.Sockets.Socket.Receive*\"&gt;&lt;/xref&gt;</ph> operation.","source":"Gets a value that indicates whether a <xref href=\"System.Net.Sockets.Socket\"></xref> is connected to a remote host as of the last <xref href=\"System.Net.Sockets.Socket.Send*\"></xref> or <xref href=\"System.Net.Sockets.Socket.Receive*\"></xref> operation."}],"pos":[287224,287477],"yaml":true},{"content":"The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation. When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected.  \n  \n The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation. If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call. If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.  \n  \n If you call <xref:System.Net.Sockets.Socket.Connect%2A> on a User Datagram Protocol (UDP) socket, the <xref:System.Net.Sockets.Socket.Connected%2A> property always returns `true`; however, this action does not change the inherent connectionless nature of UDP.","nodes":[{"pos":[0,237],"content":"The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation. When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected.","nodes":[{"content":"The <ph id=\"ph1\">`Connected`</ph> property gets the connection state of the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> as of the last I/O operation.","pos":[0,120],"source":"The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation."},{"content":"When it returns <ph id=\"ph1\">`false`</ph>, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> was either never connected, or is no longer connected.","pos":[121,237],"source":" When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected."}]},{"pos":[244,649],"content":"The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation. If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call. If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.","nodes":[{"content":"The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation. If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call. If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.","pos":[0,405],"nodes":[{"content":"The value of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property reflects the state of the connection as of the most recent operation.","pos":[0,141],"source":"The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation."},{"content":"If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.","pos":[142,244]},{"content":"If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.","pos":[245,405]}]}]},{"pos":[656,915],"content":"If you call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> on a User Datagram Protocol (UDP) socket, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property always returns <ph id=\"ph3\">`true`</ph>; however, this action does not change the inherent connectionless nature of UDP.","source":"If you call <xref:System.Net.Sockets.Socket.Connect%2A> on a User Datagram Protocol (UDP) socket, the <xref:System.Net.Sockets.Socket.Connected%2A> property always returns `true`; however, this action does not change the inherent connectionless nature of UDP."}],"pos":[287488,288410],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> was connected to a remote resource as of the most recent operation; otherwise, `false`.","nodes":[{"pos":[0,148],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> was connected to a remote resource as of the most recent operation; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> was connected to a remote resource as of the most recent operation; otherwise, `false`."}],"pos":[289150,289301],"yaml":true},{"content":"Closes the socket connection and allows reuse of the socket.","nodes":[{"pos":[0,60],"content":"Closes the socket connection and allows reuse of the socket.","nodes":[{"content":"Closes the socket connection and allows reuse of the socket.","pos":[0,60]}]}],"pos":[290662,290723],"yaml":true},{"content":"If you are using a connection-oriented protocol, you can use this method to close the socket. This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`. However, if `reuseSocket` is `true`, you can reuse the socket.  \n  \n To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method.  \n  \n If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent. <xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires. If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,268],"content":"If you are using a connection-oriented protocol, you can use this method to close the socket. This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`. However, if `reuseSocket` is `true`, you can reuse the socket.","nodes":[{"content":"If you are using a connection-oriented protocol, you can use this method to close the socket.","pos":[0,93]},{"content":"This method ends the connection and sets the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property to <ph id=\"ph2\">`false`</ph>.","pos":[94,205],"source":" This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`."},{"content":"However, if <ph id=\"ph1\">`reuseSocket`</ph> is <ph id=\"ph2\">`true`</ph>, you can reuse the socket.","pos":[206,268],"source":" However, if `reuseSocket` is `true`, you can reuse the socket."}]},{"pos":[275,483],"content":"To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method.","nodes":[{"content":"To ensure that all data is sent and received before the socket is closed, you should call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> method.","pos":[0,208],"source":"To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method."}]},{"pos":[490,1198],"content":"If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent. <xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires. If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.","nodes":[{"content":"If you need to call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> without first calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can set the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option to <ph id=\"ph5\">`false`</ph> and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.","pos":[0,356],"source":"If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> then blocks until the data is sent or until the specified time-out expires.","pos":[357,479],"source":" <xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires."},{"content":"If you set <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id=\"ph2\">`false`</ph> and specify a zero time-out interval, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.","pos":[480,708],"source":" If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data."}]},{"pos":[1206,1572],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1580,1805],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[290734,292552],"yaml":true,"extradata":"MT"},{"content":"`true` if this socket can be reused after the current connection is closed; otherwise, `false`.","nodes":[{"pos":[0,95],"content":"<ph id=\"ph1\">`true`</ph> if this socket can be reused after the current connection is closed; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if this socket can be reused after the current connection is closed; otherwise, `false`."}],"pos":[293304,293402],"yaml":true},{"content":"This method requires Windows 2000 or earlier, or the exception will be thrown.","nodes":[{"pos":[0,78],"content":"This method requires Windows 2000 or earlier, or the exception will be thrown.","nodes":[{"content":"This method requires Windows 2000 or earlier, or the exception will be thrown.","pos":[0,78]}]}],"pos":[293584,293663],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed."}],"pos":[293769,293844],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[293958,294014],"yaml":true},{"content":"Begins an asynchronous request to disconnect from a remote endpoint.","nodes":[{"pos":[0,68],"content":"Begins an asynchronous request to disconnect from a remote endpoint.","nodes":[{"content":"Begins an asynchronous request to disconnect from a remote endpoint.","pos":[0,68]}]}],"pos":[295269,295338],"yaml":true},{"content":"When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint. If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=fullName> to `true` in the `e` parameter, the socket can be reused.","nodes":[{"pos":[0,325],"content":"When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint. If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=fullName> to `true` in the `e` parameter, the socket can be reused.","nodes":[{"content":"When using a connection-oriented protocol, calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.DisconnectAsync%2A&gt;</ph> method requests a disconnect from a remote endpoint.","pos":[0,159],"source":"When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint."},{"content":"If you set <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=fullName&gt;</ph> to <ph id=\"ph2\">`true`</ph> in the <ph id=\"ph3\">`e`</ph> parameter, the socket can be reused.","pos":[160,325],"source":" If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=fullName> to `true` in the `e` parameter, the socket can be reused."}]}],"pos":[295349,295675],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.","source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation."}],"pos":[295870,295989],"yaml":true},{"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \n  \n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"pos":[0,209],"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`true`</ph> if the I/O operation is pending.","pos":[0,47],"source":"Returns `true` if the I/O operation is pending."},{"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.","pos":[48,209],"source":" The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation."}]},{"pos":[216,574],"content":"Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`false`</ph> if the I/O operation completed synchronously.","pos":[0,61],"source":"Returns `false` if the I/O operation completed synchronously."},{"content":"In this case, The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">e</ph><ept id=\"p2\">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","pos":[62,358],"source":" In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation."}]}],"pos":[296047,296630],"yaml":true},{"content":"The <code>e</code> parameter cannot be null.","nodes":[{"pos":[0,44],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter cannot be null.","source":"The <code>e</code> parameter cannot be null."}],"pos":[296801,296846],"yaml":true},{"content":"A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.","nodes":[{"pos":[0,163],"content":"A socket operation was already in progress using the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter."}],"pos":[296956,297120],"yaml":true},{"content":"Windows XP or later is required for this method.","nodes":[{"pos":[0,48],"content":"Windows XP or later is required for this method.","nodes":[{"content":"Windows XP or later is required for this method.","pos":[0,48]}]}],"pos":[297222,297271],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[297377,297445],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[297559,297615],"yaml":true},{"content":"Releases all resources used by the current instance of the <xref href=\"System.Net.Sockets.Socket\"></xref> class.","nodes":[{"pos":[0,112],"content":"Releases all resources used by the current instance of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> class.","source":"Releases all resources used by the current instance of the <xref href=\"System.Net.Sockets.Socket\"></xref> class."}],"pos":[298639,298752],"yaml":true},{"content":"Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>. The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state. After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.  \n  \n For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  \n  \n> [!NOTE]\n>  Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.","nodes":[{"pos":[0,369],"content":"Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>. The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state. After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.","nodes":[{"content":"Call <ph id=\"ph1\">`Dispose`</ph> when you are finished using the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,80],"source":"Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>."},{"content":"The <ph id=\"ph1\">`Dispose`</ph> method leaves the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> in an unusable state.","pos":[81,167],"source":" The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state."},{"content":"After calling <ph id=\"ph1\">`Dispose`</ph>, you must release all references to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> so the garbage collector can reclaim the memory that the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> was occupying.","pos":[168,369],"source":" After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying."}]},{"pos":[376,581],"content":"For more information, see <bpt id=\"p1\">[</bpt>Cleaning Up Unmanaged Resources<ept id=\"p1\">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id=\"p2\">[</bpt>Implementing a Dispose Method<ept id=\"p2\">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.","source":"For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md)."},{"pos":[589,855],"content":"[!NOTE]\n Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.","leadings":["","> "],"nodes":[{"content":" Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.","pos":[8,264],"nodes":[{"content":"Always call <ph id=\"ph1\">`Dispose`</ph> before you release your last reference to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[1,102],"source":" Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>."},{"content":"Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object's <ph id=\"ph2\">`Finalize`</ph> method.","pos":[103,256],"source":" Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method."}]}]}],"pos":[298763,299626],"yaml":true,"extradata":"MT"},{"content":"Releases the unmanaged resources used by the <xref href=\"System.Net.Sockets.Socket\"></xref>, and optionally disposes of the managed resources.","nodes":[{"pos":[0,142],"content":"Releases the unmanaged resources used by the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>, and optionally disposes of the managed resources.","source":"Releases the unmanaged resources used by the <xref href=\"System.Net.Sockets.Socket\"></xref>, and optionally disposes of the managed resources."}],"pos":[301033,301176],"yaml":true},{"content":"This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method. `Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`. <xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.  \n  \n When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references. This method invokes the `Dispose()` method of each referenced object.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,293],"content":"This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method. `Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`. <xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.","nodes":[{"content":"This method is called by the public <ph id=\"ph1\">`Dispose()`</ph> method and the <ph id=\"ph2\">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.","pos":[0,103],"source":"This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method."},{"content":"<ph id=\"ph1\">`Dispose()`</ph> invokes the protected <ph id=\"ph2\">`Dispose(Boolean)`</ph> method with the <ph id=\"ph3\">`disposing`</ph> parameter set to <ph id=\"ph4\">`true`</ph>.","pos":[104,209],"source":"`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`."},{"content":"<ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id=\"ph2\">`Dispose`</ph> with <ph id=\"ph3\">`disposing`</ph> set to <ph id=\"ph4\">`false`</ph>.","pos":[210,293],"source":" <xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`."}]},{"pos":[300,529],"content":"When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references. This method invokes the `Dispose()` method of each referenced object.","nodes":[{"content":"When the <ph id=\"ph1\">`disposing`</ph> parameter is <ph id=\"ph2\">`true`</ph>, this method releases all resources held by any managed objects that this <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> references.","pos":[0,159],"source":"When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references."},{"content":"This method invokes the <ph id=\"ph1\">`Dispose()`</ph> method of each referenced object.","pos":[160,229],"source":" This method invokes the `Dispose()` method of each referenced object."}]},{"pos":[537,762],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[301187,301957],"yaml":true,"extradata":"MT"},{"content":"`true` to release both managed and unmanaged resources; `false` to releases only unmanaged resources.","nodes":[{"pos":[0,101],"content":"<ph id=\"ph1\">`true`</ph> to release both managed and unmanaged resources; <ph id=\"ph2\">`false`</ph> to releases only unmanaged resources.","source":"`true` to release both managed and unmanaged resources; `false` to releases only unmanaged resources."}],"pos":[302111,302215],"yaml":true},{"content":"Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> allows Internet Protocol (IP) datagrams to be fragmented.","nodes":[{"pos":[0,188],"content":"Gets or sets a <ph id=\"ph1\">&lt;xref href=\"System.Boolean\"&gt;&lt;/xref&gt;</ph> value that specifies whether the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> allows Internet Protocol (IP) datagrams to be fragmented.","source":"Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> allows Internet Protocol (IP) datagrams to be fragmented."}],"pos":[303513,303702],"yaml":true},{"content":"Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium. Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only). If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.  \n  \n Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.","nodes":[{"pos":[0,497],"content":"Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium. Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only). If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.","nodes":[{"content":"Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium. Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only). If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.","pos":[0,497],"nodes":[{"content":"Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.","pos":[0,115]},{"content":"Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).","pos":[116,258]},{"content":"If a datagram must be fragmented, and the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.","pos":[259,497],"source":" If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram."}]}]},{"pos":[504,594],"content":"Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.","nodes":[{"content":"Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.","pos":[0,90]}]}],"pos":[303713,304312],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> allows datagram fragmentation; otherwise, `false`. The default is `true`.","nodes":[{"pos":[0,134],"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> allows datagram fragmentation; otherwise, `false`. The default is `true`.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> allows datagram fragmentation; otherwise, <ph id=\"ph3\">`false`</ph>.","pos":[0,111],"source":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> allows datagram fragmentation; otherwise, `false`."},{"content":"The default is <ph id=\"ph1\">`true`</ph>.","pos":[112,134],"source":" The default is `true`."}]}],"pos":[304815,304952],"yaml":true},{"content":"This property can be set only for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families.","nodes":[{"pos":[0,197],"content":"This property can be set only for sockets in the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"&gt;&lt;/xref&gt;</ph> families.","source":"This property can be set only for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families."}],"pos":[305120,305318],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[305432,305488],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[305594,305662],"yaml":true},{"content":"Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> is a dual-mode socket used for both IPv4 and IPv6.","nodes":[{"pos":[0,181],"content":"Gets or sets a <ph id=\"ph1\">&lt;xref href=\"System.Boolean\"&gt;&lt;/xref&gt;</ph> value that specifies whether the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is a dual-mode socket used for both IPv4 and IPv6.","source":"Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> is a dual-mode socket used for both IPv4 and IPv6."}],"pos":[306872,307054],"yaml":true},{"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> is a  dual-mode socket; otherwise, `false`. The default is `false`.","nodes":[{"pos":[0,128],"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> is a  dual-mode socket; otherwise, `false`. The default is `false`.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is a  dual-mode socket; otherwise, <ph id=\"ph3\">`false`</ph>.","pos":[0,104],"source":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> is a  dual-mode socket; otherwise, `false`."},{"content":"The default is <ph id=\"ph1\">`false`</ph>.","pos":[105,128],"source":" The default is `false`."}]}],"pos":[307170,307301],"yaml":true},{"content":"Duplicates the socket reference for the target process, and closes the socket for this process.","nodes":[{"pos":[0,95],"content":"Duplicates the socket reference for the target process, and closes the socket for this process.","nodes":[{"content":"Duplicates the socket reference for the target process, and closes the socket for this process.","pos":[0,95]}]}],"pos":[308691,308787],"yaml":true},{"content":"The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance.  \n  \n If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket. This practice is strongly discouraged.  \n  \n If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process.","nodes":[{"pos":[0,114],"content":"The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance.","nodes":[{"content":"The target process should use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> to create the duplicate socket instance.","pos":[0,114],"source":"The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance."}]},{"pos":[121,411],"content":"If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket. This practice is strongly discouraged.","nodes":[{"content":"If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket. This practice is strongly discouraged.","pos":[0,290],"nodes":[{"content":"If you call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances with the same underlying socket.","pos":[0,251],"source":"If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket."},{"content":"This practice is strongly discouraged.","pos":[252,290]}]}]},{"pos":[418,854],"content":"If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process.","nodes":[{"content":"If the process creating the socket uses asynchronous methods (<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>), the process must first set the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A&gt;</ph> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <ph id=\"ph4\">&lt;xref:System.ArgumentNullException&gt;</ph> to be thrown on the target process.","pos":[0,436],"source":"If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process."}]}],"pos":[308798,309659],"yaml":true,"extradata":"MT"},{"content":"The ID of the target process where a duplicate of the socket reference is created.","nodes":[{"pos":[0,82],"content":"The ID of the target process where a duplicate of the socket reference is created.","nodes":[{"content":"The ID of the target process where a duplicate of the socket reference is created.","pos":[0,82]}]}],"pos":[310010,310093],"yaml":true},{"content":"The socket reference to be passed to the target process.","nodes":[{"pos":[0,56],"content":"The socket reference to be passed to the target process.","nodes":[{"content":"The socket reference to be passed to the target process.","pos":[0,56]}]}],"pos":[310173,310230],"yaml":true},{"content":"<code>targetProcessID</code> is not a valid process id.  \n  \n -or-  \n  \n Duplication of the socket reference failed.","nodes":[{"pos":[0,55],"content":"<ph id=\"ph1\">&lt;code&gt;targetProcessID&lt;/code&gt;</ph> is not a valid process id.","source":"<code>targetProcessID</code> is not a valid process id."},{"pos":[62,66],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[73,116],"content":"Duplication of the socket reference failed.","nodes":[{"content":"Duplication of the socket reference failed.","pos":[0,43]}]}],"pos":[310415,310538],"yaml":true},{"content":"Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> can send or receive broadcast packets.","nodes":[{"pos":[0,169],"content":"Gets or sets a <ph id=\"ph1\">&lt;xref href=\"System.Boolean\"&gt;&lt;/xref&gt;</ph> value that specifies whether the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> can send or receive broadcast packets.","source":"Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> can send or receive broadcast packets."}],"pos":[311652,311822],"yaml":true},{"content":"Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion. For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.  \n  \n Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.","nodes":[{"pos":[0,593],"content":"Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion. For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.","nodes":[{"content":"Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion. For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.","pos":[0,593],"nodes":[{"content":"Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.","pos":[0,352]},{"content":"For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.","pos":[353,593]}]}]},{"pos":[600,690],"content":"Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.","nodes":[{"content":"Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.","pos":[0,90]}]}],"pos":[311833,312528],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> allows broadcast packets; otherwise, `false`. The default is `false`.","nodes":[{"pos":[0,130],"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> allows broadcast packets; otherwise, `false`. The default is `false`.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> allows broadcast packets; otherwise, <ph id=\"ph3\">`false`</ph>.","pos":[0,106],"source":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> allows broadcast packets; otherwise, `false`."},{"content":"The default is <ph id=\"ph1\">`false`</ph>.","pos":[107,130],"source":" The default is `false`."}]}],"pos":[313037,313170],"yaml":true},{"content":"This option is valid for a datagram socket only.","nodes":[{"pos":[0,48],"content":"This option is valid for a datagram socket only.","nodes":[{"content":"This option is valid for a datagram socket only.","pos":[0,48]}]}],"pos":[313353,313402],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[313508,313576],"yaml":true},{"content":"Asynchronously accepts an incoming connection attempt and creates a new <xref href=\"System.Net.Sockets.Socket\"></xref> object to handle remote host communication. This method returns a buffer that contains the initial data and the number of bytes transferred.","nodes":[{"pos":[0,259],"content":"Asynchronously accepts an incoming connection attempt and creates a new <xref href=\"System.Net.Sockets.Socket\"></xref> object to handle remote host communication. This method returns a buffer that contains the initial data and the number of bytes transferred.","nodes":[{"content":"Asynchronously accepts an incoming connection attempt and creates a new <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object to handle remote host communication.","pos":[0,162],"source":"Asynchronously accepts an incoming connection attempt and creates a new <xref href=\"System.Net.Sockets.Socket\"></xref> object to handle remote host communication."},{"content":"This method returns a buffer that contains the initial data and the number of bytes transferred.","pos":[163,259]}]}],"pos":[315027,315287],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns. It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.  \n  \n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt. The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.  \n  \n The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue. The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,547],"content":"<xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns. It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.","pos":[0,114],"source":"<xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>."},{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that is invoked by the <ph id=\"ph2\">&lt;xref:System.AsyncCallback&gt;</ph> delegate.","pos":[115,276],"source":" Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate."},{"content":"This callback method executes in a separate thread, and is called by the system after the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.","pos":[277,430],"source":" This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns."},{"content":"It must accept the <ph id=\"ph1\">`asyncResult`</ph> parameter returned from the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.","pos":[431,547],"source":" It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method."}]},{"pos":[554,1176],"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt. The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.","nodes":[{"content":"Within the callback method, call the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id=\"ph2\">`asyncResult`</ph> parameter to obtain the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.","pos":[0,209],"source":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made."},{"content":"After obtaining the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.","pos":[210,382],"source":" After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt."},{"content":"The <ph id=\"ph1\">`buffer`</ph> parameter of this overload contains the data that was received in the call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and the <ph id=\"ph3\">`bytesTransferred`</ph> parameter contains the number of bytes that were transferred in the call.","pos":[383,622],"source":" The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call."}]},{"pos":[1183,1522],"content":"The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue. The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue. The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.","pos":[0,339],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.","pos":[0,127],"source":"The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.","pos":[128,339],"source":" The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host."}]}]},{"pos":[1530,1896],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1904,2129],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[315298,317440],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the bytes transferred.","nodes":[{"pos":[0,86],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the bytes transferred.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the bytes transferred."}],"pos":[318376,318463],"yaml":true},{"content":"The number of bytes transferred.","nodes":[{"pos":[0,32],"content":"The number of bytes transferred.","nodes":[{"content":"The number of bytes transferred.","pos":[0,32]}]}],"pos":[318534,318567],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> object that stores state information for this asynchronous operation as well as any user defined data.","nodes":[{"pos":[0,146],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> object that stores state information for this asynchronous operation as well as any user defined data.","source":"An <xref href=\"System.IAsyncResult\"></xref> object that stores state information for this asynchronous operation as well as any user defined data."}],"pos":[318640,318787],"yaml":true},{"content":"A <xref href=\"System.Net.Sockets.Socket\"></xref> object to handle communication with the remote host.","nodes":[{"pos":[0,101],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object to handle communication with the remote host.","source":"A <xref href=\"System.Net.Sockets.Socket\"></xref> object to handle communication with the remote host."}],"pos":[318856,318958],"yaml":true},{"content":"Windows NT is required for this method.","nodes":[{"pos":[0,39],"content":"Windows NT is required for this method.","nodes":[{"content":"Windows NT is required for this method.","pos":[0,39]}]}],"pos":[319123,319163],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed."}],"pos":[319269,319344],"yaml":true},{"content":"<code>asyncResult</code> is empty.","nodes":[{"pos":[0,34],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is empty.","source":"<code>asyncResult</code> is empty."}],"pos":[319446,319481],"yaml":true},{"content":"<code>asyncResult</code> was not created by a call to <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>.","nodes":[{"pos":[0,149],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not created by a call to <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph>.","source":"<code>asyncResult</code> was not created by a call to <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>."}],"pos":[319575,319725],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\"></xref> method was previously called.","nodes":[{"pos":[0,107],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> method was previously called.","source":"<xref href=\"System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\"></xref> method was previously called."}],"pos":[319835,319943],"yaml":true},{"content":"An error occurred when attempting to access the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,95],"content":"An error occurred when attempting to access the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"An error occurred when attempting to access the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[320057,320153],"yaml":true},{"content":"Asynchronously accepts an incoming connection attempt and creates a new <xref href=\"System.Net.Sockets.Socket\"></xref> to handle remote host communication.","nodes":[{"pos":[0,155],"content":"Asynchronously accepts an incoming connection attempt and creates a new <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> to handle remote host communication.","source":"Asynchronously accepts an incoming connection attempt and creates a new <xref href=\"System.Net.Sockets.Socket\"></xref> to handle remote host communication."}],"pos":[321288,321444],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns. It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.  \n  \n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.  \n  \n The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue. The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,544],"content":"<xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns. It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.","pos":[0,114],"source":"<xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>."},{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that implements the <ph id=\"ph2\">&lt;xref:System.AsyncCallback&gt;</ph> delegate.","pos":[115,273],"source":" Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate."},{"content":"This callback method executes in a separate thread, and is called by the system after the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.","pos":[274,427],"source":" This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns."},{"content":"It must accept the <ph id=\"ph1\">`asyncResult`</ph> parameter returned from the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.","pos":[428,544],"source":" It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method."}]},{"pos":[551,933],"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.","nodes":[{"content":"Within the callback method, call the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id=\"ph2\">`asyncResult`</ph> parameter to obtain the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.","pos":[0,209],"source":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made."},{"content":"After obtaining the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.","pos":[210,382],"source":" After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt."}]},{"pos":[940,1279],"content":"The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue. The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue. The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.","pos":[0,339],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.","pos":[0,127],"source":"The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.","pos":[128,339],"source":" The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host."}]}]},{"pos":[1287,1653],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1661,1886],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[321455,323354],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Net.Sockets.Socket\"></xref> to handle communication with the remote host.","nodes":[{"pos":[0,94],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> to handle communication with the remote host.","source":"A <xref href=\"System.Net.Sockets.Socket\"></xref> to handle communication with the remote host."}],"pos":[324351,324446],"yaml":true},{"content":"<code>result</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;result&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>result</code> is `null`."}],"pos":[324611,324642],"yaml":true},{"content":"<code>result</code> was not created by a call to <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>.","nodes":[{"pos":[0,144],"content":"<ph id=\"ph1\">&lt;code&gt;result&lt;/code&gt;</ph> was not created by a call to <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph>.","source":"<code>result</code> was not created by a call to <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>."}],"pos":[324736,324881],"yaml":true},{"content":"An error occurred when attempting to access the socket. See the Remarks section for more information.","nodes":[{"pos":[0,101],"content":"An error occurred when attempting to access the socket. See the Remarks section for more information.","nodes":[{"content":"An error occurred when attempting to access the socket. See the Remarks section for more information.","pos":[0,101],"nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]},{"content":"See the Remarks section for more information.","pos":[56,101]}]}]}],"pos":[324995,325097],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[325203,325271],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\"></xref> method was previously called.","nodes":[{"pos":[0,107],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> method was previously called.","source":"<xref href=\"System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\"></xref> method was previously called."}],"pos":[325381,325489],"yaml":true},{"content":"Windows NT is required for this method.","nodes":[{"pos":[0,39],"content":"Windows NT is required for this method.","nodes":[{"content":"Windows NT is required for this method.","pos":[0,39]}]}],"pos":[325591,325631],"yaml":true},{"content":"Asynchronously accepts an incoming connection attempt and creates a new <xref href=\"System.Net.Sockets.Socket\"></xref> object to handle remote host communication. This method returns a buffer that contains the initial data transferred.","nodes":[{"pos":[0,235],"content":"Asynchronously accepts an incoming connection attempt and creates a new <xref href=\"System.Net.Sockets.Socket\"></xref> object to handle remote host communication. This method returns a buffer that contains the initial data transferred.","nodes":[{"content":"Asynchronously accepts an incoming connection attempt and creates a new <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object to handle remote host communication.","pos":[0,162],"source":"Asynchronously accepts an incoming connection attempt and creates a new <xref href=\"System.Net.Sockets.Socket\"></xref> object to handle remote host communication."},{"content":"This method returns a buffer that contains the initial data transferred.","pos":[163,235]}]}],"pos":[326835,327071],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.  \n  \n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt. The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.  \n  \n The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue. The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,430],"content":"<xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.","nodes":[{"content":"<xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.","pos":[0,430],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.","pos":[0,114],"source":"<xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>."},{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that is invoked by the <ph id=\"ph2\">&lt;xref:System.AsyncCallback&gt;</ph> delegate.","pos":[115,276],"source":" Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate."},{"content":"This callback method executes in a separate thread, and is called by the system after the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.","pos":[277,430],"source":" This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns."}]}]},{"pos":[437,1059],"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt. The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.","nodes":[{"content":"Within the callback method, call the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id=\"ph2\">`asyncResult`</ph> parameter to obtain the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.","pos":[0,209],"source":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made."},{"content":"After obtaining the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.","pos":[210,382],"source":" After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt."},{"content":"The <ph id=\"ph1\">`buffer`</ph> parameter of this overload contains the data that was received in the call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and the <ph id=\"ph3\">`bytesTransferred`</ph> parameter contains the number of bytes that were transferred in the call.","pos":[383,622],"source":" The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call."}]},{"pos":[1066,1405],"content":"The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue. The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue. The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.","pos":[0,339],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.","pos":[0,127],"source":"The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.","pos":[128,339],"source":" The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host."}]}]},{"pos":[1413,1779],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1787,2012],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[327082,329107],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the bytes transferred.","nodes":[{"pos":[0,86],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the bytes transferred.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the bytes transferred."}],"pos":[330017,330104],"yaml":true},{"content":"An <xref href=\"System.IAsyncResult\"></xref> object that stores state information for this asynchronous operation as well as any user defined data.","nodes":[{"pos":[0,146],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> object that stores state information for this asynchronous operation as well as any user defined data.","source":"An <xref href=\"System.IAsyncResult\"></xref> object that stores state information for this asynchronous operation as well as any user defined data."}],"pos":[330177,330324],"yaml":true},{"content":"A <xref href=\"System.Net.Sockets.Socket\"></xref> object to handle communication with the remote host.","nodes":[{"pos":[0,101],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object to handle communication with the remote host.","source":"A <xref href=\"System.Net.Sockets.Socket\"></xref> object to handle communication with the remote host."}],"pos":[330393,330495],"yaml":true},{"content":"Windows NT is required for this method.","nodes":[{"pos":[0,39],"content":"Windows NT is required for this method.","nodes":[{"content":"Windows NT is required for this method.","pos":[0,39]}]}],"pos":[330660,330700],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed."}],"pos":[330806,330881],"yaml":true},{"content":"<code>asyncResult</code> is empty.","nodes":[{"pos":[0,34],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is empty.","source":"<code>asyncResult</code> is empty."}],"pos":[330983,331018],"yaml":true},{"content":"<code>asyncResult</code> was not created by a call to <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>.","nodes":[{"pos":[0,149],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not created by a call to <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph>.","source":"<code>asyncResult</code> was not created by a call to <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>."}],"pos":[331112,331262],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\"></xref> method was previously called.","nodes":[{"pos":[0,107],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> method was previously called.","source":"<xref href=\"System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\"></xref> method was previously called."}],"pos":[331372,331480],"yaml":true},{"content":"An error occurred when attempting to access the <xref href=\"System.Net.Sockets.Socket\"></xref>","nodes":[{"pos":[0,94],"content":"An error occurred when attempting to access the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>","source":"An error occurred when attempting to access the <xref href=\"System.Net.Sockets.Socket\"></xref>"}],"pos":[331594,331689],"yaml":true},{"content":"Ends a pending asynchronous connection request.","nodes":[{"pos":[0,47],"content":"Ends a pending asynchronous connection request.","nodes":[{"content":"Ends a pending asynchronous connection request.","pos":[0,47]}]}],"pos":[332830,332878],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.  \n  \n Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.  \n  \n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,202],"content":"<xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> is a blocking method that completes the asynchronous remote host connection request started in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method.","pos":[0,202],"source":"<xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method."}]},{"pos":[209,662],"content":"Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.","nodes":[{"content":"Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.","pos":[0,453],"nodes":[{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, you need to create a callback method that implements the <ph id=\"ph2\">&lt;xref:System.AsyncCallback&gt;</ph> delegate.","pos":[0,159],"source":"Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate."},{"content":"This callback method executes in a separate thread and is called by the system after <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> returns.","pos":[160,302],"source":" This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns."},{"content":"The callback method must accept the <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method as a parameter.","pos":[303,453],"source":" The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter."}]}]},{"pos":[669,1065],"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.","nodes":[{"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.","pos":[0,396],"nodes":[{"content":"Within the callback method, call the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.","pos":[0,222],"source":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made."},{"content":"After obtaining the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method to successfully complete the connection attempt.","pos":[223,396],"source":" After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt."}]}]},{"pos":[1073,1439],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1447,1672],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[332889,334574],"yaml":true,"extradata":"MT"},{"content":"<code>result</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;result&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>result</code> is `null`."}],"pos":[335568,335599],"yaml":true},{"content":"<code>result</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)\"></xref> method.","nodes":[{"pos":[0,177],"content":"<ph id=\"ph1\">&lt;code&gt;result&lt;/code&gt;</ph> was not returned by a call to the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph> method.","source":"<code>result</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)\"></xref> method."}],"pos":[335693,335871],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)\"></xref> was previously called for the asynchronous connection.","nodes":[{"pos":[0,133],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous connection.","source":"<xref href=\"System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)\"></xref> was previously called for the asynchronous connection."}],"pos":[335981,336115],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[336229,336285],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[336391,336459],"yaml":true},{"content":"Ends a pending asynchronous disconnect request.","nodes":[{"pos":[0,47],"content":"Ends a pending asynchronous disconnect request.","nodes":[{"content":"Ends a pending asynchronous disconnect request.","pos":[0,47]}]}],"pos":[337618,337666],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes. For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,338],"content":"<xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes. For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.","nodes":[{"content":"<xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes. For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.","pos":[0,338],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> completes a call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>.","pos":[0,122],"source":"<xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> method blocks until the disconnect completes.","pos":[123,222],"source":" The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes."},{"content":"For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.","pos":[223,338]}]}]},{"pos":[346,712],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[720,945],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[337677,338631],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.IAsyncResult\"></xref> object that stores state information and any user-defined data for this asynchronous operation.","nodes":[{"pos":[0,139],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> object that stores state information and any user-defined data for this asynchronous operation.","source":"An <xref href=\"System.IAsyncResult\"></xref> object that stores state information and any user-defined data for this asynchronous operation."}],"pos":[339691,339831],"yaml":true},{"content":"The operating system is Windows 2000 or earlier, and this method requires Windows XP.","nodes":[{"pos":[0,85],"content":"The operating system is Windows 2000 or earlier, and this method requires Windows XP.","nodes":[{"content":"The operating system is Windows 2000 or earlier, and this method requires Windows XP.","pos":[0,85]}]}],"pos":[340000,340086],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed."}],"pos":[340192,340267],"yaml":true},{"content":"<code>asyncResult</code> is `null`.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>asyncResult</code> is `null`."}],"pos":[340369,340405],"yaml":true},{"content":"<code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)\"></xref> method.","nodes":[{"pos":[0,180],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not returned by a call to the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph> method.","source":"<code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)\"></xref> method."}],"pos":[340499,340680],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)\"></xref> was previously called for the asynchronous connection.","nodes":[{"pos":[0,136],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous connection.","source":"<xref href=\"System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)\"></xref> was previously called for the asynchronous connection."}],"pos":[340790,340927],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[341041,341097],"yaml":true},{"content":"The disconnect request has timed out.","nodes":[{"pos":[0,37],"content":"The disconnect request has timed out.","nodes":[{"content":"The disconnect request has timed out.","pos":[0,37]}]}],"pos":[341189,341227],"yaml":true},{"content":"Ends a pending asynchronous read.","nodes":[{"pos":[0,33],"content":"Ends a pending asynchronous read.","nodes":[{"content":"Ends a pending asynchronous read.","pos":[0,33]}]}],"pos":[342368,342402],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.  \n  \n Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.  \n  \n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method. Extract the receiving <xref:System.Net.Sockets.Socket> from this state object. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.  \n  \n The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer. If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.  \n  \n To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.  \n  \n To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,171],"content":"The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.","pos":[0,171],"source":"The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method."}]},{"pos":[178,631],"content":"Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.","nodes":[{"content":"Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.","pos":[0,453],"nodes":[{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, you need to create a callback method that implements the <ph id=\"ph2\">&lt;xref:System.AsyncCallback&gt;</ph> delegate.","pos":[0,159],"source":"Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate."},{"content":"This callback method executes in a separate thread and is called by the system after <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.","pos":[160,302],"source":" This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns."},{"content":"The callback method must accept the <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method as a parameter.","pos":[303,453],"source":" The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter."}]}]},{"pos":[638,1139],"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method. Extract the receiving <xref:System.Net.Sockets.Socket> from this state object. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.","nodes":[{"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method. Extract the receiving <xref:System.Net.Sockets.Socket> from this state object. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.","pos":[0,501],"nodes":[{"content":"Within the callback method, call the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.","pos":[0,216],"source":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method."},{"content":"Extract the receiving <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.","pos":[217,295],"source":" Extract the receiving <xref:System.Net.Sockets.Socket> from this state object."},{"content":"After obtaining the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.","pos":[296,501],"source":" After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read."}]}]},{"pos":[1146,1973],"content":"The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer. If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will block until data is available.","pos":[0,93],"source":"The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available."},{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.","pos":[94,264],"source":" If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer."},{"content":"If you are using a connection-oriented protocol, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id=\"ph2\">`size`</ph> parameter of the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.","pos":[265,538],"source":" If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[539,827],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes."}]},{"pos":[1980,2164],"content":"To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.","nodes":[{"content":"To obtain the received data, call the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph>, and extract the buffer contained in the resulting state object.","pos":[0,184],"source":"To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object."}]},{"pos":[2171,2299],"content":"To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.","nodes":[{"content":"To cancel a pending <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.","pos":[0,128],"source":"To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method."}]},{"pos":[2307,2673],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[2681,2857],"content":"[!NOTE]\n All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","leadings":["","> "],"nodes":[{"content":" All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[8,174],"nodes":[{"content":"All I/O initiated by a given thread is canceled when that thread exits.","pos":[1,72]},{"content":"A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[73,166]}]}]},{"pos":[2865,3090],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[342413,345525],"yaml":true,"extradata":"MT"},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[346400,346430],"yaml":true},{"content":"<code>result</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;result&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>result</code> is `null`."}],"pos":[346596,346627],"yaml":true},{"content":"<code>result</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"></xref> method.","nodes":[{"pos":[0,228],"content":"<ph id=\"ph1\">&lt;code&gt;result&lt;/code&gt;</ph> was not returned by a call to the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph> method.","source":"<code>result</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"></xref> method."}],"pos":[346721,346950],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> was previously called for the asynchronous read.","nodes":[{"pos":[0,127],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous read.","source":"<xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> was previously called for the asynchronous read."}],"pos":[347060,347188],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[347302,347358],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[347464,347532],"yaml":true},{"content":"Ends a pending asynchronous read.","nodes":[{"pos":[0,33],"content":"Ends a pending asynchronous read.","nodes":[{"content":"Ends a pending asynchronous read.","pos":[0,33]}]}],"pos":[348808,348842],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.  \n  \n Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.  \n  \n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method. Extract the receiving <xref:System.Net.Sockets.Socket> from this state object. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A>method to successfully complete the read operation and return the number of bytes read.  \n  \n The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer. If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.  \n  \n To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,171],"content":"The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.","pos":[0,171],"source":"The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method."}]},{"pos":[178,631],"content":"Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.","nodes":[{"content":"Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.","pos":[0,453],"nodes":[{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, you need to create a callback method that implements the <ph id=\"ph2\">&lt;xref:System.AsyncCallback&gt;</ph> delegate.","pos":[0,159],"source":"Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate."},{"content":"This callback method executes in a separate thread and is called by the system after <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.","pos":[160,302],"source":" This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns."},{"content":"The callback method must accept the <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method as a parameter.","pos":[303,453],"source":" The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter."}]}]},{"pos":[638,1138],"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method. Extract the receiving <xref:System.Net.Sockets.Socket> from this state object. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A>method to successfully complete the read operation and return the number of bytes read.","nodes":[{"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method. Extract the receiving <xref:System.Net.Sockets.Socket> from this state object. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A>method to successfully complete the read operation and return the number of bytes read.","pos":[0,500],"nodes":[{"content":"Within the callback method, call the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.","pos":[0,216],"source":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method."},{"content":"Extract the receiving <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.","pos":[217,295],"source":" Extract the receiving <xref:System.Net.Sockets.Socket> from this state object."},{"content":"After obtaining the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph>method to successfully complete the read operation and return the number of bytes read.","pos":[296,500],"source":" After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A>method to successfully complete the read operation and return the number of bytes read."}]}]},{"pos":[1145,1972],"content":"The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer. If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will block until data is available.","pos":[0,93],"source":"The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available."},{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.","pos":[94,264],"source":" If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer."},{"content":"If you are using a connection-oriented protocol, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id=\"ph2\">`size`</ph> parameter of the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.","pos":[265,538],"source":" If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[539,827],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes."}]},{"pos":[1979,2163],"content":"To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.","nodes":[{"content":"To obtain the received data, call the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph>, and extract the buffer contained in the resulting state object.","pos":[0,184],"source":"To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object."}]},{"pos":[2171,2537],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[2545,2721],"content":"[!NOTE]\n All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","leadings":["","> "],"nodes":[{"content":" All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[8,174],"nodes":[{"content":"All I/O initiated by a given thread is canceled when that thread exits.","pos":[1,72]},{"content":"A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[73,166]}]}]},{"pos":[2729,2954],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[348853,351827],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that stores state information and any user defined data for this asynchronous operation.","nodes":[{"pos":[0,132],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that stores state information and any user defined data for this asynchronous operation.","source":"An <xref href=\"System.IAsyncResult\"></xref> that stores state information and any user defined data for this asynchronous operation."}],"pos":[352035,352168],"yaml":true},{"content":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.","nodes":[{"pos":[0,90],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketError\"&gt;&lt;/xref&gt;</ph> object that stores the socket error.","source":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error."}],"pos":[352250,352341],"yaml":true},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[352397,352427],"yaml":true},{"content":"<code>asyncResult</code> is `null`.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>asyncResult</code> is `null`."}],"pos":[352593,352629],"yaml":true},{"content":"<code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"></xref> method.","nodes":[{"pos":[0,233],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not returned by a call to the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph> method.","source":"<code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"></xref> method."}],"pos":[352723,352957],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> was previously called for the asynchronous read.","nodes":[{"pos":[0,127],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous read.","source":"<xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> was previously called for the asynchronous read."}],"pos":[353067,353195],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[353309,353365],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[353471,353539],"yaml":true},{"content":"Ends a pending asynchronous read from a specific endpoint.","nodes":[{"pos":[0,58],"content":"Ends a pending asynchronous read from a specific endpoint.","nodes":[{"content":"Ends a pending asynchronous read from a specific endpoint.","pos":[0,58]}]}],"pos":[354797,354856],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.  \n  \n Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.  \n  \n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. Extract the receiving <xref:System.Net.Sockets.Socket> from this state object. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.  \n  \n The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer. If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes. To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object. To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>. Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> method to obtain the port number.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,179],"content":"The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.","pos":[0,179],"source":"The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method."}]},{"pos":[186,650],"content":"Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.","nodes":[{"content":"Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.","pos":[0,464],"nodes":[{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, you need to create a callback method that implements the <ph id=\"ph2\">&lt;xref:System.AsyncCallback&gt;</ph> delegate.","pos":[0,163],"source":"Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate."},{"content":"This callback method executes in a separate thread and is called by the system after<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> returns.","pos":[164,309],"source":" This callback method executes in a separate thread and is called by the system after<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns."},{"content":"The callback method must accept the <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method as a parameter.","pos":[310,464],"source":" The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter."}]}]},{"pos":[657,1166],"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. Extract the receiving <xref:System.Net.Sockets.Socket> from this state object. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.","nodes":[{"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. Extract the receiving <xref:System.Net.Sockets.Socket> from this state object. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.","pos":[0,509],"nodes":[{"content":"Within the callback method, call the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.","pos":[0,220],"source":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method."},{"content":"Extract the receiving <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.","pos":[221,299],"source":" Extract the receiving <xref:System.Net.Sockets.Socket> from this state object."},{"content":"After obtaining the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.","pos":[300,509],"source":" After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read."}]}]},{"pos":[1173,2542],"content":"The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer. If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes. To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object. To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>. Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> method to obtain the port number.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will block until data is available.","pos":[0,97],"source":"The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available."},{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.","pos":[98,272],"source":" If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer."},{"content":"If you are using a connection-oriented protocol, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id=\"ph2\">`size`</ph> parameter of the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.","pos":[273,554],"source":" If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[555,847],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes."},{"content":"To obtain the received data, call the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph> object, and extract the buffer contained in the resulting state object.","pos":[848,1039],"source":" To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object."},{"content":"To identify the originating host, extract the <ph id=\"ph1\">&lt;xref:System.Net.EndPoint&gt;</ph> and cast it to an <ph id=\"ph2\">&lt;xref:System.Net.IPEndPoint&gt;</ph>.","pos":[1040,1160],"source":" To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName&gt;</ph> method to obtain the IP address and the <ph id=\"ph2\">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName&gt;</ph> method to obtain the port number.","pos":[1161,1369],"source":" Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> method to obtain the port number."}]},{"pos":[2550,2916],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[2924,3149],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[354867,358031],"yaml":true,"extradata":"MT"},{"content":"If successful, the number of bytes received. If unsuccessful, returns 0.","nodes":[{"pos":[0,72],"content":"If successful, the number of bytes received. If unsuccessful, returns 0.","nodes":[{"content":"If successful, the number of bytes received. If unsuccessful, returns 0.","pos":[0,72],"nodes":[{"content":"If successful, the number of bytes received.","pos":[0,44]},{"content":"If unsuccessful, returns 0.","pos":[45,72]}]}]}],"pos":[358894,358967],"yaml":true},{"content":"<code>asyncResult</code> is `null`.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>asyncResult</code> is `null`."}],"pos":[359137,359173],"yaml":true},{"content":"<code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\"></xref> method.","nodes":[{"pos":[0,258],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not returned by a call to the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph> method.","source":"<code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\"></xref> method."}],"pos":[359267,359526],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\"></xref> was previously called for the asynchronous read.","nodes":[{"pos":[0,152],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous read.","source":"<xref href=\"System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\"></xref> was previously called for the asynchronous read."}],"pos":[359636,359789],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[359903,359959],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[360065,360133],"yaml":true},{"content":"Ends a pending asynchronous read from a specific endpoint. This method also reveals more information about the packet than <xref href=\"System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\"></xref>.","nodes":[{"pos":[0,227],"content":"Ends a pending asynchronous read from a specific endpoint. This method also reveals more information about the packet than <xref href=\"System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\"></xref>.","nodes":[{"content":"Ends a pending asynchronous read from a specific endpoint.","pos":[0,58]},{"content":"This method also reveals more information about the packet than <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\"&gt;&lt;/xref&gt;</ph>.","pos":[59,227],"source":" This method also reveals more information about the packet than <xref href=\"System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\"></xref>."}]}],"pos":[361751,361979],"yaml":true},{"content":"If the operation has not completed, this method blocks until it does.  \n  \n To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.  \n  \n Examine `ipPacketInformation` if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.","nodes":[{"pos":[0,69],"content":"If the operation has not completed, this method blocks until it does.","nodes":[{"content":"If the operation has not completed, this method blocks until it does.","pos":[0,69]}]},{"pos":[76,187],"content":"To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.","nodes":[{"content":"To perform this operation synchronously, use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.","pos":[0,111],"source":"To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method."}]},{"pos":[194,318],"content":"Examine <ph id=\"ph1\">`ipPacketInformation`</ph> if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.","source":"Examine `ipPacketInformation` if you need to know if the datagram was sent using a unicast, multicast, or broadcast address."}],"pos":[361990,362315],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that stores state information and any user defined data for this asynchronous operation.","nodes":[{"pos":[0,132],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that stores state information and any user defined data for this asynchronous operation.","source":"An <xref href=\"System.IAsyncResult\"></xref> that stores state information and any user defined data for this asynchronous operation."}],"pos":[362668,362801],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values for the received packet.","nodes":[{"pos":[0,112],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values for the received packet.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values for the received packet."}],"pos":[362885,362998],"yaml":true},{"content":"The source <xref href=\"System.Net.EndPoint\"></xref>.","nodes":[{"pos":[0,52],"content":"The source <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph>.","source":"The source <xref href=\"System.Net.EndPoint\"></xref>."}],"pos":[363068,363121],"yaml":true},{"content":"The <xref href=\"System.Net.IPAddress\"></xref> and interface of the received packet.","nodes":[{"pos":[0,83],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.IPAddress\"&gt;&lt;/xref&gt;</ph> and interface of the received packet.","source":"The <xref href=\"System.Net.IPAddress\"></xref> and interface of the received packet."}],"pos":[363221,363305],"yaml":true},{"content":"If successful, the number of bytes received. If unsuccessful, returns 0.","nodes":[{"pos":[0,72],"content":"If successful, the number of bytes received. If unsuccessful, returns 0.","nodes":[{"content":"If successful, the number of bytes received. If unsuccessful, returns 0.","pos":[0,72],"nodes":[{"content":"If successful, the number of bytes received.","pos":[0,44]},{"content":"If unsuccessful, returns 0.","pos":[45,72]}]}]}],"pos":[363361,363434],"yaml":true},{"content":"<code>asyncResult</code> is `null`  \n  \n -or-  \n  \n <code>endPoint</code> is `null`.","nodes":[{"pos":[0,34],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>","source":"<code>asyncResult</code> is `null`"},{"pos":[41,45],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[52,84],"content":"<ph id=\"ph1\">&lt;code&gt;endPoint&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>endPoint</code> is `null`."}],"pos":[363611,363702],"yaml":true},{"content":"<code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\"></xref> method.","nodes":[{"pos":[0,265],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not returned by a call to the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph> method.","source":"<code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\"></xref> method."}],"pos":[363796,364062],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\"></xref> was previously called for the asynchronous read.","nodes":[{"pos":[0,231],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous read.","source":"<xref href=\"System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\"></xref> was previously called for the asynchronous read."}],"pos":[364172,364404],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[364518,364574],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[364680,364748],"yaml":true},{"content":"Ends a pending asynchronous send.","nodes":[{"pos":[0,33],"content":"Ends a pending asynchronous send.","nodes":[{"content":"Ends a pending asynchronous send.","pos":[0,33]}]}],"pos":[365911,365945],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.  \n  \n Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.  \n  \n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.  \n  \n If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent. If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.  \n  \n There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \n  \n> [!NOTE]\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,143],"content":"<xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> completes the asynchronous send operation started in <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.","pos":[0,143],"source":"<xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>."}]},{"pos":[150,594],"content":"Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.","nodes":[{"content":"Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.","pos":[0,444],"nodes":[{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, you need to create a callback method that implements the <ph id=\"ph2\">&lt;xref:System.AsyncCallback&gt;</ph> delegate.","pos":[0,156],"source":"Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate."},{"content":"This callback method executes in a separate thread and is called by the system after <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> returns.","pos":[157,296],"source":" This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns."},{"content":"The callback method must accept the <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method as a parameter.","pos":[297,444],"source":" The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter."}]}]},{"pos":[601,988],"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.","nodes":[{"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.","pos":[0,387],"nodes":[{"content":"Within the callback method, call the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,184],"source":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>."},{"content":"After obtaining the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.","pos":[185,387],"source":" After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent."}]}]},{"pos":[995,1495],"content":"If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent. If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.","nodes":[{"content":"If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent. If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.","pos":[0,500],"nodes":[{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until the datagram is sent.","pos":[0,126],"source":"If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent."},{"content":"If you are using a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until some of the buffer was sent.","pos":[127,265],"source":" If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent."},{"content":"If the return value from <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indicates that the buffer was not completely sent, call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method again, modifying the buffer to hold the unsent data.","pos":[266,500],"source":" If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data."}]}]},{"pos":[1502,1891],"content":"There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,389],"nodes":[{"content":"There is no guarantee that the data you send will appear on the network immediately.","pos":[0,84]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[85,219]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[220,389],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[1899,2265],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[2273,2449],"content":"[!NOTE]\n All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","leadings":["","> "],"nodes":[{"content":" All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[8,174],"nodes":[{"content":"All I/O initiated by a given thread is canceled when that thread exits.","pos":[1,72]},{"content":"A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[73,166]}]}]},{"pos":[2457,2730],"content":"[!NOTE]\n The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","leadings":["","> "],"nodes":[{"content":" The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[8,271],"nodes":[{"content":"The successful completion of a send does not indicate that the data was successfully delivered.","pos":[1,96]},{"content":"If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[97,263]}]}]},{"pos":[2738,2963],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[365956,368942],"yaml":true,"extradata":"MT"},{"content":"If successful, the number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>; otherwise, an invalid <xref href=\"System.Net.Sockets.Socket\"></xref> error.","nodes":[{"pos":[0,170],"content":"If successful, the number of bytes sent to the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>; otherwise, an invalid <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> error.","source":"If successful, the number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>; otherwise, an invalid <xref href=\"System.Net.Sockets.Socket\"></xref> error."}],"pos":[369641,369812],"yaml":true},{"content":"<code>result</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;result&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>result</code> is `null`."}],"pos":[369975,370006],"yaml":true},{"content":"<code>result</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"></xref> method.","nodes":[{"pos":[0,225],"content":"<ph id=\"ph1\">&lt;code&gt;result&lt;/code&gt;</ph> was not returned by a call to the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph> method.","source":"<code>result</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"></xref> method."}],"pos":[370100,370326],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket.EndSend(System.IAsyncResult)\"></xref> was previously called for the asynchronous send.","nodes":[{"pos":[0,124],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndSend(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous send.","source":"<xref href=\"System.Net.Sockets.Socket.EndSend(System.IAsyncResult)\"></xref> was previously called for the asynchronous send."}],"pos":[370436,370561],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[370675,370731],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[370837,370905],"yaml":true},{"content":"Ends a pending asynchronous send.","nodes":[{"pos":[0,33],"content":"Ends a pending asynchronous send.","nodes":[{"content":"Ends a pending asynchronous send.","pos":[0,33]}]}],"pos":[372163,372197],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.  \n  \n Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.  \n  \n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.  \n  \n If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent. If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.  \n  \n There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \n  \n> [!NOTE]\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,143],"content":"<xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> completes the asynchronous send operation started in <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.","pos":[0,143],"source":"<xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>."}]},{"pos":[150,594],"content":"Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.","nodes":[{"content":"Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.","pos":[0,444],"nodes":[{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, you need to create a callback method that implements the <ph id=\"ph2\">&lt;xref:System.AsyncCallback&gt;</ph> delegate.","pos":[0,156],"source":"Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate."},{"content":"This callback method executes in a separate thread and is called by the system after <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> returns.","pos":[157,296],"source":" This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns."},{"content":"The callback method must accept the <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method as a parameter.","pos":[297,444],"source":" The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter."}]}]},{"pos":[601,988],"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.","nodes":[{"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.","pos":[0,387],"nodes":[{"content":"Within the callback method, call the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,184],"source":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>."},{"content":"After obtaining the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.","pos":[185,387],"source":" After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent."}]}]},{"pos":[995,1495],"content":"If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent. If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.","nodes":[{"content":"If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent. If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.","pos":[0,500],"nodes":[{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until the datagram is sent.","pos":[0,126],"source":"If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent."},{"content":"If you are using a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until some of the buffer was sent.","pos":[127,265],"source":" If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent."},{"content":"If the return value from <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indicates that the buffer was not completely sent, call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method again, modifying the buffer to hold the unsent data.","pos":[266,500],"source":" If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data."}]}]},{"pos":[1502,1891],"content":"There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,389],"nodes":[{"content":"There is no guarantee that the data you send will appear on the network immediately.","pos":[0,84]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[85,219]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[220,389],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[1899,2265],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[2273,2449],"content":"[!NOTE]\n All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","leadings":["","> "],"nodes":[{"content":" All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[8,174],"nodes":[{"content":"All I/O initiated by a given thread is canceled when that thread exits.","pos":[1,72]},{"content":"A pending asynchronous operation can fail if the thread exits before the operation completes.","pos":[73,166]}]}]},{"pos":[2457,2730],"content":"[!NOTE]\n The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","leadings":["","> "],"nodes":[{"content":" The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[8,271],"nodes":[{"content":"The successful completion of a send does not indicate that the data was successfully delivered.","pos":[1,96]},{"content":"If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[97,263]}]}]},{"pos":[2738,2963],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[372208,375194],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.IAsyncResult\"></xref> that stores state information for this asynchronous operation.","nodes":[{"pos":[0,106],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> that stores state information for this asynchronous operation.","source":"An <xref href=\"System.IAsyncResult\"></xref> that stores state information for this asynchronous operation."}],"pos":[375399,375506],"yaml":true},{"content":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.","nodes":[{"pos":[0,90],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketError\"&gt;&lt;/xref&gt;</ph> object that stores the socket error.","source":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error."}],"pos":[375588,375679],"yaml":true},{"content":"If successful, the number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>; otherwise, an invalid <xref href=\"System.Net.Sockets.Socket\"></xref> error.","nodes":[{"pos":[0,170],"content":"If successful, the number of bytes sent to the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>; otherwise, an invalid <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> error.","source":"If successful, the number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>; otherwise, an invalid <xref href=\"System.Net.Sockets.Socket\"></xref> error."}],"pos":[375735,375906],"yaml":true},{"content":"<code>asyncResult</code> is `null`.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>asyncResult</code> is `null`."}],"pos":[376069,376105],"yaml":true},{"content":"<code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"></xref> method.","nodes":[{"pos":[0,230],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not returned by a call to the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph> method.","source":"<code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"></xref> method."}],"pos":[376199,376430],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket.EndSend(System.IAsyncResult)\"></xref> was previously called for the asynchronous send.","nodes":[{"pos":[0,124],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndSend(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous send.","source":"<xref href=\"System.Net.Sockets.Socket.EndSend(System.IAsyncResult)\"></xref> was previously called for the asynchronous send."}],"pos":[376540,376665],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[376779,376835],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[376941,377009],"yaml":true},{"content":"Ends a pending asynchronous send of a file.","nodes":[{"pos":[0,43],"content":"Ends a pending asynchronous send of a file.","nodes":[{"content":"Ends a pending asynchronous send of a file.","pos":[0,43]}]}],"pos":[378156,378200],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.  \n  \n Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns. The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.  \n  \n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.  \n  \n If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,151],"content":"<xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> completes the asynchronous send operation started in <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>.","pos":[0,151],"source":"<xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>."}]},{"pos":[158,618],"content":"Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns. The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.","nodes":[{"content":"Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns. The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.","pos":[0,460],"nodes":[{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, you must create a callback method that implements the <ph id=\"ph2\">&lt;xref:System.AsyncCallback&gt;</ph> delegate.","pos":[0,157],"source":"Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate."},{"content":"This callback method executes in a separate thread and is called by the system after <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> returns.","pos":[158,301],"source":" This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns."},{"content":"The callback method must accept the <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> object returned by the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method as a parameter.","pos":[302,460],"source":" The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter."}]}]},{"pos":[625,980],"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.","nodes":[{"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.","pos":[0,355],"nodes":[{"content":"Within the callback method, call the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,184],"source":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>."},{"content":"After obtaining the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method to successfully complete the send operation.","pos":[185,355],"source":" After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation."}]}]},{"pos":[987,1642],"content":"If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,655],"nodes":[{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blocks until the datagram is sent.","pos":[0,126],"source":"If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent."},{"content":"If you are using a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blocks until the entire file is sent.","pos":[127,261],"source":" If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent."},{"content":"There is no guarantee that the data you send will appear on the network immediately.","pos":[262,346]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[347,481]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[482,655],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[1650,2016],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[2024,2249],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[378211,380475],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.IAsyncResult\"></xref> object that stores state information for this asynchronous operation.","nodes":[{"pos":[0,113],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> object that stores state information for this asynchronous operation.","source":"An <xref href=\"System.IAsyncResult\"></xref> object that stores state information for this asynchronous operation."}],"pos":[381212,381326],"yaml":true},{"content":"Windows NT is required for this method.","nodes":[{"pos":[0,39],"content":"Windows NT is required for this method.","nodes":[{"content":"Windows NT is required for this method.","pos":[0,39]}]}],"pos":[381493,381533],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed."}],"pos":[381639,381714],"yaml":true},{"content":"<code>asyncResult</code> is empty.","nodes":[{"pos":[0,34],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> is empty.","source":"<code>asyncResult</code> is empty."}],"pos":[381816,381851],"yaml":true},{"content":"<code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)\"></xref> method.","nodes":[{"pos":[0,177],"content":"<ph id=\"ph1\">&lt;code&gt;asyncResult&lt;/code&gt;</ph> was not returned by a call to the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph> method.","source":"<code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)\"></xref> method."}],"pos":[381945,382123],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)\"></xref> was previously called for the asynchronous <xref href=\"System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)\"></xref>.","nodes":[{"pos":[0,234],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)\"></xref> was previously called for the asynchronous <xref href=\"System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)\"></xref>."}],"pos":[382233,382468],"yaml":true},{"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"pos":[0,82],"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"content":"An error occurred when attempting to access the socket. See remarks section below.","pos":[0,82],"nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]},{"content":"See remarks section below.","pos":[56,82]}]}]}],"pos":[382582,382665],"yaml":true},{"content":"Ends a pending asynchronous send to a specific location.","nodes":[{"pos":[0,56],"content":"Ends a pending asynchronous send to a specific location.","nodes":[{"content":"Ends a pending asynchronous send to a specific location.","pos":[0,56]}]}],"pos":[383800,383857],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.  \n  \n Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.  \n  \n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.  \n  \n If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,147],"content":"<xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> completes the asynchronous send operation started in <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.","pos":[0,147],"source":"<xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>."}]},{"pos":[154,605],"content":"Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.","nodes":[{"content":"Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.","pos":[0,451],"nodes":[{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, you need to create a callback method that implements the <ph id=\"ph2\">&lt;xref:System.AsyncCallback&gt;</ph> delegate.","pos":[0,158],"source":"Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate."},{"content":"This callback method executes in a separate thread and is called by the system after <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.","pos":[159,301],"source":" This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns."},{"content":"The callback method must accept the <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method as a parameter.","pos":[302,451],"source":" The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter."}]}]},{"pos":[612,1001],"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.","nodes":[{"content":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.","pos":[0,389],"nodes":[{"content":"Within the callback method, call the <ph id=\"ph1\">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,184],"source":"Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>."},{"content":"After obtaining the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.","pos":[185,389],"source":" After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent."}]}]},{"pos":[1008,1680],"content":"If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,672],"nodes":[{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will block until the datagram is sent.","pos":[0,128],"source":"If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent."},{"content":"If you are using a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will block until the requested number of bytes are sent.","pos":[129,280],"source":" If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent."},{"content":"There is no guarantee that the data you send will appear on the network immediately.","pos":[281,365]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[366,500]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[501,672],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[1688,2054],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[2062,2287],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[383868,386170],"yaml":true,"extradata":"MT"},{"content":"If successful, the number of bytes sent; otherwise, an invalid <xref href=\"System.Net.Sockets.Socket\"></xref> error.","nodes":[{"pos":[0,116],"content":"If successful, the number of bytes sent; otherwise, an invalid <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> error.","source":"If successful, the number of bytes sent; otherwise, an invalid <xref href=\"System.Net.Sockets.Socket\"></xref> error."}],"pos":[386887,387004],"yaml":true},{"content":"<code>result</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;result&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>result</code> is `null`."}],"pos":[387169,387200],"yaml":true},{"content":"<code>result</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)\"></xref> method.","nodes":[{"pos":[0,247],"content":"<ph id=\"ph1\">&lt;code&gt;result&lt;/code&gt;</ph> was not returned by a call to the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)\"&gt;&lt;/xref&gt;</ph> method.","source":"<code>result</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)\"></xref> method."}],"pos":[387294,387542],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)\"></xref> was previously called for the asynchronous send.","nodes":[{"pos":[0,126],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)\"&gt;&lt;/xref&gt;</ph> was previously called for the asynchronous send.","source":"<xref href=\"System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)\"></xref> was previously called for the asynchronous send."}],"pos":[387652,387779],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[387893,387949],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[388055,388123],"yaml":true},{"content":"Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> allows only one process to bind to a port.","nodes":[{"pos":[0,173],"content":"Gets or sets a <ph id=\"ph1\">&lt;xref href=\"System.Boolean\"&gt;&lt;/xref&gt;</ph> value that specifies whether the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> allows only one process to bind to a port.","source":"Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> allows only one process to bind to a port."}],"pos":[389215,389389],"yaml":true},{"content":"If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port. If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.  \n  \n If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `true`, the first use of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to that port will fail until the original bound socket is destroyed.  \n  \n This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown.","nodes":[{"pos":[0,513],"content":"If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port. If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.","nodes":[{"content":"If <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> is <ph id=\"ph2\">`false`</ph>, multiple sockets can use the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.","pos":[0,271],"source":"If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port."},{"content":"If more than one socket attempts to use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29&gt;</ph> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.","pos":[272,513],"source":" If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port."}]},{"pos":[520,922],"content":"If <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> is <ph id=\"ph2\">`true`</ph>, the first use of the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to attempt to bind to that port will fail until the original bound socket is destroyed.","source":"If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `true`, the first use of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to that port will fail until the original bound socket is destroyed."},{"pos":[929,1082],"content":"This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown.","nodes":[{"content":"This property must be set before <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> is called; otherwise an <ph id=\"ph2\">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown.","pos":[0,153],"source":"This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown."}]}],"pos":[389400,390489],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> allows only one socket to bind to a specific port; otherwise, `false`. The default is `true` for Windows Server 2003 and Windows XP Service Pack 2, and `false` for all other versions.","nodes":[{"pos":[0,244],"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> allows only one socket to bind to a specific port; otherwise, `false`. The default is `true` for Windows Server 2003 and Windows XP Service Pack 2, and `false` for all other versions.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> allows only one socket to bind to a specific port; otherwise, <ph id=\"ph3\">`false`</ph>.","pos":[0,131],"source":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> allows only one socket to bind to a specific port; otherwise, `false`."},{"content":"The default is <ph id=\"ph1\">`true`</ph> for Windows Server 2003 and Windows XP Service Pack 2, and <ph id=\"ph2\">`false`</ph> for all other versions.","pos":[132,244],"source":" The default is `true` for Windows Server 2003 and Windows XP Service Pack 2, and `false` for all other versions."}]}],"pos":[391006,391253],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[391440,391496],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[391602,391670],"yaml":true},{"content":"<xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> has been called for this <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,145],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"&gt;&lt;/xref&gt;</ph> has been called for this <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> has been called for this <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[391780,391926],"yaml":true},{"content":"Frees resources used by the <xref href=\"System.Net.Sockets.Socket\"></xref> class.","nodes":[{"pos":[0,81],"content":"Frees resources used by the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> class.","source":"Frees resources used by the <xref href=\"System.Net.Sockets.Socket\"></xref> class."}],"pos":[393140,393222],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>.","nodes":[{"pos":[0,230],"content":"The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class finalizer calls the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to close the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and free resources associated with the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,230],"source":"The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>."}]}],"pos":[393233,393464],"yaml":true,"extradata":"MT"},{"content":"Returns the value of the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option in an array.","nodes":[{"pos":[0,101],"content":"Returns the value of the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> option in an array.","source":"Returns the value of the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option in an array."}],"pos":[395226,395328],"yaml":true},{"content":"The `optionLength` parameter sets the maximum size of the returned byte array. If the option value requires fewer bytes, the array will contain only that many bytes. If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>. Use this overload for any sockets that are represented by Boolean values or integers.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,400],"content":"The `optionLength` parameter sets the maximum size of the returned byte array. If the option value requires fewer bytes, the array will contain only that many bytes. If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>. Use this overload for any sockets that are represented by Boolean values or integers.","nodes":[{"content":"The <ph id=\"ph1\">`optionLength`</ph> parameter sets the maximum size of the returned byte array.","pos":[0,78],"source":"The `optionLength` parameter sets the maximum size of the returned byte array."},{"content":"If the option value requires fewer bytes, the array will contain only that many bytes.","pos":[79,165]},{"content":"If the option value requires more bytes, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[166,314],"source":" If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"Use this overload for any sockets that are represented by Boolean values or integers.","pos":[315,400]}]},{"pos":[408,774],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[782,1007],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[395339,396355],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values.","nodes":[{"pos":[0,76],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketOptionLevel\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values."}],"pos":[397208,397285],"yaml":true},{"content":"One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values.","nodes":[{"pos":[0,75],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketOptionName\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values."}],"pos":[397373,397449],"yaml":true},{"content":"The length, in bytes, of the expected return value.","nodes":[{"pos":[0,51],"content":"The length, in bytes, of the expected return value.","nodes":[{"content":"The length, in bytes, of the expected return value.","pos":[0,51]}]}],"pos":[397516,397568],"yaml":true},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the value of the socket option.","nodes":[{"pos":[0,95],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the value of the socket option.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the value of the socket option."}],"pos":[397625,397721],"yaml":true},{"content":"An error occurred when attempting to access the socket.  \n  \n \\- or -  \n  \n In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes. You can change the per socket buffer space by calling <xref href=\"System.Net.Sockets.Socket.SetSocketOption*\"></xref>.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]},{"pos":[62,69],"content":"\\- or -","nodes":[{"content":"<ph id=\"ph1\">\\-</ph> or -","pos":[0,7],"source":"\\- or -"}]},{"pos":[76,293],"content":"In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes. You can change the per socket buffer space by calling <xref href=\"System.Net.Sockets.Socket.SetSocketOption*\"></xref>.","nodes":[{"content":"In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.","pos":[0,98]},{"content":"You can change the per socket buffer space by calling <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.SetSocketOption*\"&gt;&lt;/xref&gt;</ph>.","pos":[99,217],"source":" You can change the per socket buffer space by calling <xref href=\"System.Net.Sockets.Socket.SetSocketOption*\"></xref>."}]}],"pos":[397904,398207],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[398313,398381],"yaml":true},{"content":"Returns the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option setting, represented as a byte array.","nodes":[{"pos":[0,113],"content":"Returns the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> option setting, represented as a byte array.","source":"Returns the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option setting, represented as a byte array."}],"pos":[400030,400144],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option.  \n  \n When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. Use this overload for any sockets that are represented by Boolean values or integers.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,283],"content":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,112],"source":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>."},{"content":"Upon successful completion of this method, the array specified by the <ph id=\"ph1\">`optionValue`</ph> parameter contains the value of the specified <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option.","pos":[113,283],"source":" Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option."}]},{"pos":[290,1004],"content":"When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. Use this overload for any sockets that are represented by Boolean values or integers.","nodes":[{"content":"When the length of the <ph id=\"ph1\">`optionValue`</ph> array is smaller than the number of bytes required to store the value of the specified <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> will throw a <ph id=\"ph4\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[0,272],"source":"When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[273,464],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[465,628]},{"content":"Use this overload for any sockets that are represented by Boolean values or integers.","pos":[629,714]}]},{"pos":[1012,1237],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[400155,401400],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values.","nodes":[{"pos":[0,76],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketOptionLevel\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values."}],"pos":[402253,402330],"yaml":true},{"content":"One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values.","nodes":[{"pos":[0,75],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketOptionName\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values."}],"pos":[402418,402494],"yaml":true},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is to receive the option setting.","nodes":[{"pos":[0,88],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is to receive the option setting.","source":"An array of type <xref href=\"System.Byte\"></xref> that is to receive the option setting."}],"pos":[402561,402650],"yaml":true},{"content":"An error occurred when attempting to access the socket.  \n  \n \\- or -  \n  \n In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes. You can change the per socket buffer space by calling <xref href=\"System.Net.Sockets.Socket.SetSocketOption*\"></xref>.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]},{"pos":[62,69],"content":"\\- or -","nodes":[{"content":"<ph id=\"ph1\">\\-</ph> or -","pos":[0,7],"source":"\\- or -"}]},{"pos":[76,293],"content":"In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes. You can change the per socket buffer space by calling <xref href=\"System.Net.Sockets.Socket.SetSocketOption*\"></xref>.","nodes":[{"content":"In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.","pos":[0,98]},{"content":"You can change the per socket buffer space by calling <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.SetSocketOption*\"&gt;&lt;/xref&gt;</ph>.","pos":[99,217],"source":" You can change the per socket buffer space by calling <xref href=\"System.Net.Sockets.Socket.SetSocketOption*\"></xref>."}]}],"pos":[402833,403136],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[403242,403310],"yaml":true},{"content":"Returns the value of a specified <xref href=\"System.Net.Sockets.Socket\"></xref> option, represented as an object.","nodes":[{"pos":[0,113],"content":"Returns the value of a specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> option, represented as an object.","source":"Returns the value of a specified <xref href=\"System.Net.Sockets.Socket\"></xref> option, represented as an object."}],"pos":[404893,405007],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options. For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter. For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>. If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,798],"content":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options. For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter. For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>. If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,112],"source":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>."},{"content":"Use this overload to get the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.","pos":[113,353],"source":" Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options."},{"content":"For the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, use <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for the <ph id=\"ph3\">`optionLevel`</ph> parameter.","pos":[354,489],"source":" For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter."},{"content":"For <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.","pos":[490,665],"source":" For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>."},{"content":"If you want to set the value of any of the options listed above, use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.","pos":[666,798],"source":" If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method."}]},{"pos":[806,1172],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1180,1405],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[405018,406432],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values.","nodes":[{"pos":[0,76],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketOptionLevel\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values."}],"pos":[407267,407344],"yaml":true},{"content":"One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values.","nodes":[{"pos":[0,75],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketOptionName\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values."}],"pos":[407432,407508],"yaml":true},{"content":"An object that represents the value of the option. When the <code>optionName</code> parameter is set to <xref href=\"System.Net.Sockets.SocketOptionName.Linger\"></xref> the return value is an instance of the <xref href=\"System.Net.Sockets.LingerOption\"></xref> class. When <code>optionName</code> is set to <xref href=\"System.Net.Sockets.SocketOptionName.AddMembership\"></xref> or <xref href=\"System.Net.Sockets.SocketOptionName.DropMembership\"></xref>, the return value is an instance of the <xref href=\"System.Net.Sockets.MulticastOption\"></xref> class. When <code>optionName</code> is any other value, the return value is an integer.","nodes":[{"pos":[0,635],"content":"An object that represents the value of the option. When the <code>optionName</code> parameter is set to <xref href=\"System.Net.Sockets.SocketOptionName.Linger\"></xref> the return value is an instance of the <xref href=\"System.Net.Sockets.LingerOption\"></xref> class. When <code>optionName</code> is set to <xref href=\"System.Net.Sockets.SocketOptionName.AddMembership\"></xref> or <xref href=\"System.Net.Sockets.SocketOptionName.DropMembership\"></xref>, the return value is an instance of the <xref href=\"System.Net.Sockets.MulticastOption\"></xref> class. When <code>optionName</code> is any other value, the return value is an integer.","nodes":[{"content":"An object that represents the value of the option.","pos":[0,50]},{"content":"When the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">optionName</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is set to <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketOptionName.Linger\"&gt;&lt;/xref&gt;</ph> the return value is an instance of the <ph id=\"ph3\">&lt;xref href=\"System.Net.Sockets.LingerOption\"&gt;&lt;/xref&gt;</ph> class.","pos":[51,266],"source":" When the <code>optionName</code> parameter is set to <xref href=\"System.Net.Sockets.SocketOptionName.Linger\"></xref> the return value is an instance of the <xref href=\"System.Net.Sockets.LingerOption\"></xref> class."},{"content":"When <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">optionName</ph><ept id=\"p1\">&lt;/code&gt;</ept> is set to <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketOptionName.AddMembership\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph3\">&lt;xref href=\"System.Net.Sockets.SocketOptionName.DropMembership\"&gt;&lt;/xref&gt;</ph>, the return value is an instance of the <ph id=\"ph4\">&lt;xref href=\"System.Net.Sockets.MulticastOption\"&gt;&lt;/xref&gt;</ph> class.","pos":[267,554],"source":" When <code>optionName</code> is set to <xref href=\"System.Net.Sockets.SocketOptionName.AddMembership\"></xref> or <xref href=\"System.Net.Sockets.SocketOptionName.DropMembership\"></xref>, the return value is an instance of the <xref href=\"System.Net.Sockets.MulticastOption\"></xref> class."},{"content":"When <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">optionName</ph><ept id=\"p1\">&lt;/code&gt;</ept> is any other value, the return value is an integer.","pos":[555,635],"source":" When <code>optionName</code> is any other value, the return value is an integer."}]}],"pos":[407565,408201],"yaml":true},{"content":"An error occurred when attempting to access the socket.  \n  \n -or-  \n  \n <code>optionName</code> was set to the unsupported value <xref href=\"System.Net.Sockets.SocketOptionName.MaxConnections\"></xref>.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]},{"pos":[62,66],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[73,202],"content":"<ph id=\"ph1\">&lt;code&gt;optionName&lt;/code&gt;</ph> was set to the unsupported value <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketOptionName.MaxConnections\"&gt;&lt;/xref&gt;</ph>.","source":"<code>optionName</code> was set to the unsupported value <xref href=\"System.Net.Sockets.SocketOptionName.MaxConnections\"></xref>."}],"pos":[408384,408595],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[408701,408769],"yaml":true},{"content":"Gets the operating system handle for the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,88],"content":"Gets the operating system handle for the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Gets the operating system handle for the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[409967,410056],"yaml":true},{"content":"An <xref href=\"System.IntPtr\"></xref> that represents the operating system handle for the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,137],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IntPtr\"&gt;&lt;/xref&gt;</ph> that represents the operating system handle for the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"An <xref href=\"System.IntPtr\"></xref> that represents the operating system handle for the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[410166,410304],"yaml":true},{"content":"Sets low-level operating modes for the <xref href=\"System.Net.Sockets.Socket\"></xref> using numerical control codes.","nodes":[{"pos":[0,116],"content":"Sets low-level operating modes for the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> using numerical control codes.","source":"Sets low-level operating modes for the <xref href=\"System.Net.Sockets.Socket\"></xref> using numerical control codes."}],"pos":[411592,411709],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class. For more information, see the WSAIoctl documentation in the MSDN library.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,292],"content":"The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class. For more information, see the WSAIoctl documentation in the MSDN library.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class. For more information, see the WSAIoctl documentation in the MSDN library.","pos":[0,292],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> method provides low-level access to the operating system <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> underlying the current instance of the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.","pos":[0,218],"source":"The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class."},{"content":"For more information, see the WSAIoctl documentation in the MSDN library.","pos":[219,292]}]}]},{"pos":[300,666],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[674,899],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[411720,412628],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Int32\"></xref> value that specifies the control code of the operation to perform.","nodes":[{"pos":[0,103],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Int32\"&gt;&lt;/xref&gt;</ph> value that specifies the control code of the operation to perform.","source":"An <xref href=\"System.Int32\"></xref> value that specifies the control code of the operation to perform."}],"pos":[413189,413293],"yaml":true},{"content":"A <xref href=\"System.Byte\"></xref> array that contains the input data required by the operation.","nodes":[{"pos":[0,96],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> array that contains the input data required by the operation.","source":"A <xref href=\"System.Byte\"></xref> array that contains the input data required by the operation."}],"pos":[413362,413459],"yaml":true},{"content":"A <xref href=\"System.Byte\"></xref> array that contains the output data returned by the operation.","nodes":[{"pos":[0,97],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> array that contains the output data returned by the operation.","source":"A <xref href=\"System.Byte\"></xref> array that contains the output data returned by the operation."}],"pos":[413529,413627],"yaml":true},{"content":"The number of bytes in the <code>optionOutValue</code> parameter.","nodes":[{"pos":[0,65],"content":"The number of bytes in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">optionOutValue</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"The number of bytes in the <code>optionOutValue</code> parameter."}],"pos":[413683,413749],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[413926,413982],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[414088,414156],"yaml":true},{"content":"An attempt was made to change the blocking mode without using the <xref href=\"System.Net.Sockets.Socket.Blocking\"></xref> property.","nodes":[{"pos":[0,131],"content":"An attempt was made to change the blocking mode without using the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.Blocking\"&gt;&lt;/xref&gt;</ph> property.","source":"An attempt was made to change the blocking mode without using the <xref href=\"System.Net.Sockets.Socket.Blocking\"></xref> property."}],"pos":[414266,414398],"yaml":true},{"content":"A caller in the call stack does not have the required permissions.","nodes":[{"pos":[0,66],"content":"A caller in the call stack does not have the required permissions.","nodes":[{"content":"A caller in the call stack does not have the required permissions.","pos":[0,66]}]}],"pos":[414510,414577],"yaml":true},{"content":"Sets low-level operating modes for the <xref href=\"System.Net.Sockets.Socket\"></xref> using the <xref href=\"System.Net.Sockets.IOControlCode\"></xref> enumeration to specify control codes.","nodes":[{"pos":[0,187],"content":"Sets low-level operating modes for the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> using the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.IOControlCode\"&gt;&lt;/xref&gt;</ph> enumeration to specify control codes.","source":"Sets low-level operating modes for the <xref href=\"System.Net.Sockets.Socket\"></xref> using the <xref href=\"System.Net.Sockets.IOControlCode\"></xref> enumeration to specify control codes."}],"pos":[416070,416258],"yaml":true},{"content":"This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class. For more, see the WSAIoctl documentation in the MSDN library.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,235],"content":"This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class. For more, see the WSAIoctl documentation in the MSDN library.","nodes":[{"content":"This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class. For more, see the WSAIoctl documentation in the MSDN library.","pos":[0,235],"nodes":[{"content":"This method provides low-level access to the operating system <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> underlying the current instance of the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.","pos":[0,173],"source":"This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class."},{"content":"For more, see the WSAIoctl documentation in the MSDN library.","pos":[174,235]}]}]},{"pos":[243,609],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[617,842],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[416269,417120],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Net.Sockets.IOControlCode\"></xref> value that specifies the control code of the operation to perform.","nodes":[{"pos":[0,122],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.IOControlCode\"&gt;&lt;/xref&gt;</ph> value that specifies the control code of the operation to perform.","source":"A <xref href=\"System.Net.Sockets.IOControlCode\"></xref> value that specifies the control code of the operation to perform."}],"pos":[417867,417990],"yaml":true},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the input data required by the operation.","nodes":[{"pos":[0,105],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the input data required by the operation.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the input data required by the operation."}],"pos":[418059,418165],"yaml":true},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the output data returned by the operation.","nodes":[{"pos":[0,106],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the output data returned by the operation.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the output data returned by the operation."}],"pos":[418235,418342],"yaml":true},{"content":"The number of bytes in the <code>optionOutValue</code> parameter.","nodes":[{"pos":[0,65],"content":"The number of bytes in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">optionOutValue</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"The number of bytes in the <code>optionOutValue</code> parameter."}],"pos":[418398,418464],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[418641,418697],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[418803,418871],"yaml":true},{"content":"An attempt was made to change the blocking mode without using the <xref href=\"System.Net.Sockets.Socket.Blocking\"></xref> property.","nodes":[{"pos":[0,131],"content":"An attempt was made to change the blocking mode without using the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.Blocking\"&gt;&lt;/xref&gt;</ph> property.","source":"An attempt was made to change the blocking mode without using the <xref href=\"System.Net.Sockets.Socket.Blocking\"></xref> property."}],"pos":[418981,419113],"yaml":true},{"content":"Gets a value that indicates whether the <xref href=\"System.Net.Sockets.Socket\"></xref> is bound to a specific local port.","nodes":[{"pos":[0,121],"content":"Gets a value that indicates whether the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is bound to a specific local port.","source":"Gets a value that indicates whether the <xref href=\"System.Net.Sockets.Socket\"></xref> is bound to a specific local port."}],"pos":[420317,420439],"yaml":true},{"content":"A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them.","nodes":[{"pos":[0,550],"content":"A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them.","nodes":[{"content":"A socket is considered bound to a local port if it is explicitly bound by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, or implicitly bound by calling members like <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to bind to a well-known port so that clients may connect to them.","pos":[0,550],"source":"A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them."}]}],"pos":[420450,421001],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> is bound to a local port; otherwise, `false`.","nodes":[{"pos":[0,106],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is bound to a local port; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> is bound to a local port; otherwise, `false`."}],"pos":[421489,421598],"yaml":true},{"content":"Gets or sets a value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> will delay closing a socket in an attempt to send all pending data.","nodes":[{"pos":[0,162],"content":"Gets or sets a value that specifies whether the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> will delay closing a socket in an attempt to send all pending data.","source":"Gets or sets a value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> will delay closing a socket in an attempt to send all pending data."}],"pos":[422890,423053],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves. This property when set modifies the conditions under which the connection can be reset by Winsock. Connection resets can still occur based on the IP protocol behavior.  \n  \n This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent.  \n  \n When you call methods to send data to a peer, this data is placed in the outgoing network buffer. This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.  \n  \n To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance.  \n  \n The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property.  \n  \n|LingerState.Enabled|LingerState.LingerTime|Behavior|  \n|-------------------------|----------------------------|--------------|  \n|`false` (disabled), the default value|The time-out is not applicable, (default).|Attempts to send pending data until the default IP protocol time-out expires.|  \n|`true` (enabled)|A nonzero time-out|Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.|  \n|`true` (enabled)|A zero timeout.|Discards any pending data. For connection-oriented socket (TCP, for example), Winsock resets the connection.|  \n  \n The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection. In most cases, the time-out computed by the stack is more relevant than one defined by an application. This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.  \n  \n When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.","nodes":[{"pos":[0,302],"content":"The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves. This property when set modifies the conditions under which the connection can be reset by Winsock. Connection resets can still occur based on the IP protocol behavior.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves. This property when set modifies the conditions under which the connection can be reset by Winsock. Connection resets can still occur based on the IP protocol behavior.","pos":[0,302],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property changes the way <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method behaves.","pos":[0,134],"source":"The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves."},{"content":"This property when set modifies the conditions under which the connection can be reset by Winsock.","pos":[135,233]},{"content":"Connection resets can still occur based on the IP protocol behavior.","pos":[234,302]}]}]},{"pos":[309,493],"content":"This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent.","nodes":[{"content":"This property controls the length of time that a connection-oriented connection will remain open after a call to <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> when data remains to be sent.","pos":[0,184],"source":"This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent."}]},{"pos":[500,760],"content":"When you call methods to send data to a peer, this data is placed in the outgoing network buffer. This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.","nodes":[{"content":"When you call methods to send data to a peer, this data is placed in the outgoing network buffer. This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.","pos":[0,260],"nodes":[{"content":"When you call methods to send data to a peer, this data is placed in the outgoing network buffer.","pos":[0,97]},{"content":"This property can be used to ensure that this data is sent to the remote host before the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.TcpClient.Close%2A&gt;</ph> method drops the connection.","pos":[98,260],"source":" This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection."}]}]},{"pos":[767,962],"content":"To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance.","nodes":[{"content":"To enable lingering, create a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> instance containing the desired values, and set the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property to this instance.","pos":[0,195],"source":"To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance."}]},{"pos":[969,1299],"content":"The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property.","nodes":[{"content":"The following table describes the behavior of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method for the possible values of the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.LingerOption.Enabled%2A&gt;</ph> property and the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property stored in the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property.","pos":[0,330],"source":"The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property."}]},{"pos":[1306,1325],"content":"LingerState.Enabled","nodes":[{"content":"LingerState.Enabled","pos":[0,19]}]},{"pos":[1326,1348],"content":"LingerState.LingerTime","nodes":[{"content":"LingerState.LingerTime","pos":[0,22]}]},{"pos":[1349,1357],"content":"Behavior","nodes":[{"content":"Behavior","pos":[0,8]}]},{"pos":[1436,1473],"content":"<ph id=\"ph1\">`false`</ph> (disabled), the default value","source":"`false` (disabled), the default value"},{"pos":[1474,1516],"content":"The time-out is not applicable, (default).","nodes":[{"content":"The time-out is not applicable, (default).","pos":[0,42]}]},{"pos":[1517,1594],"content":"Attempts to send pending data until the default IP protocol time-out expires.","nodes":[{"content":"Attempts to send pending data until the default IP protocol time-out expires.","pos":[0,77]}]},{"pos":[1599,1615],"content":"<ph id=\"ph1\">`true`</ph> (enabled)","source":"`true` (enabled)"},{"pos":[1616,1634],"content":"A nonzero time-out","nodes":[{"content":"A nonzero time-out","pos":[0,18]}]},{"pos":[1635,1764],"content":"Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.","nodes":[{"content":"Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.","pos":[0,129]}]},{"pos":[1769,1785],"content":"<ph id=\"ph1\">`true`</ph> (enabled)","source":"`true` (enabled)"},{"pos":[1786,1801],"content":"A zero timeout.","nodes":[{"content":"A zero timeout.","pos":[0,15]}]},{"pos":[1802,1910],"content":"Discards any pending data. For connection-oriented socket (TCP, for example), Winsock resets the connection.","nodes":[{"content":"Discards any pending data. For connection-oriented socket (TCP, for example), Winsock resets the connection.","pos":[0,108],"nodes":[{"content":"Discards any pending data.","pos":[0,26]},{"content":"For connection-oriented socket (TCP, for example), Winsock resets the connection.","pos":[27,108]}]}]},{"pos":[1918,2257],"content":"The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection. In most cases, the time-out computed by the stack is more relevant than one defined by an application. This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.","nodes":[{"content":"The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection. In most cases, the time-out computed by the stack is more relevant than one defined by an application. This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.","pos":[0,339],"nodes":[{"content":"The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.","pos":[0,116]},{"content":"In most cases, the time-out computed by the stack is more relevant than one defined by an application.","pos":[117,219]},{"content":"This is the default behavior for a socket when the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property is not set.","pos":[220,339],"source":" This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set."}]}]},{"pos":[2264,2523],"content":"When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.","nodes":[{"content":"When the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property stored in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.","pos":[0,259],"source":"When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override."}]}],"pos":[423064,425608],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Net.Sockets.LingerOption\"></xref> that specifies how to linger while closing a socket.","nodes":[{"pos":[0,107],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.LingerOption\"&gt;&lt;/xref&gt;</ph> that specifies how to linger while closing a socket.","source":"A <xref href=\"System.Net.Sockets.LingerOption\"></xref> that specifies how to linger while closing a socket."}],"pos":[426153,426261],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[426440,426496],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[426602,426670],"yaml":true},{"content":"Places a <xref href=\"System.Net.Sockets.Socket\"></xref> in a listening state.","nodes":[{"pos":[0,77],"content":"Places a <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> in a listening state.","source":"Places a <xref href=\"System.Net.Sockets.Socket\"></xref> in a listening state."}],"pos":[427929,428007],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts. The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance. To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value. <xref:System.Net.Sockets.Socket.Listen%2A> does not block.  \n  \n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.  \n  \n> [!NOTE]\n>  You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \n  \n> [!NOTE]\n>  The backlog parameter is limited to different values depending on the Operating System. You may specify a higher value, but the backlog will be limited based on the Operating System.","nodes":[{"pos":[0,453],"content":"<xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts. The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance. To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value. <xref:System.Net.Sockets.Socket.Listen%2A> does not block.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> causes a connection-oriented <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to listen for incoming connection attempts.","pos":[0,148],"source":"<xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts."},{"content":"The <ph id=\"ph1\">`backlog`</ph> parameter specifies the number of incoming connections that can be queued for acceptance.","pos":[149,252],"source":" The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance."},{"content":"To determine the maximum number of connections you can specify, retrieve the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionName.MaxConnections&gt;</ph> value.","pos":[253,394],"source":" To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> does not block.","pos":[395,453],"source":" <xref:System.Net.Sockets.Socket.Listen%2A> does not block."}]},{"pos":[460,927],"content":"If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.","nodes":[{"content":"If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.","pos":[0,467],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A&gt;</ph> property to obtain the specific error code.","pos":[0,166],"source":"If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[167,330]},{"content":"Use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to accept a connection from the queue.","pos":[331,467],"source":" Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue."}]}]},{"pos":[935,1172],"content":"[!NOTE]\n You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>.","leadings":["","> "],"nodes":[{"content":"You must call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method before calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> will throw a <ph id=\"ph4\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[9,235],"source":" You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]},{"pos":[1180,1405],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]},{"pos":[1413,1606],"content":"[!NOTE]\n The backlog parameter is limited to different values depending on the Operating System. You may specify a higher value, but the backlog will be limited based on the Operating System.","leadings":["","> "],"nodes":[{"content":" The backlog parameter is limited to different values depending on the Operating System. You may specify a higher value, but the backlog will be limited based on the Operating System.","pos":[8,191],"nodes":[{"content":"The backlog parameter is limited to different values depending on the Operating System.","pos":[1,88]},{"content":"You may specify a higher value, but the backlog will be limited based on the Operating System.","pos":[89,183]}]}]}],"pos":[428018,429638],"yaml":true,"extradata":"MT"},{"content":"The maximum length of the pending connections queue.","nodes":[{"pos":[0,52],"content":"The maximum length of the pending connections queue.","nodes":[{"content":"The maximum length of the pending connections queue.","pos":[0,52]}]}],"pos":[430323,430376],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[430550,430606],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[430712,430780],"yaml":true},{"content":"Gets the local endpoint.","nodes":[{"pos":[0,24],"content":"Gets the local endpoint.","nodes":[{"content":"Gets the local endpoint.","pos":[0,24]}]}],"pos":[432020,432045],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound. You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information. You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> method to retrieve the local port number.  \n  \n The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation. For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. For connectionless protocols, the first I/O operation would be any of the send or receive calls.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,578],"content":"The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound. You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information. You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> method to retrieve the local port number.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound. You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information. You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> method to retrieve the local port number.","pos":[0,578],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property gets an <ph id=\"ph2\">&lt;xref:System.Net.EndPoint&gt;</ph> that contains the local IP address and port number to which your <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is bound.","pos":[0,205],"source":"The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound."},{"content":"You must cast this <ph id=\"ph1\">&lt;xref:System.Net.EndPoint&gt;</ph> to an <ph id=\"ph2\">&lt;xref:System.Net.IPEndPoint&gt;</ph> before retrieving any information.","pos":[206,321],"source":" You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information."},{"content":"You can then call the <ph id=\"ph1\">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName&gt;</ph> method to retrieve the local <ph id=\"ph2\">&lt;xref:System.Net.IPAddress&gt;</ph>, and the <ph id=\"ph3\">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName&gt;</ph> method to retrieve the local port number.","pos":[322,578],"source":" You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> method to retrieve the local port number."}]}]},{"pos":[585,1205],"content":"The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation. For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. For connectionless protocols, the first I/O operation would be any of the send or receive calls.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation. For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. For connectionless protocols, the first I/O operation would be any of the send or receive calls.","pos":[0,620],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property is usually set after you make a call to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.","pos":[0,155],"source":"The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method."},{"content":"If you allow the system to assign your socket's local IP address and port number, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property will be set after the first I/O operation.","pos":[156,343],"source":" If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation."},{"content":"For connection-oriented protocols, the first I/O operation would be a call to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[344,523],"source":" For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"For connectionless protocols, the first I/O operation would be any of the send or receive calls.","pos":[524,620]}]}]},{"pos":[1213,1579],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1587,1812],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[432056,433879],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Net.EndPoint\"></xref> that the <xref href=\"System.Net.Sockets.Socket\"></xref> is using for communications.","nodes":[{"pos":[0,129],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph> that the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is using for communications.","source":"The <xref href=\"System.Net.EndPoint\"></xref> that the <xref href=\"System.Net.Sockets.Socket\"></xref> is using for communications."}],"pos":[434498,434628],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[434809,434865],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[434971,435039],"yaml":true},{"content":"Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.","nodes":[{"pos":[0,112],"content":"Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.","nodes":[{"content":"Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.","pos":[0,112]}]}],"pos":[436303,436416],"yaml":true},{"content":"Multicast is a scalable method for many-to-many communication on the Internet. A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.  \n  \n Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.","nodes":[{"pos":[0,243],"content":"Multicast is a scalable method for many-to-many communication on the Internet. A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.","nodes":[{"content":"Multicast is a scalable method for many-to-many communication on the Internet. A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.","pos":[0,243],"nodes":[{"content":"Multicast is a scalable method for many-to-many communication on the Internet.","pos":[0,78]},{"content":"A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.","pos":[79,243]}]}]},{"pos":[250,340],"content":"Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.","nodes":[{"content":"Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.","pos":[0,90]}]}],"pos":[436427,436772],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> receives outgoing multicast packets; otherwise, `false`.","nodes":[{"pos":[0,117],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> receives outgoing multicast packets; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> receives outgoing multicast packets; otherwise, `false`."}],"pos":[437285,437405],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[437590,437646],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[437752,437820],"yaml":true},{"content":"Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the stream <xref href=\"System.Net.Sockets.Socket\"></xref> is using the Nagle algorithm.","nodes":[{"pos":[0,167],"content":"Gets or sets a <ph id=\"ph1\">&lt;xref href=\"System.Boolean\"&gt;&lt;/xref&gt;</ph> value that specifies whether the stream <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is using the Nagle algorithm.","source":"Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the stream <xref href=\"System.Net.Sockets.Socket\"></xref> is using the Nagle algorithm."}],"pos":[439024,439192],"yaml":true},{"content":"The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances. A TCP packet consists of 40 bytes of header plus the data being sent. When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion. The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.  \n  \n The majority of network applications should use the Nagle algorithm.  \n  \n Setting this property on a User Datagram Protocol (UDP) socket will have no effect.","nodes":[{"pos":[0,752],"content":"The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances. A TCP packet consists of 40 bytes of header plus the data being sent. When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion. The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.","nodes":[{"content":"The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances. A TCP packet consists of 40 bytes of header plus the data being sent. When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion. The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.","pos":[0,752],"nodes":[{"content":"The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.","pos":[0,177]},{"content":"A TCP packet consists of 40 bytes of header plus the data being sent.","pos":[178,247]},{"content":"When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.","pos":[248,571]},{"content":"The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.","pos":[572,752]}]}]},{"pos":[759,827],"content":"The majority of network applications should use the Nagle algorithm.","nodes":[{"content":"The majority of network applications should use the Nagle algorithm.","pos":[0,68]}]},{"pos":[834,917],"content":"Setting this property on a User Datagram Protocol (UDP) socket will have no effect.","nodes":[{"content":"Setting this property on a User Datagram Protocol (UDP) socket will have no effect.","pos":[0,83]}]}],"pos":[439203,440127],"yaml":true,"extradata":"MT"},{"content":"`false` if the <xref href=\"System.Net.Sockets.Socket\"></xref> uses the Nagle algorithm; otherwise, `true`. The default is `false`.","nodes":[{"pos":[0,130],"content":"`false` if the <xref href=\"System.Net.Sockets.Socket\"></xref> uses the Nagle algorithm; otherwise, `true`. The default is `false`.","nodes":[{"content":"<ph id=\"ph1\">`false`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> uses the Nagle algorithm; otherwise, <ph id=\"ph3\">`true`</ph>.","pos":[0,106],"source":"`false` if the <xref href=\"System.Net.Sockets.Socket\"></xref> uses the Nagle algorithm; otherwise, `true`."},{"content":"The default is <ph id=\"ph1\">`false`</ph>.","pos":[107,130],"source":" The default is `false`."}]}],"pos":[440620,440753],"yaml":true},{"content":"An error occurred when attempting to access the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,95],"content":"An error occurred when attempting to access the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"An error occurred when attempting to access the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[440928,441024],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[441130,441198],"yaml":true},{"content":"Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).","nodes":[{"pos":[0,114],"content":"Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).","nodes":[{"content":"Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).","pos":[0,114]}]}],"pos":[442444,442559],"yaml":true},{"content":"The operating system may support both IPv4 and IPv6 protocols.","nodes":[{"pos":[0,62],"content":"The operating system may support both IPv4 and IPv6 protocols.","nodes":[{"content":"The operating system may support both IPv4 and IPv6 protocols.","pos":[0,62]}]}],"pos":[442570,442633],"yaml":true,"extradata":"MT"},{"content":"`true` if the operating system and network adaptors support the IPv4 protocol; otherwise, `false`.","nodes":[{"pos":[0,98],"content":"<ph id=\"ph1\">`true`</ph> if the operating system and network adaptors support the IPv4 protocol; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the operating system and network adaptors support the IPv4 protocol; otherwise, `false`."}],"pos":[442757,442858],"yaml":true},{"content":"Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).","nodes":[{"pos":[0,114],"content":"Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).","nodes":[{"content":"Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).","pos":[0,114]}]}],"pos":[444175,444290],"yaml":true},{"content":"The operating system may support both IPv4 and IPv6 protocols.","nodes":[{"pos":[0,62],"content":"The operating system may support both IPv4 and IPv6 protocols.","nodes":[{"content":"The operating system may support both IPv4 and IPv6 protocols.","pos":[0,62]}]}],"pos":[444301,444364],"yaml":true,"extradata":"MT"},{"content":"`true` if the operating system and network adaptors support the IPv6 protocol; otherwise, `false`.","nodes":[{"pos":[0,98],"content":"<ph id=\"ph1\">`true`</ph> if the operating system and network adaptors support the IPv6 protocol; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the operating system and network adaptors support the IPv6 protocol; otherwise, `false`."}],"pos":[444488,444589],"yaml":true},{"content":"Determines the status of the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,76],"content":"Determines the status of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Determines the status of the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[446033,446110],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>. Specify <xref:System.Net.Sockets.SelectMode?displayProperty=fullName> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable. Specify <xref:System.Net.Sockets.SelectMode?displayProperty=fullName> to determine if the <xref:System.Net.Sockets.Socket> is writable. Use <xref:System.Net.Sockets.SelectMode?displayProperty=fullName> to detect an error condition. <xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses. Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response. If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully. You must attempt to send or receive data to detect these kinds of errors.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,886],"content":"The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>. Specify <xref:System.Net.Sockets.SelectMode?displayProperty=fullName> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable. Specify <xref:System.Net.Sockets.SelectMode?displayProperty=fullName> to determine if the <xref:System.Net.Sockets.Socket> is writable. Use <xref:System.Net.Sockets.SelectMode?displayProperty=fullName> to detect an error condition. <xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses. Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response. If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method will check the state of the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,113],"source":"The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>."},{"content":"Specify <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SelectMode?displayProperty=fullName&gt;</ph> for the <ph id=\"ph2\">`selectMode`</ph> parameter to determine if the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is readable.","pos":[114,280],"source":" Specify <xref:System.Net.Sockets.SelectMode?displayProperty=fullName> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable."},{"content":"Specify <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SelectMode?displayProperty=fullName&gt;</ph> to determine if the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is writable.","pos":[281,416],"source":" Specify <xref:System.Net.Sockets.SelectMode?displayProperty=fullName> to determine if the <xref:System.Net.Sockets.Socket> is writable."},{"content":"Use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SelectMode?displayProperty=fullName&gt;</ph> to detect an error condition.","pos":[417,512],"source":" Use <xref:System.Net.Sockets.SelectMode?displayProperty=fullName> to detect an error condition."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> will block execution until the specified time period, measured in <ph id=\"ph2\">`microseconds`</ph>, elapses.","pos":[513,644],"source":" <xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses."},{"content":"Set the <ph id=\"ph1\">`microSeconds`</ph> parameter to a negative integer if you would like to wait indefinitely for a response.","pos":[645,754],"source":" Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response."},{"content":"If you want to check the status of multiple sockets, you might prefer to use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> method.","pos":[755,886],"source":" If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method."}]},{"pos":[894,1260],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[1268,1500],"content":"[!NOTE]\n This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully. You must attempt to send or receive data to detect these kinds of errors.","leadings":["","> "],"nodes":[{"content":" This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully. You must attempt to send or receive data to detect these kinds of errors.","pos":[8,230],"nodes":[{"content":"This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.","pos":[1,148]},{"content":"You must attempt to send or receive data to detect these kinds of errors.","pos":[149,222]}]}]},{"pos":[1508,1733],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[446121,447866],"yaml":true,"extradata":"MT"},{"content":"The time to wait for a response, in microseconds.","nodes":[{"pos":[0,49],"content":"The time to wait for a response, in microseconds.","nodes":[{"content":"The time to wait for a response, in microseconds.","pos":[0,49]}]}],"pos":[448574,448624],"yaml":true},{"content":"One of the <xref href=\"System.Net.Sockets.SelectMode\"></xref> values.","nodes":[{"pos":[0,69],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SelectMode\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SelectMode\"></xref> values."}],"pos":[448700,448770],"yaml":true},{"content":"The status of the <xref href=\"System.Net.Sockets.Socket\"></xref> based on the polling mode value passed in the <code>mode</code> parameter.  \n  \n <table><thead><tr><th> Mode  \n  \n </th><th> Return Value  \n  \n </th></tr></thead><tbody><tr><td><xref href=\"System.Net.Sockets.SelectMode.SelectRead\"></xref></td><td>`true` if <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> has been called and a connection is pending;  \n  \n -or-  \n  \n `true` if data is available for reading;  \n  \n -or-  \n  \n `true` if the connection has been closed, reset, or terminated;  \n  \n otherwise, returns `false`.  \n  \n </td></tr><tr><td><xref href=\"System.Net.Sockets.SelectMode.SelectWrite\"></xref></td><td>`true`, if processing a <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\"></xref>, and the connection has succeeded;  \n  \n -or-  \n  \n `true` if data can be sent;  \n  \n otherwise, returns `false`.  \n  \n </td></tr><tr><td><xref href=\"System.Net.Sockets.SelectMode.SelectError\"></xref></td><td>`true` if processing a <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\"></xref> that does not block, and the connection has failed;  \n  \n -or-  \n  \n `true` if <xref href=\"System.Net.Sockets.SocketOptionName.OutOfBandInline\"></xref> is not set and out-of-band data is available;  \n  \n otherwise, returns `false`.  \n  \n </td></tr></tbody></table>","nodes":[{"pos":[0,139],"content":"The status of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> based on the polling mode value passed in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">mode</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"The status of the <xref href=\"System.Net.Sockets.Socket\"></xref> based on the polling mode value passed in the <code>mode</code> parameter."},{"pos":[146,434],"content":"<table><thead><tr><th> Mode  \n  \n </th><th> Return Value  \n  \n </th></tr></thead><tbody><tr><td><xref href=\"System.Net.Sockets.SelectMode.SelectRead\"></xref></td><td>`true` if <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> has been called and a connection is pending;","nodes":[{"content":"Mode","pos":[23,32],"source":" Mode  \n  \n "},{"content":"Return Value","pos":[44,61],"source":" Return Value  \n  \n "},{"content":"<ph id=\"ph1\">`true`</ph> if <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"&gt;&lt;/xref&gt;</ph> has been called and a connection is pending;","pos":[166,288],"source":"`true` if <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> has been called and a connection is pending;"}]},{"pos":[441,445],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[452,492],"content":"<ph id=\"ph1\">`true`</ph> if data is available for reading;","source":"`true` if data is available for reading;"},{"pos":[499,503],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[510,573],"content":"<ph id=\"ph1\">`true`</ph> if the connection has been closed, reset, or terminated;","source":"`true` if the connection has been closed, reset, or terminated;"},{"pos":[580,607],"content":"otherwise, returns <ph id=\"ph1\">`false`</ph>.","source":"otherwise, returns `false`."},{"pos":[614,837],"content":"</td></tr><tr><td><xref href=\"System.Net.Sockets.SelectMode.SelectWrite\"></xref></td><td>`true`, if processing a <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\"></xref>, and the connection has succeeded;","nodes":[{"content":"<ph id=\"ph1\">`true`</ph>, if processing a <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\"&gt;&lt;/xref&gt;</ph>, and the connection has succeeded;","pos":[89,223],"source":"`true`, if processing a <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\"></xref>, and the connection has succeeded;"}]},{"pos":[844,848],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[855,882],"content":"<ph id=\"ph1\">`true`</ph> if data can be sent;","source":"`true` if data can be sent;"},{"pos":[889,916],"content":"otherwise, returns <ph id=\"ph1\">`false`</ph>.","source":"otherwise, returns `false`."},{"pos":[923,1162],"content":"</td></tr><tr><td><xref href=\"System.Net.Sockets.SelectMode.SelectError\"></xref></td><td>`true` if processing a <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\"></xref> that does not block, and the connection has failed;","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if processing a <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\"&gt;&lt;/xref&gt;</ph> that does not block, and the connection has failed;","pos":[89,239],"source":"`true` if processing a <xref href=\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\"></xref> that does not block, and the connection has failed;"}]},{"pos":[1169,1173],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[1180,1308],"content":"<ph id=\"ph1\">`true`</ph> if <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketOptionName.OutOfBandInline\"&gt;&lt;/xref&gt;</ph> is not set and out-of-band data is available;","source":"`true` if <xref href=\"System.Net.Sockets.SocketOptionName.OutOfBandInline\"></xref> is not set and out-of-band data is available;"},{"pos":[1315,1342],"content":"otherwise, returns <ph id=\"ph1\">`false`</ph>.","source":"otherwise, returns `false`."}],"pos":[448828,450256],"yaml":true},{"content":"The <code>mode</code> parameter is not one of the <xref href=\"System.Net.Sockets.SelectMode\"></xref> values.","nodes":[{"pos":[0,108],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">mode</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is not one of the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SelectMode\"&gt;&lt;/xref&gt;</ph> values.","source":"The <code>mode</code> parameter is not one of the <xref href=\"System.Net.Sockets.SelectMode\"></xref> values."}],"pos":[450416,450525],"yaml":true},{"content":"An error occurred when attempting to access the socket. See remarks below.","nodes":[{"pos":[0,74],"content":"An error occurred when attempting to access the socket. See remarks below.","nodes":[{"content":"An error occurred when attempting to access the socket. See remarks below.","pos":[0,74],"nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]},{"content":"See remarks below.","pos":[56,74]}]}]}],"pos":[450639,450714],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[450820,450888],"yaml":true},{"content":"Gets the protocol type of the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,77],"content":"Gets the protocol type of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Gets the protocol type of the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[452122,452200],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>.","nodes":[{"pos":[0,196],"content":"The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> property is set when the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created, and specifies the protocol used by that <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,196],"source":"The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>."}]}],"pos":[452211,452408],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Net.Sockets.ProtocolType\"></xref> values.","nodes":[{"pos":[0,71],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.ProtocolType\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.ProtocolType\"></xref> values."}],"pos":[453146,453218],"yaml":true},{"content":"Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into a receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.","nodes":[{"pos":[0,169],"content":"Receives data from a bound <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> into a receive buffer, using the specified <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>.","source":"Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into a receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>."}],"pos":[454945,455115],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.  \n  \n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \n  \n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. An error occurred when attempting to access the socket. See Remarks below. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \n  \n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \n  \n If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,257],"content":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.","pos":[0,257],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.","pos":[0,142],"source":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read."},{"content":"You can call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.","pos":[143,257],"source":" You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets."}]}]},{"pos":[264,1005],"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","pos":[0,741],"nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>The <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[0,517],"source":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you are using a connectionless protocol, you can also use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.","pos":[518,638],"source":" If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.","pos":[639,741],"source":" <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host."}]}]},{"pos":[1012,1925],"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. An error occurred when attempting to access the socket. See Remarks below. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","nodes":[{"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. An error occurred when attempting to access the socket. See Remarks below. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","pos":[0,913],"nodes":[{"content":"If no data is available for reading, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,245],"source":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[246,390],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[391,627],"source":" If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"An error occurred when attempting to access the socket.","pos":[628,683]},{"content":"See Remarks below.","pos":[684,702]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.","pos":[703,820],"source":" You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.","pos":[821,913],"source":" When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation."}]}]},{"pos":[1932,2444],"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","nodes":[{"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","pos":[0,512],"nodes":[{"content":"If you are using a connection-oriented <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the size parameter.","pos":[0,226],"source":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[227,512],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes."}]}]},{"pos":[2451,2917],"content":"If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.","nodes":[{"content":"If you are using a connectionless <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.","pos":[0,247],"source":"If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method."},{"content":"If the datagram you receive is larger than the size of the <ph id=\"ph1\">`buffer`</ph> parameter, <ph id=\"ph2\">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.","pos":[248,466],"source":" If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown."}]},{"pos":[2925,3291],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3299,3524],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[455126,458667],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.","nodes":[{"pos":[0,101],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data."}],"pos":[458916,459018],"yaml":true},{"content":"The position in the <code>buffer</code> parameter to store the received data.","nodes":[{"pos":[0,77],"content":"The position in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">buffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter to store the received data.","source":"The position in the <code>buffer</code> parameter to store the received data."}],"pos":[459079,459157],"yaml":true},{"content":"The number of bytes to receive.","nodes":[{"pos":[0,31],"content":"The number of bytes to receive.","nodes":[{"content":"The number of bytes to receive.","pos":[0,31]}]}],"pos":[459216,459248],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[459332,459421],"yaml":true},{"content":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.","nodes":[{"pos":[0,90],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketError\"&gt;&lt;/xref&gt;</ph> object that stores the socket error.","source":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error."}],"pos":[459503,459594],"yaml":true},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[459650,459680],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[459843,459874],"yaml":true},{"content":"<code>offset</code> is less than 0.  \n  \n -or-  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n -or-  \n  \n <code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.","source":"<code>offset</code> is less than 0."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,123],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>offset</code> is greater than the length of <code>buffer</code>."},{"pos":[130,134],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[141,174],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[181,185],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[192,313],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id=\"ph3\">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.","source":"<code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter."}],"pos":[459988,460316],"yaml":true},{"content":"<code>socketFlags</code> is not a valid combination of values.  \n  \n -or-  \n  \n The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"></xref> property is not set.  \n  \n -or-  \n  \n An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.","source":"<code>socketFlags</code> is not a valid combination of values."},{"pos":[69,73],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[80,165],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"&gt;&lt;/xref&gt;</ph> property is not set.","source":"The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"></xref> property is not set."},{"pos":[172,176],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[183,283],"content":"An operating system error occurs while accessing the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[460430,460728],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[460834,460902],"yaml":true},{"content":"A caller in the call stack does not have the required permissions.","nodes":[{"pos":[0,66],"content":"A caller in the call stack does not have the required permissions.","nodes":[{"content":"A caller in the call stack does not have the required permissions.","pos":[0,66]}]}],"pos":[461014,461081],"yaml":true},{"content":"Receives the specified number of bytes from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into the specified offset position of the receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.","nodes":[{"pos":[0,229],"content":"Receives the specified number of bytes from a bound <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> into the specified offset position of the receive buffer, using the specified <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>.","source":"Receives the specified number of bytes from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into the specified offset position of the receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>."}],"pos":[462604,462834],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.  \n  \n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \n  \n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. An error occurred when attempting to access the socket. See Remarks below. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \n  \n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \n  \n If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,257],"content":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.","pos":[0,257],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.","pos":[0,142],"source":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read."},{"content":"You can call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.","pos":[143,257],"source":" You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets."}]}]},{"pos":[264,1007],"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","pos":[0,743],"nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.","pos":[0,293],"source":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[294,519],"source":" The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you are using a connectionless protocol, you can also use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.","pos":[520,640],"source":" If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.","pos":[641,743],"source":" <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host."}]}]},{"pos":[1014,1927],"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. An error occurred when attempting to access the socket. See Remarks below. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","nodes":[{"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. An error occurred when attempting to access the socket. See Remarks below. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","pos":[0,913],"nodes":[{"content":"If no data is available for reading, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,245],"source":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[246,390],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[391,627],"source":" If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"An error occurred when attempting to access the socket.","pos":[628,683]},{"content":"See Remarks below.","pos":[684,702]},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.","pos":[703,820],"source":" You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.","pos":[821,913],"source":" When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation."}]}]},{"pos":[1934,2446],"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","nodes":[{"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","pos":[0,512],"nodes":[{"content":"If you are using a connection-oriented <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the size parameter.","pos":[0,226],"source":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[227,512],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes."}]}]},{"pos":[2453,2919],"content":"If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.","nodes":[{"content":"If you are using a connectionless <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.","pos":[0,247],"source":"If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method."},{"content":"If the datagram you receive is larger than the size of the <ph id=\"ph1\">`buffer`</ph> parameter, <ph id=\"ph2\">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.","pos":[248,466],"source":" If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown."}]},{"pos":[2927,3293],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3301,3526],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[462845,466388],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data.","nodes":[{"pos":[0,97],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data."}],"pos":[467170,467268],"yaml":true},{"content":"The location in <code>buffer</code> to store the received data.","nodes":[{"pos":[0,63],"content":"The location in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">buffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> to store the received data.","source":"The location in <code>buffer</code> to store the received data."}],"pos":[467329,467393],"yaml":true},{"content":"The number of bytes to receive.","nodes":[{"pos":[0,31],"content":"The number of bytes to receive.","nodes":[{"content":"The number of bytes to receive.","pos":[0,31]}]}],"pos":[467452,467484],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[467568,467657],"yaml":true},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[467713,467743],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[467906,467937],"yaml":true},{"content":"<code>offset</code> is less than 0.  \n  \n -or-  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n -or-  \n  \n <code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.","source":"<code>offset</code> is less than 0."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,123],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>offset</code> is greater than the length of <code>buffer</code>."},{"pos":[130,134],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[141,174],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[181,185],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[192,313],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id=\"ph3\">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.","source":"<code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter."}],"pos":[468051,468379],"yaml":true},{"content":"<code>socketFlags</code> is not a valid combination of values.  \n  \n -or-  \n  \n The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"></xref> property was not set.  \n  \n -or-  \n  \n An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.","source":"<code>socketFlags</code> is not a valid combination of values."},{"pos":[69,73],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[80,166],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"&gt;&lt;/xref&gt;</ph> property was not set.","source":"The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"></xref> property was not set."},{"pos":[173,177],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[184,284],"content":"An operating system error occurs while accessing the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[468493,468792],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[468898,468966],"yaml":true},{"content":"A caller in the call stack does not have the required permissions.","nodes":[{"pos":[0,66],"content":"A caller in the call stack does not have the required permissions.","nodes":[{"content":"A caller in the call stack does not have the required permissions.","pos":[0,66]}]}],"pos":[469078,469145],"yaml":true},{"content":"Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into the list of receive buffers, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.","nodes":[{"pos":[0,180],"content":"Receives data from a bound <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> into the list of receive buffers, using the specified <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>.","source":"Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into the list of receive buffers, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>."}],"pos":[470899,471080],"yaml":true},{"content":"This method reads data into the `buffers` parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.  \n  \n This overload requires you to provide one or more receive buffers. The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.  \n  \n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \n  \n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \n  \n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \n  \n If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,173],"content":"This method reads data into the `buffers` parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.","nodes":[{"content":"This method reads data into the <ph id=\"ph1\">`buffers`</ph> parameter and returns the number of bytes successfully read.","pos":[0,102],"source":"This method reads data into the `buffers` parameter and returns the number of bytes successfully read."},{"content":"You can call from both connection-oriented and connectionless sockets.","pos":[103,173]}]},{"pos":[180,350],"content":"This overload requires you to provide one or more receive buffers. The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.","nodes":[{"content":"This overload requires you to provide one or more receive buffers. The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.","pos":[0,170],"nodes":[{"content":"This overload requires you to provide one or more receive buffers.","pos":[0,66]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.","pos":[67,170],"source":" The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>."}]}]},{"pos":[357,1111],"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","pos":[0,754],"nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.","pos":[0,293],"source":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[294,530],"source":" The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you are using a connectionless protocol, you can also use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.","pos":[531,651],"source":" If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.","pos":[652,754],"source":" <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host."}]}]},{"pos":[1118,1952],"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","nodes":[{"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","pos":[0,834],"nodes":[{"content":"If no data is available for reading, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,245],"source":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call throws a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[246,386],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[387,623],"source":" If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.","pos":[624,741],"source":" You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.","pos":[742,834],"source":" When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation."}]}]},{"pos":[1959,2442],"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","nodes":[{"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","pos":[0,483],"nodes":[{"content":"If you are using a connection-oriented <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.","pos":[0,197],"source":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[198,483],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes."}]}]},{"pos":[2449,2916],"content":"If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.","nodes":[{"content":"If you are using a connectionless <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>,<ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.","pos":[0,246],"source":"If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method."},{"content":"If the datagram you receive is larger than the size of the <ph id=\"ph1\">`buffers`</ph> parameter, <ph id=\"ph2\">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.","pos":[247,467],"source":" If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown."}]},{"pos":[2924,3290],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3298,3523],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[471091,474633],"yaml":true,"extradata":"MT"},{"content":"A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the received data.","nodes":[{"pos":[0,127],"content":"A list of <ph id=\"ph1\">&lt;xref href=\"System.ArraySegment`1\"&gt;&lt;/xref&gt;</ph>s of type <ph id=\"ph2\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the received data.","source":"A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the received data."}],"pos":[475006,475134],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[475218,475307],"yaml":true},{"content":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.","nodes":[{"pos":[0,90],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketError\"&gt;&lt;/xref&gt;</ph> object that stores the socket error.","source":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error."}],"pos":[475389,475480],"yaml":true},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[475536,475566],"yaml":true},{"content":"<code>buffers</code> is `null`.  \n  \n -or-  \n  \n <code>buffers</code>.Count is zero.","nodes":[{"pos":[0,31],"content":"<ph id=\"ph1\">&lt;code&gt;buffers&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffers</code> is `null`."},{"pos":[38,42],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[49,84],"content":"<ph id=\"ph1\">&lt;code&gt;buffers&lt;/code&gt;</ph>.Count is zero.","source":"<code>buffers</code>.Count is zero."}],"pos":[475729,475820],"yaml":true},{"content":"An error occurred while attempting to access the socket.","nodes":[{"pos":[0,56],"content":"An error occurred while attempting to access the socket.","nodes":[{"content":"An error occurred while attempting to access the socket.","pos":[0,56]}]}],"pos":[475934,475991],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[476097,476165],"yaml":true},{"content":"Receives the specified number of bytes of data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into a receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.","nodes":[{"pos":[0,202],"content":"Receives the specified number of bytes of data from a bound <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> into a receive buffer, using the specified <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>.","source":"Receives the specified number of bytes of data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into a receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>."}],"pos":[477777,477980],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.  \n  \n This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>.  \n  \n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \n  \n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.  \n  \n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \n  \n If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,259],"content":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the <ph id=\"ph2\">`buffer`</ph> parameter and returns the number of bytes successfully read.","pos":[0,144],"source":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read."},{"content":"You can call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.","pos":[145,259],"source":" You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets."}]},{"pos":[266,424],"content":"This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>.","nodes":[{"content":"This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.","pos":[0,158],"source":"This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>."}]},{"pos":[431,1174],"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","pos":[0,743],"nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.","pos":[0,293],"source":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[294,519],"source":" The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you are using a connectionless protocol, you can also use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.","pos":[520,640],"source":" If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.","pos":[641,743],"source":" <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host."}]}]},{"pos":[1181,2020],"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.","nodes":[{"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.","pos":[0,839],"nodes":[{"content":"If no data is available for reading, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,245],"source":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[246,390],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[391,627],"source":" If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.","pos":[628,745],"source":" You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry your receive operation.","pos":[746,839],"source":" When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation."}]}]},{"pos":[2027,2541],"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","nodes":[{"content":"If you are using a connection-oriented <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the <ph id=\"ph3\">`size`</ph> parameter.","pos":[0,228],"source":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[229,514],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes."}]},{"pos":[2548,3014],"content":"If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.","nodes":[{"content":"If you are using a connectionless <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.","pos":[0,247],"source":"If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method."},{"content":"If the datagram you receive is larger than the size of the <ph id=\"ph1\">`buffer`</ph> parameter, <ph id=\"ph2\">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.","pos":[248,466],"source":" If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown."}]},{"pos":[3022,3388],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3396,3621],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[477991,481631],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.","nodes":[{"pos":[0,101],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data."}],"pos":[482364,482466],"yaml":true},{"content":"The number of bytes to receive.","nodes":[{"pos":[0,31],"content":"The number of bytes to receive.","nodes":[{"content":"The number of bytes to receive.","pos":[0,31]}]}],"pos":[482525,482557],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[482641,482730],"yaml":true},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[482786,482816],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[482979,483010],"yaml":true},{"content":"<code>size</code> exceeds the size of <code>buffer</code>.","nodes":[{"pos":[0,58],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> exceeds the size of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>size</code> exceeds the size of <code>buffer</code>."}],"pos":[483124,483183],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[483297,483353],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[483459,483527],"yaml":true},{"content":"A caller in the call stack does not have the required permissions.","nodes":[{"pos":[0,66],"content":"A caller in the call stack does not have the required permissions.","nodes":[{"content":"A caller in the call stack does not have the required permissions.","pos":[0,66]}]}],"pos":[483639,483706],"yaml":true},{"content":"Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into the list of receive buffers.","nodes":[{"pos":[0,107],"content":"Receives data from a bound <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> into the list of receive buffers.","source":"Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into the list of receive buffers."}],"pos":[485193,485301],"yaml":true},{"content":"This method reads data into the buffers parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.  \n  \n This overload requires you to provide one or more receive buffers.  \n  \n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \n  \n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \n  \n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \n  \n If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n **Note** This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,171],"content":"This method reads data into the buffers parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.","nodes":[{"content":"This method reads data into the buffers parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.","pos":[0,171],"nodes":[{"content":"This method reads data into the buffers parameter and returns the number of bytes successfully read.","pos":[0,100]},{"content":"You can call from both connection-oriented and connectionless sockets.","pos":[101,171]}]}]},{"pos":[178,244],"content":"This overload requires you to provide one or more receive buffers.","nodes":[{"content":"This overload requires you to provide one or more receive buffers.","pos":[0,66]}]},{"pos":[251,1005],"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","pos":[0,754],"nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.","pos":[0,293],"source":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[294,530],"source":" The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you are using a connectionless protocol, you can also use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.","pos":[531,651],"source":" If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.","pos":[652,754],"source":" <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host."}]}]},{"pos":[1012,1850],"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","nodes":[{"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","pos":[0,838],"nodes":[{"content":"If no data is available for reading, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,245],"source":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[246,390],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[391,627],"source":" If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.","pos":[628,745],"source":" You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.","pos":[746,838],"source":" When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation."}]}]},{"pos":[1857,2340],"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","nodes":[{"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","pos":[0,483],"nodes":[{"content":"If you are using a connection-oriented <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.","pos":[0,197],"source":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[198,483],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes."}]}]},{"pos":[2347,2817],"content":"If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.","nodes":[{"content":"If you are using a connectionless <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.","pos":[0,249],"source":"If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method."},{"content":"If the datagram you receive is larger than the size of the <ph id=\"ph1\">`buffers`</ph> parameter, <ph id=\"ph2\">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.","pos":[250,470],"source":" If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown."}]},{"pos":[2825,3191],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3198,3421],"content":"**Note** This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept> This member outputs trace information when you enable network tracing in your application.","pos":[0,99],"source":"**Note** This member outputs trace information when you enable network tracing in your application."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[100,223],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}],"pos":[485312,488751],"yaml":true,"extradata":"MT"},{"content":"A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the received data.","nodes":[{"pos":[0,127],"content":"A list of <ph id=\"ph1\">&lt;xref href=\"System.ArraySegment`1\"&gt;&lt;/xref&gt;</ph>s of type <ph id=\"ph2\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the received data.","source":"A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the received data."}],"pos":[488989,489117],"yaml":true},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[489173,489203],"yaml":true},{"content":"The <code>buffer</code> parameter is `null`.","nodes":[{"pos":[0,44],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">buffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>buffer</code> parameter is `null`."}],"pos":[489366,489411],"yaml":true},{"content":"An error occurred while attempting to access the socket.","nodes":[{"pos":[0,56],"content":"An error occurred while attempting to access the socket.","nodes":[{"content":"An error occurred while attempting to access the socket.","pos":[0,56]}]}],"pos":[489525,489582],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[489688,489756],"yaml":true},{"content":"Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into a receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.","nodes":[{"pos":[0,169],"content":"Receives data from a bound <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> into a receive buffer, using the specified <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>.","source":"Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into a receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>."}],"pos":[491224,491394],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.  \n  \n This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>. The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.  \n  \n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \n  \n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A>method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.  \n  \n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \n  \n If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,257],"content":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.","pos":[0,257],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.","pos":[0,142],"source":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read."},{"content":"You can call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.","pos":[143,257],"source":" You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets."}]}]},{"pos":[264,472],"content":"This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>. The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.","nodes":[{"content":"This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>. The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.","pos":[0,208],"nodes":[{"content":"This overload only requires you to provide a receive buffer and the necessary <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.","pos":[0,116],"source":"This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>."},{"content":"The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.","pos":[117,208]}]}]},{"pos":[479,1222],"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","pos":[0,743],"nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.","pos":[0,293],"source":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[294,519],"source":" The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you are using a connectionless protocol, you can also use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.","pos":[520,640],"source":" If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.","pos":[641,743],"source":" <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host."}]}]},{"pos":[1229,1797],"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A>method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.","nodes":[{"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A>method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.","pos":[0,568],"nodes":[{"content":"If no data is available for reading, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available.","pos":[0,127],"source":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available."},{"content":"If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>method will complete immediately and throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[128,356],"source":" If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A>method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.","pos":[357,474],"source":" You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry your receive operation.","pos":[475,568],"source":" When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation."}]}]},{"pos":[1804,2286],"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","nodes":[{"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","pos":[0,482],"nodes":[{"content":"If you are using a connection-oriented <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available up to the size of the buffer.","pos":[0,196],"source":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[197,482],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes."}]}]},{"pos":[2293,2761],"content":"If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.","nodes":[{"content":"If you are using a connectionless <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.","pos":[0,249],"source":"If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method."},{"content":"If the datagram you receive is larger than the size of the <ph id=\"ph1\">`buffer`</ph> parameter, <ph id=\"ph2\">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.","pos":[250,468],"source":" If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown."}]},{"pos":[2769,3135],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3143,3368],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[491405,494792],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.","nodes":[{"pos":[0,101],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data."}],"pos":[495554,495656],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[495740,495829],"yaml":true},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[495885,495915],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[496078,496109],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[496223,496279],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[496385,496453],"yaml":true},{"content":"A caller in the call stack does not have the required permissions.","nodes":[{"pos":[0,66],"content":"A caller in the call stack does not have the required permissions.","nodes":[{"content":"A caller in the call stack does not have the required permissions.","pos":[0,66]}]}],"pos":[496565,496632],"yaml":true},{"content":"Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into a receive buffer.","nodes":[{"pos":[0,96],"content":"Receives data from a bound <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> into a receive buffer.","source":"Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into a receive buffer."}],"pos":[497903,498000],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.  \n  \n This overload only requires you to provide a receive buffer. The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.  \n  \n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \n  \n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \n  \n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \n  \n If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,257],"content":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.","pos":[0,257],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.","pos":[0,142],"source":"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read."},{"content":"You can call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.","pos":[143,257],"source":" You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets."}]}]},{"pos":[264,522],"content":"This overload only requires you to provide a receive buffer. The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.","nodes":[{"content":"This overload only requires you to provide a receive buffer. The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.","pos":[0,258],"nodes":[{"content":"This overload only requires you to provide a receive buffer.","pos":[0,60]},{"content":"The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.","pos":[61,258],"source":" The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>."}]}]},{"pos":[529,1272],"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","pos":[0,743],"nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.","pos":[0,293],"source":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[294,519],"source":" The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you are using a connectionless protocol, you can also use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.","pos":[520,640],"source":" If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.","pos":[641,743],"source":" <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host."}]}]},{"pos":[1279,2117],"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","nodes":[{"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","pos":[0,838],"nodes":[{"content":"If no data is available for reading, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,245],"source":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[246,390],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[391,627],"source":" If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.","pos":[628,745],"source":" You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.","pos":[746,838],"source":" When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation."}]}]},{"pos":[2124,2607],"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","nodes":[{"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","pos":[0,483],"nodes":[{"content":"If you are using a connection-oriented <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.","pos":[0,197],"source":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[198,483],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes."}]}]},{"pos":[2614,3080],"content":"If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.","nodes":[{"content":"If you are using a connectionless <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.","pos":[0,247],"source":"If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method."},{"content":"If the datagram you receive is larger than the size of the <ph id=\"ph1\">`buffer`</ph> parameter, <ph id=\"ph2\">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.","pos":[248,466],"source":" If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown."}]},{"pos":[3088,3454],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3462,3687],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[498011,501717],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.","nodes":[{"pos":[0,101],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data."}],"pos":[502363,502465],"yaml":true},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[502521,502551],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[502714,502745],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[502859,502915],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[503021,503089],"yaml":true},{"content":"A caller in the call stack does not have the required permissions.","nodes":[{"pos":[0,66],"content":"A caller in the call stack does not have the required permissions.","nodes":[{"content":"A caller in the call stack does not have the required permissions.","pos":[0,66]}]}],"pos":[503201,503268],"yaml":true},{"content":"Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into the list of receive buffers, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.","nodes":[{"pos":[0,180],"content":"Receives data from a bound <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> into the list of receive buffers, using the specified <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>.","source":"Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into the list of receive buffers, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>."}],"pos":[504887,505068],"yaml":true},{"content":"This method reads data into the `buffers` parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.  \n  \n This overload requires you to provide one or more receive buffers. The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.  \n  \n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \n  \n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \n  \n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \n  \n If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,173],"content":"This method reads data into the `buffers` parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.","nodes":[{"content":"This method reads data into the <ph id=\"ph1\">`buffers`</ph> parameter and returns the number of bytes successfully read.","pos":[0,102],"source":"This method reads data into the `buffers` parameter and returns the number of bytes successfully read."},{"content":"You can call from both connection-oriented and connectionless sockets.","pos":[103,173]}]},{"pos":[180,350],"content":"This overload requires you to provide one or more receive buffers. The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.","nodes":[{"content":"This overload requires you to provide one or more receive buffers. The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.","pos":[0,170],"nodes":[{"content":"This overload requires you to provide one or more receive buffers.","pos":[0,66]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.","pos":[67,170],"source":" The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>."}]}]},{"pos":[357,1111],"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.","pos":[0,754],"nodes":[{"content":"If you are using a connection-oriented protocol, you must either call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.","pos":[0,293],"source":"If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[294,530],"source":" The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you are using a connectionless protocol, you can also use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.","pos":[531,651],"source":" If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.","pos":[652,754],"source":" <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host."}]}]},{"pos":[1118,1952],"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","nodes":[{"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","pos":[0,834],"nodes":[{"content":"If no data is available for reading, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,245],"source":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call throws a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[246,386],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[387,623],"source":" If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.","pos":[624,741],"source":" You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.","pos":[742,834],"source":" When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation."}]}]},{"pos":[1959,2442],"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","nodes":[{"content":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.","pos":[0,483],"nodes":[{"content":"If you are using a connection-oriented <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.","pos":[0,197],"source":"If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[198,483],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes."}]}]},{"pos":[2449,2919],"content":"If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.","nodes":[{"content":"If you are using a connectionless <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.","pos":[0,249],"source":"If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method."},{"content":"If the datagram you receive is larger than the size of the <ph id=\"ph1\">`buffers`</ph> parameter, <ph id=\"ph2\">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.","pos":[250,470],"source":" If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown."}]},{"pos":[2927,3293],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3301,3526],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[505079,508624],"yaml":true,"extradata":"MT"},{"content":"A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the received data.","nodes":[{"pos":[0,127],"content":"A list of <ph id=\"ph1\">&lt;xref href=\"System.ArraySegment`1\"&gt;&lt;/xref&gt;</ph>s of type <ph id=\"ph2\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the received data.","source":"A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the received data."}],"pos":[509391,509519],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[509603,509692],"yaml":true},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[509748,509778],"yaml":true},{"content":"<code>buffers</code> is `null`.  \n  \n -or-  \n  \n <code>buffers</code>.Count is zero.","nodes":[{"pos":[0,31],"content":"<ph id=\"ph1\">&lt;code&gt;buffers&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffers</code> is `null`."},{"pos":[38,42],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[49,84],"content":"<ph id=\"ph1\">&lt;code&gt;buffers&lt;/code&gt;</ph>.Count is zero.","source":"<code>buffers</code>.Count is zero."}],"pos":[509941,510032],"yaml":true},{"content":"An error occurred while attempting to access the socket.","nodes":[{"pos":[0,56],"content":"An error occurred while attempting to access the socket.","nodes":[{"content":"An error occurred while attempting to access the socket.","pos":[0,56]}]}],"pos":[510146,510203],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[510309,510377],"yaml":true},{"content":"Begins an asynchronous request to receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object.","nodes":[{"pos":[0,118],"content":"Begins an asynchronous request to receive data from a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object.","source":"Begins an asynchronous request to receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object."}],"pos":[511947,512066],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data. The socket's local address must be known.  \n  \n For bound connectionless sockets, this function restricts the addresses from which received messages are accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses are silently discarded.  \n  \n The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request. For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=fullName>.  \n  \n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \n  \n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \n  \n For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.  \n  \n For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter. If the message is larger than the buffer, the buffer is filled with the first part of the message.  \n  \n For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented. For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read. For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure. In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.","nodes":[{"pos":[0,197],"content":"The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data. The socket's local address must be known.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data. The socket's local address must be known.","pos":[0,197],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.","pos":[0,155],"source":"The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data."},{"content":"The socket's local address must be known.","pos":[156,197]}]}]},{"pos":[204,460],"content":"For bound connectionless sockets, this function restricts the addresses from which received messages are accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses are silently discarded.","nodes":[{"content":"For bound connectionless sockets, this function restricts the addresses from which received messages are accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses are silently discarded.","pos":[0,256],"nodes":[{"content":"For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.","pos":[0,114]},{"content":"The function only returns messages from the remote address specified in the connection.","pos":[115,202]},{"content":"Messages from other addresses are silently discarded.","pos":[203,256]}]}]},{"pos":[467,806],"content":"The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request. For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=fullName>.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName&gt;</ph> property on the <ph id=\"ph2\">`e`</ph> parameter provides the Window Sockets service provider with additional information about the read request.","pos":[0,217],"source":"The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request."},{"content":"For more information about how to use this parameter, see <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=fullName&gt;</ph>.","pos":[218,339],"source":" For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=fullName>."}]},{"pos":[813,981],"content":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:","nodes":[{"content":"The following properties and events on the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required to successfully call this method:","pos":[0,168],"source":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:"}]},{"pos":[991,1161],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=fullName>","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=fullName&gt;</ph>","pos":[0,170],"source":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=fullName>"}]},{"pos":[1171,1343],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> if <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> is set","pos":[0,172],"source":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set"}]},{"pos":[1353,1526],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName&gt;</ph> if <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> is set","pos":[0,173],"source":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set"}]},{"pos":[1536,1617],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>","nodes":[]},{"pos":[1624,2064],"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","nodes":[{"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[0,440],"nodes":[{"content":"The caller may set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.","pos":[0,293],"source":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method."},{"content":"If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[294,440]}]}]},{"pos":[2071,2241],"content":"For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.","nodes":[{"content":"For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.","pos":[0,170]}]},{"pos":[2248,2492],"content":"For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter. If the message is larger than the buffer, the buffer is filled with the first part of the message.","nodes":[{"content":"For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the <ph id=\"ph1\">`e`</ph> parameter.","pos":[0,145],"source":"For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter."},{"content":"If the message is larger than the buffer, the buffer is filled with the first part of the message.","pos":[146,244]}]},{"pos":[2499,3420],"content":"For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented. For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read. For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure. In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.","nodes":[{"content":"For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented. For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read. For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure. In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.","pos":[0,921],"nodes":[{"content":"For connection-oriented sockets, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.","pos":[0,242],"source":"For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented."},{"content":"For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.","pos":[243,357]},{"content":"For message-oriented sockets, where a zero byte message is often allowable, a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName&gt;</ph> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.","pos":[358,667],"source":" For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure."},{"content":"In any case, a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName&gt;</ph> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.","pos":[668,921],"source":" In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred."}]}]}],"pos":[512077,515522],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.","source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation."}],"pos":[515714,515833],"yaml":true},{"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \n  \n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"pos":[0,209],"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`true`</ph> if the I/O operation is pending.","pos":[0,47],"source":"Returns `true` if the I/O operation is pending."},{"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.","pos":[48,209],"source":" The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation."}]},{"pos":[216,574],"content":"Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`false`</ph> if the I/O operation completed synchronously.","pos":[0,61],"source":"Returns `false` if the I/O operation completed synchronously."},{"content":"In this case, The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">e</ph><ept id=\"p2\">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","pos":[62,358],"source":" In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation."}]}],"pos":[515891,516474],"yaml":true},{"content":"An argument was invalid. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\"></xref> or <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> properties on the <code>e</code> parameter must reference valid buffers. One or the other of these properties may be set, but not both at the same time.","nodes":[{"pos":[0,324],"content":"An argument was invalid. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\"></xref> or <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> properties on the <code>e</code> parameter must reference valid buffers. One or the other of these properties may be set, but not both at the same time.","nodes":[{"content":"An argument was invalid.","pos":[0,24]},{"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"&gt;&lt;/xref&gt;</ph> properties on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph3\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter must reference valid buffers.","pos":[25,244],"source":" The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\"></xref> or <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> properties on the <code>e</code> parameter must reference valid buffers."},{"content":"One or the other of these properties may be set, but not both at the same time.","pos":[245,324]}]}],"pos":[516634,516959],"yaml":true},{"content":"A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.","nodes":[{"pos":[0,163],"content":"A socket operation was already in progress using the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter."}],"pos":[517069,517233],"yaml":true},{"content":"Windows XP or later is required for this method.","nodes":[{"pos":[0,48],"content":"Windows XP or later is required for this method.","nodes":[{"content":"Windows XP or later is required for this method.","pos":[0,48]}]}],"pos":[517335,517384],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[517490,517558],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[517672,517728],"yaml":true},{"content":"Gets or sets a value that specifies the size of the receive buffer of the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,121],"content":"Gets or sets a value that specifies the size of the receive buffer of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Gets or sets a value that specifies the size of the receive buffer of the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[518992,519114],"yaml":true},{"content":"A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties. Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)","nodes":[{"pos":[0,352],"content":"A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties. Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)","nodes":[{"content":"A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties. Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)","pos":[0,352],"nodes":[{"content":"A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.","pos":[0,178]},{"content":"Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)","pos":[179,352]}]}]}],"pos":[519125,519478],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Int32\"></xref> that contains the size, in bytes, of the receive buffer. The default is 8192.","nodes":[{"pos":[0,114],"content":"An <xref href=\"System.Int32\"></xref> that contains the size, in bytes, of the receive buffer. The default is 8192.","nodes":[{"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Int32\"&gt;&lt;/xref&gt;</ph> that contains the size, in bytes, of the receive buffer.","pos":[0,93],"source":"An <xref href=\"System.Int32\"></xref> that contains the size, in bytes, of the receive buffer."},{"content":"The default is 8192.","pos":[94,114]}]}],"pos":[519988,520103],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[520288,520344],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[520450,520518],"yaml":true},{"content":"The value specified for a set operation is less than 0.","nodes":[{"pos":[0,55],"content":"The value specified for a set operation is less than 0.","nodes":[{"content":"The value specified for a set operation is less than 0.","pos":[0,55]}]}],"pos":[520632,520688],"yaml":true},{"content":"Receives a datagram into the data buffer and stores the endpoint.","nodes":[{"pos":[0,65],"content":"Receives a datagram into the data buffer and stores the endpoint.","nodes":[{"content":"Receives a datagram into the data buffer and stores the endpoint.","pos":[0,65]}]}],"pos":[522076,522142],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.  \n  \n This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host. The buffer offset defaults to 0. The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>.  \n  \n> [!NOTE]\n>  Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.  \n  \n If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \n  \n Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.  \n  \n With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,325],"content":"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id=\"ph2\">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.","pos":[0,213],"source":"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent."},{"content":"This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.","pos":[214,325]}]},{"pos":[332,636],"content":"This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host. The buffer offset defaults to 0. The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>.","nodes":[{"content":"This overload only requires you to provide a receive <ph id=\"ph1\">`buffer`</ph>, and an <ph id=\"ph2\">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.","pos":[0,129],"source":"This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host."},{"content":"The buffer offset defaults to 0.","pos":[130,162]},{"content":"The size defaults to the length of the <ph id=\"ph1\">`buffer`</ph> parameter and the <ph id=\"ph2\">`socketFlags`</ph> value defaults to <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.","pos":[163,304],"source":" The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>."}]},{"pos":[644,978],"content":"[!NOTE]\n Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.","leadings":["","> "],"nodes":[{"content":" Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.","pos":[8,332],"nodes":[{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.","pos":[1,205],"source":" Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method."},{"content":"If you do not, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[206,324],"source":" If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]}]},{"pos":[985,1671],"content":"With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.","nodes":[{"content":"With connectionless protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.","pos":[0,156],"source":"With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer."},{"content":"If the datagram you receive is larger than the size of <ph id=\"ph1\">`buffer`</ph>, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id=\"ph3\">`buffer`</ph> with as much of the message as is possible, and throw a <ph id=\"ph4\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[157,398],"source":" If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are using an unreliable protocol, the excess data will be lost.","pos":[399,469]},{"content":"If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.","pos":[470,686],"source":" If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer."}]},{"pos":[1678,2261],"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","nodes":[{"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","pos":[0,583],"nodes":[{"content":"If no data is available for reading, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.","pos":[0,131],"source":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available."},{"content":"If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[132,372],"source":" If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.","pos":[373,490],"source":" You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.","pos":[491,583],"source":" When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation."}]}]},{"pos":[2268,3195],"content":"Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.","nodes":[{"content":"Although <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.","pos":[0,150],"source":"Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well."},{"content":"If you choose to do so, you must first either establish a remote host connection by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[151,408],"source":" If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you do not establish or accept a connection before calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[409,588],"source":" If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>."},{"content":"You can also establish a default remote host for a connectionless protocol prior to calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.","pos":[589,740],"source":" You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method."},{"content":"In either of these cases, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id=\"ph2\">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.","pos":[741,927],"source":" In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host."}]},{"pos":[3202,3640],"content":"With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.","nodes":[{"content":"With connection-oriented sockets, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the size of <ph id=\"ph2\">`buffer`</ph>.","pos":[0,148],"source":"With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[149,438],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes."}]},{"pos":[3648,4014],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[4022,4311],"content":"[!NOTE]\n The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id=\"ph2\">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id=\"ph5\">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.","pos":[9,287],"source":" The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>."}]},{"pos":[4319,4544],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[522153,526722],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data.","nodes":[{"pos":[0,97],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data."}],"pos":[527398,527496],"yaml":true},{"content":"An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server.","nodes":[{"pos":[0,100],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph>, passed by reference, that represents the remote server.","source":"An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server."}],"pos":[527566,527667],"yaml":true},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[527723,527753],"yaml":true},{"content":"<code>buffer</code> is `null`.  \n  \n -or-  \n  \n <code>remoteEP</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."},{"pos":[37,41],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[48,80],"content":"<ph id=\"ph1\">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>remoteEP</code> is `null`."}],"pos":[527920,528007],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[528121,528177],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[528283,528351],"yaml":true},{"content":"A caller in the call stack does not have the required permissions.","nodes":[{"pos":[0,66],"content":"A caller in the call stack does not have the required permissions.","nodes":[{"content":"A caller in the call stack does not have the required permissions.","pos":[0,66]}]}],"pos":[528463,528530],"yaml":true},{"content":"Receives a datagram into the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint.","nodes":[{"pos":[0,139],"content":"Receives a datagram into the data buffer, using the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>, and stores the endpoint.","source":"Receives a datagram into the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint."}],"pos":[530050,530190],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.  \n  \n This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host. The offset defaults to 0 and the size defaults to the length of the buffer parameter.  \n  \n> [!NOTE]\n>  Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.  \n  \n If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When<xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \n  \n Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.  \n  \n With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,325],"content":"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id=\"ph2\">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.","pos":[0,213],"source":"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent."},{"content":"This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.","pos":[214,325]}]},{"pos":[332,598],"content":"This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host. The offset defaults to 0 and the size defaults to the length of the buffer parameter.","nodes":[{"content":"This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host. The offset defaults to 0 and the size defaults to the length of the buffer parameter.","pos":[0,266],"nodes":[{"content":"This overload only requires you to provide a receive buffer, the necessary <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, and an <ph id=\"ph2\">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.","pos":[0,180],"source":"This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host."},{"content":"The offset defaults to 0 and the size defaults to the length of the buffer parameter.","pos":[181,266]}]}]},{"pos":[606,940],"content":"[!NOTE]\n Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.","leadings":["","> "],"nodes":[{"content":" Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.","pos":[8,332],"nodes":[{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.","pos":[1,205],"source":" Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method."},{"content":"If you do not, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[206,324],"source":" If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]}]},{"pos":[947,1633],"content":"With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.","nodes":[{"content":"With connectionless protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.","pos":[0,156],"source":"With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer."},{"content":"If the datagram you receive is larger than the size of <ph id=\"ph1\">`buffer`</ph>, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id=\"ph3\">`buffer`</ph> with as much of the message as is possible, and throw a <ph id=\"ph4\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[157,398],"source":" If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are using an unreliable protocol, the excess data will be lost.","pos":[399,469]},{"content":"If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.","pos":[470,686],"source":" If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer."}]},{"pos":[1640,2222],"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When<xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","nodes":[{"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When<xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","pos":[0,582],"nodes":[{"content":"If no data is available for reading, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.","pos":[0,131],"source":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available."},{"content":"If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[132,372],"source":" If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.","pos":[373,490],"source":" You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading."},{"content":"When<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.","pos":[491,582],"source":" When<xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation."}]}]},{"pos":[2229,3156],"content":"Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.","nodes":[{"content":"Although <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.","pos":[0,150],"source":"Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well."},{"content":"If you choose to do so, you must first either establish a remote host connection by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[151,408],"source":" If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you do not establish or accept a connection before calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[409,588],"source":" If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>."},{"content":"You can also establish a default remote host for a connectionless protocol prior to calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.","pos":[589,740],"source":" You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method."},{"content":"In either of these cases, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id=\"ph2\">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.","pos":[741,927],"source":" In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host."}]},{"pos":[3163,3601],"content":"With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.","nodes":[{"content":"With connection-oriented sockets, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the size of <ph id=\"ph2\">`buffer`</ph>.","pos":[0,148],"source":"With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been Received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[149,438],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes."}]},{"pos":[3609,3975],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3983,4272],"content":"[!NOTE]\n The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id=\"ph2\">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id=\"ph5\">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.","pos":[9,287],"source":" The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>."}]},{"pos":[4280,4505],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[530201,534731],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.","nodes":[{"pos":[0,101],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for the received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data."}],"pos":[535569,535671],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[535755,535844],"yaml":true},{"content":"An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server.","nodes":[{"pos":[0,100],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph>, passed by reference, that represents the remote server.","source":"An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server."}],"pos":[535914,536015],"yaml":true},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[536071,536101],"yaml":true},{"content":"<code>buffer</code> is `null`.  \n  \n -or-  \n  \n <code>remoteEP</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."},{"pos":[37,41],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[48,80],"content":"<ph id=\"ph1\">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>remoteEP</code> is `null`."}],"pos":[536268,536355],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[536469,536525],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[536631,536699],"yaml":true},{"content":"A caller in the call stack does not have the required permissions.","nodes":[{"pos":[0,66],"content":"A caller in the call stack does not have the required permissions.","nodes":[{"content":"A caller in the call stack does not have the required permissions.","pos":[0,66]}]}],"pos":[536811,536878],"yaml":true},{"content":"Receives the specified number of bytes into the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint.","nodes":[{"pos":[0,158],"content":"Receives the specified number of bytes into the data buffer, using the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>, and stores the endpoint.","source":"Receives the specified number of bytes into the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint."}],"pos":[538458,538617],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.  \n  \n This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host. The buffer offset defaults to 0.  \n  \n With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.  \n  \n If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \n  \n Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.  \n  \n With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.  \n  \n> [!NOTE]\n>  Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,325],"content":"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id=\"ph2\">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.","pos":[0,213],"source":"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent."},{"content":"This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.","pos":[214,325]}]},{"pos":[332,586],"content":"This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host. The buffer offset defaults to 0.","nodes":[{"content":"This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host. The buffer offset defaults to 0.","pos":[0,254],"nodes":[{"content":"This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, and an <ph id=\"ph2\">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.","pos":[0,221],"source":"This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host."},{"content":"The buffer offset defaults to 0.","pos":[222,254]}]}]},{"pos":[593,1279],"content":"With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.","nodes":[{"content":"With connectionless protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.","pos":[0,156],"source":"With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer."},{"content":"If the datagram you receive is larger than the size of <ph id=\"ph1\">`buffer`</ph>, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id=\"ph3\">`buffer`</ph> with as much of the message as is possible, and throw a <ph id=\"ph4\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[157,398],"source":" If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are using an unreliable protocol, the excess data will be lost.","pos":[399,469]},{"content":"If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.","pos":[470,686],"source":" If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer."}]},{"pos":[1286,1869],"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","nodes":[{"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","pos":[0,583],"nodes":[{"content":"If no data is available for reading, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.","pos":[0,131],"source":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available."},{"content":"If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[132,372],"source":" If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.","pos":[373,490],"source":" You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.","pos":[491,583],"source":" When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation."}]}]},{"pos":[1876,2803],"content":"Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.","nodes":[{"content":"Although <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.","pos":[0,150],"source":"Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well."},{"content":"If you choose to do so, you must first either establish a remote host connection by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[151,408],"source":" If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you do not establish or accept a connection before calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[409,588],"source":" If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>."},{"content":"You can also establish a default remote host for a connectionless protocol prior to calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.","pos":[589,740],"source":" You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method."},{"content":"In either of these cases, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id=\"ph2\">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.","pos":[741,927],"source":" In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host."}]},{"pos":[2810,3281],"content":"With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.","nodes":[{"content":"With connection-oriented sockets, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the number of bytes specified by the <ph id=\"ph2\">`size`</ph> parameter.","pos":[0,181],"source":"With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[182,471],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes."}]},{"pos":[3289,3979],"content":"[!NOTE]\n Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,688],"nodes":[{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.","pos":[1,205],"source":" Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method."},{"content":"If you do not, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[206,324],"source":" If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[325,516],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[517,680]}]}]},{"pos":[3987,4276],"content":"[!NOTE]\n The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id=\"ph2\">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id=\"ph5\">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.","pos":[9,287],"source":" The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>."}]},{"pos":[4284,4509],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[538628,543159],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data.","nodes":[{"pos":[0,97],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data."}],"pos":[544028,544126],"yaml":true},{"content":"The number of bytes to receive.","nodes":[{"pos":[0,31],"content":"The number of bytes to receive.","nodes":[{"content":"The number of bytes to receive.","pos":[0,31]}]}],"pos":[544185,544217],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[544301,544390],"yaml":true},{"content":"An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server.","nodes":[{"pos":[0,100],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph>, passed by reference, that represents the remote server.","source":"An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server."}],"pos":[544460,544561],"yaml":true},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[544617,544647],"yaml":true},{"content":"<code>buffer</code> is `null`.  \n  \n -or-  \n  \n <code>remoteEP</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."},{"pos":[37,41],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[48,80],"content":"<ph id=\"ph1\">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>remoteEP</code> is `null`."}],"pos":[544814,544901],"yaml":true},{"content":"<code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of <code>buffer</code>.","nodes":[{"pos":[0,33],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[40,44],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[51,119],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>size</code> is greater than the length of <code>buffer</code>."}],"pos":[545015,545141],"yaml":true},{"content":"<code>socketFlags</code> is not a valid combination of values.  \n  \n -or-  \n  \n The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"></xref> property was not set.  \n  \n -or-  \n  \n An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.","source":"<code>socketFlags</code> is not a valid combination of values."},{"pos":[69,73],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[80,166],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"&gt;&lt;/xref&gt;</ph> property was not set.","source":"The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"></xref> property was not set."},{"pos":[173,177],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[184,284],"content":"An operating system error occurs while accessing the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[545255,545554],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[545660,545728],"yaml":true},{"content":"A caller in the call stack does not have the required permissions.","nodes":[{"pos":[0,66],"content":"A caller in the call stack does not have the required permissions.","nodes":[{"content":"A caller in the call stack does not have the required permissions.","pos":[0,66]}]}],"pos":[545840,545907],"yaml":true},{"content":"Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint.","nodes":[{"pos":[0,192],"content":"Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>, and stores the endpoint.","source":"Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint."}],"pos":[547547,547740],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.  \n  \n With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.  \n  \n If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \n  \n Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.  \n  \n With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.  \n  \n> [!NOTE]\n>  Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the<xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,325],"content":"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id=\"ph2\">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.","pos":[0,213],"source":"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent."},{"content":"This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.","pos":[214,325]}]},{"pos":[332,1018],"content":"With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.","nodes":[{"content":"With connectionless protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.","pos":[0,156],"source":"With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer."},{"content":"If the datagram you receive is larger than the size of <ph id=\"ph1\">`buffer`</ph>, the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id=\"ph3\">`buffer`</ph> with as much of the message as is possible, and throw a <ph id=\"ph4\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[157,398],"source":" If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are using an unreliable protocol, the excess data will be lost.","pos":[399,469]},{"content":"If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.","pos":[470,686],"source":" If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer."}]},{"pos":[1025,1608],"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","nodes":[{"content":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.","pos":[0,583],"nodes":[{"content":"If no data is available for reading, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.","pos":[0,131],"source":"If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available."},{"content":"If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[132,372],"source":" If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>."},{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.","pos":[373,490],"source":" You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading."},{"content":"When <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.","pos":[491,583],"source":" When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation."}]}]},{"pos":[1615,2542],"content":"Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.","nodes":[{"content":"Although <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.","pos":[0,150],"source":"Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well."},{"content":"If you choose to do so, you must first either establish a remote host connection by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[151,408],"source":" If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you do not establish or accept a connection before calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[409,588],"source":" If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>."},{"content":"You can also establish a default remote host for a connectionless protocol prior to calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.","pos":[589,740],"source":" You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method."},{"content":"In either of these cases, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id=\"ph2\">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.","pos":[741,927],"source":" In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host."}]},{"pos":[2549,3020],"content":"With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.","nodes":[{"content":"With connection-oriented sockets, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the amount of bytes specified by the <ph id=\"ph2\">`size`</ph> parameter.","pos":[0,181],"source":"With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter."},{"content":"If the remote host shuts down the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been Received, the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.","pos":[182,471],"source":" If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes."}]},{"pos":[3028,3718],"content":"[!NOTE]\n Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,688],"nodes":[{"content":"Before calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.","pos":[1,205],"source":" Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method."},{"content":"If you do not, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[206,324],"source":" If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[325,516],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[517,680]}]}]},{"pos":[3726,4014],"content":"[!NOTE]\n The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the<xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id=\"ph2\">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the<ph id=\"ph4\">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id=\"ph5\">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.","pos":[9,286],"source":" The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the<xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>."}]},{"pos":[4022,4247],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[547751,552018],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data.","nodes":[{"pos":[0,97],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data."}],"pos":[552907,553005],"yaml":true},{"content":"The position in the <code>buffer</code> parameter to store the received data.","nodes":[{"pos":[0,77],"content":"The position in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">buffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter to store the received data.","source":"The position in the <code>buffer</code> parameter to store the received data."}],"pos":[553066,553144],"yaml":true},{"content":"The number of bytes to receive.","nodes":[{"pos":[0,31],"content":"The number of bytes to receive.","nodes":[{"content":"The number of bytes to receive.","pos":[0,31]}]}],"pos":[553203,553235],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[553319,553408],"yaml":true},{"content":"An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server.","nodes":[{"pos":[0,100],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph>, passed by reference, that represents the remote server.","source":"An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server."}],"pos":[553478,553579],"yaml":true},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[553635,553665],"yaml":true},{"content":"<code>buffer</code> is `null`.  \n  \n -or-  \n  \n <code>remoteEP</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."},{"pos":[37,41],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[48,80],"content":"<ph id=\"ph1\">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>remoteEP</code> is `null`."}],"pos":[553832,553919],"yaml":true},{"content":"<code>offset</code> is less than 0.  \n  \n -or-  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n -or-  \n  \n <code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of the <code>buffer</code> minus the value of the offset parameter.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.","source":"<code>offset</code> is less than 0."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,123],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>offset</code> is greater than the length of <code>buffer</code>."},{"pos":[130,134],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[141,174],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[181,185],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[192,304],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of the <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the offset parameter.","source":"<code>size</code> is greater than the length of the <code>buffer</code> minus the value of the offset parameter."}],"pos":[554033,554352],"yaml":true},{"content":"<code>socketFlags</code> is not a valid combination of values.  \n  \n -or-  \n  \n The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"></xref> property was not set.  \n  \n -or-  \n  \n An error occurred when attempting to access the socket.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.","source":"<code>socketFlags</code> is not a valid combination of values."},{"pos":[69,73],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[80,166],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"&gt;&lt;/xref&gt;</ph> property was not set.","source":"The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"></xref> property was not set."},{"pos":[173,177],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[184,239],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[554466,554718],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[554824,554892],"yaml":true},{"content":"Begins to asynchronously receive data from a specified network device.","nodes":[{"pos":[0,70],"content":"Begins to asynchronously receive data from a specified network device.","nodes":[{"content":"Begins to asynchronously receive data from a specified network device.","pos":[0,70]}]}],"pos":[556337,556408],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket. The socket's local address must be known.  \n  \n The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.  \n  \n The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request. For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=fullName>.  \n  \n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \n  \n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \n  \n For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer. The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data.  \n  \n For byte streamstyle sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted. The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data.","nodes":[{"pos":[0,167],"content":"The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket. The socket's local address must be known.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket. The socket's local address must be known.","pos":[0,167],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> method is used primarily to receive data on a connectionless socket.","pos":[0,125],"source":"The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket."},{"content":"The socket's local address must be known.","pos":[126,167]}]}]},{"pos":[174,390],"content":"The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.","nodes":[{"content":"The caller must set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> property to the <ph id=\"ph2\">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host from which the data is to be received.","pos":[0,216],"source":"The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received."}]},{"pos":[397,736],"content":"The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request. For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=fullName>.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName&gt;</ph> property on the <ph id=\"ph2\">`e`</ph> parameter provides the Window Sockets service provider with additional information about the read request.","pos":[0,217],"source":"The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request."},{"content":"For more information about how to use this parameter, see <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=fullName&gt;</ph>.","pos":[218,339],"source":" For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=fullName>."}]},{"pos":[743,911],"content":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:","nodes":[{"content":"The following properties and events on the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required to successfully call this method:","pos":[0,168],"source":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:"}]},{"pos":[921,1002],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName>","nodes":[]},{"pos":[1012,1092],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName>","nodes":[]},{"pos":[1102,1183],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName>","nodes":[]},{"pos":[1193,1282],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>","nodes":[]},{"pos":[1292,1373],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>","nodes":[]},{"pos":[1380,1824],"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","nodes":[{"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[0,444],"nodes":[{"content":"The caller may set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.","pos":[0,297],"source":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method."},{"content":"If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[298,444]}]}]},{"pos":[1831,2197],"content":"For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer. The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data.","nodes":[{"content":"For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer. The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data.","pos":[0,366],"nodes":[{"content":"For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.","pos":[0,111]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.","pos":[112,366],"source":" The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data."}]}]},{"pos":[2204,2629],"content":"For byte streamstyle sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted. The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data.","nodes":[{"content":"For byte streamstyle sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted. The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data.","pos":[0,425],"nodes":[{"content":"For byte streamstyle sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.","pos":[0,170]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.","pos":[171,425],"source":" The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data."}]}]}],"pos":[556419,559073],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.","source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation."}],"pos":[559269,559388],"yaml":true},{"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \n  \n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"pos":[0,209],"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`true`</ph> if the I/O operation is pending.","pos":[0,47],"source":"Returns `true` if the I/O operation is pending."},{"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.","pos":[48,209],"source":" The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation."}]},{"pos":[216,574],"content":"Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`false`</ph> if the I/O operation completed synchronously.","pos":[0,61],"source":"Returns `false` if the I/O operation completed synchronously."},{"content":"In this case, The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">e</ph><ept id=\"p2\">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","pos":[62,358],"source":" In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation."}]}],"pos":[559446,560029],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null.","nodes":[{"pos":[0,95],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"&gt;&lt;/xref&gt;</ph> cannot be null.","source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null."}],"pos":[560201,560297],"yaml":true},{"content":"A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.","nodes":[{"pos":[0,163],"content":"A socket operation was already in progress using the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter."}],"pos":[560407,560571],"yaml":true},{"content":"Windows XP or later is required for this method.","nodes":[{"pos":[0,48],"content":"Windows XP or later is required for this method.","nodes":[{"content":"Windows XP or later is required for this method.","pos":[0,48]}]}],"pos":[560673,560722],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[560828,560896],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[561010,561066],"yaml":true},{"content":"Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint and packet information.","nodes":[{"pos":[0,215],"content":"Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>, and stores the endpoint and packet information.","source":"Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint and packet information."}],"pos":[562934,563150],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.  \n  \n The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket. The socket's local address must be known. This method can only be used with datagram and raw sockets. The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method. This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.  \n  \n For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter. The `offset` parameter determines where in the `buffer` the data is placed. The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.  \n  \n The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>. However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set. If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.  \n  \n To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.  \n  \n An application can examine the `ipPacketInformation` parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.  \n  \n> [!NOTE]\n>  The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,270],"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method reads data into the <ph id=\"ph2\">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.","source":"The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet."},{"pos":[277,787],"content":"The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket. The socket's local address must be known. This method can only be used with datagram and raw sockets. The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method. This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket. The socket's local address must be known. This method can only be used with datagram and raw sockets. The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method. This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.","pos":[0,510],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method is used primarily to receive message data on a connectionless socket.","pos":[0,135],"source":"The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket."},{"content":"The socket's local address must be known.","pos":[136,177]},{"content":"This method can only be used with datagram and raw sockets.","pos":[178,237]},{"content":"The socket must be initialized with the socket type set to <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> before calling this method.","pos":[238,411],"source":" The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method."},{"content":"This can be done when the socket is constructed using <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.","pos":[412,510],"source":" This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>."}]}]},{"pos":[794,1146],"content":"For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter. The `offset` parameter determines where in the `buffer` the data is placed. The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.","nodes":[{"content":"For message-oriented sockets, an incoming message is placed into the <ph id=\"ph1\">`buffer`</ph> parameter up to the total size specified in the <ph id=\"ph2\">`size`</ph> parameter.","pos":[0,143],"source":"For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter."},{"content":"The <ph id=\"ph1\">`offset`</ph> parameter determines where in the <ph id=\"ph2\">`buffer`</ph> the data is placed.","pos":[144,219],"source":" The `offset` parameter determines where in the `buffer` the data is placed."},{"content":"The actual amount of data placed into the <ph id=\"ph1\">`buffer`</ph> is returned by the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.","pos":[220,352],"source":" The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method."}]},{"pos":[1153,2206],"content":"The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>. However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set. If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method automatically method sets the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id=\"ph3\">`true`</ph> the first time it is called for a given <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,254],"source":"The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>."},{"content":"However, the returned <ph id=\"ph1\">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> object will only be valid for packets which arrive at the local computer after the socket option has been set.","pos":[255,433],"source":" However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set."},{"content":"If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method or implicitly by one of the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> methods) and its first call to the <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method, calls to <ph id=\"ph7\">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method will return invalid <ph id=\"ph8\">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects for these packets.","pos":[434,1053],"source":" If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets."}]},{"pos":[2213,2614],"content":"To ensure that all <ph id=\"ph1\">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects are valid, an application should set the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id=\"ph3\">`true`</ph> before it is bound to a local endpoint using the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> method.","source":"To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method."},{"pos":[2621,2778],"content":"An application can examine the <ph id=\"ph1\">`ipPacketInformation`</ph> parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.","source":"An application can examine the `ipPacketInformation` parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address."},{"pos":[2786,3075],"content":"[!NOTE]\n The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id=\"ph2\">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id=\"ph5\">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.","pos":[9,287],"source":" The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>."}]},{"pos":[3083,3308],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[563161,566488],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data.","nodes":[{"pos":[0,97],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that is the storage location for received data.","source":"An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data."}],"pos":[566857,566955],"yaml":true},{"content":"The position in the <code>buffer</code> parameter to store the received data.","nodes":[{"pos":[0,77],"content":"The position in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">buffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter to store the received data.","source":"The position in the <code>buffer</code> parameter to store the received data."}],"pos":[567016,567094],"yaml":true},{"content":"The number of bytes to receive.","nodes":[{"pos":[0,31],"content":"The number of bytes to receive.","nodes":[{"content":"The number of bytes to receive.","pos":[0,31]}]}],"pos":[567153,567185],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[567269,567358],"yaml":true},{"content":"An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server.","nodes":[{"pos":[0,100],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph>, passed by reference, that represents the remote server.","source":"An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server."}],"pos":[567428,567529],"yaml":true},{"content":"An <xref href=\"System.Net.Sockets.IPPacketInformation\"></xref> holding address and interface information.","nodes":[{"pos":[0,105],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.IPPacketInformation\"&gt;&lt;/xref&gt;</ph> holding address and interface information.","source":"An <xref href=\"System.Net.Sockets.IPPacketInformation\"></xref> holding address and interface information."}],"pos":[567629,567735],"yaml":true},{"content":"The number of bytes received.","nodes":[{"pos":[0,29],"content":"The number of bytes received.","nodes":[{"content":"The number of bytes received.","pos":[0,29]}]}],"pos":[567791,567821],"yaml":true},{"content":"<code>buffer</code> is `null`.  \n  \n \\- or-  \n  \n <code>remoteEP</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."},{"pos":[37,43],"content":"\\- or-","nodes":[{"content":"<ph id=\"ph1\">\\-</ph> or-","pos":[0,6],"source":"\\- or-"}]},{"pos":[50,82],"content":"<ph id=\"ph1\">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>remoteEP</code> is `null`."}],"pos":[567995,568085],"yaml":true},{"content":"<code>offset</code> is less than 0.  \n  \n -or-  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n -or-  \n  \n <code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of the <code>buffer</code> minus the value of the offset parameter.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.","source":"<code>offset</code> is less than 0."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,123],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>offset</code> is greater than the length of <code>buffer</code>."},{"pos":[130,134],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[141,174],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[181,185],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[192,304],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of the <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the offset parameter.","source":"<code>size</code> is greater than the length of the <code>buffer</code> minus the value of the offset parameter."}],"pos":[568199,568518],"yaml":true},{"content":"<code>socketFlags</code> is not a valid combination of values.  \n  \n -or-  \n  \n The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"></xref> property was not set.  \n  \n -or-  \n  \n The .NET Framework is running on an AMD 64-bit processor.  \n  \n -or-  \n  \n An error occurred when attempting to access the socket.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.","source":"<code>socketFlags</code> is not a valid combination of values."},{"pos":[69,73],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[80,166],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"&gt;&lt;/xref&gt;</ph> property was not set.","source":"The <xref href=\"System.Net.Sockets.Socket.LocalEndPoint\"></xref> property was not set."},{"pos":[173,177],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[184,241],"content":"The .NET Framework is running on an AMD 64-bit processor.","nodes":[{"content":"The .NET Framework is running on an AMD 64-bit processor.","pos":[0,57]}]},{"pos":[248,252],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[259,314],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[568632,568963],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[569069,569137],"yaml":true},{"content":"The operating system is Windows 2000 or earlier, and this method requires Windows XP.","nodes":[{"pos":[0,85],"content":"The operating system is Windows 2000 or earlier, and this method requires Windows XP.","nodes":[{"content":"The operating system is Windows 2000 or earlier, and this method requires Windows XP.","pos":[0,85]}]}],"pos":[569239,569325],"yaml":true},{"content":"Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SocketFlags\"></xref>, and stores the endpoint and packet information.","nodes":[{"pos":[0,260],"content":"Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SocketFlags\"&gt;&lt;/xref&gt;</ph>, and stores the endpoint and packet information.","source":"Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SocketFlags\"></xref>, and stores the endpoint and packet information."}],"pos":[570852,571113],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket. The socket's local address must be known. This method can only be used with datagram and raw sockets. The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method. This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.  \n  \n The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.  \n  \n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \n  \n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \n  \n For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer. The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data.  \n  \n The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>. However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set. If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.  \n  \n To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to`true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.  \n  \n An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.","nodes":[{"pos":[0,515],"content":"The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket. The socket's local address must be known. This method can only be used with datagram and raw sockets. The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method. This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket. The socket's local address must be known. This method can only be used with datagram and raw sockets. The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method. This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.","pos":[0,515],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method is used primarily to receive message data on a connectionless socket.","pos":[0,140],"source":"The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket."},{"content":"The socket's local address must be known.","pos":[141,182]},{"content":"This method can only be used with datagram and raw sockets.","pos":[183,242]},{"content":"The socket must be initialized with the socket type set to <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> before calling this method.","pos":[243,416],"source":" The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method."},{"content":"This can be done when the socket is constructed using <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.","pos":[417,515],"source":" This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>."}]}]},{"pos":[522,738],"content":"The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.","nodes":[{"content":"The caller must set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> property to the <ph id=\"ph2\">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host from which the data is to be received.","pos":[0,216],"source":"The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received."}]},{"pos":[745,913],"content":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:","nodes":[{"content":"The following properties and events on the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required to successfully call this method:","pos":[0,168],"source":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:"}]},{"pos":[923,1004],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName>","nodes":[]},{"pos":[1014,1094],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName>","nodes":[]},{"pos":[1104,1185],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName>","nodes":[]},{"pos":[1195,1284],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>","nodes":[]},{"pos":[1294,1375],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>","nodes":[]},{"pos":[1382,1833],"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","nodes":[{"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[0,451],"nodes":[{"content":"The caller may set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.","pos":[0,304],"source":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method."},{"content":"If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[305,451]}]}]},{"pos":[1840,2206],"content":"For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer. The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data.","nodes":[{"content":"For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer. The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data.","pos":[0,366],"nodes":[{"content":"For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.","pos":[0,111]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.","pos":[112,366],"source":" The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data."}]}]},{"pos":[2213,3276],"content":"The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>. However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set. If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method automatically sets the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id=\"ph3\">`true`</ph> the first time it is called for a given <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,252],"source":"The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>."},{"content":"However, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> object will only be valid for packets which arrive at the local computer after the socket option has been set.","pos":[253,422],"source":" However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set."},{"content":"If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method or implicitly by one of the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> methods) and the first call to the <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method, calls to <ph id=\"ph7\">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method will result in invalid <ph id=\"ph8\">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects for these packets.","pos":[423,1063],"source":" If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets."}]},{"pos":[3283,3683],"content":"To ensure that all <ph id=\"ph1\">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects are valid, an application should set the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to<ph id=\"ph3\">`true`</ph> before it is bound to a local endpoint using the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> method.","source":"To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to`true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method."},{"pos":[3690,3879],"content":"An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.","nodes":[{"content":"An application can examine the resulting <ph id=\"ph1\">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.","pos":[0,189],"source":"An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address."}]}],"pos":[571124,575030],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.","source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation."}],"pos":[575286,575405],"yaml":true},{"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \n  \n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"pos":[0,209],"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`true`</ph> if the I/O operation is pending.","pos":[0,47],"source":"Returns `true` if the I/O operation is pending."},{"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.","pos":[48,209],"source":" The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation."}]},{"pos":[216,574],"content":"Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`false`</ph> if the I/O operation completed synchronously.","pos":[0,61],"source":"Returns `false` if the I/O operation completed synchronously."},{"content":"In this case, The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">e</ph><ept id=\"p2\">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","pos":[62,358],"source":" In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation."}]}],"pos":[575463,576046],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null.","nodes":[{"pos":[0,95],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"&gt;&lt;/xref&gt;</ph> cannot be null.","source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null."}],"pos":[576225,576321],"yaml":true},{"content":"Windows XP or later is required for this method.","nodes":[{"pos":[0,48],"content":"Windows XP or later is required for this method.","nodes":[{"content":"Windows XP or later is required for this method.","pos":[0,48]}]}],"pos":[576423,576472],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[576578,576646],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[576760,576816],"yaml":true},{"content":"Gets or sets a value that specifies the amount of time after which a synchronous <xref href=\"System.Net.Sockets.Socket.Receive*\"></xref> call will time out.","nodes":[{"pos":[0,156],"content":"Gets or sets a value that specifies the amount of time after which a synchronous <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.Receive*\"&gt;&lt;/xref&gt;</ph> call will time out.","source":"Gets or sets a value that specifies the amount of time after which a synchronous <xref href=\"System.Net.Sockets.Socket.Receive*\"></xref> call will time out."}],"pos":[578102,578259],"yaml":true},{"content":"This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only. If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"pos":[0,237],"content":"This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only. If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only. If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.","pos":[0,237],"nodes":[{"content":"This option applies to synchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> calls only.","pos":[0,90],"source":"This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only."},{"content":"If the time-out period is exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[91,237],"source":" If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>."}]}]}],"pos":[578270,578508],"yaml":true,"extradata":"MT"},{"content":"The time-out value, in milliseconds. The default value is 0, which indicates an infinite time-out period. Specifying -1 also indicates an infinite time-out period.","nodes":[{"pos":[0,163],"content":"The time-out value, in milliseconds. The default value is 0, which indicates an infinite time-out period. Specifying -1 also indicates an infinite time-out period.","nodes":[{"content":"The time-out value, in milliseconds. The default value is 0, which indicates an infinite time-out period. Specifying -1 also indicates an infinite time-out period.","pos":[0,163],"nodes":[{"content":"The time-out value, in milliseconds.","pos":[0,36]},{"content":"The default value is 0, which indicates an infinite time-out period.","pos":[37,105]},{"content":"Specifying -1 also indicates an infinite time-out period.","pos":[106,163]}]}]}],"pos":[579012,579176],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[579358,579414],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[579520,579588],"yaml":true},{"content":"The value specified for a set operation is less than -1.","nodes":[{"pos":[0,56],"content":"The value specified for a set operation is less than -1.","nodes":[{"content":"The value specified for a set operation is less than -1.","pos":[0,56]}]}],"pos":[579702,579759],"yaml":true},{"content":"Gets the remote endpoint.","nodes":[{"pos":[0,25],"content":"Gets the remote endpoint.","nodes":[{"content":"Gets the remote endpoint.","pos":[0,25]}]}],"pos":[581005,581031],"yaml":true},{"content":"If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate. You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information. You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> method to retrieve the remote port number.  \n  \n The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>. If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,851],"content":"If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate. You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information. You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> method to retrieve the remote port number.","nodes":[{"content":"If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate. You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information. You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> method to retrieve the remote port number.","pos":[0,851],"nodes":[{"content":"If you are using a connection-oriented protocol, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property gets the <ph id=\"ph2\">&lt;xref:System.Net.EndPoint&gt;</ph> that contains the remote IP address and port number to which the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is connected.","pos":[0,260],"source":"If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected."},{"content":"If you are using a connectionless protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> contains the default remote IP address and port number with which the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will communicate.","pos":[261,476],"source":" If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate."},{"content":"You must cast this <ph id=\"ph1\">&lt;xref:System.Net.EndPoint&gt;</ph> to an <ph id=\"ph2\">&lt;xref:System.Net.IPEndPoint&gt;</ph> before retrieving any information.","pos":[477,592],"source":" You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information."},{"content":"You can then call the <ph id=\"ph1\">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName&gt;</ph> method to retrieve the remote <ph id=\"ph2\">&lt;xref:System.Net.IPAddress&gt;</ph>, and the <ph id=\"ph3\">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName&gt;</ph> method to retrieve the remote port number.","pos":[593,851],"source":" You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> method to retrieve the remote port number."}]}]},{"pos":[858,1540],"content":"The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>. If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>. If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[0,682],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> is set after a call to either <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[0,175],"source":"The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"If you try to access this property earlier, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[176,326],"source":" If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[327,518],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[519,682]}]}]},{"pos":[1548,1773],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[581042,582823],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Net.EndPoint\"></xref> with which the <xref href=\"System.Net.Sockets.Socket\"></xref> is communicating.","nodes":[{"pos":[0,124],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph> with which the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is communicating.","source":"The <xref href=\"System.Net.EndPoint\"></xref> with which the <xref href=\"System.Net.Sockets.Socket\"></xref> is communicating."}],"pos":[583443,583568],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[583750,583806],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[583912,583980],"yaml":true},{"content":"Determines the status of one or more sockets.","nodes":[{"pos":[0,45],"content":"Determines the status of one or more sockets.","nodes":[{"content":"Determines the status of one or more sockets.","pos":[0,45]}]}],"pos":[585527,585573],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances. You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method. Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter. To check your sockets for writability, use the `checkWrite` parameter. For detecting error conditions, use `checkError`. After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions.  \n  \n If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking. If you have already accepted the connection, readability means that data is available for reading. In these cases, all receive operations will succeed without blocking. Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.  \n  \n <xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first. Setting `microSeconds` to -1 specifies an infinite time-out.  \n  \n If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully. If you already have a connection established, writability means that all send operations will succeed without blocking.  \n  \n If you have made a non-blocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, the `checkerror` parameter identifies sockets that have not connected successfully.  \n  \n> [!NOTE]\n>  Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>.  \n  \n> [!NOTE]\n>  This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully. You must attempt to send or receive data to detect these kinds of errors.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","nodes":[{"pos":[0,726],"content":"<xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances. You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method. Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter. To check your sockets for writability, use the `checkWrite` parameter. For detecting error conditions, use `checkError`. After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> is a static method that determines the status of one or more <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances.","pos":[0,147],"source":"<xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances."},{"content":"You must place one or more sockets into an <ph id=\"ph1\">&lt;xref:System.Collections.IList&gt;</ph> before you can use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> method.","pos":[148,296],"source":" You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method."},{"content":"Check for readability by calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> with the <ph id=\"ph2\">&lt;xref:System.Collections.IList&gt;</ph> as the <ph id=\"ph3\">`checkRead`</ph> parameter.","pos":[297,443],"source":" Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter."},{"content":"To check your sockets for writability, use the <ph id=\"ph1\">`checkWrite`</ph> parameter.","pos":[444,514],"source":" To check your sockets for writability, use the `checkWrite` parameter."},{"content":"For detecting error conditions, use <ph id=\"ph1\">`checkError`</ph>.","pos":[515,564],"source":" For detecting error conditions, use `checkError`."},{"content":"After calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Collections.IList&gt;</ph> will be filled with only those sockets that satisfy the conditions.","pos":[565,726],"source":" After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions."}]},{"pos":[733,1271],"content":"If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking. If you have already accepted the connection, readability means that data is available for reading. In these cases, all receive operations will succeed without blocking. Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.","nodes":[{"content":"If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking. If you have already accepted the connection, readability means that data is available for reading. In these cases, all receive operations will succeed without blocking. Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.","pos":[0,538],"nodes":[{"content":"If you are in a listening state, readability means that a call to <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> will succeed without blocking.","pos":[0,139],"source":"If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking."},{"content":"If you have already accepted the connection, readability means that data is available for reading.","pos":[140,238]},{"content":"In these cases, all receive operations will succeed without blocking.","pos":[239,308]},{"content":"Readability can also indicate whether the remote <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> has shut down the connection; in that case a call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will return immediately, with zero bytes returned.","pos":[309,538],"source":" Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned."}]}]},{"pos":[1278,1603],"content":"<xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first. Setting `microSeconds` to -1 specifies an infinite time-out.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> returns when at least one of the sockets of interest (the sockets in the <ph id=\"ph2\">`checkRead`</ph>, <ph id=\"ph3\">`checkWrite`</ph>, and <ph id=\"ph4\">`checkError`</ph> lists) meets its specified criteria, or the <ph id=\"ph5\">`microSeconds`</ph> parameter is exceeded, whichever comes first.","pos":[0,264],"source":"<xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first."},{"content":"Setting <ph id=\"ph1\">`microSeconds`</ph> to -1 specifies an infinite time-out.","pos":[265,325],"source":" Setting `microSeconds` to -1 specifies an infinite time-out."}]},{"pos":[1610,1864],"content":"If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully. If you already have a connection established, writability means that all send operations will succeed without blocking.","nodes":[{"content":"If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully. If you already have a connection established, writability means that all send operations will succeed without blocking.","pos":[0,254],"nodes":[{"content":"If you make a nonblocking call to <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, writability means that you have connected successfully.","pos":[0,134],"source":"If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully."},{"content":"If you already have a connection established, writability means that all send operations will succeed without blocking.","pos":[135,254]}]}]},{"pos":[1871,2039],"content":"If you have made a non-blocking call to <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the <ph id=\"ph2\">`checkerror`</ph> parameter identifies sockets that have not connected successfully.","source":"If you have made a non-blocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, the `checkerror` parameter identifies sockets that have not connected successfully."},{"pos":[2047,2200],"content":"[!NOTE]\n Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>.","leadings":["","> "],"nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method if you only want to determine the status of a single <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[9,151],"source":" Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>."}]},{"pos":[2208,2440],"content":"[!NOTE]\n This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully. You must attempt to send or receive data to detect these kinds of errors.","leadings":["","> "],"nodes":[{"content":" This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully. You must attempt to send or receive data to detect these kinds of errors.","pos":[8,230],"nodes":[{"content":"This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.","pos":[1,148]},{"content":"You must attempt to send or receive data to detect these kinds of errors.","pos":[149,222]}]}]},{"pos":[2448,2814],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]}],"pos":[585584,588418],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Collections.IList\"></xref> of <xref href=\"System.Net.Sockets.Socket\"></xref> instances to check for readability.","nodes":[{"pos":[0,134],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Collections.IList\"&gt;&lt;/xref&gt;</ph> of <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> instances to check for readability.","source":"An <xref href=\"System.Collections.IList\"></xref> of <xref href=\"System.Net.Sockets.Socket\"></xref> instances to check for readability."}],"pos":[589181,589316],"yaml":true},{"content":"An <xref href=\"System.Collections.IList\"></xref> of <xref href=\"System.Net.Sockets.Socket\"></xref> instances to check for writability.","nodes":[{"pos":[0,134],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Collections.IList\"&gt;&lt;/xref&gt;</ph> of <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> instances to check for writability.","source":"An <xref href=\"System.Collections.IList\"></xref> of <xref href=\"System.Net.Sockets.Socket\"></xref> instances to check for writability."}],"pos":[589393,589528],"yaml":true},{"content":"An <xref href=\"System.Collections.IList\"></xref> of <xref href=\"System.Net.Sockets.Socket\"></xref> instances to check for errors.","nodes":[{"pos":[0,129],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Collections.IList\"&gt;&lt;/xref&gt;</ph> of <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> instances to check for errors.","source":"An <xref href=\"System.Collections.IList\"></xref> of <xref href=\"System.Net.Sockets.Socket\"></xref> instances to check for errors."}],"pos":[589605,589735],"yaml":true},{"content":"The time-out value, in microseconds. A -1 value indicates an infinite time-out.","nodes":[{"pos":[0,79],"content":"The time-out value, in microseconds. A -1 value indicates an infinite time-out.","nodes":[{"content":"The time-out value, in microseconds. A -1 value indicates an infinite time-out.","pos":[0,79],"nodes":[{"content":"The time-out value, in microseconds.","pos":[0,36]},{"content":"A -1 value indicates an infinite time-out.","pos":[37,79]}]}]}],"pos":[589802,589882],"yaml":true},{"content":"The <code>checkRead</code> parameter is `null` or empty.  \n  \n -and-  \n  \n The <code>checkWrite</code> parameter is `null` or empty  \n  \n -and-  \n  \n The <code>checkError</code> parameter is `null` or empty.","nodes":[{"pos":[0,56],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">checkRead</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph> or empty.","source":"The <code>checkRead</code> parameter is `null` or empty."},{"pos":[63,68],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[75,131],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">checkWrite</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph> or empty","source":"The <code>checkWrite</code> parameter is `null` or empty"},{"pos":[138,143],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[150,207],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">checkError</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph> or empty.","source":"The <code>checkError</code> parameter is `null` or empty."}],"pos":[590044,590262],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[590376,590432],"yaml":true},{"content":"Sends data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,73],"content":"Sends data to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Sends data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[591685,591759],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.  \n  \n This overload requires a buffer that contains the data you want to send. The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.  \n  \n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \n  \n If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \n  \n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,361],"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.","nodes":[{"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.","pos":[0,361],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.","pos":[0,249],"source":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.","pos":[250,361],"source":" <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols."}]}]},{"pos":[368,604],"content":"This overload requires a buffer that contains the data you want to send. The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.","nodes":[{"content":"This overload requires a buffer that contains the data you want to send. The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.","pos":[0,236],"nodes":[{"content":"This overload requires a buffer that contains the data you want to send.","pos":[0,72]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.","pos":[73,236],"source":" The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer."}]}]},{"pos":[611,1076],"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","nodes":[{"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","pos":[0,465],"nodes":[{"content":"If you are using a connectionless protocol, you must call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[0,229],"source":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are using a connection-oriented protocol, you must either use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.","pos":[230,465],"source":" If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection."}]}]},{"pos":[1083,1778],"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","pos":[0,695],"nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.","pos":[0,162],"source":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method."},{"content":"If you do not use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.","pos":[163,363],"source":" If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[364,522],"source":" You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"You can also change the default remote host prior to calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[523,695],"source":" You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>."}]}]},{"pos":[1785,2885],"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,1100],"nodes":[{"content":"If you are using a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,256],"source":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[257,398],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"In nonblocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.","pos":[399,548],"source":" In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer."},{"content":"It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.","pos":[549,710]},{"content":"There is also no guarantee that the data you send will appear on the network immediately.","pos":[711,800]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[801,935]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[936,1100],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[2893,3259],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3267,3540],"content":"[!NOTE]\n The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","leadings":["","> "],"nodes":[{"content":" The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[8,271],"nodes":[{"content":"The successful completion of a send does not indicate that the data was successfully delivered.","pos":[1,96]},{"content":"If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[97,263]}]}]},{"pos":[3548,3773],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[591770,595563],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.","nodes":[{"pos":[0,84],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent."}],"pos":[596218,596303],"yaml":true},{"content":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,79],"content":"The number of bytes sent to the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[596359,596439],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[596599,596630],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[596744,596800],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[596906,596974],"yaml":true},{"content":"Sends the set of buffers in the list to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,99],"content":"Sends the set of buffers in the list to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Sends the set of buffers in the list to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[598443,598543],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.  \n  \n This overload requires at least one buffer that contains the data you want to send.  \n  \n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \n  \n If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \n  \n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,111],"content":"<xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.","pos":[0,111],"source":"<xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols."}]},{"pos":[118,201],"content":"This overload requires at least one buffer that contains the data you want to send.","nodes":[{"content":"This overload requires at least one buffer that contains the data you want to send.","pos":[0,83]}]},{"pos":[208,673],"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","nodes":[{"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","pos":[0,465],"nodes":[{"content":"If you are using a connectionless protocol, you must call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[0,229],"source":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are using a connection-oriented protocol, you must either use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.","pos":[230,465],"source":" If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection."}]}]},{"pos":[680,1375],"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","pos":[0,695],"nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.","pos":[0,162],"source":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method."},{"content":"If you do not use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.","pos":[163,363],"source":" If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[364,522],"source":" You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"You can also change the default remote host prior to calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[523,695],"source":" You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>."}]}]},{"pos":[1382,2482],"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,1100],"nodes":[{"content":"If you are using a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,256],"source":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[257,398],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"In nonblocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.","pos":[399,548],"source":" In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer."},{"content":"It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.","pos":[549,710]},{"content":"There is also no guarantee that the data you send will appear on the network immediately.","pos":[711,800]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[801,935]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[936,1100],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[2490,2856],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[2864,3137],"content":"[!NOTE]\n The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","leadings":["","> "],"nodes":[{"content":" The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[8,271],"nodes":[{"content":"The successful completion of a send does not indicate that the data was successfully delivered.","pos":[1,96]},{"content":"If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[97,263]}]}]},{"pos":[3145,3370],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[598554,601944],"yaml":true,"extradata":"MT"},{"content":"A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.","nodes":[{"pos":[0,129],"content":"A list of <ph id=\"ph1\">&lt;xref href=\"System.ArraySegment`1\"&gt;&lt;/xref&gt;</ph>s of type <ph id=\"ph2\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.","source":"A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the data to be sent."}],"pos":[602179,602309],"yaml":true},{"content":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,79],"content":"The number of bytes sent to the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[602365,602445],"yaml":true},{"content":"<code>buffers</code> is `null`.","nodes":[{"pos":[0,31],"content":"<ph id=\"ph1\">&lt;code&gt;buffers&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffers</code> is `null`."}],"pos":[602605,602637],"yaml":true},{"content":"<code>buffers</code> is empty.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffers&lt;/code&gt;</ph> is empty.","source":"<code>buffers</code> is empty."}],"pos":[602731,602762],"yaml":true},{"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"pos":[0,82],"content":"An error occurred when attempting to access the socket. See remarks section below.","nodes":[{"content":"An error occurred when attempting to access the socket. See remarks section below.","pos":[0,82],"nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]},{"content":"See remarks section below.","pos":[56,82]}]}]}],"pos":[602876,602959],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[603065,603133],"yaml":true},{"content":"Sends data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.","nodes":[{"pos":[0,145],"content":"Sends data to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> using the specified <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>.","source":"Sends data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>."}],"pos":[604580,604726],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.  \n  \n This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>. The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed.  \n  \n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \n  \n If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \n  \n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n> [!NOTE]\n>  You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see[Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,374],"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.","nodes":[{"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.","pos":[0,374],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.","pos":[0,251],"source":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method can be used for both connection-oriented and connectionless protocols.","pos":[252,374],"source":" The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols."}]}]},{"pos":[381,776],"content":"This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>. The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed.","nodes":[{"content":"This overload requires a buffer that contains the data you want to send and a bitwise combination of <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.","pos":[0,139],"source":"This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>."},{"content":"The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.","pos":[140,240]},{"content":"If you specify the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id=\"ph2\">`socketflags`</ph> parameter value, the data you are sending will not be routed.","pos":[241,395],"source":" If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed."}]},{"pos":[783,1248],"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","nodes":[{"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","pos":[0,465],"nodes":[{"content":"If you are using a connectionless protocol, you must call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[0,229],"source":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are using a connection-oriented protocol, you must either use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.","pos":[230,465],"source":" If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection."}]}]},{"pos":[1255,1961],"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","pos":[0,706],"nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.","pos":[0,162],"source":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method."},{"content":"If you do not use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method before each call to <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.","pos":[163,374],"source":" If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[375,533],"source":" You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"You can also change the default remote host prior to calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[534,706],"source":" You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>."}]}]},{"pos":[1968,3074],"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,1106],"nodes":[{"content":"If you are using a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,256],"source":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[257,398],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"In nonblocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.","pos":[399,548],"source":" In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer."},{"content":"It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.","pos":[549,716]},{"content":"There is also no guarantee that the data you send will appear on the network immediately.","pos":[717,806]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[807,941]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[942,1106],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[3082,3712],"content":"[!NOTE]\n You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,628],"nodes":[{"content":"You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.","pos":[1,121]},{"content":"If it does, the datagram will not be sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[122,264],"source":" If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[265,456],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[457,620]}]}]},{"pos":[3720,3993],"content":"[!NOTE]\n The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","leadings":["","> "],"nodes":[{"content":" The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[8,271],"nodes":[{"content":"The successful completion of a send does not indicate that the data was successfully delivered.","pos":[1,96]},{"content":"If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[97,263]}]}]},{"pos":[4001,4225],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see[Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see[Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,222],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see<bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,214],"source":" For more information, see[Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[604737,608982],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.","nodes":[{"pos":[0,84],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent."}],"pos":[609681,609766],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[609850,609939],"yaml":true},{"content":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,79],"content":"The number of bytes sent to the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[609995,610075],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[610235,610266],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[610380,610436],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[610542,610610],"yaml":true},{"content":"Sends the set of buffers in the list to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.","nodes":[{"pos":[0,172],"content":"Sends the set of buffers in the list to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>, using the specified <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>.","source":"Sends the set of buffers in the list to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>."}],"pos":[612211,612384],"yaml":true},{"content":"This overload requires at least one buffer that contains the data you want to send. The <xref:System.Net.Sockets.SocketFlags> value defaults to 0. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.  \n  \n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \n  \n If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \n  \n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,295],"content":"This overload requires at least one buffer that contains the data you want to send. The <xref:System.Net.Sockets.SocketFlags> value defaults to 0. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.","nodes":[{"content":"This overload requires at least one buffer that contains the data you want to send.","pos":[0,83]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.","pos":[84,146],"source":" The <xref:System.Net.Sockets.SocketFlags> value defaults to 0."},{"content":"If you specify the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id=\"ph2\">`socketFlags`</ph> parameter, the data you are sending will not be routed.","pos":[147,295],"source":" If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed."}]},{"pos":[302,767],"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","nodes":[{"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","pos":[0,465],"nodes":[{"content":"If you are using a connectionless protocol, you must call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[0,229],"source":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are using a connection-oriented protocol, you must either use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.","pos":[230,465],"source":" If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection."}]}]},{"pos":[774,1469],"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","pos":[0,695],"nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.","pos":[0,162],"source":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method."},{"content":"If you do not use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.","pos":[163,363],"source":" If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[364,522],"source":" You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"You can also change the default remote host prior to calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[523,695],"source":" You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>."}]}]},{"pos":[1476,2577],"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,1101],"nodes":[{"content":"If you are using a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,256],"source":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[257,398],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"In non-blocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.","pos":[399,549],"source":" In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer."},{"content":"It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.","pos":[550,711]},{"content":"There is also no guarantee that the data you send will appear on the network immediately.","pos":[712,801]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[802,936]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[937,1101],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[2585,2951],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[2959,3232],"content":"[!NOTE]\n The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","leadings":["","> "],"nodes":[{"content":" The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[8,271],"nodes":[{"content":"The successful completion of a send does not indicate that the data was successfully delivered.","pos":[1,96]},{"content":"If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[97,263]}]}]},{"pos":[3240,3465],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[612395,615878],"yaml":true,"extradata":"MT"},{"content":"A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.","nodes":[{"pos":[0,129],"content":"A list of <ph id=\"ph1\">&lt;xref href=\"System.ArraySegment`1\"&gt;&lt;/xref&gt;</ph>s of type <ph id=\"ph2\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.","source":"A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the data to be sent."}],"pos":[616157,616287],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[616371,616460],"yaml":true},{"content":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,79],"content":"The number of bytes sent to the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[616516,616596],"yaml":true},{"content":"<code>buffers</code> is `null`.","nodes":[{"pos":[0,31],"content":"<ph id=\"ph1\">&lt;code&gt;buffers&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffers</code> is `null`."}],"pos":[616756,616788],"yaml":true},{"content":"<code>buffers</code> is empty.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffers&lt;/code&gt;</ph> is empty.","source":"<code>buffers</code> is empty."}],"pos":[616882,616913],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[617027,617083],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[617189,617257],"yaml":true},{"content":"Sends the specified number of bytes of data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.","nodes":[{"pos":[0,179],"content":"Sends the specified number of bytes of data to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>, using the specified <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>.","source":"Sends the specified number of bytes of data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>."}],"pos":[618808,618988],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.  \n  \n This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \n  \n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \n  \n If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \n  \n With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n> [!NOTE]\n>  You must ensure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,363],"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.","nodes":[{"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.","pos":[0,363],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.","pos":[0,251],"source":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.","pos":[252,363],"source":" <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols."}]}]},{"pos":[370,701],"content":"This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.","nodes":[{"content":"This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.","pos":[0,182],"source":"This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>."},{"content":"If you specify the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id=\"ph2\">`socketflags`</ph> parameter, the data you are sending will not be routed.","pos":[183,331],"source":" If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed."}]},{"pos":[708,1173],"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","nodes":[{"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","pos":[0,465],"nodes":[{"content":"If you are using a connectionless protocol, you must call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[0,229],"source":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are using a connection-oriented protocol, you must either use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.","pos":[230,465],"source":" If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection."}]}]},{"pos":[1180,1897],"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","pos":[0,717],"nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.","pos":[0,162],"source":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method."},{"content":"If you do not use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method before each call to the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.","pos":[163,385],"source":" If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[386,544],"source":" You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"You can also change the default remote host prior to calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[545,717],"source":" You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>."}]}]},{"pos":[1904,2995],"content":"With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,1091],"nodes":[{"content":"With a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,243],"source":"With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[244,385],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"In nonblocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.","pos":[386,533],"source":" In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request."},{"content":"It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.","pos":[534,701]},{"content":"There is also no guarantee that the data you send will appear on the network immediately.","pos":[702,791]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[792,926]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[927,1091],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[3003,3618],"content":"[!NOTE]\n You must ensure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" You must ensure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,613],"nodes":[{"content":"You must ensure that the size does not exceed the maximum packet size of the underlying service provider.","pos":[1,106]},{"content":"If it does, the datagram will not be sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[107,249],"source":" If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[250,441],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[442,605]}]}]},{"pos":[3626,3899],"content":"[!NOTE]\n The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","leadings":["","> "],"nodes":[{"content":" The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[8,271],"nodes":[{"content":"The successful completion of a send does not indicate that the data was successfully delivered.","pos":[1,96]},{"content":"If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[97,263]}]}]},{"pos":[3907,4132],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[618999,623151],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.","nodes":[{"pos":[0,84],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent."}],"pos":[623917,624002],"yaml":true},{"content":"The number of bytes to send.","nodes":[{"pos":[0,28],"content":"The number of bytes to send.","nodes":[{"content":"The number of bytes to send.","pos":[0,28]}]}],"pos":[624061,624090],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[624174,624263],"yaml":true},{"content":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,79],"content":"The number of bytes sent to the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[624319,624399],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[624559,624590],"yaml":true},{"content":"<code>size</code> is less than 0 or exceeds the size of the buffer.","nodes":[{"pos":[0,67],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0 or exceeds the size of the buffer.","source":"<code>size</code> is less than 0 or exceeds the size of the buffer."}],"pos":[624704,624772],"yaml":true},{"content":"<code>socketFlags</code> is not a valid combination of values.  \n  \n -or-  \n  \n An operating system error occurs while accessing the socket.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.","source":"<code>socketFlags</code> is not a valid combination of values."},{"pos":[69,73],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[80,140],"content":"An operating system error occurs while accessing the socket.","nodes":[{"content":"An operating system error occurs while accessing the socket.","pos":[0,60]}]}],"pos":[624886,625033],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[625139,625207],"yaml":true},{"content":"Sends the set of buffers in the list to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.","nodes":[{"pos":[0,172],"content":"Sends the set of buffers in the list to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>, using the specified <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>.","source":"Sends the set of buffers in the list to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>."}],"pos":[626943,627116],"yaml":true},{"content":"This overload requires at least one buffer that contains the data you want to send. The <xref:System.Net.Sockets.SocketFlags> value defaults to 0. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.  \n  \n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \n  \n If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \n  \n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,295],"content":"This overload requires at least one buffer that contains the data you want to send. The <xref:System.Net.Sockets.SocketFlags> value defaults to 0. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.","nodes":[{"content":"This overload requires at least one buffer that contains the data you want to send.","pos":[0,83]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.","pos":[84,146],"source":" The <xref:System.Net.Sockets.SocketFlags> value defaults to 0."},{"content":"If you specify the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id=\"ph2\">`socketFlags`</ph> parameter, the data you are sending will not be routed.","pos":[147,295],"source":" If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed."}]},{"pos":[302,767],"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","nodes":[{"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","pos":[0,465],"nodes":[{"content":"If you are using a connectionless protocol, you must call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[0,229],"source":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are using a connection-oriented protocol, you must either use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.","pos":[230,465],"source":" If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection."}]}]},{"pos":[774,1469],"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","pos":[0,695],"nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.","pos":[0,162],"source":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method."},{"content":"If you do not use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.","pos":[163,363],"source":" If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>."},{"content":"You can use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[364,522],"source":" You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"You can also change the default remote host prior to calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[523,695],"source":" You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>."}]}]},{"pos":[1476,2577],"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,1101],"nodes":[{"content":"If you are using a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,256],"source":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[257,398],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"In non-blocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.","pos":[399,549],"source":" In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer."},{"content":"It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.","pos":[550,711]},{"content":"There is also no guarantee that the data you send will appear on the network immediately.","pos":[712,801]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[802,936]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[937,1101],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[2585,2951],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[2959,3232],"content":"[!NOTE]\n The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","leadings":["","> "],"nodes":[{"content":" The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[8,271],"nodes":[{"content":"The successful completion of a send does not indicate that the data was successfully delivered.","pos":[1,96]},{"content":"If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[97,263]}]}]},{"pos":[3240,3465],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[627127,630610],"yaml":true,"extradata":"MT"},{"content":"A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.","nodes":[{"pos":[0,129],"content":"A list of <ph id=\"ph1\">&lt;xref href=\"System.ArraySegment`1\"&gt;&lt;/xref&gt;</ph>s of type <ph id=\"ph2\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.","source":"A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the data to be sent."}],"pos":[630980,631110],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[631194,631283],"yaml":true},{"content":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.","nodes":[{"pos":[0,90],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketError\"&gt;&lt;/xref&gt;</ph> object that stores the socket error.","source":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error."}],"pos":[631365,631456],"yaml":true},{"content":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,79],"content":"The number of bytes sent to the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[631512,631592],"yaml":true},{"content":"<code>buffers</code> is `null`.","nodes":[{"pos":[0,31],"content":"<ph id=\"ph1\">&lt;code&gt;buffers&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffers</code> is `null`."}],"pos":[631752,631784],"yaml":true},{"content":"<code>buffers</code> is empty.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffers&lt;/code&gt;</ph> is empty.","source":"<code>buffers</code> is empty."}],"pos":[631878,631909],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[632023,632079],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[632185,632253],"yaml":true},{"content":"Sends the specified number of bytes of data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, starting at the specified offset, and using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.","nodes":[{"pos":[0,217],"content":"Sends the specified number of bytes of data to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>, starting at the specified offset, and using the specified <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>.","source":"Sends the specified number of bytes of data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, starting at the specified offset, and using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>."}],"pos":[633917,634135],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.  \n  \n In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \n  \n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \n  \n If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>. If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \n  \n You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,361],"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.","nodes":[{"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.","pos":[0,361],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.","pos":[0,249],"source":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.","pos":[250,361],"source":" <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols."}]}]},{"pos":[368,534],"content":"In this overload, if you specify the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id=\"ph2\">`socketflags`</ph> parameter, the data you are sending will not be routed.","source":"In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed."},{"pos":[541,1005],"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","nodes":[{"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","pos":[0,464],"nodes":[{"content":"If you are using a connectionless protocol, you must call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[0,228],"source":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are using a connection-oriented protocol, you must either use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.","pos":[229,464],"source":" If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection."}]}]},{"pos":[1012,1691],"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>. If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>. If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","pos":[0,679],"nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.","pos":[0,151],"source":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>."},{"content":"If you do not use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, you will have to call <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.","pos":[152,341],"source":" If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>."},{"content":"It is okay to use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[342,506],"source":" It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"You can also change the default remote host prior to calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[507,679],"source":" You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>."}]}]},{"pos":[1698,1952],"content":"You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.","pos":[0,254],"nodes":[{"content":"You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.","pos":[0,111]},{"content":"If it does, the datagram will not be sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[112,254],"source":" If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]}]},{"pos":[1959,3062],"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,1103],"nodes":[{"content":"If you are using a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,255],"source":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[256,397],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"In nonblocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.","pos":[398,545],"source":" In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request."},{"content":"It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.","pos":[546,713]},{"content":"There is also no guarantee that the data you send will appear on the network immediately.","pos":[714,803]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[804,938]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[939,1103],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[3070,3436],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3444,3717],"content":"[!NOTE]\n The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","leadings":["","> "],"nodes":[{"content":" The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[8,271],"nodes":[{"content":"The successful completion of a send does not indicate that the data was successfully delivered.","pos":[1,96]},{"content":"If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[97,263]}]}]},{"pos":[3725,3950],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[634146,638118],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.","nodes":[{"pos":[0,84],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent."}],"pos":[638918,639003],"yaml":true},{"content":"The position in the data buffer at which to begin sending data.","nodes":[{"pos":[0,63],"content":"The position in the data buffer at which to begin sending data.","nodes":[{"content":"The position in the data buffer at which to begin sending data.","pos":[0,63]}]}],"pos":[639064,639128],"yaml":true},{"content":"The number of bytes to send.","nodes":[{"pos":[0,28],"content":"The number of bytes to send.","nodes":[{"content":"The number of bytes to send.","pos":[0,28]}]}],"pos":[639187,639216],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[639300,639389],"yaml":true},{"content":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,79],"content":"The number of bytes sent to the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[639445,639525],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[639685,639716],"yaml":true},{"content":"<code>offset</code> is less than 0.  \n  \n -or-  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n -or-  \n  \n <code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.","source":"<code>offset</code> is less than 0."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,123],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>offset</code> is greater than the length of <code>buffer</code>."},{"pos":[130,134],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[141,174],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[181,185],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[192,313],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id=\"ph3\">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.","source":"<code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter."}],"pos":[639830,640158],"yaml":true},{"content":"<code>socketFlags</code> is not a valid combination of values.  \n  \n -or-  \n  \n An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.","source":"<code>socketFlags</code> is not a valid combination of values."},{"pos":[69,73],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[80,180],"content":"An operating system error occurs while accessing the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[640272,640461],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[640567,640635],"yaml":true},{"content":"Sends the specified number of bytes of data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, starting at the specified offset, and using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>","nodes":[{"pos":[0,216],"content":"Sends the specified number of bytes of data to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>, starting at the specified offset, and using the specified <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>","source":"Sends the specified number of bytes of data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, starting at the specified offset, and using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>"}],"pos":[642275,642492],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.  \n  \n In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \n  \n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a<xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \n  \n If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>. If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \n  \n You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see[Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,361],"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.","nodes":[{"content":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.","pos":[0,361],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.","pos":[0,249],"source":"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.","pos":[250,361],"source":" <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols."}]}]},{"pos":[368,534],"content":"In this overload, if you specify the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id=\"ph2\">`socketflags`</ph> parameter, the data you are sending will not be routed.","source":"In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed."},{"pos":[541,1004],"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a<xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","nodes":[{"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a<xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","pos":[0,463],"nodes":[{"content":"If you are using a connectionless protocol, you must call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a<ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[0,227],"source":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a<xref:System.Net.Sockets.SocketException>."},{"content":"If you are using a connection-oriented protocol, you must either use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.","pos":[228,463],"source":" If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection."}]}]},{"pos":[1011,1690],"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>. If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>. If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.","pos":[0,679],"nodes":[{"content":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.","pos":[0,151],"source":"If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>."},{"content":"If you do not use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, you will have to call <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.","pos":[152,341],"source":" If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>."},{"content":"It is okay to use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[342,506],"source":" It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>."},{"content":"You can also change the default remote host prior to calling <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.","pos":[507,679],"source":" You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>."}]}]},{"pos":[1697,1951],"content":"You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.","pos":[0,254],"nodes":[{"content":"You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.","pos":[0,111]},{"content":"If it does, the datagram will not be sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[112,254],"source":" If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]}]},{"pos":[1958,3061],"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,1103],"nodes":[{"content":"If you are using a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName&gt;</ph>.","pos":[0,255],"source":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>."},{"content":"If the time-out value was exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[256,397],"source":" If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"In nonblocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.","pos":[398,545],"source":" In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request."},{"content":"It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.","pos":[546,713]},{"content":"There is also no guarantee that the data you send will appear on the network immediately.","pos":[714,803]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[804,938]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[939,1103],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[3069,3435],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3443,3716],"content":"[!NOTE]\n The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","leadings":["","> "],"nodes":[{"content":" The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[8,271],"nodes":[{"content":"The successful completion of a send does not indicate that the data was successfully delivered.","pos":[1,96]},{"content":"If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.","pos":[97,263]}]}]},{"pos":[3724,3948],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see[Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see[Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,222],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see<bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,214],"source":" For more information, see[Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[642503,646473],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.","nodes":[{"pos":[0,84],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent."}],"pos":[647319,647404],"yaml":true},{"content":"The position in the data buffer at which to begin sending data.","nodes":[{"pos":[0,63],"content":"The position in the data buffer at which to begin sending data.","nodes":[{"content":"The position in the data buffer at which to begin sending data.","pos":[0,63]}]}],"pos":[647465,647529],"yaml":true},{"content":"The number of bytes to send.","nodes":[{"pos":[0,28],"content":"The number of bytes to send.","nodes":[{"content":"The number of bytes to send.","pos":[0,28]}]}],"pos":[647588,647617],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[647701,647790],"yaml":true},{"content":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.","nodes":[{"pos":[0,90],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketError\"&gt;&lt;/xref&gt;</ph> object that stores the socket error.","source":"A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error."}],"pos":[647872,647963],"yaml":true},{"content":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,79],"content":"The number of bytes sent to the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[648019,648099],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[648259,648290],"yaml":true},{"content":"<code>offset</code> is less than 0.  \n  \n -or-  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n -or-  \n  \n <code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.","source":"<code>offset</code> is less than 0."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,123],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>offset</code> is greater than the length of <code>buffer</code>."},{"pos":[130,134],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[141,174],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[181,185],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[192,313],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id=\"ph3\">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.","source":"<code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter."}],"pos":[648404,648732],"yaml":true},{"content":"<code>socketFlags</code> is not a valid combination of values.  \n  \n -or-  \n  \n An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.","source":"<code>socketFlags</code> is not a valid combination of values."},{"pos":[69,73],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[80,180],"content":"An operating system error occurs while accessing the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[648846,649035],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[649141,649209],"yaml":true},{"content":"Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object.","nodes":[{"pos":[0,95],"content":"Sends data asynchronously to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object.","source":"Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object."}],"pos":[650612,650708],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket. This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.  \n  \n The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.  \n  \n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \n  \n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \n  \n The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.  \n  \n Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread.  \n  \n For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider. If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAEMSGSIZE error code (10040).  \n  \n Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered.","nodes":[{"pos":[0,268],"content":"The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket. This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket. This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.","pos":[0,268],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method is used to write outgoing data from one or more buffers on a connection-oriented socket.","pos":[0,145],"source":"The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket."},{"content":"This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.","pos":[146,268]}]}]},{"pos":[275,704],"content":"The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id=\"ph7\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.","pos":[0,429],"source":"The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method."}]},{"pos":[711,879],"content":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:","nodes":[{"content":"The following properties and events on the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required to successfully call this method:","pos":[0,168],"source":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:"}]},{"pos":[889,1059],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=fullName>","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=fullName&gt;</ph>","pos":[0,170],"source":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=fullName>"}]},{"pos":[1069,1241],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName&gt;</ph> if <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> is set","pos":[0,172],"source":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set"}]},{"pos":[1251,1424],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName&gt;</ph> if <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName&gt;</ph> is set","pos":[0,173],"source":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set"}]},{"pos":[1434,1515],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>","nodes":[]},{"pos":[1522,1959],"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","nodes":[{"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[0,437],"nodes":[{"content":"The caller may set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.","pos":[0,290],"source":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method."},{"content":"If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[291,437]}]}]},{"pos":[1966,2359],"content":"The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method will throw an exception if you do not first call <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph><ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id=\"ph7\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>.","pos":[0,393],"source":"The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>."}]},{"pos":[2366,2501],"content":"Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread.","nodes":[{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.","pos":[0,135],"source":"Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread."}]},{"pos":[2508,3001],"content":"For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider. If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAEMSGSIZE error code (10040).","nodes":[{"content":"For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider. If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAEMSGSIZE error code (10040).","pos":[0,493],"nodes":[{"content":"For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.","pos":[0,120]},{"content":"If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method throws a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName&gt;</ph> set to the native Winsock WSAEMSGSIZE error code (10040).","pos":[121,493],"source":" If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAEMSGSIZE error code (10040)."}]}]},{"pos":[3008,3163],"content":"Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered.","nodes":[{"content":"Note that the successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method does not indicate that the data was successfully delivered.","pos":[0,155],"source":"Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered."}]}],"pos":[650719,653907],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.","source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation."}],"pos":[654096,654215],"yaml":true},{"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \n  \n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"pos":[0,209],"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`true`</ph> if the I/O operation is pending.","pos":[0,47],"source":"Returns `true` if the I/O operation is pending."},{"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.","pos":[48,209],"source":" The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation."}]},{"pos":[216,574],"content":"Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`false`</ph> if the I/O operation completed synchronously.","pos":[0,61],"source":"Returns `false` if the I/O operation completed synchronously."},{"content":"In this case, The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">e</ph><ept id=\"p2\">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","pos":[62,358],"source":" In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation."}]}],"pos":[654273,654856],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\"></xref> or <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> properties on the <code>e</code> parameter must reference valid buffers. One or the other of these properties may be set, but not both at the same time.","nodes":[{"pos":[0,299],"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\"></xref> or <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> properties on the <code>e</code> parameter must reference valid buffers. One or the other of these properties may be set, but not both at the same time.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"&gt;&lt;/xref&gt;</ph> properties on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph3\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter must reference valid buffers.","pos":[0,219],"source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\"></xref> or <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> properties on the <code>e</code> parameter must reference valid buffers."},{"content":"One or the other of these properties may be set, but not both at the same time.","pos":[220,299]}]}],"pos":[655013,655313],"yaml":true},{"content":"A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.","nodes":[{"pos":[0,163],"content":"A socket operation was already in progress using the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter."}],"pos":[655423,655587],"yaml":true},{"content":"Windows XP or later is required for this method.","nodes":[{"pos":[0,48],"content":"Windows XP or later is required for this method.","nodes":[{"content":"Windows XP or later is required for this method.","pos":[0,48]}]}],"pos":[655689,655738],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[655844,655912],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is not yet connected or was not obtained via an <xref href=\"System.Net.Sockets.Socket.Accept\"></xref>, <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\"></xref>,or <xref href=\"System.Net.Sockets.Socket.BeginAccept*\"></xref>, method.","nodes":[{"pos":[0,325],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is not yet connected or was not obtained via an <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket.Accept\"&gt;&lt;/xref&gt;</ph>, <ph id=\"ph3\">&lt;xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\"&gt;&lt;/xref&gt;</ph>,or <ph id=\"ph4\">&lt;xref href=\"System.Net.Sockets.Socket.BeginAccept*\"&gt;&lt;/xref&gt;</ph>, method.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> is not yet connected or was not obtained via an <xref href=\"System.Net.Sockets.Socket.Accept\"></xref>, <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\"></xref>,or <xref href=\"System.Net.Sockets.Socket.BeginAccept*\"></xref>, method."}],"pos":[656026,656352],"yaml":true},{"content":"Gets or sets a value that specifies the size of the send buffer of the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,118],"content":"Gets or sets a value that specifies the size of the send buffer of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Gets or sets a value that specifies the size of the send buffer of the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[657598,657717],"yaml":true},{"content":"A larger buffer size might delay the recognition of connection difficulties. Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)","nodes":[{"pos":[0,250],"content":"A larger buffer size might delay the recognition of connection difficulties. Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)","nodes":[{"content":"A larger buffer size might delay the recognition of connection difficulties. Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)","pos":[0,250],"nodes":[{"content":"A larger buffer size might delay the recognition of connection difficulties.","pos":[0,76]},{"content":"Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)","pos":[77,250]}]}]}],"pos":[657728,657979],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Int32\"></xref> that contains the size, in bytes, of the send buffer. The default is 8192.","nodes":[{"pos":[0,111],"content":"An <xref href=\"System.Int32\"></xref> that contains the size, in bytes, of the send buffer. The default is 8192.","nodes":[{"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Int32\"&gt;&lt;/xref&gt;</ph> that contains the size, in bytes, of the send buffer.","pos":[0,90],"source":"An <xref href=\"System.Int32\"></xref> that contains the size, in bytes, of the send buffer."},{"content":"The default is 8192.","pos":[91,111]}]}],"pos":[658483,658595],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[658777,658833],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[658939,659007],"yaml":true},{"content":"The value specified for a set operation is less than 0.","nodes":[{"pos":[0,55],"content":"The value specified for a set operation is less than 0.","nodes":[{"content":"The value specified for a set operation is less than 0.","pos":[0,55]}]}],"pos":[659121,659177],"yaml":true},{"content":"Sends the file <code>fileName</code> to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object with the <xref href=\"System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread\"></xref> transmit flag.","nodes":[{"pos":[0,212],"content":"Sends the file <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">fileName</ph><ept id=\"p1\">&lt;/code&gt;</ept> to a connected <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object with the <ph id=\"ph3\">&lt;xref href=\"System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread\"&gt;&lt;/xref&gt;</ph> transmit flag.","source":"Sends the file <code>fileName</code> to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object with the <xref href=\"System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread\"></xref> transmit flag."}],"pos":[660454,660667],"yaml":true},{"content":"This overload sends the file `fileName` to the connected socket. The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`. If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards (\"..\\\\\\myfile.txt\") and UNC share names (\"\\\\\\\\\\\\\\shared directory\\\\\\myfile.txt\") are supported. If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.  \n  \n This method uses the `TransmitFile` function found in the Windows Sockets 2 API. For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.  \n  \n <xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. <xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.  \n  \n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \n  \n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent. In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,594],"content":"This overload sends the file `fileName` to the connected socket. The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`. If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards (\"..\\\\\\myfile.txt\") and UNC share names (\"\\\\\\\\\\\\\\shared directory\\\\\\myfile.txt\") are supported. If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.","nodes":[{"content":"This overload sends the file <ph id=\"ph1\">`fileName`</ph> to the connected socket.","pos":[0,64],"source":"This overload sends the file `fileName` to the connected socket."},{"content":"The <ph id=\"ph1\">`flags`</ph> parameter defaults to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread&gt;</ph> (0), and the <ph id=\"ph3\">`preBuffer`</ph> and <ph id=\"ph4\">`postBuffer`</ph> parameters default to <ph id=\"ph5\">`null`</ph>.","pos":[65,239],"source":" The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`."},{"content":"If <ph id=\"ph1\">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.","pos":[240,398],"source":" If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified."},{"content":"Wildcards (\"..<ph id=\"ph1\">\\\\</ph>\\myfile.txt\") and UNC share names (\"<ph id=\"ph2\">\\\\</ph><ph id=\"ph3\">\\\\</ph><ph id=\"ph4\">\\\\</ph>\\shared directory<ph id=\"ph5\">\\\\</ph>\\myfile.txt\") are supported.","pos":[399,504],"source":" Wildcards (\"..\\\\\\myfile.txt\") and UNC share names (\"\\\\\\\\\\\\\\shared directory\\\\\\myfile.txt\") are supported."},{"content":"If the file is not found, the exception <ph id=\"ph1\">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.","pos":[505,594],"source":" If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown."}]},{"pos":[601,810],"content":"This method uses the `TransmitFile` function found in the Windows Sockets 2 API. For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.","nodes":[{"content":"This method uses the <ph id=\"ph1\">`TransmitFile`</ph> function found in the Windows Sockets 2 API.","pos":[0,80],"source":"This method uses the `TransmitFile` function found in the Windows Sockets 2 API."},{"content":"For more information about the <ph id=\"ph1\">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.","pos":[81,209],"source":" For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library."}]},{"pos":[817,1142],"content":"<xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. <xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.","nodes":[{"content":"<xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. <xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.","pos":[0,325],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> synchronously sends a file to the remote host specified in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[0,205],"source":"<xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> can be used for both connection-oriented and for connectionless protocols.","pos":[206,325],"source":" <xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols."}]}]},{"pos":[1149,1630],"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","nodes":[{"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","pos":[0,481],"nodes":[{"content":"If you are using a connectionless protocol, you must call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, otherwise <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> throws a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.","pos":[0,246],"source":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception."},{"content":"If you are using a connection-oriented protocol, you must either use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection or use <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.","pos":[247,481],"source":" If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection."}]}]},{"pos":[1637,2280],"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent. In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent. In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,643],"nodes":[{"content":"If you are using a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blocks until the file is sent.","pos":[0,124],"source":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent."},{"content":"In nonblocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> may complete successfully before the entire file has been sent.","pos":[125,254],"source":" In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent."},{"content":"There is no guarantee that the data you send will appear on the network immediately.","pos":[255,339]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[340,474]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[475,643],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[2288,2654],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[2662,2887],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[660678,663599],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.String\"></xref> that contains the path and name of the file to be sent. This parameter can be `null`.","nodes":[{"pos":[0,122],"content":"A <xref href=\"System.String\"></xref> that contains the path and name of the file to be sent. This parameter can be `null`.","nodes":[{"content":"A <ph id=\"ph1\">&lt;xref href=\"System.String\"&gt;&lt;/xref&gt;</ph> that contains the path and name of the file to be sent.","pos":[0,92],"source":"A <xref href=\"System.String\"></xref> that contains the path and name of the file to be sent."},{"content":"This parameter can be <ph id=\"ph1\">`null`</ph>.","pos":[93,122],"source":" This parameter can be `null`."}]}],"pos":[664221,664344],"yaml":true},{"content":"The socket is not connected to a remote host.","nodes":[{"pos":[0,45],"content":"The socket is not connected to a remote host.","nodes":[{"content":"The socket is not connected to a remote host.","pos":[0,45]}]}],"pos":[664508,664554],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed."}],"pos":[664660,664735],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object is not in blocking mode and cannot accept this synchronous call.","nodes":[{"pos":[0,122],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object is not in blocking mode and cannot accept this synchronous call.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object is not in blocking mode and cannot accept this synchronous call."}],"pos":[664845,664968],"yaml":true},{"content":"The file <code>fileName</code> was not found.","nodes":[{"pos":[0,45],"content":"The file <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">fileName</ph><ept id=\"p1\">&lt;/code&gt;</ept> was not found.","source":"The file <code>fileName</code> was not found."}],"pos":[665076,665122],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[665236,665292],"yaml":true},{"content":"Sends the file <code>fileName</code> and buffers of data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object using the specified <xref href=\"System.Net.Sockets.TransmitFileOptions\"></xref> value.","nodes":[{"pos":[0,212],"content":"Sends the file <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">fileName</ph><ept id=\"p1\">&lt;/code&gt;</ept> and buffers of data to a connected <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object using the specified <ph id=\"ph3\">&lt;xref href=\"System.Net.Sockets.TransmitFileOptions\"&gt;&lt;/xref&gt;</ph> value.","source":"Sends the file <code>fileName</code> and buffers of data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object using the specified <xref href=\"System.Net.Sockets.TransmitFileOptions\"></xref> value."}],"pos":[666697,666910],"yaml":true},{"content":"This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values. The `preBuffer` parameter contains any data you want to precede the file. `postBuffer` contains data you want to follow the file. If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards (\"..\\\\\\myfile.txt\") and UNC share names (\"\\\\\\\\\\\\\\shared directory\\\\\\myfile.txt\") are supported.  \n  \n The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer. For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.  \n  \n This method uses the `TransmitFile` function found in the Windows Sockets 2 API. For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.  \n  \n <xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. <xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.  \n  \n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \n  \n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent. In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,548],"content":"This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values. The `preBuffer` parameter contains any data you want to precede the file. `postBuffer` contains data you want to follow the file. If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards (\"..\\\\\\myfile.txt\") and UNC share names (\"\\\\\\\\\\\\\\shared directory\\\\\\myfile.txt\") are supported.","nodes":[{"content":"This overload requires the name of the file you want to send and a bitwise combination of <ph id=\"ph1\">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> values.","pos":[0,143],"source":"This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values."},{"content":"The <ph id=\"ph1\">`preBuffer`</ph> parameter contains any data you want to precede the file.","pos":[144,217],"source":" The `preBuffer` parameter contains any data you want to precede the file."},{"content":"<ph id=\"ph1\">`postBuffer`</ph> contains data you want to follow the file.","pos":[218,273],"source":"`postBuffer` contains data you want to follow the file."},{"content":"If <ph id=\"ph1\">`fileName`</ph> is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.","pos":[274,442],"source":" If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified."},{"content":"Wildcards (\"..<ph id=\"ph1\">\\\\</ph>\\myfile.txt\") and UNC share names (\"<ph id=\"ph2\">\\\\</ph><ph id=\"ph3\">\\\\</ph><ph id=\"ph4\">\\\\</ph>\\shared directory<ph id=\"ph5\">\\\\</ph>\\myfile.txt\") are supported.","pos":[443,548],"source":" Wildcards (\"..\\\\\\myfile.txt\") and UNC share names (\"\\\\\\\\\\\\\\shared directory\\\\\\myfile.txt\") are supported."}]},{"pos":[555,779],"content":"The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer. For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.","nodes":[{"content":"The <ph id=\"ph1\">`flags`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.","pos":[0,119],"source":"The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer."},{"content":"For more information about how to use this parameter, see <ph id=\"ph1\">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.","pos":[120,224],"source":" For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>."}]},{"pos":[786,995],"content":"This method uses the `TransmitFile` function found in the Windows Sockets 2 API. For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.","nodes":[{"content":"This method uses the <ph id=\"ph1\">`TransmitFile`</ph> function found in the Windows Sockets 2 API.","pos":[0,80],"source":"This method uses the `TransmitFile` function found in the Windows Sockets 2 API."},{"content":"For more information about the <ph id=\"ph1\">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.","pos":[81,209],"source":" For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library."}]},{"pos":[1002,1327],"content":"<xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. <xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.","nodes":[{"content":"<xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. <xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.","pos":[0,325],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> synchronously sends a file to the remote host specified in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[0,205],"source":"<xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> can be used for both connection-oriented and for connectionless protocols.","pos":[206,325],"source":" <xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols."}]}]},{"pos":[1334,1806],"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","nodes":[{"content":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.","pos":[0,472],"nodes":[{"content":"If you are using a connectionless protocol, you must call <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method; otherwise <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> throws a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[0,236],"source":"If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>."},{"content":"If you are using a connection-oriented protocol, you must either use <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.","pos":[237,472],"source":" If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection."}]}]},{"pos":[1813,2463],"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent. In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent. In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,650],"nodes":[{"content":"If you are using a connection-oriented protocol, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blocks until the entire file is sent.","pos":[0,131],"source":"If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent."},{"content":"In nonblocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> may complete successfully before the entire file has been sent.","pos":[132,261],"source":" In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent."},{"content":"There is no guarantee that the data you send will appear on the network immediately.","pos":[262,346]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[347,481]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[482,650],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[2471,2837],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[2845,3070],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[666921,670027],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.String\"></xref> that contains the path and name of the file to be sent. This parameter can be `null`.","nodes":[{"pos":[0,122],"content":"A <xref href=\"System.String\"></xref> that contains the path and name of the file to be sent. This parameter can be `null`.","nodes":[{"content":"A <ph id=\"ph1\">&lt;xref href=\"System.String\"&gt;&lt;/xref&gt;</ph> that contains the path and name of the file to be sent.","pos":[0,92],"source":"A <xref href=\"System.String\"></xref> that contains the path and name of the file to be sent."},{"content":"This parameter can be <ph id=\"ph1\">`null`</ph>.","pos":[93,122],"source":" This parameter can be `null`."}]}],"pos":[670869,670992],"yaml":true},{"content":"A <xref href=\"System.Byte\"></xref> array that contains data to be sent before the file is sent. This parameter can be `null`.","nodes":[{"pos":[0,125],"content":"A <xref href=\"System.Byte\"></xref> array that contains data to be sent before the file is sent. This parameter can be `null`.","nodes":[{"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> array that contains data to be sent before the file is sent.","pos":[0,95],"source":"A <xref href=\"System.Byte\"></xref> array that contains data to be sent before the file is sent."},{"content":"This parameter can be <ph id=\"ph1\">`null`</ph>.","pos":[96,125],"source":" This parameter can be `null`."}]}],"pos":[671057,671183],"yaml":true},{"content":"A <xref href=\"System.Byte\"></xref> array that contains data to be sent after the file is sent. This parameter can be `null`.","nodes":[{"pos":[0,124],"content":"A <xref href=\"System.Byte\"></xref> array that contains data to be sent after the file is sent. This parameter can be `null`.","nodes":[{"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> array that contains data to be sent after the file is sent.","pos":[0,94],"source":"A <xref href=\"System.Byte\"></xref> array that contains data to be sent after the file is sent."},{"content":"This parameter can be <ph id=\"ph1\">`null`</ph>.","pos":[95,124],"source":" This parameter can be `null`."}]}],"pos":[671249,671374],"yaml":true},{"content":"One or more of <xref href=\"System.Net.Sockets.TransmitFileOptions\"></xref> values.","nodes":[{"pos":[0,82],"content":"One or more of <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.TransmitFileOptions\"&gt;&lt;/xref&gt;</ph> values.","source":"One or more of <xref href=\"System.Net.Sockets.TransmitFileOptions\"></xref> values."}],"pos":[671460,671543],"yaml":true},{"content":"The operating system is not Windows NT or later.  \n  \n \\- or -  \n  \n The socket is not connected to a remote host.","nodes":[{"pos":[0,48],"content":"The operating system is not Windows NT or later.","nodes":[{"content":"The operating system is not Windows NT or later.","pos":[0,48]}]},{"pos":[55,62],"content":"\\- or -","nodes":[{"content":"<ph id=\"ph1\">\\-</ph> or -","pos":[0,7],"source":"\\- or -"}]},{"pos":[69,114],"content":"The socket is not connected to a remote host.","nodes":[{"content":"The socket is not connected to a remote host.","pos":[0,45]}]}],"pos":[671707,671829],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed."}],"pos":[671935,672010],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object is not in blocking mode and cannot accept this synchronous call.","nodes":[{"pos":[0,122],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object is not in blocking mode and cannot accept this synchronous call.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object is not in blocking mode and cannot accept this synchronous call."}],"pos":[672120,672243],"yaml":true},{"content":"The file <code>fileName</code> was not found.","nodes":[{"pos":[0,45],"content":"The file <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">fileName</ph><ept id=\"p1\">&lt;/code&gt;</ept> was not found.","source":"The file <code>fileName</code> was not found."}],"pos":[672351,672397],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[672511,672567],"yaml":true},{"content":"Sends a collection of files or in memory data buffers asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object.","nodes":[{"pos":[0,138],"content":"Sends a collection of files or in memory data buffers asynchronously to a connected <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object.","source":"Sends a collection of files or in memory data buffers asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object."}],"pos":[673828,673967],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host. The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.  \n  \n If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=fullName> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards and UNC share names are supported. If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.  \n  \n To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.  \n  \n The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=fullName> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer. For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.  \n  \n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \n  \n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \n  \n This method uses the TransmitPackets function found in the Windows Sockets 2 API. For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.  \n  \n Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host. With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.  \n  \n The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used. On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.  \n  \n On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization.  \n  \n Use of the <xref:System.Net.Sockets.TransmitFileOptions?displayProperty=fullName> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=fullName> property on the `e` parameter can deliver significant performance benefits. If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching. Note that there is a difference between kernel and user-mode APCs. Kernel APCs launch when a thread is in a wait state. User-mode APCs launch when a thread is in an alertable wait state","nodes":[{"pos":[0,226],"content":"The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host. The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host. The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.","pos":[0,226],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is used to send a collection of files or in memory data buffers to remote host.","pos":[0,143],"source":"The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> must already be connected to the remote host.","pos":[144,226],"source":" The <xref:System.Net.Sockets.Socket> must already be connected to the remote host."}]}]},{"pos":[233,590],"content":"If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=fullName> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards and UNC share names are supported. If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.","nodes":[{"content":"If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=fullName> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards and UNC share names are supported. If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.","pos":[0,357],"nodes":[{"content":"If a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SendPacketsElement?displayProperty=fullName&gt;</ph> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.","pos":[0,236],"source":"If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=fullName> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified."},{"content":"Wildcards and UNC share names are supported.","pos":[237,281]},{"content":"If the file is not found, <ph id=\"ph1\">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.","pos":[282,357],"source":" If the file is not found, <xref:System.IO.FileNotFoundException> is thrown."}]}]},{"pos":[597,845],"content":"To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.","nodes":[{"content":"To be notified of completion, you must create a callback method that implements the EventHandler<ph id=\"ph1\">\\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName&gt;</ph> event.","pos":[0,248],"source":"To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event."}]},{"pos":[852,1180],"content":"The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=fullName> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer. For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=fullName&gt;</ph> property on the <ph id=\"ph2\">`e`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.","pos":[0,223],"source":"The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=fullName> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer."},{"content":"For more information about how to use this parameter, see <ph id=\"ph1\">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.","pos":[224,328],"source":" For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>."}]},{"pos":[1187,1355],"content":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:","nodes":[{"content":"The following properties and events on the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required to successfully call this method:","pos":[0,168],"source":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:"}]},{"pos":[1365,1459],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=fullName>","nodes":[]},{"pos":[1469,1550],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>","nodes":[]},{"pos":[1557,2001],"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","nodes":[{"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[0,444],"nodes":[{"content":"The caller may set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.","pos":[0,297],"source":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method."},{"content":"If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[298,444]}]}]},{"pos":[2008,2219],"content":"This method uses the TransmitPackets function found in the Windows Sockets 2 API. For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.","nodes":[{"content":"This method uses the TransmitPackets function found in the Windows Sockets 2 API. For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.","pos":[0,211],"nodes":[{"content":"This method uses the TransmitPackets function found in the Windows Sockets 2 API.","pos":[0,81]},{"content":"For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.","pos":[82,211]}]}]},{"pos":[2226,2918],"content":"Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host. With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.","nodes":[{"content":"Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host. With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.","pos":[0,692],"nodes":[{"content":"Although intended for connection-oriented protocols, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method also works for connectionless protocols, provided that you first call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method to establish a default remote host.","pos":[0,380],"source":"Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host."},{"content":"With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.","pos":[381,536]},{"content":"If it does, the datagram is not sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> throws a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.","pos":[537,692],"source":" If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception."}]}]},{"pos":[2925,3183],"content":"The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used. On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used. On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.","pos":[0,258],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized according to the operating system on which it is used.","pos":[0,131],"source":"The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used."},{"content":"On Windows server editions, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized for high performance.","pos":[132,258],"source":" On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance."}]}]},{"pos":[3190,3339],"content":"On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization.","nodes":[{"content":"On Windows client editions, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized for minimum memory and resource utilization.","pos":[0,149],"source":"On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization."}]},{"pos":[3346,4003],"content":"Use of the <xref:System.Net.Sockets.TransmitFileOptions?displayProperty=fullName> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=fullName> property on the `e` parameter can deliver significant performance benefits. If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching. Note that there is a difference between kernel and user-mode APCs. Kernel APCs launch when a thread is in a wait state. User-mode APCs launch when a thread is in an alertable wait state","nodes":[{"content":"Use of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.TransmitFileOptions?displayProperty=fullName&gt;</ph> flag in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=fullName&gt;</ph> property on the <ph id=\"ph3\">`e`</ph> parameter can deliver significant performance benefits.","pos":[0,261],"source":"Use of the <xref:System.Net.Sockets.TransmitFileOptions?displayProperty=fullName> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=fullName> property on the `e` parameter can deliver significant performance benefits."},{"content":"If the thread initiating the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.","pos":[262,471],"source":" If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching."},{"content":"Note that there is a difference between kernel and user-mode APCs.","pos":[472,538]},{"content":"Kernel APCs launch when a thread is in a wait state.","pos":[539,591]},{"content":"User-mode APCs launch when a thread is in an alertable wait state","pos":[592,657]}]}],"pos":[673978,678009],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.","source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation."}],"pos":[678258,678377],"yaml":true},{"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \n  \n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"pos":[0,209],"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`true`</ph> if the I/O operation is pending.","pos":[0,47],"source":"Returns `true` if the I/O operation is pending."},{"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.","pos":[48,209],"source":" The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation."}]},{"pos":[216,574],"content":"Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`false`</ph> if the I/O operation completed synchronously.","pos":[0,61],"source":"Returns `false` if the I/O operation completed synchronously."},{"content":"In this case, The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">e</ph><ept id=\"p2\">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","pos":[62,358],"source":" In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation."}]}],"pos":[678435,679018],"yaml":true},{"content":"The file specified in the <xref href=\"System.Net.Sockets.SendPacketsElement.FilePath\"></xref> property was not found.","nodes":[{"pos":[0,117],"content":"The file specified in the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SendPacketsElement.FilePath\"&gt;&lt;/xref&gt;</ph> property was not found.","source":"The file specified in the <xref href=\"System.Net.Sockets.SendPacketsElement.FilePath\"></xref> property was not found."}],"pos":[679196,679314],"yaml":true},{"content":"A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.","nodes":[{"pos":[0,163],"content":"A socket operation was already in progress using the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter."}],"pos":[679424,679588],"yaml":true},{"content":"Windows XP or later is required for this method. This exception also occurs if the <xref href=\"System.Net.Sockets.Socket\"></xref> is not connected to a remote host.","nodes":[{"pos":[0,164],"content":"Windows XP or later is required for this method. This exception also occurs if the <xref href=\"System.Net.Sockets.Socket\"></xref> is not connected to a remote host.","nodes":[{"content":"Windows XP or later is required for this method.","pos":[0,48]},{"content":"This exception also occurs if the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is not connected to a remote host.","pos":[49,164],"source":" This exception also occurs if the <xref href=\"System.Net.Sockets.Socket\"></xref> is not connected to a remote host."}]}],"pos":[679690,679855],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[679961,680029],"yaml":true},{"content":"A connectionless <xref href=\"System.Net.Sockets.Socket\"></xref> is being used and the file being sent exceeds the maximum packet size of the underlying transport.","nodes":[{"pos":[0,162],"content":"A connectionless <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is being used and the file being sent exceeds the maximum packet size of the underlying transport.","source":"A connectionless <xref href=\"System.Net.Sockets.Socket\"></xref> is being used and the file being sent exceeds the maximum packet size of the underlying transport."}],"pos":[680143,680306],"yaml":true},{"content":"Gets or sets a value that specifies the amount of time after which a synchronous <xref href=\"System.Net.Sockets.Socket.Send*\"></xref> call will time out.","nodes":[{"pos":[0,153],"content":"Gets or sets a value that specifies the amount of time after which a synchronous <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket.Send*\"&gt;&lt;/xref&gt;</ph> call will time out.","source":"Gets or sets a value that specifies the amount of time after which a synchronous <xref href=\"System.Net.Sockets.Socket.Send*\"></xref> call will time out."}],"pos":[681574,681728],"yaml":true},{"content":"This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only. If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"pos":[0,231],"content":"This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only. If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only. If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.","pos":[0,231],"nodes":[{"content":"This option applies to synchronous <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> calls only.","pos":[0,87],"source":"This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only."},{"content":"If the time-out period is exceeded, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[88,231],"source":" If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>."}]}]}],"pos":[681739,681971],"yaml":true,"extradata":"MT"},{"content":"The time-out value, in milliseconds. If you set the property with a value between 1 and 499, the value will be changed to 500. The default value is 0, which indicates an infinite time-out period. Specifying -1 also indicates an infinite time-out period.","nodes":[{"pos":[0,253],"content":"The time-out value, in milliseconds. If you set the property with a value between 1 and 499, the value will be changed to 500. The default value is 0, which indicates an infinite time-out period. Specifying -1 also indicates an infinite time-out period.","nodes":[{"content":"The time-out value, in milliseconds. If you set the property with a value between 1 and 499, the value will be changed to 500. The default value is 0, which indicates an infinite time-out period. Specifying -1 also indicates an infinite time-out period.","pos":[0,253],"nodes":[{"content":"The time-out value, in milliseconds.","pos":[0,36]},{"content":"If you set the property with a value between 1 and 499, the value will be changed to 500.","pos":[37,126]},{"content":"The default value is 0, which indicates an infinite time-out period.","pos":[127,195]},{"content":"Specifying -1 also indicates an infinite time-out period.","pos":[196,253]}]}]}],"pos":[682469,682723],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[682902,682958],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[683064,683132],"yaml":true},{"content":"The value specified for a set operation is less than -1.","nodes":[{"pos":[0,56],"content":"The value specified for a set operation is less than -1.","nodes":[{"content":"The value specified for a set operation is less than -1.","pos":[0,56]}]}],"pos":[683246,683303],"yaml":true},{"content":"Sends data to the specified endpoint.","nodes":[{"pos":[0,37],"content":"Sends data to the specified endpoint.","nodes":[{"content":"Sends data to the specified endpoint.","pos":[0,37]}]}],"pos":[684658,684696],"yaml":true},{"content":"In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the `buffer` parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to 0.  \n  \n If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.  \n  \n Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method. In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.  \n  \n Blocking sockets will block until the all of the bytes in the buffer are sent. Since a nonblocking<xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,193],"content":"In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the <ph id=\"ph1\">`buffer`</ph> parameter, and the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.","source":"In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the `buffer` parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to 0."},{"pos":[200,1183],"content":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.","nodes":[{"content":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.","pos":[0,215],"source":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>."},{"content":"You only need to do this if you intend to call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.","pos":[216,315],"source":" You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method."},{"content":"If you do call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id=\"ph3\">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.","pos":[316,549],"source":" If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only."},{"content":"You are also not required to call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.","pos":[550,748],"source":" You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number."},{"content":"If you need to identify the assigned local network address and port number, you can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.","pos":[749,983],"source":" If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes."}]},{"pos":[1190,2066],"content":"Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method. In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.","nodes":[{"content":"Although intended for connectionless protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.","pos":[0,137],"source":"Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols."},{"content":"If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[138,404],"source":" If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you do not establish or accept a remote host connection, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[405,563],"source":" If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"You can also establish a default remote host for a connectionless protocol prior to calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.","pos":[564,710],"source":" You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method."},{"content":"In either of these cases, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id=\"ph2\">`remoteEP`</ph> parameter and only send data to the connected or default remote host.","pos":[711,876],"source":" In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host."}]},{"pos":[2073,2841],"content":"Blocking sockets will block until the all of the bytes in the buffer are sent. Since a nonblocking<xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"Blocking sockets will block until the all of the bytes in the buffer are sent.","pos":[0,78]},{"content":"Since a nonblocking<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes in the <ph id=\"ph2\">`buffer`</ph>.","pos":[79,205],"source":" Since a nonblocking<xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`."},{"content":"It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <ph id=\"ph1\">`buffer`</ph>.","pos":[206,376],"source":" It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`."},{"content":"There is also no guarantee that the data you send will appear on the network immediately.","pos":[377,466]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.","pos":[467,601]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[602,768],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send."}]},{"pos":[2848,3493],"content":"If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.","pos":[0,645],"nodes":[{"content":"If you are using a connectionless protocol in blocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.","pos":[0,142],"source":"If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent."},{"content":"If you want to send data to a broadcast address, you must first call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>.","pos":[143,372],"source":" If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>."},{"content":"You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.","pos":[373,500]},{"content":"If it does, the datagram will not be sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[501,645],"source":" If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]}]},{"pos":[3501,3867],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3875,4100],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[684707,688824],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.","nodes":[{"pos":[0,84],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent."}],"pos":[689498,689583],"yaml":true},{"content":"The <xref href=\"System.Net.EndPoint\"></xref> that represents the destination for the data.","nodes":[{"pos":[0,90],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph> that represents the destination for the data.","source":"The <xref href=\"System.Net.EndPoint\"></xref> that represents the destination for the data."}],"pos":[689653,689744],"yaml":true},{"content":"The number of bytes sent.","nodes":[{"pos":[0,25],"content":"The number of bytes sent.","nodes":[{"content":"The number of bytes sent.","pos":[0,25]}]}],"pos":[689800,689826],"yaml":true},{"content":"<code>buffer</code> is `null`.  \n  \n -or-  \n  \n <code>remoteEP</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."},{"pos":[37,41],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[48,80],"content":"<ph id=\"ph1\">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>remoteEP</code> is `null`."}],"pos":[689988,690075],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[690189,690245],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[690351,690419],"yaml":true},{"content":"Sends data to a specific endpoint using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.","nodes":[{"pos":[0,106],"content":"Sends data to a specific endpoint using the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>.","source":"Sends data to a specific endpoint using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>."}],"pos":[691906,692013],"yaml":true},{"content":"In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \n  \n If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.  \n  \n Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method. In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.  \n  \n Blocking sockets will block until the requested all of the bytes in the `buffer` are sent. Since a nonblocking<xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,269],"content":"In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.","nodes":[{"content":"In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the <ph id=\"ph1\">`buffer`</ph>.","pos":[0,120],"source":"In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`."},{"content":"If you specify the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id=\"ph2\">`socketflags`</ph> parameter, the data you are sending will not be routed.","pos":[121,269],"source":" If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed."}]},{"pos":[276,1259],"content":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.","nodes":[{"content":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.","pos":[0,215],"source":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>."},{"content":"You only need to do this if you intend to call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.","pos":[216,315],"source":" You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method."},{"content":"If you do call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id=\"ph3\">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.","pos":[316,549],"source":" If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only."},{"content":"You are also not required to call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.","pos":[550,748],"source":" You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number."},{"content":"If you need to identify the assigned local network address and port number, you can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.","pos":[749,983],"source":" If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes."}]},{"pos":[1266,2142],"content":"Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method. In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.","nodes":[{"content":"Although intended for connectionless protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.","pos":[0,137],"source":"Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols."},{"content":"If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[138,404],"source":" If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you do not establish or accept a remote host connection, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[405,563],"source":" If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"You can also establish a default remote host for a connectionless protocol prior to calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.","pos":[564,710],"source":" You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method."},{"content":"In either of these cases, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id=\"ph2\">`remoteEP`</ph> parameter and only send data to the connected or default remote host.","pos":[711,876],"source":" In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host."}]},{"pos":[2149,2930],"content":"Blocking sockets will block until the requested all of the bytes in the `buffer` are sent. Since a nonblocking<xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"Blocking sockets will block until the requested all of the bytes in the <ph id=\"ph1\">`buffer`</ph> are sent.","pos":[0,90],"source":"Blocking sockets will block until the requested all of the bytes in the `buffer` are sent."},{"content":"Since a nonblocking<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes in the <ph id=\"ph2\">`buffer`</ph>.","pos":[91,217],"source":" Since a nonblocking<xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`."},{"content":"It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <ph id=\"ph1\">`buffer`</ph>.","pos":[218,388],"source":" It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`."},{"content":"There is also no guarantee that the data you send will appear on the network immediately.","pos":[389,478]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.","pos":[479,614]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[615,781],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send."}]},{"pos":[2937,3582],"content":"If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.","pos":[0,645],"nodes":[{"content":"If you are using a connectionless protocol in blocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.","pos":[0,142],"source":"If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent."},{"content":"If you want to send data to a broadcast address, you must first call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>.","pos":[143,372],"source":" If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>."},{"content":"You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.","pos":[373,500]},{"content":"If it does, the datagram will not be sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[501,645],"source":" If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]}]},{"pos":[3590,3956],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3964,4189],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[692024,696230],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.","nodes":[{"pos":[0,84],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent."}],"pos":[697054,697139],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[697223,697312],"yaml":true},{"content":"The <xref href=\"System.Net.EndPoint\"></xref> that represents the destination location for the data.","nodes":[{"pos":[0,99],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph> that represents the destination location for the data.","source":"The <xref href=\"System.Net.EndPoint\"></xref> that represents the destination location for the data."}],"pos":[697382,697482],"yaml":true},{"content":"The number of bytes sent.","nodes":[{"pos":[0,25],"content":"The number of bytes sent.","nodes":[{"content":"The number of bytes sent.","pos":[0,25]}]}],"pos":[697538,697564],"yaml":true},{"content":"<code>buffer</code> is `null`.  \n  \n -or-  \n  \n <code>remoteEP</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."},{"pos":[37,41],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[48,80],"content":"<ph id=\"ph1\">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>remoteEP</code> is `null`."}],"pos":[697726,697813],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[697927,697983],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[698089,698157],"yaml":true},{"content":"Sends the specified number of bytes of data to the specified endpoint using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.","nodes":[{"pos":[0,142],"content":"Sends the specified number of bytes of data to the specified endpoint using the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>.","source":"Sends the specified number of bytes of data to the specified endpoint using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>."}],"pos":[699704,699847],"yaml":true},{"content":"In this overload, the buffer offset defaults to 0. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \n  \n If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.  \n  \n Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method. In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.  \n  \n Blocking sockets will block until the requested number of bytes are sent. Since a nonblocking<xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,199],"content":"In this overload, the buffer offset defaults to 0. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.","nodes":[{"content":"In this overload, the buffer offset defaults to 0.","pos":[0,50]},{"content":"If you specify the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id=\"ph2\">`socketflags`</ph> parameter, the data you are sending will not be routed.","pos":[51,199],"source":" If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed."}]},{"pos":[206,1189],"content":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.","nodes":[{"content":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.","pos":[0,215],"source":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>."},{"content":"You only need to do this if you intend to call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.","pos":[216,315],"source":" You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method."},{"content":"If you do call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id=\"ph3\">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.","pos":[316,549],"source":" If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only."},{"content":"You are also not required to call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.","pos":[550,748],"source":" You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number."},{"content":"If you need to identify the assigned local network address and port number, you can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.","pos":[749,983],"source":" If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes."}]},{"pos":[1196,2072],"content":"Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method. In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.","nodes":[{"content":"Although intended for connectionless protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.","pos":[0,137],"source":"Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols."},{"content":"If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[138,404],"source":" If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you do not establish or accept a remote host connection, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[405,563],"source":" If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"You can also establish a default remote host for a connectionless protocol prior to calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.","pos":[564,710],"source":" You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method."},{"content":"In either of these cases, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id=\"ph2\">`remoteEP`</ph> parameter and only send data to the connected or default remote host.","pos":[711,876],"source":" In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host."}]},{"pos":[2079,2856],"content":"Blocking sockets will block until the requested number of bytes are sent. Since a nonblocking<xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"Blocking sockets will block until the requested number of bytes are sent. Since a nonblocking<xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,777],"nodes":[{"content":"Blocking sockets will block until the requested number of bytes are sent.","pos":[0,73]},{"content":"Since a nonblocking<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes requested in a single operation.","pos":[74,216],"source":" Since a nonblocking<xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation."},{"content":"It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.","pos":[217,384]},{"content":"There is also no guarantee that the data you send will appear on the network immediately.","pos":[385,474]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.","pos":[475,610]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[611,777],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[2863,3508],"content":"If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.","pos":[0,645],"nodes":[{"content":"If you are using a connectionless protocol in blocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.","pos":[0,142],"source":"If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent."},{"content":"If you want to send data to a broadcast address, you must first call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>.","pos":[143,372],"source":" If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>."},{"content":"You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.","pos":[373,500]},{"content":"If it does, the datagram will not be sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[501,645],"source":" If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]}]},{"pos":[3516,3882],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3890,4115],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[699858,703990],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.","nodes":[{"pos":[0,84],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent."}],"pos":[704838,704923],"yaml":true},{"content":"The number of bytes to send.","nodes":[{"pos":[0,28],"content":"The number of bytes to send.","nodes":[{"content":"The number of bytes to send.","pos":[0,28]}]}],"pos":[704982,705011],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[705095,705184],"yaml":true},{"content":"The <xref href=\"System.Net.EndPoint\"></xref> that represents the destination location for the data.","nodes":[{"pos":[0,99],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph> that represents the destination location for the data.","source":"The <xref href=\"System.Net.EndPoint\"></xref> that represents the destination location for the data."}],"pos":[705254,705354],"yaml":true},{"content":"The number of bytes sent.","nodes":[{"pos":[0,25],"content":"The number of bytes sent.","nodes":[{"content":"The number of bytes sent.","pos":[0,25]}]}],"pos":[705410,705436],"yaml":true},{"content":"<code>buffer</code> is `null`.  \n  \n -or-  \n  \n <code>remoteEP</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."},{"pos":[37,41],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[48,80],"content":"<ph id=\"ph1\">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>remoteEP</code> is `null`."}],"pos":[705598,705685],"yaml":true},{"content":"The specified <code>size</code> exceeds the size of <code>buffer</code>.","nodes":[{"pos":[0,72],"content":"The specified <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">size</ph><ept id=\"p1\">&lt;/code&gt;</ept> exceeds the size of <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">buffer</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","source":"The specified <code>size</code> exceeds the size of <code>buffer</code>."}],"pos":[705799,705872],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[705986,706042],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[706148,706216],"yaml":true},{"content":"Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.","nodes":[{"pos":[0,197],"content":"Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph>.","source":"Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>."}],"pos":[707823,708021],"yaml":true},{"content":"In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \n  \n If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.  \n  \n Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method. In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.  \n  \n Blocking sockets will block until the requested number of bytes are sent. Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation. It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.  \n  \n If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,166],"content":"In this overload, if you specify the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id=\"ph2\">`socketflags`</ph> parameter, the data you are sending will not be routed.","source":"In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed."},{"pos":[173,1156],"content":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.","nodes":[{"content":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.","pos":[0,215],"source":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>."},{"content":"You only need to do this if you intend to call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.","pos":[216,315],"source":" You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method."},{"content":"If you do call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id=\"ph3\">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.","pos":[316,549],"source":" If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only."},{"content":"You are also not required to call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.","pos":[550,748],"source":" You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number."},{"content":"If you need to identify the assigned local network address and port number, you can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.","pos":[749,983],"source":" If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes."}]},{"pos":[1163,2039],"content":"Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method. In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.","nodes":[{"content":"Although intended for connectionless protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.","pos":[0,137],"source":"Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols."},{"content":"If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.","pos":[138,404],"source":" If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method."},{"content":"If you do not establish or accept a remote host connection, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[405,563],"source":" If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"You can also establish a default remote host for a connectionless protocol prior to calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.","pos":[564,710],"source":" You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method."},{"content":"In either of these cases, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id=\"ph2\">`remoteEP`</ph> parameter and only send data to the connected or default remote host.","pos":[711,876],"source":" In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host."}]},{"pos":[2046,2824],"content":"Blocking sockets will block until the requested number of bytes are sent. Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation. It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.","nodes":[{"content":"Blocking sockets will block until the requested number of bytes are sent. Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation. It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.","pos":[0,778],"nodes":[{"content":"Blocking sockets will block until the requested number of bytes are sent.","pos":[0,73]},{"content":"Since a non-blocking <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes requested in a single operation.","pos":[74,218],"source":" Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation."},{"content":"It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.","pos":[219,385]},{"content":"There is also no guarantee that the data you send will appear on the network immediately.","pos":[386,475]},{"content":"To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.","pos":[476,611]},{"content":"A successful completion of the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.","pos":[612,778],"source":" A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send."}]}]},{"pos":[2831,3460],"content":"If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.","pos":[0,629],"nodes":[{"content":"If you are using a connectionless protocol in blocking mode, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.","pos":[0,142],"source":"If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent."},{"content":"If you want to send data to a broadcast address, you must first call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph>.","pos":[143,372],"source":" If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>."},{"content":"You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.","pos":[373,484]},{"content":"If it does, the datagram will not be sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[485,629],"source":" If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]}]},{"pos":[3468,3834],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3842,4067],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[708032,712116],"yaml":true,"extradata":"MT"},{"content":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.","nodes":[{"pos":[0,84],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that contains the data to be sent.","source":"An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent."}],"pos":[712985,713070],"yaml":true},{"content":"The position in the data buffer at which to begin sending data.","nodes":[{"pos":[0,63],"content":"The position in the data buffer at which to begin sending data.","nodes":[{"content":"The position in the data buffer at which to begin sending data.","pos":[0,63]}]}],"pos":[713131,713195],"yaml":true},{"content":"The number of bytes to send.","nodes":[{"pos":[0,28],"content":"The number of bytes to send.","nodes":[{"content":"The number of bytes to send.","pos":[0,28]}]}],"pos":[713254,713283],"yaml":true},{"content":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.","nodes":[{"pos":[0,88],"content":"A bitwise combination of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketFlags\"&gt;&lt;/xref&gt;</ph> values.","source":"A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values."}],"pos":[713367,713456],"yaml":true},{"content":"The <xref href=\"System.Net.EndPoint\"></xref> that represents the destination location for the data.","nodes":[{"pos":[0,99],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.EndPoint\"&gt;&lt;/xref&gt;</ph> that represents the destination location for the data.","source":"The <xref href=\"System.Net.EndPoint\"></xref> that represents the destination location for the data."}],"pos":[713526,713626],"yaml":true},{"content":"The number of bytes sent.","nodes":[{"pos":[0,25],"content":"The number of bytes sent.","nodes":[{"content":"The number of bytes sent.","pos":[0,25]}]}],"pos":[713682,713708],"yaml":true},{"content":"<code>buffer</code> is `null`.  \n  \n -or-  \n  \n <code>remoteEP</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."},{"pos":[37,41],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[48,80],"content":"<ph id=\"ph1\">&lt;code&gt;remoteEP&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>remoteEP</code> is `null`."}],"pos":[713870,713957],"yaml":true},{"content":"<code>offset</code> is less than 0.  \n  \n -or-  \n  \n <code>offset</code> is greater than the length of <code>buffer</code>.  \n  \n -or-  \n  \n <code>size</code> is less than 0.  \n  \n -or-  \n  \n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is less than 0.","source":"<code>offset</code> is less than 0."},{"pos":[42,46],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[53,123],"content":"<ph id=\"ph1\">&lt;code&gt;offset&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph>.","source":"<code>offset</code> is greater than the length of <code>buffer</code>."},{"pos":[130,134],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[141,174],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is less than 0.","source":"<code>size</code> is less than 0."},{"pos":[181,185],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[192,313],"content":"<ph id=\"ph1\">&lt;code&gt;size&lt;/code&gt;</ph> is greater than the length of <ph id=\"ph2\">&lt;code&gt;buffer&lt;/code&gt;</ph> minus the value of the <ph id=\"ph3\">&lt;code&gt;offset&lt;/code&gt;</ph> parameter.","source":"<code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter."}],"pos":[714071,714399],"yaml":true},{"content":"<code>socketFlags</code> is not a valid combination of values.  \n  \n -or-  \n  \n An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;socketFlags&lt;/code&gt;</ph> is not a valid combination of values.","source":"<code>socketFlags</code> is not a valid combination of values."},{"pos":[69,73],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[80,180],"content":"An operating system error occurs while accessing the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"An operating system error occurs while accessing the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[714513,714702],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[714808,714876],"yaml":true},{"content":"A caller in the call stack does not have the required permissions.","nodes":[{"pos":[0,66],"content":"A caller in the call stack does not have the required permissions.","nodes":[{"content":"A caller in the call stack does not have the required permissions.","pos":[0,66]}]}],"pos":[714988,715055],"yaml":true},{"content":"Sends data asynchronously to a specific remote host.","nodes":[{"pos":[0,52],"content":"Sends data asynchronously to a specific remote host.","nodes":[{"content":"Sends data asynchronously to a specific remote host.","pos":[0,52]}]}],"pos":[716470,716523],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property of the `e` parameter. Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread. Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols.  \n  \n To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.  \n  \n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  \n  \n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \n  \n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \n  \n If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method. Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>. When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property and send data to the <xref:System.Net.EndPoint?displayProperty=fullName> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.  \n  \n If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods. If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method. In this case, the underlying service provider will assign the most appropriate local network IP address and port number. Use a port number of zero if you want the underlying service provider to select a free port. If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event is signaled and the associated delegates are called.  \n  \n If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName> to true. You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \n  \n If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> property, the data you are sending will not be routed.  \n  \n For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport. If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>. The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.","nodes":[{"pos":[0,568],"content":"The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property of the `e` parameter. Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread. Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method starts an asynchronous send operation to the remote host specified in the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> property of the <ph id=\"ph3\">`e`</ph> parameter.","pos":[0,253],"source":"The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property of the `e` parameter."},{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.","pos":[254,391],"source":" Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread."},{"content":"Although this method is intended for connectionless protocols, <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> works with both connectionless and connection-oriented protocols.","pos":[392,568],"source":" Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols."}]},{"pos":[575,823],"content":"To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.","nodes":[{"content":"To be notified of completion, you must create a callback method that implements the EventHandler<ph id=\"ph1\">\\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName&gt;</ph> event.","pos":[0,248],"source":"To be notified of completion, you must create a callback method that implements the EventHandler\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event."}]},{"pos":[830,998],"content":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:","nodes":[{"content":"The following properties and events on the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName&gt;</ph> object are required to successfully call this method:","pos":[0,168],"source":"The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:"}]},{"pos":[1008,1089],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName>","nodes":[]},{"pos":[1099,1179],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName>","nodes":[]},{"pos":[1189,1270],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName>","nodes":[]},{"pos":[1280,1369],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>","nodes":[]},{"pos":[1379,1460],"content":"<xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>","nodes":[]},{"pos":[1467,1906],"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","nodes":[{"content":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[0,439],"nodes":[{"content":"The caller may set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName&gt;</ph> property to any user state object desired before calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.","pos":[0,292],"source":"The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method."},{"content":"If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.","pos":[293,439]}]}]},{"pos":[1913,3002],"content":"If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method. Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>. When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property and send data to the <xref:System.Net.EndPoint?displayProperty=fullName> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.","nodes":[{"content":"If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method. Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>. When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property and send data to the <xref:System.Net.EndPoint?displayProperty=fullName> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.","pos":[0,1089],"nodes":[{"content":"If you are using a connection-oriented protocol, you must first call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.","pos":[0,369],"source":"If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method."},{"content":"Otherwise <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[370,483],"source":" Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"When using a connection-oriented protocol, the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method will ignore the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> property and send data to the <ph id=\"ph3\">&lt;xref:System.Net.EndPoint?displayProperty=fullName&gt;</ph> established in the <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id=\"ph6\">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id=\"ph7\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph8\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id=\"ph9\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.","pos":[484,1089],"source":" When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property and send data to the <xref:System.Net.EndPoint?displayProperty=fullName> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method."}]}]},{"pos":[3009,4513],"content":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods. If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method. In this case, the underlying service provider will assign the most appropriate local network IP address and port number. Use a port number of zero if you want the underlying service provider to select a free port. If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event is signaled and the associated delegates are called.","nodes":[{"content":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods. If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method. In this case, the underlying service provider will assign the most appropriate local network IP address and port number. Use a port number of zero if you want the underlying service provider to select a free port. If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event is signaled and the associated delegates are called.","pos":[0,1504],"nodes":[{"content":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method prior to calling <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>.","pos":[0,323],"source":"If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>."},{"content":"You only need to do this if you intend to call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> methods.","pos":[324,478],"source":" You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods."},{"content":"If you do call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method prior to calling <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>, the <ph id=\"ph5\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName&gt;</ph> property will override the specified default remote host for that send operation only.","pos":[479,898],"source":" If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property will override the specified default remote host for that send operation only."},{"content":"You are also not required to call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.","pos":[899,985],"source":" You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method."},{"content":"In this case, the underlying service provider will assign the most appropriate local network IP address and port number.","pos":[986,1106]},{"content":"Use a port number of zero if you want the underlying service provider to select a free port.","pos":[1107,1199]},{"content":"If you need to identify the assigned local network IP address and port number, you can use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName&gt;</ph> event is signaled and the associated delegates are called.","pos":[1200,1504],"source":" If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event is signaled and the associated delegates are called."}]}]},{"pos":[4520,5035],"content":"If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName> to true. You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.","nodes":[{"content":"If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName> to true. You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.","pos":[0,515],"nodes":[{"content":"If you want to send data to a broadcast address, you must first call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option for <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName&gt;</ph> to true.","pos":[0,238],"source":"If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName> to true."},{"content":"You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.","pos":[239,365]},{"content":"If it does, the datagram will not be sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[366,515],"source":" If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>."}]}]},{"pos":[5042,5224],"content":"If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> property, the data you are sending will not be routed.","nodes":[{"content":"If you specify the DontRoute flag in the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName&gt;</ph> property, the data you are sending will not be routed.","pos":[0,182],"source":"If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> property, the data you are sending will not be routed."}]},{"pos":[5231,5720],"content":"For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport. If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>. The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.","nodes":[{"content":"For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport. If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>. The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.","pos":[0,489],"nodes":[{"content":"For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.","pos":[0,116]},{"content":"If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.","pos":[117,343],"source":" If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>."},{"content":"The successful completion of a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method does not indicate that the data was successfully delivered.","pos":[344,489],"source":" The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered."}]}]}],"pos":[716534,722284],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.","nodes":[{"pos":[0,118],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object to use for this asynchronous socket operation.","source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation."}],"pos":[722475,722594],"yaml":true},{"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \n  \n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"pos":[0,209],"content":"Returns `true` if the I/O operation is pending. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`true`</ph> if the I/O operation is pending.","pos":[0,47],"source":"Returns `true` if the I/O operation is pending."},{"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will be raised upon completion of the operation.","pos":[48,209],"source":" The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation."}]},{"pos":[216,574],"content":"Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","nodes":[{"content":"Returns <ph id=\"ph1\">`false`</ph> if the I/O operation completed synchronously.","pos":[0,61],"source":"Returns `false` if the I/O operation completed synchronously."},{"content":"In this case, The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"&gt;&lt;/xref&gt;</ph> event on the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter will not be raised and the <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">e</ph><ept id=\"p2\">&lt;/code&gt;</ept> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.","pos":[62,358],"source":" In this case, The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Completed\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation."}]}],"pos":[722652,723235],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null.","nodes":[{"pos":[0,95],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"&gt;&lt;/xref&gt;</ph> cannot be null.","source":"The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null."}],"pos":[723402,723498],"yaml":true},{"content":"A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.","nodes":[{"pos":[0,163],"content":"A socket operation was already in progress using the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"&gt;&lt;/xref&gt;</ph> object specified in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">e</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter."}],"pos":[723608,723772],"yaml":true},{"content":"Windows XP or later is required for this method.","nodes":[{"pos":[0,48],"content":"Windows XP or later is required for this method.","nodes":[{"content":"Windows XP or later is required for this method.","pos":[0,48]}]}],"pos":[723874,723923],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[724029,724097],"yaml":true},{"content":"The protocol specified is connection-oriented, but the <xref href=\"System.Net.Sockets.Socket\"></xref> is not yet connected.","nodes":[{"pos":[0,123],"content":"The protocol specified is connection-oriented, but the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> is not yet connected.","source":"The protocol specified is connection-oriented, but the <xref href=\"System.Net.Sockets.Socket\"></xref> is not yet connected."}],"pos":[724211,724335],"yaml":true},{"content":"Set the IP protection level on a socket.","nodes":[{"pos":[0,40],"content":"Set the IP protection level on a socket.","nodes":[{"content":"Set the IP protection level on a socket.","pos":[0,40]}]}],"pos":[725786,725827],"yaml":true},{"content":"The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix. This socket option enables applications to place access restrictions on IPv6 or IP sockets. Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks. This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.  \n  \n This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration.  \n  \n The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance. NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.  \n  \n When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, or <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, this explicitly disables NAT traversal for a <xref:System.Net.Sockets.Socket> instance.  \n  \n When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, this may allow NAT traversal for a <xref:System.Net.Sockets.Socket> depending on firewall rules in place on the system.","nodes":[{"pos":[0,791],"content":"The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix. This socket option enables applications to place access restrictions on IPv6 or IP sockets. Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks. This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.","pos":[0,207],"source":"The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix."},{"content":"This socket option enables applications to place access restrictions on IPv6 or IP sockets.","pos":[208,299]},{"content":"Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.","pos":[300,427]},{"content":"This socket option can also be used to remove access restrictions if the <ph id=\"ph1\">`level`</ph> parameter is set to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.IPProtectionLevel.Unrestricted&gt;</ph>.","pos":[428,586],"source":" This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>."},{"content":"This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.","pos":[587,791]}]},{"pos":[798,920],"content":"This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration.","nodes":[{"content":"This socket option has defined protection levels specified in the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.IPProtectionLevel&gt;</ph> enumeration.","pos":[0,122],"source":"This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration."}]},{"pos":[927,1175],"content":"The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance. NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.","nodes":[{"content":"The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance. NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.","pos":[0,248],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> method is used to enable or disable Network Address Traversal (NAT) for a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.","pos":[0,177],"source":"The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance."},{"content":"NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.","pos":[178,248]}]}]},{"pos":[1182,1425],"content":"When the <ph id=\"ph1\">`level`</ph> parameter is set to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, or <ph id=\"ph3\">&lt;xref:System.Net.Sockets.IPProtectionLevel.Restricted&gt;</ph>, this explicitly disables NAT traversal for a <ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.","source":"When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, or <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, this explicitly disables NAT traversal for a <xref:System.Net.Sockets.Socket> instance."},{"pos":[1432,1648],"content":"When the <ph id=\"ph1\">`level`</ph> parameter is set to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, this may allow NAT traversal for a <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> depending on firewall rules in place on the system.","source":"When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, this may allow NAT traversal for a <xref:System.Net.Sockets.Socket> depending on firewall rules in place on the system."}],"pos":[725838,727497],"yaml":true,"extradata":"MT"},{"content":"The IP protection level to set on this socket.","nodes":[{"pos":[0,46],"content":"The IP protection level to set on this socket.","nodes":[{"content":"The IP protection level to set on this socket.","pos":[0,46]}]}],"pos":[727699,727746],"yaml":true},{"content":"The <code>level</code> parameter cannot be <xref href=\"System.Net.Sockets.IPProtectionLevel.Unspecified\"></xref>. The IP protection level cannot be set to unspecified.","nodes":[{"pos":[0,167],"content":"The <code>level</code> parameter cannot be <xref href=\"System.Net.Sockets.IPProtectionLevel.Unspecified\"></xref>. The IP protection level cannot be set to unspecified.","nodes":[{"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">level</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter cannot be <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.IPProtectionLevel.Unspecified\"&gt;&lt;/xref&gt;</ph>.","pos":[0,113],"source":"The <code>level</code> parameter cannot be <xref href=\"System.Net.Sockets.IPProtectionLevel.Unspecified\"></xref>."},{"content":"The IP protection level cannot be set to unspecified.","pos":[114,167]}]}],"pos":[727914,728082],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.AddressFamily\"></xref> of the socket must be either <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref>.","nodes":[{"pos":[0,226],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.AddressFamily\"&gt;&lt;/xref&gt;</ph> of the socket must be either <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph3\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"&gt;&lt;/xref&gt;</ph>.","source":"The <xref href=\"System.Net.Sockets.AddressFamily\"></xref> of the socket must be either <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref>."}],"pos":[728184,728411],"yaml":true},{"content":"Sets the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option to the specified <xref href=\"System.Boolean\"></xref> value.","nodes":[{"pos":[0,132],"content":"Sets the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> option to the specified <ph id=\"ph2\">&lt;xref href=\"System.Boolean\"&gt;&lt;/xref&gt;</ph> value.","source":"Sets the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option to the specified <xref href=\"System.Boolean\"></xref> value."}],"pos":[729882,730015],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Set `optionValue` to `true` to enable the option, or to `false` to disable the option.  \n  \n <xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.  \n  \n Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload. These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value. If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter. The option you choose to set must be specified in the `optionName` parameter. If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.  \n  \n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.Debug>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  \n  \n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  \n  \n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  \n  \n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  \n  \n For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","nodes":[{"pos":[0,199],"content":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Set `optionValue` to `true` to enable the option, or to `false` to disable the option.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,112],"source":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>."},{"content":"Set <ph id=\"ph1\">`optionValue`</ph> to <ph id=\"ph2\">`true`</ph> to enable the option, or to <ph id=\"ph3\">`false`</ph> to disable the option.","pos":[113,199],"source":" Set `optionValue` to `true` to enable the option, or to `false` to disable the option."}]},{"pos":[206,288],"content":"<xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options are grouped by level of protocol support.","pos":[0,82],"source":"<xref:System.Net.Sockets.Socket> options are grouped by level of protocol support."}]},{"pos":[295,867],"content":"Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload. These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value. If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter. The option you choose to set must be specified in the `optionName` parameter. If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.","nodes":[{"content":"Listed below are the various <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that can be set using this overload.","pos":[0,106],"source":"Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload."},{"content":"These options are grouped by the appropriate <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> value.","pos":[107,202],"source":" These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value."},{"content":"If you intend to set any of these options, be sure to use the appropriate <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> value for the <ph id=\"ph2\">`optionLevel`</ph> parameter.","pos":[203,359],"source":" If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter."},{"content":"The option you choose to set must be specified in the <ph id=\"ph1\">`optionName`</ph> parameter.","pos":[360,437],"source":" The option you choose to set must be specified in the `optionName` parameter."},{"content":"If you want to get the current value of any of the options listed, use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.","pos":[438,572],"source":" If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method."}]},{"pos":[874,987],"content":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.","pos":[0,113],"source":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload."}]},{"pos":[997,1056],"content":"<xref:System.Net.Sockets.SocketOptionName.AcceptConnection>","nodes":[]},{"pos":[1066,1118],"content":"<xref:System.Net.Sockets.SocketOptionName.Broadcast>","nodes":[]},{"pos":[1128,1181],"content":"<xref:System.Net.Sockets.SocketOptionName.DontLinger>","nodes":[]},{"pos":[1191,1239],"content":"<xref:System.Net.Sockets.SocketOptionName.Debug>","nodes":[]},{"pos":[1249,1301],"content":"<xref:System.Net.Sockets.SocketOptionName.KeepAlive>","nodes":[]},{"pos":[1311,1369],"content":"<xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>","nodes":[]},{"pos":[1379,1434],"content":"<xref:System.Net.Sockets.SocketOptionName.ReuseAddress>","nodes":[]},{"pos":[1441,1554],"content":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.","pos":[0,113],"source":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload."}]},{"pos":[1564,1621],"content":"<xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>","nodes":[]},{"pos":[1631,1691],"content":"<xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>","nodes":[]},{"pos":[1701,1755],"content":"<xref:System.Net.Sockets.SocketOptionName.UseLoopback>","nodes":[]},{"pos":[1762,1875],"content":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.","pos":[0,113],"source":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload."}]},{"pos":[1885,1937],"content":"<xref:System.Net.Sockets.SocketOptionName.BsdUrgent>","nodes":[]},{"pos":[1947,1999],"content":"<xref:System.Net.Sockets.SocketOptionName.Expedited>","nodes":[]},{"pos":[2009,2059],"content":"<xref:System.Net.Sockets.SocketOptionName.NoDelay>","nodes":[]},{"pos":[2066,2179],"content":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.","pos":[0,113],"source":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload."}]},{"pos":[2189,2242],"content":"<xref:System.Net.Sockets.SocketOptionName.NoChecksum>","nodes":[]},{"pos":[2249,2356],"content":"For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.","nodes":[{"content":"For more information on these options, refer to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeration.","pos":[0,107],"source":"For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration."}]},{"pos":[2364,2740],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,374],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,202],"source":" If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[203,366]}]}]}],"pos":[730026,732814],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values.","nodes":[{"pos":[0,76],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketOptionLevel\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values."}],"pos":[733505,733582],"yaml":true},{"content":"One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values.","nodes":[{"pos":[0,75],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketOptionName\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values."}],"pos":[733670,733746],"yaml":true},{"content":"The value of the option, represented as a <xref href=\"System.Boolean\"></xref>.","nodes":[{"pos":[0,78],"content":"The value of the option, represented as a <ph id=\"ph1\">&lt;xref href=\"System.Boolean\"&gt;&lt;/xref&gt;</ph>.","source":"The value of the option, represented as a <xref href=\"System.Boolean\"></xref>."}],"pos":[733814,733893],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> object has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed."}],"pos":[734068,734143],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[734257,734313],"yaml":true},{"content":"Sets the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option to the specified value, represented as a byte array.","nodes":[{"pos":[0,125],"content":"Sets the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> option to the specified value, represented as a byte array.","source":"Sets the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option to the specified value, represented as a byte array."}],"pos":[735962,736088],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,230],"content":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.","nodes":[{"content":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.","pos":[0,230],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,112],"source":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>."},{"content":"Use this overload to set those <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that require a byte array as an option value.","pos":[113,230],"source":" Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value."}]}]},{"pos":[238,604],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[612,837],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[736099,736945],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values.","nodes":[{"pos":[0,76],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketOptionLevel\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values."}],"pos":[737760,737837],"yaml":true},{"content":"One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values.","nodes":[{"pos":[0,75],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketOptionName\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values."}],"pos":[737925,738001],"yaml":true},{"content":"An array of type <xref href=\"System.Byte\"></xref> that represents the value of the option.","nodes":[{"pos":[0,90],"content":"An array of type <ph id=\"ph1\">&lt;xref href=\"System.Byte\"&gt;&lt;/xref&gt;</ph> that represents the value of the option.","source":"An array of type <xref href=\"System.Byte\"></xref> that represents the value of the option."}],"pos":[738068,738159],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[738342,738398],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[738504,738572],"yaml":true},{"content":"Sets the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option to the specified integer value.","nodes":[{"pos":[0,104],"content":"Sets the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> option to the specified integer value.","source":"Sets the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option to the specified integer value."}],"pos":[740215,740320],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option. For an option with an integer data type, specify the appropriate value. <xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.  \n  \n Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload. These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>. If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter. The option you choose to set must be specified in the `optionName` parameter. If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.  \n  \n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.Debug>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.Error>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.Type>  \n  \n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  \n  \n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  \n  \n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  \n  \n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \n  \n-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  \n  \n For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,407],"content":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option. For an option with an integer data type, specify the appropriate value. <xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.","nodes":[{"content":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option. For an option with an integer data type, specify the appropriate value. <xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.","pos":[0,407],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,112],"source":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>."},{"content":"For an option with a <ph id=\"ph1\">&lt;xref:System.Boolean&gt;</ph> data type, specify a nonzero value to enable the option, and a zero value to disable the option.","pos":[113,252],"source":" For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option."},{"content":"For an option with an integer data type, specify the appropriate value.","pos":[253,324]},{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options are grouped by level of protocol support.","pos":[325,407],"source":" <xref:System.Net.Sockets.Socket> options are grouped by level of protocol support."}]}]},{"pos":[414,974],"content":"Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload. These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>. If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter. The option you choose to set must be specified in the `optionName` parameter. If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.","nodes":[{"content":"Listed below are the various <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that can be set using this overload.","pos":[0,106],"source":"Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload."},{"content":"These options are grouped by the appropriate <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>.","pos":[107,196],"source":" These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>."},{"content":"If you intend to set any of these options, be sure to use the appropriate <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> for the <ph id=\"ph2\">`optionLevel`</ph> parameter.","pos":[197,347],"source":" If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter."},{"content":"The option you choose to set must be specified in the <ph id=\"ph1\">`optionName`</ph> parameter.","pos":[348,425],"source":" The option you choose to set must be specified in the `optionName` parameter."},{"content":"If you want to get the current value of any of the options listed, use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.","pos":[426,560],"source":" If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method."}]},{"pos":[981,1094],"content":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.","pos":[0,113],"source":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload."}]},{"pos":[1104,1156],"content":"<xref:System.Net.Sockets.SocketOptionName.Broadcast>","nodes":[]},{"pos":[1166,1219],"content":"<xref:System.Net.Sockets.SocketOptionName.DontLinger>","nodes":[]},{"pos":[1229,1277],"content":"<xref:System.Net.Sockets.SocketOptionName.Debug>","nodes":[]},{"pos":[1287,1335],"content":"<xref:System.Net.Sockets.SocketOptionName.Error>","nodes":[]},{"pos":[1345,1397],"content":"<xref:System.Net.Sockets.SocketOptionName.KeepAlive>","nodes":[]},{"pos":[1407,1465],"content":"<xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>","nodes":[]},{"pos":[1475,1531],"content":"<xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>","nodes":[]},{"pos":[1541,1598],"content":"<xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>","nodes":[]},{"pos":[1608,1663],"content":"<xref:System.Net.Sockets.SocketOptionName.ReuseAddress>","nodes":[]},{"pos":[1673,1726],"content":"<xref:System.Net.Sockets.SocketOptionName.SendBuffer>","nodes":[]},{"pos":[1736,1790],"content":"<xref:System.Net.Sockets.SocketOptionName.SendTimeout>","nodes":[]},{"pos":[1800,1847],"content":"<xref:System.Net.Sockets.SocketOptionName.Type>","nodes":[]},{"pos":[1854,1967],"content":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.","pos":[0,113],"source":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload."}]},{"pos":[1977,2034],"content":"<xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>","nodes":[]},{"pos":[2044,2096],"content":"<xref:System.Net.Sockets.SocketOptionName.IPOptions>","nodes":[]},{"pos":[2106,2161],"content":"<xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>","nodes":[]},{"pos":[2171,2232],"content":"<xref:System.Net.Sockets.SocketOptionName.MulticastInterface>","nodes":[]},{"pos":[2242,2302],"content":"<xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>","nodes":[]},{"pos":[2312,2374],"content":"<xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>","nodes":[]},{"pos":[2384,2440],"content":"<xref:System.Net.Sockets.SocketOptionName.TypeOfService>","nodes":[]},{"pos":[2450,2504],"content":"<xref:System.Net.Sockets.SocketOptionName.UseLoopback>","nodes":[]},{"pos":[2511,2624],"content":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.","pos":[0,113],"source":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload."}]},{"pos":[2634,2686],"content":"<xref:System.Net.Sockets.SocketOptionName.BsdUrgent>","nodes":[]},{"pos":[2696,2748],"content":"<xref:System.Net.Sockets.SocketOptionName.Expedited>","nodes":[]},{"pos":[2758,2808],"content":"<xref:System.Net.Sockets.SocketOptionName.NoDelay>","nodes":[]},{"pos":[2815,2928],"content":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.","pos":[0,113],"source":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload."}]},{"pos":[2938,2997],"content":"<xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>","nodes":[]},{"pos":[3007,3060],"content":"<xref:System.Net.Sockets.SocketOptionName.NoChecksum>","nodes":[]},{"pos":[3067,3180],"content":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName&gt;</ph> options that can be set using this overload.","pos":[0,113],"source":"<xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload."}]},{"pos":[3190,3241],"content":"<xref:System.Net.Sockets.SocketOptionName.HopLimit>","nodes":[]},{"pos":[3248,3358],"content":"For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.","nodes":[{"content":"For more information about these options, refer to the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeration.","pos":[0,110],"source":"For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration."}]},{"pos":[3366,3732],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]},{"pos":[3740,3965],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[740331,744371],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values.","nodes":[{"pos":[0,76],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketOptionLevel\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values."}],"pos":[745183,745260],"yaml":true},{"content":"One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values.","nodes":[{"pos":[0,75],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketOptionName\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values."}],"pos":[745348,745424],"yaml":true},{"content":"A value of the option.","nodes":[{"pos":[0,22],"content":"A value of the option.","nodes":[{"content":"A value of the option.","pos":[0,22]}]}],"pos":[745490,745513],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[745696,745752],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[745858,745926],"yaml":true},{"content":"Sets the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option to the specified value, represented as an object.","nodes":[{"pos":[0,122],"content":"Sets the specified <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> option to the specified value, represented as an object.","source":"Sets the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option to the specified value, represented as an object."}],"pos":[747575,747698],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options. For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter. For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>. If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","nodes":[{"pos":[0,806],"content":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options. For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter. For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>. If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,112],"source":"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>."},{"content":"Use this overload to set the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id=\"ph4\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.","pos":[113,353],"source":" Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options."},{"content":"For the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, use <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for the <ph id=\"ph3\">`optionLevel`</ph> parameter.","pos":[354,489],"source":" For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter."},{"content":"For <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.","pos":[490,665],"source":" For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>."},{"content":"If you want to get the current value of any of the options listed above, use the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.","pos":[666,806],"source":" If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method."}]},{"pos":[814,1180],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,364],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,192],"source":" If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[193,356]}]}]}],"pos":[747709,748895],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values.","nodes":[{"pos":[0,76],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketOptionLevel\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values."}],"pos":[749710,749787],"yaml":true},{"content":"One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values.","nodes":[{"pos":[0,75],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketOptionName\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values."}],"pos":[749875,749951],"yaml":true},{"content":"A <xref href=\"System.Net.Sockets.LingerOption\"></xref> or <xref href=\"System.Net.Sockets.MulticastOption\"></xref> that contains the value of the option.","nodes":[{"pos":[0,152],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.LingerOption\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.MulticastOption\"&gt;&lt;/xref&gt;</ph> that contains the value of the option.","source":"A <xref href=\"System.Net.Sockets.LingerOption\"></xref> or <xref href=\"System.Net.Sockets.MulticastOption\"></xref> that contains the value of the option."}],"pos":[750018,750171],"yaml":true},{"content":"<code>optionValue</code> is `null`.","nodes":[{"pos":[0,35],"content":"<ph id=\"ph1\">&lt;code&gt;optionValue&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>optionValue</code> is `null`."}],"pos":[750342,750378],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[750492,750548],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[750654,750722],"yaml":true},{"content":"Disables sends and receives on a <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,80],"content":"Disables sends and receives on a <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Disables sends and receives on a <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[752083,752164],"yaml":true},{"content":"When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>. This ensures that all data is sent and received on the connected socket before it is closed.  \n  \n Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>. Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.  \n  \n The following table shows the <xref:System.Net.Sockets.SocketShutdown> enumeration values that are valid for the `how` parameter.  \n  \n|Value|Description|  \n|-----------|-----------------|  \n|Send|Disable sending on this <xref:System.Net.Sockets.Socket>.|  \n|Receive|Disable receiving on this <xref:System.Net.Sockets.Socket>.|  \n|Both|Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>.|  \n  \n Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed. If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect.  \n  \n Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed. This has no effect on lower protocol layers. If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :  \n  \n-   Data is in the incoming network buffer waiting to be received.  \n  \n-   More data has arrived.  \n  \n If you are using a connectionless protocol, datagrams are accepted and queued. However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender. Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.  \n  \n Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Both> disables both sends and receives as described above.  \n  \n> [!NOTE]\n>  If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \n  \n> [!NOTE]\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","nodes":[{"pos":[0,280],"content":"When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>. This ensures that all data is sent and received on the connected socket before it is closed.","nodes":[{"content":"When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>. This ensures that all data is sent and received on the connected socket before it is closed.","pos":[0,280],"nodes":[{"content":"When using a connection-oriented <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, always call the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method before closing the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,187],"source":"When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>."},{"content":"This ensures that all data is sent and received on the connected socket before it is closed.","pos":[188,280]}]}]},{"pos":[287,518],"content":"Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>. Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.","nodes":[{"content":"Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>. Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.","pos":[0,231],"nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to free all managed and unmanaged resources associated with the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,155],"source":"Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>."},{"content":"Do not attempt to reuse the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> after closing.","pos":[156,231],"source":" Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing."}]}]},{"pos":[525,654],"content":"The following table shows the <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketShutdown&gt;</ph> enumeration values that are valid for the <ph id=\"ph2\">`how`</ph> parameter.","source":"The following table shows the <xref:System.Net.Sockets.SocketShutdown> enumeration values that are valid for the `how` parameter."},{"pos":[661,666],"content":"Value","nodes":[{"content":"Value","pos":[0,5]}]},{"pos":[667,678],"content":"Description","nodes":[{"content":"Description","pos":[0,11]}]},{"pos":[717,721],"content":"Send","nodes":[{"content":"Send","pos":[0,4]}]},{"pos":[722,779],"content":"Disable sending on this <xref:System.Net.Sockets.Socket>.","nodes":[{"content":"Disable sending on this <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,57],"source":"Disable sending on this <xref:System.Net.Sockets.Socket>."}]},{"pos":[784,791],"content":"Receive","nodes":[{"content":"Receive","pos":[0,7]}]},{"pos":[792,851],"content":"Disable receiving on this <xref:System.Net.Sockets.Socket>.","nodes":[{"content":"Disable receiving on this <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,59],"source":"Disable receiving on this <xref:System.Net.Sockets.Socket>."}]},{"pos":[856,860],"content":"Both","nodes":[{"content":"Both","pos":[0,4]}]},{"pos":[861,937],"content":"Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>.","nodes":[{"content":"Disable both sending and receiving on this <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.","pos":[0,76],"source":"Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>."}]},{"pos":[945,1246],"content":"Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed. If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect.","nodes":[{"content":"Setting <ph id=\"ph1\">`how`</ph> to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> specifies that subsequent calls to <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> are not allowed.","pos":[0,155],"source":"Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed."},{"content":"If you are using a connectionless <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, specifying <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> will have no effect.","pos":[156,301],"source":" If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect."}]},{"pos":[1253,1644],"content":"Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed. This has no effect on lower protocol layers. If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :","nodes":[{"content":"Setting <ph id=\"ph1\">`how`</ph> to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketShutdown.Receive&gt;</ph> specifies that subsequent calls to <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> are not allowed.","pos":[0,161],"source":"Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed."},{"content":"This has no effect on lower protocol layers.","pos":[162,206]},{"content":"If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> :","pos":[207,391],"source":" If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :"}]},{"pos":[1654,1716],"content":"Data is in the incoming network buffer waiting to be received.","nodes":[{"content":"Data is in the incoming network buffer waiting to be received.","pos":[0,62]}]},{"pos":[1726,1748],"content":"More data has arrived.","nodes":[{"content":"More data has arrived.","pos":[0,22]}]},{"pos":[1755,2101],"content":"If you are using a connectionless protocol, datagrams are accepted and queued. However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender. Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.","nodes":[{"content":"If you are using a connectionless protocol, datagrams are accepted and queued. However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender. Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.","pos":[0,346],"nodes":[{"content":"If you are using a connectionless protocol, datagrams are accepted and queued.","pos":[0,78]},{"content":"However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.","pos":[79,222]},{"content":"Using <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> on a connectionless <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is not recommended.","pos":[223,346],"source":" Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended."}]}]},{"pos":[2108,2223],"content":"Setting <ph id=\"ph1\">`how`</ph> to <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketShutdown.Both&gt;</ph> disables both sends and receives as described above.","source":"Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Both> disables both sends and receives as described above."},{"pos":[2231,2666],"content":"[!NOTE]\n If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","leadings":["","> "],"nodes":[{"content":" If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[8,433],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, use the <ph id=\"ph3\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[1,261],"source":" If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[262,425]}]}]},{"pos":[2674,2899],"content":"[!NOTE]\n This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","leadings":["","> "],"nodes":[{"content":" This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).","pos":[8,223],"nodes":[{"content":"This member outputs trace information when you enable network tracing in your application.","pos":[1,91]},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Network Tracing in the .NET Framework<ept id=\"p1\">](~/docs/framework/network-programming/network-tracing.md)</ept>.","pos":[92,215],"source":" For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md)."}]}]}],"pos":[752175,755105],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Net.Sockets.SocketShutdown\"></xref> values that specifies the operation that will no longer be allowed.","nodes":[{"pos":[0,133],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketShutdown\"&gt;&lt;/xref&gt;</ph> values that specifies the operation that will no longer be allowed.","source":"One of the <xref href=\"System.Net.Sockets.SocketShutdown\"></xref> values that specifies the operation that will no longer be allowed."}],"pos":[755854,755988],"yaml":true},{"content":"An error occurred when attempting to access the socket.","nodes":[{"pos":[0,55],"content":"An error occurred when attempting to access the socket.","nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]}]}],"pos":[756164,756220],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[756326,756394],"yaml":true},{"content":"Gets the type of the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,68],"content":"Gets the type of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Gets the type of the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[757616,757685],"yaml":true},{"content":"<xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.","nodes":[{"pos":[0,124],"content":"<xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph> is read-only and is set when the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created.","pos":[0,124],"source":"<xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created."}]}],"pos":[757696,757821],"yaml":true,"extradata":"MT"},{"content":"One of the <xref href=\"System.Net.Sockets.SocketType\"></xref> values.","nodes":[{"pos":[0,69],"content":"One of the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.SocketType\"&gt;&lt;/xref&gt;</ph> values.","source":"One of the <xref href=\"System.Net.Sockets.SocketType\"></xref> values."}],"pos":[758553,758623],"yaml":true},{"content":"Gets a value indicating whether IPv4 support is available and enabled on the current host.","nodes":[{"pos":[0,90],"content":"Gets a value indicating whether IPv4 support is available and enabled on the current host.","nodes":[{"content":"Gets a value indicating whether IPv4 support is available and enabled on the current host.","pos":[0,90]}]}],"pos":[759924,760015],"yaml":true},{"content":"The operating system may support both IPv4 and IPv6 protocols.","nodes":[{"pos":[0,62],"content":"The operating system may support both IPv4 and IPv6 protocols.","nodes":[{"content":"The operating system may support both IPv4 and IPv6 protocols.","pos":[0,62]}]}],"pos":[760026,760089],"yaml":true,"extradata":"MT"},{"content":"`true` if the current host supports the IPv4 protocol; otherwise, `false`.","nodes":[{"pos":[0,74],"content":"<ph id=\"ph1\">`true`</ph> if the current host supports the IPv4 protocol; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the current host supports the IPv4 protocol; otherwise, `false`."}],"pos":[760275,760352],"yaml":true},{"content":"Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <xref href=\"System.Net.Dns\"></xref> members.","nodes":[{"pos":[0,129],"content":"Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <ph id=\"ph1\">&lt;xref href=\"System.Net.Dns\"&gt;&lt;/xref&gt;</ph> members.","source":"Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <xref href=\"System.Net.Dns\"></xref> members."}],"pos":[761520,761650],"yaml":true},{"content":"The operating system may support both IPv4 and IPv6 protocols.","nodes":[{"pos":[0,62],"content":"The operating system may support both IPv4 and IPv6 protocols.","nodes":[{"content":"The operating system may support both IPv4 and IPv6 protocols.","pos":[0,62]}]}],"pos":[761661,761724],"yaml":true,"extradata":"MT"},{"content":"`true` if the Framework supports IPv6 for certain obsolete <xref href=\"System.Net.Dns\"></xref> methods; otherwise, `false`.","nodes":[{"pos":[0,123],"content":"<ph id=\"ph1\">`true`</ph> if the Framework supports IPv6 for certain obsolete <ph id=\"ph2\">&lt;xref href=\"System.Net.Dns\"&gt;&lt;/xref&gt;</ph> methods; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the Framework supports IPv6 for certain obsolete <xref href=\"System.Net.Dns\"></xref> methods; otherwise, `false`."}],"pos":[761910,762036],"yaml":true},{"content":"Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <xref href=\"System.Net.Sockets.Socket\"></xref>.","nodes":[{"pos":[0,158],"content":"Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph>.","source":"Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <xref href=\"System.Net.Sockets.Socket\"></xref>."}],"pos":[763150,763309],"yaml":true},{"content":"The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) \"TTL exceeded\" error message is returned to the sender.  \n  \n The TTL value may be set to a value from 0 to 255. When this property is not set, the default TTL value for a socket is 32.  \n  \n Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.  \n  \n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","nodes":[{"pos":[0,219],"content":"The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) \"TTL exceeded\" error message is returned to the sender.","nodes":[{"content":"The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) \"TTL exceeded\" error message is returned to the sender.","pos":[0,219]}]},{"pos":[226,349],"content":"The TTL value may be set to a value from 0 to 255. When this property is not set, the default TTL value for a socket is 32.","nodes":[{"content":"The TTL value may be set to a value from 0 to 255. When this property is not set, the default TTL value for a socket is 32.","pos":[0,123],"nodes":[{"content":"The TTL value may be set to a value from 0 to 255.","pos":[0,50]},{"content":"When this property is not set, the default TTL value for a socket is 32.","pos":[51,123]}]}]},{"pos":[356,522],"content":"Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.","nodes":[{"content":"Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.","pos":[0,166]}]},{"pos":[529,884],"content":"If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","nodes":[{"content":"If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[0,355],"nodes":[{"content":"If you receive a <ph id=\"ph1\">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName&gt;</ph> property to obtain the specific error code.","pos":[0,191],"source":"If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code."},{"content":"After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.","pos":[192,355]}]}]}],"pos":[763320,764215],"yaml":true,"extradata":"MT"},{"content":"The TTL value.","nodes":[{"pos":[0,14],"content":"The TTL value.","nodes":[{"content":"The TTL value.","pos":[0,14]}]}],"pos":[764699,764714],"yaml":true},{"content":"The TTL value can't be set to a negative number.","nodes":[{"pos":[0,48],"content":"The TTL value can't be set to a negative number.","nodes":[{"content":"The TTL value can't be set to a negative number.","pos":[0,48]}]}],"pos":[764885,764934],"yaml":true},{"content":"This property can be set only for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families.","nodes":[{"pos":[0,197],"content":"This property can be set only for sockets in the <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"&gt;&lt;/xref&gt;</ph> families.","source":"This property can be set only for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families."}],"pos":[765036,765234],"yaml":true},{"content":"An error occurred when attempting to access the socket. This error is also returned when an attempt was made to set TTL to a value higher than 255.","nodes":[{"pos":[0,147],"content":"An error occurred when attempting to access the socket. This error is also returned when an attempt was made to set TTL to a value higher than 255.","nodes":[{"content":"An error occurred when attempting to access the socket. This error is also returned when an attempt was made to set TTL to a value higher than 255.","pos":[0,147],"nodes":[{"content":"An error occurred when attempting to access the socket.","pos":[0,55]},{"content":"This error is also returned when an attempt was made to set TTL to a value higher than 255.","pos":[56,147]}]}]}],"pos":[765348,765496],"yaml":true},{"content":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.","nodes":[{"pos":[0,67],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> has been closed.","source":"The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed."}],"pos":[765602,765670],"yaml":true},{"content":"Specifies whether the socket should only use Overlapped I/O mode.","nodes":[{"pos":[0,65],"content":"Specifies whether the socket should only use Overlapped I/O mode.","nodes":[{"content":"Specifies whether the socket should only use Overlapped I/O mode.","pos":[0,65]}]}],"pos":[766946,767012],"yaml":true},{"content":"Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>. Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.","nodes":[{"pos":[0,296],"content":"Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>. Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.","nodes":[{"content":"Set this property to <ph id=\"ph1\">`true`</ph> for a <ph id=\"ph2\">&lt;xref:System.Net.Sockets.Socket&gt;</ph> you intend to call <ph id=\"ph3\">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.","pos":[0,140],"source":"Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>."},{"content":"Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <ph id=\"ph1\">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.","pos":[141,296],"source":" Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>."}]}],"pos":[767023,767320],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> uses only overlapped I/O; otherwise, `false`. The default is `false`.","nodes":[{"pos":[0,130],"content":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> uses only overlapped I/O; otherwise, `false`. The default is `false`.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Net.Sockets.Socket\"&gt;&lt;/xref&gt;</ph> uses only overlapped I/O; otherwise, <ph id=\"ph3\">`false`</ph>.","pos":[0,106],"source":"`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> uses only overlapped I/O; otherwise, `false`."},{"content":"The default is <ph id=\"ph1\">`false`</ph>.","pos":[107,130],"source":" The default is `false`."}]}],"pos":[767521,767654],"yaml":true},{"content":"The socket has been bound to a completion port.","nodes":[{"pos":[0,47],"content":"The socket has been bound to a completion port.","nodes":[{"content":"The socket has been bound to a completion port.","pos":[0,47]}]}],"pos":[767837,767885],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Net.Sockets.Socket\n  commentId: T:System.Net.Sockets.Socket\n  id: Socket\n  children:\n  - System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)\n  - System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)\n  - System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)\n  - System.Net.Sockets.Socket.Accept\n  - System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  - System.Net.Sockets.Socket.AddressFamily\n  - System.Net.Sockets.Socket.Available\n  - System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)\n  - System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\n  - System.Net.Sockets.Socket.Blocking\n  - System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  - System.Net.Sockets.Socket.Close(System.Int32)\n  - System.Net.Sockets.Socket.Close\n  - System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\n  - System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\n  - System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\n  - System.Net.Sockets.Socket.Connect(System.String,System.Int32)\n  - System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  - System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\n  - System.Net.Sockets.Socket.Connected\n  - System.Net.Sockets.Socket.Disconnect(System.Boolean)\n  - System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  - System.Net.Sockets.Socket.Dispose\n  - System.Net.Sockets.Socket.Dispose(System.Boolean)\n  - System.Net.Sockets.Socket.DontFragment\n  - System.Net.Sockets.Socket.DualMode\n  - System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)\n  - System.Net.Sockets.Socket.EnableBroadcast\n  - System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)\n  - System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\n  - System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)\n  - System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)\n  - System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)\n  - System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\n  - System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)\n  - System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\n  - System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\n  - System.Net.Sockets.Socket.EndSend(System.IAsyncResult)\n  - System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)\n  - System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)\n  - System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)\n  - System.Net.Sockets.Socket.ExclusiveAddressUse\n  - System.Net.Sockets.Socket.Finalize\n  - System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\n  - System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])\n  - System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)\n  - System.Net.Sockets.Socket.Handle\n  - System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])\n  - System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])\n  - System.Net.Sockets.Socket.IsBound\n  - System.Net.Sockets.Socket.LingerState\n  - System.Net.Sockets.Socket.Listen(System.Int32)\n  - System.Net.Sockets.Socket.LocalEndPoint\n  - System.Net.Sockets.Socket.MulticastLoopback\n  - System.Net.Sockets.Socket.NoDelay\n  - System.Net.Sockets.Socket.OSSupportsIPv4\n  - System.Net.Sockets.Socket.OSSupportsIPv6\n  - System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)\n  - System.Net.Sockets.Socket.ProtocolType\n  - System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  - System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)\n  - System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  - System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\n  - System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  - System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\n  - System.Net.Sockets.Socket.Receive(System.Byte[])\n  - System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\n  - System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  - System.Net.Sockets.Socket.ReceiveBufferSize\n  - System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)\n  - System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  - System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  - System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  - System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  - System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\n  - System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  - System.Net.Sockets.Socket.ReceiveTimeout\n  - System.Net.Sockets.Socket.RemoteEndPoint\n  - System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)\n  - System.Net.Sockets.Socket.Send(System.Byte[])\n  - System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  - System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)\n  - System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\n  - System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\n  - System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  - System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)\n  - System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  - System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  - System.Net.Sockets.Socket.SendBufferSize\n  - System.Net.Sockets.Socket.SendFile(System.String)\n  - System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)\n  - System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  - System.Net.Sockets.Socket.SendTimeout\n  - System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)\n  - System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  - System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  - System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  - System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  - System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)\n  - System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)\n  - System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])\n  - System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\n  - System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)\n  - System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\n  - System.Net.Sockets.Socket.SocketType\n  - System.Net.Sockets.Socket.SupportsIPv4\n  - System.Net.Sockets.Socket.SupportsIPv6\n  - System.Net.Sockets.Socket.Ttl\n  - System.Net.Sockets.Socket.UseOnlyOverlappedIO\n  langs:\n  - csharp\n  name: Socket\n  nameWithType: Socket\n  fullName: System.Net.Sockets.Socket\n  type: Class\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Implements the Berkeley sockets interface.\n  remarks: \"The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications. The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.  \\n  \\n The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods. For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.  \\n  \\n If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.  \\n  \\n-   If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method. The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host. Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method. Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number. Use a port number of zero if you want the underlying service provider to assign a free port for you. If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method. To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.  \\n  \\n-   If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all. Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams. Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.  \\n  \\n To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.  \\n  \\n-   If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host. Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously. Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.  \\n  \\n-   If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>and<xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams.  \\n  \\n If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.  \\n  \\n When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>. After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.  \\n  \\n The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method. Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.  \\n  \\n> [!NOTE]\\n>  If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>. These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.\"\n  example:\n  - \"The following code example shows how the <xref:System.Net.Sockets.Socket> class can be used to send data to an HTTP server and receive the response. This example blocks until the entire page is received.  \\n  \\n [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]\\n [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]\\n [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]\"\n  syntax:\n    content: 'public class Socket : IDisposable'\n  inheritance:\n  - System.Object\n  implements:\n  - System.IDisposable\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  extensionMethods:\n  - System.Net.Sockets.SocketTaskExtensions.AcceptAsync(System.Net.Sockets.Socket)\n  - System.Net.Sockets.SocketTaskExtensions.AcceptAsync(System.Net.Sockets.Socket,System.Net.Sockets.Socket)\n  - System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.Net.EndPoint)\n  - System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.Net.IPAddress,System.Int32)\n  - System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.Net.IPAddress[],System.Int32)\n  - System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.String,System.Int32)\n  - System.Net.Sockets.SocketTaskExtensions.ReceiveAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags)\n  - System.Net.Sockets.SocketTaskExtensions.ReceiveAsync(System.Net.Sockets.Socket,System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\n  - System.Net.Sockets.SocketTaskExtensions.ReceiveFromAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  - System.Net.Sockets.SocketTaskExtensions.ReceiveMessageFromAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  - System.Net.Sockets.SocketTaskExtensions.SendAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags)\n  - System.Net.Sockets.SocketTaskExtensions.SendAsync(System.Net.Sockets.Socket,System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\n  - System.Net.Sockets.SocketTaskExtensions.SendToAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)\n  commentId: M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)\n  id: '#ctor(System.Net.Sockets.SocketInformation)'\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Socket(SocketInformation)\n  nameWithType: Socket.Socket(SocketInformation)\n  fullName: Socket.Socket(SocketInformation)\n  type: Constructor\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Initializes a new instance of the <xref href=\"System.Net.Sockets.Socket\"></xref> class using the specified value returned from <xref href=\"System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)\"></xref>.\n  remarks: If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket. This practice is strongly discouraged.\n  syntax:\n    content: public Socket (System.Net.Sockets.SocketInformation socketInformation);\n    parameters:\n    - id: socketInformation\n      type: System.Net.Sockets.SocketInformation\n      description: The socket information returned by <xref href=\"System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)\"></xref>.\n  overload: System.Net.Sockets.Socket.#ctor*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)\n  commentId: M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)\n  id: '#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)'\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Socket(SocketType, ProtocolType)\n  nameWithType: Socket.Socket(SocketType, ProtocolType)\n  fullName: Socket.Socket(SocketType, ProtocolType)\n  type: Constructor\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Initializes a new instance of the <xref href=\"System.Net.Sockets.Socket\"></xref> class using the specified socket type and protocol.\n  remarks: \"The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>. The two parameters are not independent. Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol. If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.  \\n  \\n> [!NOTE]\\n>  If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  syntax:\n    content: public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);\n    parameters:\n    - id: socketType\n      type: System.Net.Sockets.SocketType\n      description: One of the <xref href=\"System.Net.Sockets.SocketType\"></xref> values.\n    - id: protocolType\n      type: System.Net.Sockets.ProtocolType\n      description: One of the <xref href=\"System.Net.Sockets.ProtocolType\"></xref> values.\n  overload: System.Net.Sockets.Socket.#ctor*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: The combination of  <code>socketType</code> and <code>protocolType</code> results in an invalid socket.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)\n  commentId: M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)\n  id: '#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)'\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Socket(AddressFamily, SocketType, ProtocolType)\n  nameWithType: Socket.Socket(AddressFamily, SocketType, ProtocolType)\n  fullName: Socket.Socket(AddressFamily, SocketType, ProtocolType)\n  type: Constructor\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Initializes a new instance of the <xref href=\"System.Net.Sockets.Socket\"></xref> class using the specified address family, socket type and protocol.\n  remarks: \"The `addressFamily` parameter specifies the addressing scheme that the<xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>. The three parameters are not independent. Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol. If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.  \\n  \\n> [!NOTE]\\n>  If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example demonstrates how to create an instance of the <xref:System.Net.Sockets.Socket> class.  \\n  \\n [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]\\n [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]\\n [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]\"\n  syntax:\n    content: public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);\n    parameters:\n    - id: addressFamily\n      type: System.Net.Sockets.AddressFamily\n      description: One of the <xref href=\"System.Net.Sockets.AddressFamily\"></xref> values.\n    - id: socketType\n      type: System.Net.Sockets.SocketType\n      description: One of the <xref href=\"System.Net.Sockets.SocketType\"></xref> values.\n    - id: protocolType\n      type: System.Net.Sockets.ProtocolType\n      description: One of the <xref href=\"System.Net.Sockets.ProtocolType\"></xref> values.\n  overload: System.Net.Sockets.Socket.#ctor*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: The combination of <code>addressFamily</code>, <code>socketType</code>, and <code>protocolType</code> results in an invalid socket.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Accept\n  commentId: M:System.Net.Sockets.Socket.Accept\n  id: Accept\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Accept()\n  nameWithType: Socket.Accept()\n  fullName: Socket.Accept()\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Creates a new <xref href=\"System.Net.Sockets.Socket\"></xref> for a newly created connection.\n  remarks: \"<xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.  \\n  \\n In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued. Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.  \\n  \\n If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example accepts a simple <xref:System.Net.Sockets.Socket> connection.  \\n  \\n [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]\\n [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]\"\n  syntax:\n    content: public System.Net.Sockets.Socket Accept ();\n    parameters: []\n    return:\n      type: System.Net.Sockets.Socket\n      description: A <xref href=\"System.Net.Sockets.Socket\"></xref> for a newly created connection.\n  overload: System.Net.Sockets.Socket.Accept*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The accepting socket is not listening for connections. You must call <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> and <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref> before calling <xref href=\"System.Net.Sockets.Socket.Accept\"></xref>.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  commentId: M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  id: AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: AcceptAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.AcceptAsync(SocketAsyncEventArgs)\n  fullName: Socket.AcceptAsync(SocketAsyncEventArgs)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Begins an asynchronous operation to accept an incoming connection attempt.\n  remarks: \"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.  \\n  \\n To be notified of completion, you must create a callback method that implements the EventHandler\\\\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.  \\n  \\n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required:  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \\n  \\n The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> property.  \\n  \\n If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=fullName> property.  \\n  \\n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \\n  \\n Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds. In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the maximum number of bytes of data to receive in the buffer. These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=fullName> method. Part of the buffer passed in will be consumed internally for use by the the underlying Winsock AcceptEx call. This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> instance provided. The amount of the buffer used internally varies based on the address family of the socket. The minimum buffer size required is 288 bytes. If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received. If a timeout occurs, the connection is reset. So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.  \\n  \\n The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful.  \\n  \\n The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>. This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence). Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.\"\n  syntax:\n    content: public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);\n    parameters:\n    - id: e\n      type: System.Net.Sockets.SocketAsyncEventArgs\n      description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.\n    return:\n      type: System.Boolean\n      description: \"Returns `true` if the I/O operation is pending. The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \\n  \\n Returns `false` if the I/O operation completed synchronously. The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.\"\n  overload: System.Net.Sockets.Socket.AcceptAsync*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"An argument is not valid. This exception occurs if the buffer provided is not large enough. The buffer must be at least 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes.  \\n  \\n This exception also occurs if multiple buffers are specified, the <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\\\"></xref> property is not null.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: An argument is out of range. The exception occurs if the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Count\"></xref> is less than 0.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: \"An invalid operation was requested. This exception occurs if the accepting <xref href=\\\"System.Net.Sockets.Socket\\\"></xref> is not listening for connections or the accepted socket is bound.  \\n  \\n You must call the <xref href=\\\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\\\"></xref> and <xref href=\\\"System.Net.Sockets.Socket.Listen(System.Int32)\\\"></xref> method before calling the <xref href=\\\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\\\"></xref> method.  \\n  \\n This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <code>e</code> parameter.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows XP or later is required for this method.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.AddressFamily\n  commentId: P:System.Net.Sockets.Socket.AddressFamily\n  id: AddressFamily\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: AddressFamily\n  nameWithType: Socket.AddressFamily\n  fullName: Socket.AddressFamily\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets the address family of the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use. This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.\n  example:\n  - \"The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.  \\n  \\n [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]\\n [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]\\n [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]\"\n  syntax:\n    content: public System.Net.Sockets.AddressFamily AddressFamily { get; }\n    return:\n      type: System.Net.Sockets.AddressFamily\n      description: One of the <xref href=\"System.Net.Sockets.AddressFamily\"></xref> values.\n  overload: System.Net.Sockets.Socket.AddressFamily*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Available\n  commentId: P:System.Net.Sockets.Socket.Available\n  id: Available\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Available\n  nameWithType: Socket.Available\n  fullName: Socket.Available\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets the amount of data that has been received from the network and is available to be read.\n  remarks: \"If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>. The available data is the total amount of data queued in the network buffer for reading. If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.  \\n  \\n If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example compares the results of calling IOControl with FIONREAD and the Available property.  \\n  \\n [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]\\n [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]\"\n  syntax:\n    content: public int Available { get; }\n    return:\n      type: System.Int32\n      description: The number of bytes of data received from the network and available to be read.\n  overload: System.Net.Sockets.Socket.Available*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)\n  id: BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginAccept(Socket, Int32, AsyncCallback, Object)\n  nameWithType: Socket.BeginAccept(Socket, Int32, AsyncCallback, Object)\n  fullName: Socket.BeginAccept(Socket, Int32, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.\n  remarks: \"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. This overload allows you to specify the accepted socket in the `acceptSocket` parameter. If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.  \\n  \\n Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.  \\n  \\n You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.  \\n  \\n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.  \\n  \\n <xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.  \\n  \\n The system may also use the calling thread to invoke the callback method. In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously.  \\n  \\n For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \\n  \\n To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.  \\n  \\n> [!NOTE]\\n>  You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  example:\n  - \"The following code example opens a socket and accepts an asynchronous connection. In this example, the socket accepts the initial 10 bytes of data and the `acceptSocket` parameter is `null`, which forces the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to create the accepted socket. The number of bytes received and the data are displayed on the console by the callback delegate. See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.  \\n  \\n [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]\\n [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]\"\n  syntax:\n    content: public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);\n    parameters:\n    - id: acceptSocket\n      type: System.Net.Sockets.Socket\n      description: The accepted <xref href=\"System.Net.Sockets.Socket\"></xref> object. This value may be `null`.\n    - id: receiveSize\n      type: System.Int32\n      description: The maximum number of bytes to receive.\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate.\n    - id: state\n      type: System.Object\n      description: An object that contains state information for this request.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> object that references the asynchronous <xref href=\"System.Net.Sockets.Socket\"></xref> object creation.\n  overload: System.Net.Sockets.Socket.BeginAccept*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows NT is required for this method.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: \"The accepting socket is not listening for connections. You must call <xref href=\\\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\\\"></xref> and <xref href=\\\"System.Net.Sockets.Socket.Listen(System.Int32)\\\"></xref> before calling <xref href=\\\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\\\"></xref>.  \\n  \\n -or-  \\n  \\n The accepted socket is bound.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>receiveSize</code> is less than 0.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)\n  id: BeginAccept(System.Int32,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginAccept(Int32, AsyncCallback, Object)\n  nameWithType: Socket.BeginAccept(Int32, AsyncCallback, Object)\n  fullName: Socket.BeginAccept(Int32, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.\n  remarks: \"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts. Accepting connections asynchronously enables you to send and receive data within a separate execution thread. This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.  \\n  \\n Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.  \\n  \\n You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.  \\n  \\n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.  \\n  \\n <xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.  \\n  \\n The system may also use the calling thread to invoke the callback method. In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously.  \\n  \\n For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \\n  \\n To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.  When the <xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.  \\n  \\n> [!NOTE]\\n>  You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  example:\n  - \"The following code example opens a socket and accepts an asynchronous connection. In this example, the socket accepts the initial 10 bytes of data. The number of bytes received and the data are displayed on the console by the callback delegate. See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.  \\n  \\n [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]\\n [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]\"\n  syntax:\n    content: public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);\n    parameters:\n    - id: receiveSize\n      type: System.Int32\n      description: The number of bytes to accept from the sender.\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate.\n    - id: state\n      type: System.Object\n      description: An object that contains state information for this request.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous <xref href=\"System.Net.Sockets.Socket\"></xref> creation.\n  overload: System.Net.Sockets.Socket.BeginAccept*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows NT is required for this method.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: \"The accepting socket is not listening for connections. You must call <xref href=\\\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\\\"></xref> and <xref href=\\\"System.Net.Sockets.Socket.Listen(System.Int32)\\\"></xref> before calling <xref href=\\\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\\\"></xref>.  \\n  \\n -or-  \\n  \\n The accepted socket is bound.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>receiveSize</code> is less than 0.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\n  id: BeginAccept(System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginAccept(AsyncCallback, Object)\n  nameWithType: Socket.BeginAccept(AsyncCallback, Object)\n  fullName: Socket.BeginAccept(AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins an asynchronous operation to accept an incoming connection attempt.\n  remarks: \"Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts. Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread. Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.  \\n  \\n You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.  \\n  \\n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved. <xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host. You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.  \\n  \\n The system may also use the calling thread to invoke the callback method. In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A>method completed synchronously.  \\n  \\n For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \\n  \\n To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>. When the<xref:System.Net.Sockets.Socket.Close%2A>method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A>method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.  \\n  \\n> [!NOTE]\\n>  You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  example:\n  - \"The following code example attempts to receive an incoming connection asynchronously.  \\n  \\n [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]\\n [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]\\n [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]\"\n  syntax:\n    content: public IAsyncResult BeginAccept (AsyncCallback callback, object state);\n    parameters:\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate.\n    - id: state\n      type: System.Object\n      description: An object that contains state information for this request.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous <xref href=\"System.Net.Sockets.Socket\"></xref> creation.\n  overload: System.Net.Sockets.Socket.BeginAccept*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows NT is required for this method.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: \"The accepting socket is not listening for connections. You must call <xref href=\\\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\\\"></xref> and <xref href=\\\"System.Net.Sockets.Socket.Listen(System.Int32)\\\"></xref> before calling <xref href=\\\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\\\"></xref>.  \\n  \\n -or-  \\n  \\n The accepted socket is bound.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>receiveSize</code> is less than 0.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)\n  id: BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginConnect(EndPoint, AsyncCallback, Object)\n  nameWithType: Socket.BeginConnect(EndPoint, AsyncCallback, Object)\n  fullName: Socket.BeginConnect(EndPoint, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins an asynchronous request for a remote host connection.\n  remarks: \"If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host. Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.  \\n  \\n You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method. At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter.  \\n  \\n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \\n  \\n If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`. If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.  \\n  \\n To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  example:\n  - \"The following code example initiates an asynchronous connection attempt.  \\n  \\n [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]\\n [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]\\n [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]\"\n  syntax:\n    content: public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);\n    parameters:\n    - id: remoteEP\n      type: System.Net.EndPoint\n      description: ''\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate.\n    - id: state\n      type: System.Object\n      description: An object that contains state information for this request.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous connection.\n  overload: System.Net.Sockets.Socket.BeginConnect*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>remoteEP</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller higher in the call stack does not have permission for the requested operation.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)\n  id: BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginConnect(IPAddress, Int32, AsyncCallback, Object)\n  nameWithType: Socket.BeginConnect(IPAddress, Int32, AsyncCallback, Object)\n  fullName: Socket.BeginConnect(IPAddress, Int32, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins an asynchronous request for a remote host connection. The host is specified by an <xref href=\"System.Net.IPAddress\"></xref> and a port number.\n  remarks: \"The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method. Typically, the method is invoked by the `requestCallback` delegate.  \\n  \\n This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.  \\n  \\n To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.  \\n  \\n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <xref:System.Net.EndPoint> that is used must be different.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  example:\n  - \"The following code example initiates an asynchronous connection attempt.  \\n  \\n [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]\\n [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  \\n  \\n [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]\\n [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]\"\n  syntax:\n    content: public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);\n    parameters:\n    - id: address\n      type: System.Net.IPAddress\n      description: The <xref href=\"System.Net.IPAddress\"></xref> of the remote host.\n    - id: port\n      type: System.Int32\n      description: The port number of the remote host.\n    - id: requestCallback\n      type: System.AsyncCallback\n      description: ''\n    - id: state\n      type: System.Object\n      description: A user-defined object that contains information about the connect operation. This object is passed to the <code>requestCallback</code> delegate when the operation is complete.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous connection.\n  overload: System.Net.Sockets.Socket.BeginConnect*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>address</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> is not in the socket family.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The port number is not valid.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The length of <code>address</code> is zero.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)\n  id: BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginConnect(IPAddress[], Int32, AsyncCallback, Object)\n  nameWithType: Socket.BeginConnect(IPAddress[], Int32, AsyncCallback, Object)\n  fullName: Socket.BeginConnect(IPAddress[], Int32, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins an asynchronous request for a remote host connection. The host is specified by an <xref href=\"System.Net.IPAddress\"></xref> array and a port number.\n  remarks: \"The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method. Typically, the method is invoked by the `requestCallback` delegate.  \\n  \\n This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.  \\n  \\n To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.  \\n  \\n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <xref:System.Net.EndPoint> that is used must be different.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  example:\n  - \"The following code example initiates an asynchronous connection attempt.  \\n  \\n [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]\\n [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  \\n  \\n [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]\\n [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]\"\n  syntax:\n    content: public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);\n    parameters:\n    - id: addresses\n      type: System.Net.IPAddress[]\n      description: At least one <xref href=\"System.Net.IPAddress\"></xref>, designating the remote host.\n    - id: port\n      type: System.Int32\n      description: The port number of the remote host.\n    - id: requestCallback\n      type: System.AsyncCallback\n      description: ''\n    - id: state\n      type: System.Object\n      description: A user-defined object that contains information about the connect operation. This object is passed to the <code>requestCallback</code> delegate when the operation is complete.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous connections.\n  overload: System.Net.Sockets.Socket.BeginConnect*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>addresses</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: This method is valid for sockets that use <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The port number is not valid.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The length of <code>address</code> is zero.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)\n  id: BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginConnect(String, Int32, AsyncCallback, Object)\n  nameWithType: Socket.BeginConnect(String, Int32, AsyncCallback, Object)\n  fullName: Socket.BeginConnect(String, Int32, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins an asynchronous request for a remote host connection. The host is specified by a host name and a port number.\n  remarks: \"The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method. Typically, the method is invoked by the `requestCallback` delegate.  \\n  \\n This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.  \\n  \\n To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>. When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.  A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.  \\n  \\n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete. This is a limitation of the underlying provider. Also the <xref:System.Net.EndPoint> that is used must be different.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  example:\n  - \"The following code example initiates an asynchronous connection attempt.  \\n  \\n [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]\\n [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  \\n  \\n [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]\\n [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]\"\n  syntax:\n    content: public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);\n    parameters:\n    - id: host\n      type: System.String\n      description: The name of the remote host.\n    - id: port\n      type: System.Int32\n      description: The port number of the remote host.\n    - id: requestCallback\n      type: System.AsyncCallback\n      description: ''\n    - id: state\n      type: System.Object\n      description: A user-defined object that contains information about the connect operation. This object is passed to the <code>requestCallback</code> delegate when the operation is complete.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous connection.\n  overload: System.Net.Sockets.Socket.BeginConnect*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>host</code> is `null`.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The port number is not valid.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)\n  id: BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginDisconnect(Boolean, AsyncCallback, Object)\n  nameWithType: Socket.BeginDisconnect(Boolean, AsyncCallback, Object)\n  fullName: Socket.BeginDisconnect(Boolean, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins an asynchronous request to disconnect from a remote endpoint.\n  remarks: \"If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint. If `reuseSocket` is `true`, you can reuse the socket.  \\n  \\n The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method. The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete. For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example creates a socket for asynchronous communication and sends some data to a remote host. When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity. Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request. When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.  \\n  \\n [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]\\n [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]\"\n  syntax:\n    content: public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);\n    parameters:\n    - id: reuseSocket\n      type: System.Boolean\n      description: '`true` if this socket can be reused after the connection is closed; otherwise, `false`.'\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate.\n    - id: state\n      type: System.Object\n      description: An object that contains state information for this request.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> object that references the asynchronous operation.\n  overload: System.Net.Sockets.Socket.BeginDisconnect*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operating system is Windows 2000 or earlier, and this method requires Windows XP.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  id: BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginReceive(Byte[], Int32, Int32, SocketFlags, SocketError, AsyncCallback, Object)\n  nameWithType: Socket.BeginReceive(Byte[], Int32, Int32, SocketFlags, SocketError, AsyncCallback, Object)\n  fullName: Socket.BeginReceive(Byte[], Int32, Int32, SocketFlags, SocketError, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins to asynchronously receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: \"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method. Typically, the method is invoked by the `callback` delegate.  \\n  \\n This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.  \\n  \\n To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.  \\n  \\n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \\n  \\n> [!NOTE]\\n>  `state` is an instantiation of a user-defined class.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  syntax:\n    content: public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.\n    - id: offset\n      type: System.Int32\n      description: The location in <code>buffer</code> to store the received data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to receive.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: ''\n    - id: errorCode\n      type: System.Net.Sockets.SocketError\n      description: ''\n    - id: callback\n      type: System.AsyncCallback\n      description: An <xref href=\"System.AsyncCallback\"></xref> delegate that references the method to invoke when the operation is complete.\n    - id: state\n      type: System.Object\n      description: A user-defined object that contains information about the receive operation. This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read.\n  overload: System.Net.Sockets.Socket.BeginReceive*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>offset</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>offset</code> is greater than the length of <code>buffer</code>.  \\n  \\n -or-  \\n  \\n <code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.\"\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  id: BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginReceive(Byte[], Int32, Int32, SocketFlags, AsyncCallback, Object)\n  nameWithType: Socket.BeginReceive(Byte[], Int32, Int32, SocketFlags, AsyncCallback, Object)\n  fullName: Socket.BeginReceive(Byte[], Int32, Int32, SocketFlags, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins to asynchronously receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: \"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method. Typically, the method is invoked by the `callback` delegate.  \\n  \\n This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.  \\n  \\n To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.  \\n  \\n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \\n  \\n> [!NOTE]\\n>  `state` is an instantiation of a user-defined class.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  example:\n  - \"The following code example begins to asynchronously receive data from a connected <xref:System.Net.Sockets.Socket>.  \\n  \\n [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]\\n [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]\\n [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  \\n  \\n [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]\\n [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]\\n [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  \\n  \\n [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]\\n [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]\\n [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]\"\n  syntax:\n    content: public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.\n    - id: offset\n      type: System.Int32\n      description: The zero-based position in the <code>buffer</code> parameter at which to store the received data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to receive.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: ''\n    - id: callback\n      type: System.AsyncCallback\n      description: An <xref href=\"System.AsyncCallback\"></xref> delegate that references the method to invoke when the operation is complete.\n    - id: state\n      type: System.Object\n      description: A user-defined object that contains information about the receive operation. This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read.\n  overload: System.Net.Sockets.Socket.BeginReceive*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>offset</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>offset</code> is greater than the length of <code>buffer</code>.  \\n  \\n -or-  \\n  \\n <code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.\"\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  id: BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginReceive(IList<ArraySegment<Byte>>, SocketFlags, AsyncCallback, Object)\n  nameWithType: Socket.BeginReceive(IList<ArraySegment<Byte>>, SocketFlags, AsyncCallback, Object)\n  fullName: Socket.BeginReceive(IList<ArraySegment<Byte>>, SocketFlags, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins to asynchronously receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: \"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method. Typically, the method is invoked by the `callback` delegate.  \\n  \\n This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.  \\n  \\n To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.  \\n  \\n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \\n  \\n> [!NOTE]\\n>  `state` is an instantiation of a user-defined class.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      public IAsyncResult BeginReceive (System.Collections.Generic.IList<ArraySegment<byte>> buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);\n    parameters:\n    - id: buffers\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: callback\n      type: System.AsyncCallback\n      description: An <xref href=\"System.AsyncCallback\"></xref> delegate that references the method to invoke when the operation is complete.\n    - id: state\n      type: System.Object\n      description: A user-defined object that contains information about the receive operation. This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read.\n  overload: System.Net.Sockets.Socket.BeginReceive*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  attributes:\n  - type: System.CLSCompliantAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  id: BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginReceive(IList<ArraySegment<Byte>>, SocketFlags, SocketError, AsyncCallback, Object)\n  nameWithType: Socket.BeginReceive(IList<ArraySegment<Byte>>, SocketFlags, SocketError, AsyncCallback, Object)\n  fullName: Socket.BeginReceive(IList<ArraySegment<Byte>>, SocketFlags, SocketError, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins to asynchronously receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: \"The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method. Typically, the method is invoked by the `callback` delegate.  \\n  \\n This method does not block until the operation is complete. To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.  \\n  \\n To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.  \\n  \\n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \\n  \\n> [!NOTE]\\n>  `state` is an instantiation of a user-defined class.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket>methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      public IAsyncResult BeginReceive (System.Collections.Generic.IList<ArraySegment<byte>> buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);\n    parameters:\n    - id: buffers\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: errorCode\n      type: System.Net.Sockets.SocketError\n      description: A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.\n    - id: callback\n      type: System.AsyncCallback\n      description: An <xref href=\"System.AsyncCallback\"></xref> delegate that references the method to invoke when the operation is complete.\n    - id: state\n      type: System.Object\n      description: A user-defined object that contains information about the receive operation. This object is passed to the <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> delegate when the operation is complete.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read.\n  overload: System.Net.Sockets.Socket.BeginReceive*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  attributes:\n  - type: System.CLSCompliantAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\n  id: BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginReceiveFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  nameWithType: Socket.BeginReceiveFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  fullName: Socket.BeginReceiveFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins to asynchronously receive data from a specified network device.\n  remarks: \"The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host. Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.  \\n  \\n You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter.  \\n  \\n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName>. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \\n  \\n> [!NOTE]\\n>  Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent. For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts. In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer.  \\n  \\n To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.  \\n  \\n Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.  \\n  \\n With connection-oriented sockets, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.  \\n  \\n To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  example:\n  - \"The following code example asynchronously receives connectionless datagrams from a remote host.  \\n  \\n [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]\\n [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]\\n [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]\"\n  syntax:\n    content: public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.\n    - id: offset\n      type: System.Int32\n      description: The zero-based position in the <code>buffer</code> parameter at which to store the data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to receive.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: ''\n    - id: remoteEP\n      type: System.Net.EndPoint\n      description: ''\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate.\n    - id: state\n      type: System.Object\n      description: An object that contains state information for this request.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read.\n  overload: System.Net.Sockets.Socket.BeginReceiveFrom*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>buffer</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>remoteEP</code> is `null`.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>offset</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>offset</code> is greater than the length of <code>buffer</code>.  \\n  \\n -or-  \\n  \\n <code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller higher in the call stack does not have permission for the requested operation.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\n  id: BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginReceiveMessageFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  nameWithType: Socket.BeginReceiveMessageFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  fullName: Socket.BeginReceiveMessageFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint and packet information..\n  remarks: \"The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method. Typically, the method is invoked by the `asyncCallback` delegate.  \\n  \\n This method does not block until the operation completes. To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.  \\n  \\n To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.  \\n  \\n For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  \\n  \\n This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet. For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  syntax:\n    content: >-\n      [System.MonoTODO]\n\n      public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.\n    - id: offset\n      type: System.Int32\n      description: The zero-based position in the <code>buffer</code> parameter at which to store the data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to receive.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: remoteEP\n      type: System.Net.EndPoint\n      description: An <xref href=\"System.Net.EndPoint\"></xref> that represents the source of the data.\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate.\n    - id: state\n      type: System.Object\n      description: An object that contains state information for this request.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous read.\n  overload: System.Net.Sockets.Socket.BeginReceiveMessageFrom*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>buffer</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>remoteEP</code> is `null`.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>offset</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>offset</code> is greater than the length of <code>buffer</code>.  \\n  \\n -or-  \\n  \\n <code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operating system is Windows 2000 or earlier, and this method requires Windows XP.\n  attributes:\n  - type: System.MonoTODO\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  id: BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginSend(IList<ArraySegment<Byte>>, SocketFlags, AsyncCallback, Object)\n  nameWithType: Socket.BeginSend(IList<ArraySegment<Byte>>, SocketFlags, AsyncCallback, Object)\n  fullName: Socket.BeginSend(IList<ArraySegment<Byte>>, SocketFlags, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: \"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.  \\n  \\n You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.  \\n  \\n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \\n  \\n Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \\n  \\n> [!NOTE]\\n>  `state` is an instantiation of a user-defined class.  \\n  \\n> [!NOTE]\\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  syntax:\n    content: public IAsyncResult BeginSend (System.Collections.Generic.IList<ArraySegment<byte>> buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);\n    parameters:\n    - id: buffers\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the data to send.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate.\n    - id: state\n      type: System.Object\n      description: An object that contains state information for this request.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send.\n  overload: System.Net.Sockets.Socket.BeginSend*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffers</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>buffers</code> is empty.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket. See remarks section below.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  id: BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginSend(IList<ArraySegment<Byte>>, SocketFlags, SocketError, AsyncCallback, Object)\n  nameWithType: Socket.BeginSend(IList<ArraySegment<Byte>>, SocketFlags, SocketError, AsyncCallback, Object)\n  fullName: Socket.BeginSend(IList<ArraySegment<Byte>>, SocketFlags, SocketError, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: \"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.  \\n  \\n You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.  \\n  \\n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \\n  \\n Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \\n  \\n> [!NOTE]\\n>  `state` is an instantiation of a user-defined class.  \\n  \\n> [!NOTE]\\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      public IAsyncResult BeginSend (System.Collections.Generic.IList<ArraySegment<byte>> buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);\n    parameters:\n    - id: buffers\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the data to send.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: errorCode\n      type: System.Net.Sockets.SocketError\n      description: A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate.\n    - id: state\n      type: System.Object\n      description: An object that contains state information for this request.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send.\n  overload: System.Net.Sockets.Socket.BeginSend*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffers</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>buffers</code> is empty.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket. See remarks section below.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  attributes:\n  - type: System.CLSCompliantAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  id: BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginSend(Byte[], Int32, Int32, SocketFlags, AsyncCallback, Object)\n  nameWithType: Socket.BeginSend(Byte[], Int32, Int32, SocketFlags, AsyncCallback, Object)\n  fullName: Socket.BeginSend(Byte[], Int32, Int32, SocketFlags, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: \"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.  \\n  \\n You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.  \\n  \\n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \\n  \\n Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \\n  \\n> [!NOTE]\\n>  `state` is an instantiation of a user-defined class.  \\n  \\n> [!NOTE]\\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  example:\n  - \"The following code example begins asynchronously sending data to a remote host.  \\n  \\n [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]\\n [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]\\n [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]\"\n  syntax:\n    content: public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the data to send.\n    - id: offset\n      type: System.Int32\n      description: The zero-based position in the <code>buffer</code> parameter at which to begin sending data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to send.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: ''\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate.\n    - id: state\n      type: System.Object\n      description: An object that contains state information for this request.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send.\n  overload: System.Net.Sockets.Socket.BeginSend*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket. See remarks section below.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>offset</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>offset</code> is less than the length of <code>buffer</code>.  \\n  \\n -or-  \\n  \\n <code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  id: BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginSend(Byte[], Int32, Int32, SocketFlags, SocketError, AsyncCallback, Object)\n  nameWithType: Socket.BeginSend(Byte[], Int32, Int32, SocketFlags, SocketError, AsyncCallback, Object)\n  fullName: Socket.BeginSend(Byte[], Int32, Int32, SocketFlags, SocketError, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: \"The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method. <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.  \\n  \\n You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.  \\n  \\n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \\n  \\n Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \\n  \\n> [!NOTE]\\n>  `state` is an instantiation of a user-defined class.  \\n  \\n> [!NOTE]\\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  syntax:\n    content: public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the data to send.\n    - id: offset\n      type: System.Int32\n      description: The zero-based position in the <code>buffer</code> parameter at which to begin sending data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to send.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: errorCode\n      type: System.Net.Sockets.SocketError\n      description: A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate.\n    - id: state\n      type: System.Object\n      description: An object that contains state information for this request.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send.\n  overload: System.Net.Sockets.Socket.BeginSend*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket. See remarks section below.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>offset</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>offset</code> is less than the length of <code>buffer</code>.  \\n  \\n -or-  \\n  \\n <code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)\n  id: BeginSendFile(System.String,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginSendFile(String, AsyncCallback, Object)\n  nameWithType: Socket.BeginSendFile(String, AsyncCallback, Object)\n  fullName: Socket.BeginSendFile(String, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Sends the file <code>fileName</code> to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object using the <xref href=\"System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread\"></xref> flag.\n  remarks: \"This overload sends the file `fileName` to the connected socket. If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards (\\\"..\\\\\\\\\\\\myfile.txt\\\") and UNC share names (\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\shared directory\\\\\\\\\\\\myfile.txt\\\") are supported. If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.  \\n  \\n This method uses the `TransmitFile` function found in the Windows Sockets 2 API. For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.  \\n  \\n The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.  \\n  \\n To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter. To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication. If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.  \\n  \\n Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \\n  \\n Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  example:\n  - \"The following code example creates and connects a socket for asynchronous communication. First, the file \\\"text.txt\\\" is sent asynchronously to the remote host. The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.  \\n  \\n [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]\\n [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]\"\n  syntax:\n    content: public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);\n    parameters:\n    - id: fileName\n      type: System.String\n      description: A string that contains the path and name of the file to send. This parameter can be `null`.\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate.\n    - id: state\n      type: System.Object\n      description: An object that contains state information for this request.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> object that represents the asynchronous send.\n  overload: System.Net.Sockets.Socket.BeginSendFile*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The socket is not connected to a remote host.\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: The file <code>fileName</code> was not found.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket. See remarks section below.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)\n  id: BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginSendFile(String, Byte[], Byte[], TransmitFileOptions, AsyncCallback, Object)\n  nameWithType: Socket.BeginSendFile(String, Byte[], Byte[], TransmitFileOptions, AsyncCallback, Object)\n  fullName: Socket.BeginSendFile(String, Byte[], Byte[], TransmitFileOptions, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Sends a file and buffers of data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object.\n  remarks: \"This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values. The `preBuffer` parameter contains any data you want to precede the file. `postBuffer` contains data you want to follow the file. If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards (\\\"..\\\\\\\\\\\\myfile.txt\\\") and UNC share names (\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\shared directory\\\\\\\\\\\\myfile.txt\\\") are supported. If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.  \\n  \\n The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer. For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.  \\n  \\n This method uses the `TransmitFile` function found in the Windows Sockets 2 API. For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.  \\n  \\n The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.  \\n  \\n To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter. To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication. If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information. Pass an instance of this custom object to the<xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.  \\n  \\n Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception. For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \\n  \\n Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host. With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  example:\n  - \"The following code example creates and connects a socket for asynchronous communication and begins sending the file \\\"text.txt\\\" asynchronously to the remote host. In this example, a `preBuffer` and a `postBuffer` of data is created to send with the file and the default <xref:System.Net.Sockets.TransmitFileOptions> value is used. The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.  \\n  \\n [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]\\n [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]\"\n  syntax:\n    content: public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);\n    parameters:\n    - id: fileName\n      type: System.String\n      description: A string that contains the path and name of the file to be sent. This parameter can be `null`.\n    - id: preBuffer\n      type: System.Byte[]\n      description: A <xref href=\"System.Byte\"></xref> array that contains data to be sent before the file is sent. This parameter can be `null`.\n    - id: postBuffer\n      type: System.Byte[]\n      description: A <xref href=\"System.Byte\"></xref> array that contains data to be sent after the file is sent. This parameter can be `null`.\n    - id: flags\n      type: System.Net.Sockets.TransmitFileOptions\n      description: A bitwise combination of <xref href=\"System.Net.Sockets.TransmitFileOptions\"></xref> values.\n    - id: callback\n      type: System.AsyncCallback\n      description: An <xref href=\"System.AsyncCallback\"></xref> delegate to be invoked when this operation completes. This parameter can be `null`.\n    - id: state\n      type: System.Object\n      description: A user-defined object that contains state information for this request. This parameter can be `null`.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> object that represents the asynchronous operation.\n  overload: System.Net.Sockets.Socket.BeginSendFile*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket. See remarks section below.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: \"The operating system is not Windows NT or later.  \\n  \\n \\\\- or -  \\n  \\n The socket is not connected to a remote host.\"\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: The file <code>fileName</code> was not found.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)\n  commentId: M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)\n  id: BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: BeginSendTo(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  nameWithType: Socket.BeginSendTo(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  fullName: Socket.BeginSendTo(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Sends data asynchronously to a specific remote host.\n  remarks: \"The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter. Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread. Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols.  \\n  \\n You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method. To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication. If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information. Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter.  \\n  \\n Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method. When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception. If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=fullName> method. Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing. For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  \\n  \\n If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.  \\n  \\n If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method. In this case, the underlying service provider will assign the most appropriate local network address and port number. Use a port number of zero if you want the underlying service provider to select a free port. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes.  \\n  \\n If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. -You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods. After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.\"\n  example:\n  - \"The following code example asynchronously sends data to the specified remote host.  \\n  \\n [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]\\n [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]\\n [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]\"\n  syntax:\n    content: public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the data to send.\n    - id: offset\n      type: System.Int32\n      description: The zero-based position in <code>buffer</code> at which to begin sending data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to send.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: ''\n    - id: remoteEP\n      type: System.Net.EndPoint\n      description: ''\n    - id: callback\n      type: System.AsyncCallback\n      description: The <xref href=\"System.AsyncCallback\"></xref> delegate.\n    - id: state\n      type: System.Object\n      description: An object that contains state information for this request.\n    return:\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that references the asynchronous send.\n  overload: System.Net.Sockets.Socket.BeginSendTo*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>buffer</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>remoteEP</code> is `null`.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>offset</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>offset</code> is greater than the length of <code>buffer</code>.  \\n  \\n -or-  \\n  \\n <code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller higher in the call stack does not have permission for the requested operation.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\n  commentId: M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\n  id: Bind(System.Net.EndPoint)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Bind(EndPoint)\n  nameWithType: Socket.Bind(EndPoint)\n  fullName: Socket.Bind(EndPoint)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Associates a <xref href=\"System.Net.Sockets.Socket\"></xref> with a local endpoint.\n  remarks: \"Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint. You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method. You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint. You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.  \\n  \\n Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data. If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=fullName> as the address parameter, and the underlying service provider will assign the most appropriate network address. This might help simplify your application if you have multiple network interfaces. If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number. In this case, the service provider will assign an available port number between 1024 and 5000.  \\n  \\n If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method. If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.  \\n  \\n If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method.  \\n  \\n> [!NOTE]\\n>  If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number.  \\n  \\n> [!NOTE]\\n>  You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example binds a <xref:System.Net.Sockets.Socket> using the specified local endpoint.  \\n  \\n [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]\\n [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]\"\n  syntax:\n    content: public void Bind (System.Net.EndPoint localEP);\n    parameters:\n    - id: localEP\n      type: System.Net.EndPoint\n      description: The local <xref href=\"System.Net.EndPoint\"></xref> to associate with the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  overload: System.Net.Sockets.Socket.Bind*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>localEP</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller higher in the call stack does not have permission for the requested operation.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Blocking\n  commentId: P:System.Net.Sockets.Socket.Blocking\n  id: Blocking\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Blocking\n  nameWithType: Socket.Blocking\n  fullName: Socket.Blocking\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets or sets a value that indicates whether the <xref href=\"System.Net.Sockets.Socket\"></xref> is in blocking mode.\n  remarks: \"The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode.  \\n  \\n If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes. If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`. The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods. If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  syntax:\n    content: public bool Blocking { get; set; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> will block; otherwise, `false`. The default is `true`.'\n  overload: System.Net.Sockets.Socket.Blocking*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  commentId: M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  id: CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: CancelConnectAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.CancelConnectAsync(SocketAsyncEventArgs)\n  fullName: Socket.CancelConnectAsync(SocketAsyncEventArgs)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Cancels an asynchronous request for a remote host connection.\n  remarks: The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection.\n  syntax:\n    content: public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);\n    parameters:\n    - id: e\n      type: System.Net.Sockets.SocketAsyncEventArgs\n      description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object used to request the connection to the remote host by calling one of the <xref href=\"System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\"></xref> methods.\n  overload: System.Net.Sockets.Socket.CancelConnectAsync*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>e</code> parameter cannot be null and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller higher in the call stack does not have permission for the requested operation.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Close(System.Int32)\n  commentId: M:System.Net.Sockets.Socket.Close(System.Int32)\n  id: Close(System.Int32)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Close(Int32)\n  nameWithType: Socket.Close(Int32)\n  fullName: Socket.Close(Int32)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Closes the <xref href=\"System.Net.Sockets.Socket\"></xref> connection and releases all associated resources with a specified timeout to allow queued data to be sent.\n  remarks: \"The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>. Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.  \\n  \\n For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>. This ensures that all data is sent and received on the connected socket before it is closed.  \\n  \\n If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval. <xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires. If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.  \\n  \\n> [!NOTE]\\n>  To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period. Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example demonstrates how to close a <xref:System.Net.Sockets.Socket>.  \\n  \\n [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]\\n [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]\"\n  syntax:\n    content: public void Close (int timeout);\n    parameters:\n    - id: timeout\n      type: System.Int32\n      description: Wait up to <code>timeout</code> seconds to send any remaining data, then close the socket.\n  overload: System.Net.Sockets.Socket.Close*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Close\n  commentId: M:System.Net.Sockets.Socket.Close\n  id: Close\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Close()\n  nameWithType: Socket.Close()\n  fullName: Socket.Close()\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Closes the <xref href=\"System.Net.Sockets.Socket\"></xref> connection and releases all associated resources.\n  remarks: \"The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>. Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.  \\n  \\n For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method. This ensures that all data is sent and received on the connected socket before it is closed.  \\n  \\n If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval. <xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires. If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.  \\n  \\n> [!NOTE]\\n>  To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period. Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example closes a <xref:System.Net.Sockets.Socket>.  \\n  \\n [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]\\n [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]\"\n  syntax:\n    content: public void Close ();\n    parameters: []\n  overload: System.Net.Sockets.Socket.Close*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\n  commentId: M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\n  id: Connect(System.Net.EndPoint)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Connect(EndPoint)\n  nameWithType: Socket.Connect(EndPoint)\n  fullName: Socket.Connect(EndPoint)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Establishes a connection to a remote host.\n  remarks: \"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.  \\n  \\n If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully. Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.  \\n  \\n> [!NOTE]\\n>  If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.  \\n  \\n> [!NOTE]\\n>  If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example connects to a remote endpoint and then verifies the connection.  \\n  \\n [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]\\n [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]\"\n  syntax:\n    content: public void Connect (System.Net.EndPoint remoteEP);\n    parameters:\n    - id: remoteEP\n      type: System.Net.EndPoint\n      description: An <xref href=\"System.Net.EndPoint\"></xref> that represents the remote device.\n  overload: System.Net.Sockets.Socket.Connect*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>remoteEP</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller higher in the call stack does not have permission for the requested operation.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\n  commentId: M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\n  id: Connect(System.Net.IPAddress,System.Int32)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Connect(IPAddress, Int32)\n  nameWithType: Socket.Connect(IPAddress, Int32)\n  fullName: Socket.Connect(IPAddress, Int32)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Establishes a connection to a remote host. The host is specified by an IP address and a port number.\n  remarks: \"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.  \\n  \\n If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully. Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.  \\n  \\n> [!NOTE]\\n>  If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.  \\n  \\n> [!NOTE]\\n>  If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example connects to a remote endpoint and then verifies the connection.  \\n  \\n [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]\\n [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]\"\n  syntax:\n    content: public void Connect (System.Net.IPAddress address, int port);\n    parameters:\n    - id: address\n      type: System.Net.IPAddress\n      description: The IP address of the remote host.\n    - id: port\n      type: System.Int32\n      description: The port number of the remote host.\n  overload: System.Net.Sockets.Socket.Connect*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>address</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The port number is not valid.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The length of <code>address</code> is zero.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\n  commentId: M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\n  id: Connect(System.Net.IPAddress[],System.Int32)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Connect(IPAddress[], Int32)\n  nameWithType: Socket.Connect(IPAddress[], Int32)\n  fullName: Socket.Connect(IPAddress[], Int32)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Establishes a connection to a remote host. The host is specified by an array of IP addresses and a port number.\n  remarks: \"This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host. If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.  \\n  \\n If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully. Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.  \\n  \\n> [!NOTE]\\n>  If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.  \\n  \\n> [!NOTE]\\n>  If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example connects to a remote endpoint and then verifies the connection.  \\n  \\n [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]\\n [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]\"\n  syntax:\n    content: public void Connect (System.Net.IPAddress[] addresses, int port);\n    parameters:\n    - id: addresses\n      type: System.Net.IPAddress[]\n      description: The IP addresses of the remote host.\n    - id: port\n      type: System.Int32\n      description: The port number of the remote host.\n  overload: System.Net.Sockets.Socket.Connect*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>addresses</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The port number is not valid.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The length of <code>address</code> is zero.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Connect(System.String,System.Int32)\n  commentId: M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)\n  id: Connect(System.String,System.Int32)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Connect(String, Int32)\n  nameWithType: Socket.Connect(String, Int32)\n  fullName: Socket.Connect(String, Int32)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Establishes a connection to a remote host. The host is specified by a host name and a port number.\n  remarks: \"If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host. After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.  \\n  \\n If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded. If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>. If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection. Connectionless protocols will not throw an exception because they simply establish a default remote host. You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully. Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.  \\n  \\n If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address. This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.  \\n  \\n> [!NOTE]\\n>  If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number. If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation. If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.  \\n  \\n> [!NOTE]\\n>  If the socket has been previously disconnected, then you cannot use this method to restore the connection. Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect. This is a limitation of the underlying provider.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example connects to a remote endpoint and then verifies the connection.  \\n  \\n [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]\\n [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]\"\n  syntax:\n    content: public void Connect (string host, int port);\n    parameters:\n    - id: host\n      type: System.String\n      description: The name of the remote host.\n    - id: port\n      type: System.Int32\n      description: The port number of the remote host.\n  overload: System.Net.Sockets.Socket.Connect*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>host</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The port number is not valid.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: This method is valid for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> is <xref href=\"System.Net.Sockets.Socket.Listen(System.Int32)\"></xref>ing.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  commentId: M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  id: ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: ConnectAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.ConnectAsync(SocketAsyncEventArgs)\n  fullName: Socket.ConnectAsync(SocketAsyncEventArgs)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Begins an asynchronous request for a connection to a remote host.\n  remarks: \"If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.  \\n  \\n To be notified of completion, you must create a callback method that implements the EventHandler\\\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.  \\n  \\n The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.  \\n  \\n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \\n  \\n If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.  \\n  \\n If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`. If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required:  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  \\n  \\n Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds. In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the number of bytes of data to send from the buffer. Once a connection is established, this buffer of data is sent.  \\n  \\n If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.  \\n  \\n If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.  \\n  \\n The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> are not the same address family.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.\"\n  syntax:\n    content: public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);\n    parameters:\n    - id: e\n      type: System.Net.Sockets.SocketAsyncEventArgs\n      description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.\n    return:\n      type: System.Boolean\n      description: \"Returns `true` if the I/O operation is pending. The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \\n  \\n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.\"\n  overload: System.Net.Sockets.Socket.ConnectAsync*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: An argument is not valid. This exception occurs if multiple buffers are specified, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> property is not null.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>e</code> parameter cannot be null and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> is listening or a socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows XP or later is required for this method. This exception also occurs if the local endpoint and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> are not the same address family.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller higher in the call stack does not have permission for the requested operation.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\n  commentId: M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\n  id: ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: ConnectAsync(SocketType, ProtocolType, SocketAsyncEventArgs)\n  nameWithType: Socket.ConnectAsync(SocketType, ProtocolType, SocketAsyncEventArgs)\n  fullName: Socket.ConnectAsync(SocketType, ProtocolType, SocketAsyncEventArgs)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Begins an asynchronous request for a connection to a remote host.\n  remarks: \"If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters.  \\n  \\n To be notified of completion, you must create a callback method that implements the EventHandler\\\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.  \\n  \\n The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.  \\n  \\n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \\n  \\n If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data. You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host. If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded. If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.  \\n  \\n If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`. If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required:  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  \\n  \\n Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds. In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> property needs to be set to the number of bytes of data to send from the buffer. Once a connection is established, this buffer of data is sent.  \\n  \\n If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.  \\n  \\n If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.  \\n  \\n The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> are not the same address family.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.\"\n  syntax:\n    content: public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);\n    parameters:\n    - id: socketType\n      type: System.Net.Sockets.SocketType\n      description: One of the <xref href=\"System.Net.Sockets.SocketType\"></xref> values.\n    - id: protocolType\n      type: System.Net.Sockets.ProtocolType\n      description: One of the <xref href=\"System.Net.Sockets.ProtocolType\"></xref> values.\n    - id: e\n      type: System.Net.Sockets.SocketAsyncEventArgs\n      description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.\n    return:\n      type: System.Boolean\n      description: \"Returns `true` if the I/O operation is pending. The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \\n  \\n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.\"\n  overload: System.Net.Sockets.Socket.ConnectAsync*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: An argument is not valid. This exception occurs if multiple buffers are specified, the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> property is not null.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>e</code> parameter cannot be null and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> is listening or a socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows XP or later is required for this method. This exception also occurs if the local endpoint and the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> are not the same address family.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller higher in the call stack does not have permission for the requested operation.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Connected\n  commentId: P:System.Net.Sockets.Socket.Connected\n  id: Connected\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Connected\n  nameWithType: Socket.Connected\n  fullName: Socket.Connected\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets a value that indicates whether a <xref href=\"System.Net.Sockets.Socket\"></xref> is connected to a remote host as of the last <xref href=\"System.Net.Sockets.Socket.Send*\"></xref> or <xref href=\"System.Net.Sockets.Socket.Receive*\"></xref> operation.\n  remarks: \"The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation. When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected.  \\n  \\n The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation. If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call. If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.  \\n  \\n If you call <xref:System.Net.Sockets.Socket.Connect%2A> on a User Datagram Protocol (UDP) socket, the <xref:System.Net.Sockets.Socket.Connected%2A> property always returns `true`; however, this action does not change the inherent connectionless nature of UDP.\"\n  example:\n  - \"The following code example connects to a remote endpoint, checks the <xref:System.Net.Sockets.Socket.Connected%2A> property, and checks the current state of the connection.  \\n  \\n [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]\\n [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]\"\n  syntax:\n    content: public bool Connected { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> was connected to a remote resource as of the most recent operation; otherwise, `false`.'\n  overload: System.Net.Sockets.Socket.Connected*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Disconnect(System.Boolean)\n  commentId: M:System.Net.Sockets.Socket.Disconnect(System.Boolean)\n  id: Disconnect(System.Boolean)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Disconnect(Boolean)\n  nameWithType: Socket.Disconnect(Boolean)\n  fullName: Socket.Disconnect(Boolean)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Closes the socket connection and allows reuse of the socket.\n  remarks: \"If you are using a connection-oriented protocol, you can use this method to close the socket. This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`. However, if `reuseSocket` is `true`, you can reuse the socket.  \\n  \\n To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method.  \\n  \\n If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent. <xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires. If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example creates a socket for synchronous communication and sends some data to a remote host. It then calls <xref:System.Net.Sockets.Socket.Shutdown%2A>, to stop the send and receive activity, and <xref:System.Net.Sockets.Socket.Disconnect%2A>, to close the socket connection.  \\n  \\n [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]\\n [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]\"\n  syntax:\n    content: public void Disconnect (bool reuseSocket);\n    parameters:\n    - id: reuseSocket\n      type: System.Boolean\n      description: '`true` if this socket can be reused after the current connection is closed; otherwise, `false`.'\n  overload: System.Net.Sockets.Socket.Disconnect*\n  exceptions:\n  - type: System.PlatformNotSupportedException\n    commentId: T:System.PlatformNotSupportedException\n    description: This method requires Windows 2000 or earlier, or the exception will be thrown.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  commentId: M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  id: DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: DisconnectAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.DisconnectAsync(SocketAsyncEventArgs)\n  fullName: Socket.DisconnectAsync(SocketAsyncEventArgs)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Begins an asynchronous request to disconnect from a remote endpoint.\n  remarks: When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint. If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=fullName> to `true` in the `e` parameter, the socket can be reused.\n  syntax:\n    content: public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);\n    parameters:\n    - id: e\n      type: System.Net.Sockets.SocketAsyncEventArgs\n      description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.\n    return:\n      type: System.Boolean\n      description: \"Returns `true` if the I/O operation is pending. The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \\n  \\n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.\"\n  overload: System.Net.Sockets.Socket.DisconnectAsync*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>e</code> parameter cannot be null.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows XP or later is required for this method.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Dispose\n  commentId: M:System.Net.Sockets.Socket.Dispose\n  id: Dispose\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Dispose()\n  nameWithType: Socket.Dispose()\n  fullName: Socket.Dispose()\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Releases all resources used by the current instance of the <xref href=\"System.Net.Sockets.Socket\"></xref> class.\n  remarks: \"Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>. The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state. After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.  \\n  \\n For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  \\n  \\n> [!NOTE]\\n>  Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.\"\n  syntax:\n    content: public void Dispose ();\n    parameters: []\n  overload: System.Net.Sockets.Socket.Dispose*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Dispose(System.Boolean)\n  commentId: M:System.Net.Sockets.Socket.Dispose(System.Boolean)\n  id: Dispose(System.Boolean)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Dispose(Boolean)\n  nameWithType: Socket.Dispose(Boolean)\n  fullName: Socket.Dispose(Boolean)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Releases the unmanaged resources used by the <xref href=\"System.Net.Sockets.Socket\"></xref>, and optionally disposes of the managed resources.\n  remarks: \"This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method. `Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`. <xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.  \\n  \\n When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references. This method invokes the `Dispose()` method of each referenced object.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  syntax:\n    content: protected virtual void Dispose (bool disposing);\n    parameters:\n    - id: disposing\n      type: System.Boolean\n      description: '`true` to release both managed and unmanaged resources; `false` to releases only unmanaged resources.'\n  overload: System.Net.Sockets.Socket.Dispose*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.DontFragment\n  commentId: P:System.Net.Sockets.Socket.DontFragment\n  id: DontFragment\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: DontFragment\n  nameWithType: Socket.DontFragment\n  fullName: Socket.DontFragment\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> allows Internet Protocol (IP) datagrams to be fragmented.\n  remarks: \"Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium. Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only). If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.  \\n  \\n Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.\"\n  example:\n  - \"The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.DontFragment%2A> property.  \\n  \\n [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]\\n [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]\"\n  syntax:\n    content: public bool DontFragment { get; set; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> allows datagram fragmentation; otherwise, `false`. The default is `true`.'\n  overload: System.Net.Sockets.Socket.DontFragment*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: This property can be set only for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.DualMode\n  commentId: P:System.Net.Sockets.Socket.DualMode\n  id: DualMode\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: DualMode\n  nameWithType: Socket.DualMode\n  fullName: Socket.DualMode\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> is a dual-mode socket used for both IPv4 and IPv6.\n  syntax:\n    content: public bool DualMode { get; set; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> is a  dual-mode socket; otherwise, `false`. The default is `false`.'\n  overload: System.Net.Sockets.Socket.DualMode*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)\n  commentId: M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)\n  id: DuplicateAndClose(System.Int32)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: DuplicateAndClose(Int32)\n  nameWithType: Socket.DuplicateAndClose(Int32)\n  fullName: Socket.DuplicateAndClose(Int32)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Duplicates the socket reference for the target process, and closes the socket for this process.\n  remarks: \"The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance.  \\n  \\n If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket. This practice is strongly discouraged.  \\n  \\n If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process.\"\n  syntax:\n    content: >-\n      [System.MonoLimitation(\"We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains\")]\n\n      public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);\n    parameters:\n    - id: targetProcessId\n      type: System.Int32\n      description: The ID of the target process where a duplicate of the socket reference is created.\n    return:\n      type: System.Net.Sockets.SocketInformation\n      description: The socket reference to be passed to the target process.\n  overload: System.Net.Sockets.Socket.DuplicateAndClose*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: \"<code>targetProcessID</code> is not a valid process id.  \\n  \\n -or-  \\n  \\n Duplication of the socket reference failed.\"\n  attributes:\n  - type: System.MonoLimitation\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.EnableBroadcast\n  commentId: P:System.Net.Sockets.Socket.EnableBroadcast\n  id: EnableBroadcast\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: EnableBroadcast\n  nameWithType: Socket.EnableBroadcast\n  fullName: Socket.EnableBroadcast\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> can send or receive broadcast packets.\n  remarks: \"Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion. For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.  \\n  \\n Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.\"\n  example:\n  - \"The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> property.  \\n  \\n [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]\\n [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]\"\n  syntax:\n    content: public bool EnableBroadcast { get; set; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> allows broadcast packets; otherwise, `false`. The default is `false`.'\n  overload: System.Net.Sockets.Socket.EnableBroadcast*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: This option is valid for a datagram socket only.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)\n  commentId: M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)\n  id: EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: EndAccept(Byte[], Int32, IAsyncResult)\n  nameWithType: Socket.EndAccept(Byte[], Int32, IAsyncResult)\n  fullName: Socket.EndAccept(Byte[], Int32, IAsyncResult)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Asynchronously accepts an incoming connection attempt and creates a new <xref href=\"System.Net.Sockets.Socket\"></xref> object to handle remote host communication. This method returns a buffer that contains the initial data and the number of bytes transferred.\n  remarks: \"<xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns. It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.  \\n  \\n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt. The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.  \\n  \\n The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue. The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data. The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request. The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.  \\n  \\n [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]\\n [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]\"\n  syntax:\n    content: public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the bytes transferred.\n    - id: bytesTransferred\n      type: System.Int32\n      description: The number of bytes transferred.\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> object that stores state information for this asynchronous operation as well as any user defined data.\n    return:\n      type: System.Net.Sockets.Socket\n      description: A <xref href=\"System.Net.Sockets.Socket\"></xref> object to handle communication with the remote host.\n  overload: System.Net.Sockets.Socket.EndAccept*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows NT is required for this method.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>asyncResult</code> is empty.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>asyncResult</code> was not created by a call to <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref href=\"System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\"></xref> method was previously called.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\n  commentId: M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\n  id: EndAccept(System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: EndAccept(IAsyncResult)\n  nameWithType: Socket.EndAccept(IAsyncResult)\n  fullName: Socket.EndAccept(IAsyncResult)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Asynchronously accepts an incoming connection attempt and creates a new <xref href=\"System.Net.Sockets.Socket\"></xref> to handle remote host communication.\n  remarks: \"<xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns. It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.  \\n  \\n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.  \\n  \\n The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue. The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example ends an asynchronous request and creates a new <xref:System.Net.Sockets.Socket> to accept an incoming connection request. For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).  \\n  \\n [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]\\n [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]\\n [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]\"\n  syntax:\n    content: public System.Net.Sockets.Socket EndAccept (IAsyncResult result);\n    parameters:\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: ''\n    return:\n      type: System.Net.Sockets.Socket\n      description: A <xref href=\"System.Net.Sockets.Socket\"></xref> to handle communication with the remote host.\n  overload: System.Net.Sockets.Socket.EndAccept*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>result</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>result</code> was not created by a call to <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket. See the Remarks section for more information.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref href=\"System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\"></xref> method was previously called.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows NT is required for this method.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)\n  commentId: M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)\n  id: EndAccept(System.Byte[]@,System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: EndAccept(Byte[], IAsyncResult)\n  nameWithType: Socket.EndAccept(Byte[], IAsyncResult)\n  fullName: Socket.EndAccept(Byte[], IAsyncResult)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Asynchronously accepts an incoming connection attempt and creates a new <xref href=\"System.Net.Sockets.Socket\"></xref> object to handle remote host communication. This method returns a buffer that contains the initial data transferred.\n  remarks: \"<xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.  \\n  \\n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt. The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.  \\n  \\n The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue. The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data. The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request. The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.  \\n  \\n [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]\\n [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]\"\n  syntax:\n    content: public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the bytes transferred.\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> object that stores state information for this asynchronous operation as well as any user defined data.\n    return:\n      type: System.Net.Sockets.Socket\n      description: A <xref href=\"System.Net.Sockets.Socket\"></xref> object to handle communication with the remote host.\n  overload: System.Net.Sockets.Socket.EndAccept*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows NT is required for this method.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>asyncResult</code> is empty.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>asyncResult</code> was not created by a call to <xref href=\"System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\"></xref>.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref href=\"System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\"></xref> method was previously called.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the <xref href=\"System.Net.Sockets.Socket\"></xref>\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)\n  commentId: M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)\n  id: EndConnect(System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: EndConnect(IAsyncResult)\n  nameWithType: Socket.EndConnect(IAsyncResult)\n  fullName: Socket.EndConnect(IAsyncResult)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Ends a pending asynchronous connection request.\n  remarks: \"<xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.  \\n  \\n Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.  \\n  \\n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example ends the asynchronous connection attempt. For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).  \\n  \\n [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]\\n [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]\\n [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]\"\n  syntax:\n    content: public void EndConnect (IAsyncResult result);\n    parameters:\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: ''\n  overload: System.Net.Sockets.Socket.EndConnect*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>result</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>result</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)\"></xref> method.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref href=\"System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)\"></xref> was previously called for the asynchronous connection.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)\n  commentId: M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)\n  id: EndDisconnect(System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: EndDisconnect(IAsyncResult)\n  nameWithType: Socket.EndDisconnect(IAsyncResult)\n  fullName: Socket.EndDisconnect(IAsyncResult)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Ends a pending asynchronous disconnect request.\n  remarks: \"<xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes. For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example creates a socket for asynchronous communication and sends some data to a remote host. When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity. Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request. The callback delegate calls <xref:System.Net.Sockets.Socket.EndDisconnect%2A> to end the asynchronous request. When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.  \\n  \\n [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]\\n [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]\"\n  syntax:\n    content: public void EndDisconnect (IAsyncResult asyncResult);\n    parameters:\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> object that stores state information and any user-defined data for this asynchronous operation.\n  overload: System.Net.Sockets.Socket.EndDisconnect*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operating system is Windows 2000 or earlier, and this method requires Windows XP.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>asyncResult</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)\"></xref> method.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref href=\"System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)\"></xref> was previously called for the asynchronous connection.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.Net.WebException\n    commentId: T:System.Net.WebException\n    description: The disconnect request has timed out.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\n  commentId: M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\n  id: EndReceive(System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: EndReceive(IAsyncResult)\n  nameWithType: Socket.EndReceive(IAsyncResult)\n  fullName: Socket.EndReceive(IAsyncResult)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Ends a pending asynchronous read.\n  remarks: \"The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.  \\n  \\n Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.  \\n  \\n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method. Extract the receiving <xref:System.Net.Sockets.Socket> from this state object. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.  \\n  \\n The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer. If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.  \\n  \\n To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.  \\n  \\n To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example ends a pending asynchronous read. For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](~/docs/framework/network-programming/socket-code-examples.md).  \\n  \\n [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]\\n [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]\\n [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]\"\n  syntax:\n    content: public int EndReceive (IAsyncResult result);\n    parameters:\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: ''\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.EndReceive*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>result</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>result</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"></xref> method.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> was previously called for the asynchronous read.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)\n  commentId: M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)\n  id: EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: EndReceive(IAsyncResult, SocketError)\n  nameWithType: Socket.EndReceive(IAsyncResult, SocketError)\n  fullName: Socket.EndReceive(IAsyncResult, SocketError)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Ends a pending asynchronous read.\n  remarks: \"The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.  \\n  \\n Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.  \\n  \\n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method. Extract the receiving <xref:System.Net.Sockets.Socket> from this state object. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A>method to successfully complete the read operation and return the number of bytes read.  \\n  \\n The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer. If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.  \\n  \\n To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  syntax:\n    content: public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);\n    parameters:\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that stores state information and any user defined data for this asynchronous operation.\n    - id: errorCode\n      type: System.Net.Sockets.SocketError\n      description: A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.EndReceive*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>asyncResult</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"></xref> method.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref href=\"System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\"></xref> was previously called for the asynchronous read.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\n  commentId: M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\n  id: EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: EndReceiveFrom(IAsyncResult, EndPoint)\n  nameWithType: Socket.EndReceiveFrom(IAsyncResult, EndPoint)\n  fullName: Socket.EndReceiveFrom(IAsyncResult, EndPoint)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Ends a pending asynchronous read from a specific endpoint.\n  remarks: \"The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.  \\n  \\n Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after<xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.  \\n  \\n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. Extract the receiving <xref:System.Net.Sockets.Socket> from this state object. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.  \\n  \\n The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer. If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes. To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object. To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>. Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> method to obtain the port number.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example ends a pending asynchronous read from a specific <xref:System.Net.EndPoint>.  \\n  \\n [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]\\n [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]\\n [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]\"\n  syntax:\n    content: public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);\n    parameters:\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: ''\n    - id: endPoint\n      type: System.Net.EndPoint\n      description: ''\n    return:\n      type: System.Int32\n      description: If successful, the number of bytes received. If unsuccessful, returns 0.\n  overload: System.Net.Sockets.Socket.EndReceiveFrom*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>asyncResult</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\"></xref> method.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref href=\"System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\"></xref> was previously called for the asynchronous read.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\n  commentId: M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\n  id: EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: EndReceiveMessageFrom(IAsyncResult, SocketFlags, EndPoint, IPPacketInformation)\n  nameWithType: Socket.EndReceiveMessageFrom(IAsyncResult, SocketFlags, EndPoint, IPPacketInformation)\n  fullName: Socket.EndReceiveMessageFrom(IAsyncResult, SocketFlags, EndPoint, IPPacketInformation)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Ends a pending asynchronous read from a specific endpoint. This method also reveals more information about the packet than <xref href=\"System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\"></xref>.\n  remarks: \"If the operation has not completed, this method blocks until it does.  \\n  \\n To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.  \\n  \\n Examine `ipPacketInformation` if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.\"\n  syntax:\n    content: >-\n      [System.MonoTODO]\n\n      public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);\n    parameters:\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that stores state information and any user defined data for this asynchronous operation.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values for the received packet.\n    - id: endPoint\n      type: System.Net.EndPoint\n      description: The source <xref href=\"System.Net.EndPoint\"></xref>.\n    - id: ipPacketInformation\n      type: System.Net.Sockets.IPPacketInformation\n      description: The <xref href=\"System.Net.IPAddress\"></xref> and interface of the received packet.\n    return:\n      type: System.Int32\n      description: If successful, the number of bytes received. If unsuccessful, returns 0.\n  overload: System.Net.Sockets.Socket.EndReceiveMessageFrom*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>asyncResult</code> is `null`  \\n  \\n -or-  \\n  \\n <code>endPoint</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\"></xref> method.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref href=\"System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\"></xref> was previously called for the asynchronous read.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  attributes:\n  - type: System.MonoTODO\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.EndSend(System.IAsyncResult)\n  commentId: M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)\n  id: EndSend(System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: EndSend(IAsyncResult)\n  nameWithType: Socket.EndSend(IAsyncResult)\n  fullName: Socket.EndSend(IAsyncResult)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Ends a pending asynchronous send.\n  remarks: \"<xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.  \\n  \\n Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.  \\n  \\n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.  \\n  \\n If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent. If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.  \\n  \\n There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \\n  \\n> [!NOTE]\\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example ends a pending asynchronous send.  \\n  \\n [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]\\n [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]\\n [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]\"\n  syntax:\n    content: public int EndSend (IAsyncResult result);\n    parameters:\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: ''\n    return:\n      type: System.Int32\n      description: If successful, the number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>; otherwise, an invalid <xref href=\"System.Net.Sockets.Socket\"></xref> error.\n  overload: System.Net.Sockets.Socket.EndSend*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>result</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>result</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"></xref> method.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref href=\"System.Net.Sockets.Socket.EndSend(System.IAsyncResult)\"></xref> was previously called for the asynchronous send.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)\n  commentId: M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)\n  id: EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: EndSend(IAsyncResult, SocketError)\n  nameWithType: Socket.EndSend(IAsyncResult, SocketError)\n  fullName: Socket.EndSend(IAsyncResult, SocketError)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Ends a pending asynchronous send.\n  remarks: \"<xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.  \\n  \\n Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.  \\n  \\n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.  \\n  \\n If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent. If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.  \\n  \\n There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  All I/O initiated by a given thread is canceled when that thread exits. A pending asynchronous operation can fail if the thread exits before the operation completes.  \\n  \\n> [!NOTE]\\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  syntax:\n    content: public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);\n    parameters:\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> that stores state information for this asynchronous operation.\n    - id: errorCode\n      type: System.Net.Sockets.SocketError\n      description: A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.\n    return:\n      type: System.Int32\n      description: If successful, the number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>; otherwise, an invalid <xref href=\"System.Net.Sockets.Socket\"></xref> error.\n  overload: System.Net.Sockets.Socket.EndSend*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>asyncResult</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\"></xref> method.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref href=\"System.Net.Sockets.Socket.EndSend(System.IAsyncResult)\"></xref> was previously called for the asynchronous send.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)\n  commentId: M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)\n  id: EndSendFile(System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: EndSendFile(IAsyncResult)\n  nameWithType: Socket.EndSendFile(IAsyncResult)\n  fullName: Socket.EndSendFile(IAsyncResult)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Ends a pending asynchronous send of a file.\n  remarks: \"<xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.  \\n  \\n Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns. The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.  \\n  \\n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.  \\n  \\n If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example creates and connects a socket for asynchronous communication and begins sending the file \\\"text.txt\\\" asynchronously to the remote host. The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.  \\n  \\n [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]\\n [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]\"\n  syntax:\n    content: public void EndSendFile (IAsyncResult asyncResult);\n    parameters:\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: An <xref href=\"System.IAsyncResult\"></xref> object that stores state information for this asynchronous operation.\n  overload: System.Net.Sockets.Socket.EndSendFile*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows NT is required for this method.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>asyncResult</code> is empty.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>asyncResult</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)\"></xref> method.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref href=\"System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)\"></xref> was previously called for the asynchronous <xref href=\"System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)\"></xref>.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket. See remarks section below.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)\n  commentId: M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)\n  id: EndSendTo(System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: EndSendTo(IAsyncResult)\n  nameWithType: Socket.EndSendTo(IAsyncResult)\n  fullName: Socket.EndSendTo(IAsyncResult)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Ends a pending asynchronous send to a specific location.\n  remarks: \"<xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.  \\n  \\n Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate. This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns. The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.  \\n  \\n Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>. After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.  \\n  \\n If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent. If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example ends an asynchronous send to a specific location.  \\n  \\n [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]\\n [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]\\n [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]\"\n  syntax:\n    content: public int EndSendTo (IAsyncResult result);\n    parameters:\n    - id: asyncResult\n      type: System.IAsyncResult\n      description: ''\n    return:\n      type: System.Int32\n      description: If successful, the number of bytes sent; otherwise, an invalid <xref href=\"System.Net.Sockets.Socket\"></xref> error.\n  overload: System.Net.Sockets.Socket.EndSendTo*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>result</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>result</code> was not returned by a call to the <xref href=\"System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)\"></xref> method.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref href=\"System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)\"></xref> was previously called for the asynchronous send.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.ExclusiveAddressUse\n  commentId: P:System.Net.Sockets.Socket.ExclusiveAddressUse\n  id: ExclusiveAddressUse\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: ExclusiveAddressUse\n  nameWithType: Socket.ExclusiveAddressUse\n  fullName: Socket.ExclusiveAddressUse\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> allows only one process to bind to a port.\n  remarks: \"If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port. If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.  \\n  \\n If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `true`, the first use of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to that port will fail until the original bound socket is destroyed.  \\n  \\n This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown.\"\n  example:\n  - \"The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> property.  \\n  \\n [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]\\n [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]\"\n  syntax:\n    content: public bool ExclusiveAddressUse { get; set; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> allows only one socket to bind to a specific port; otherwise, `false`. The default is `true` for Windows Server 2003 and Windows XP Service Pack 2, and `false` for all other versions.'\n  overload: System.Net.Sockets.Socket.ExclusiveAddressUse*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <xref href=\"System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\"></xref> has been called for this <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Finalize\n  commentId: M:System.Net.Sockets.Socket.Finalize\n  id: Finalize\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Finalize()\n  nameWithType: Socket.Finalize()\n  fullName: Socket.Finalize()\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Frees resources used by the <xref href=\"System.Net.Sockets.Socket\"></xref> class.\n  remarks: The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>.\n  syntax:\n    content: ~Socket ();\n    parameters: []\n  overload: System.Net.Sockets.Socket.Finalize*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\n  commentId: M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\n  id: GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: GetSocketOption(SocketOptionLevel, SocketOptionName, Int32)\n  nameWithType: Socket.GetSocketOption(SocketOptionLevel, SocketOptionName, Int32)\n  fullName: Socket.GetSocketOption(SocketOptionLevel, SocketOptionName, Int32)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Returns the value of the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option in an array.\n  remarks: \"The `optionLength` parameter sets the maximum size of the returned byte array. If the option value requires fewer bytes, the array will contain only that many bytes. If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>. Use this overload for any sockets that are represented by Boolean values or integers.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.  \\n  \\n [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]\\n [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]\\n [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]\"\n  syntax:\n    content: public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);\n    parameters:\n    - id: optionLevel\n      type: System.Net.Sockets.SocketOptionLevel\n      description: One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values.\n    - id: optionName\n      type: System.Net.Sockets.SocketOptionName\n      description: One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values.\n    - id: optionLength\n      type: System.Int32\n      description: The length, in bytes, of the expected return value.\n    return:\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the value of the socket option.\n  overload: System.Net.Sockets.Socket.GetSocketOption*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: \"An error occurred when attempting to access the socket.  \\n  \\n \\\\- or -  \\n  \\n In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes. You can change the per socket buffer space by calling <xref href=\\\"System.Net.Sockets.Socket.SetSocketOption*\\\"></xref>.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])\n  commentId: M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])\n  id: GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: GetSocketOption(SocketOptionLevel, SocketOptionName, Byte[])\n  nameWithType: Socket.GetSocketOption(SocketOptionLevel, SocketOptionName, Byte[])\n  fullName: Socket.GetSocketOption(SocketOptionLevel, SocketOptionName, Byte[])\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Returns the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option setting, represented as a byte array.\n  remarks: \"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option.  \\n  \\n When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. Use this overload for any sockets that are represented by Boolean values or integers.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.  \\n  \\n [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]\\n [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]\\n [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]\"\n  syntax:\n    content: public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);\n    parameters:\n    - id: optionLevel\n      type: System.Net.Sockets.SocketOptionLevel\n      description: One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values.\n    - id: optionName\n      type: System.Net.Sockets.SocketOptionName\n      description: One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values.\n    - id: optionValue\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is to receive the option setting.\n  overload: System.Net.Sockets.Socket.GetSocketOption*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: \"An error occurred when attempting to access the socket.  \\n  \\n \\\\- or -  \\n  \\n In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes. You can change the per socket buffer space by calling <xref href=\\\"System.Net.Sockets.Socket.SetSocketOption*\\\"></xref>.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)\n  commentId: M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)\n  id: GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: GetSocketOption(SocketOptionLevel, SocketOptionName)\n  nameWithType: Socket.GetSocketOption(SocketOptionLevel, SocketOptionName)\n  fullName: Socket.GetSocketOption(SocketOptionLevel, SocketOptionName)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Returns the value of a specified <xref href=\"System.Net.Sockets.Socket\"></xref> option, represented as an object.\n  remarks: \"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options. For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter. For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>. If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.  \\n  \\n [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]\\n [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]\\n [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]\"\n  syntax:\n    content: public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);\n    parameters:\n    - id: optionLevel\n      type: System.Net.Sockets.SocketOptionLevel\n      description: One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values.\n    - id: optionName\n      type: System.Net.Sockets.SocketOptionName\n      description: One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values.\n    return:\n      type: System.Object\n      description: An object that represents the value of the option. When the <code>optionName</code> parameter is set to <xref href=\"System.Net.Sockets.SocketOptionName.Linger\"></xref> the return value is an instance of the <xref href=\"System.Net.Sockets.LingerOption\"></xref> class. When <code>optionName</code> is set to <xref href=\"System.Net.Sockets.SocketOptionName.AddMembership\"></xref> or <xref href=\"System.Net.Sockets.SocketOptionName.DropMembership\"></xref>, the return value is an instance of the <xref href=\"System.Net.Sockets.MulticastOption\"></xref> class. When <code>optionName</code> is any other value, the return value is an integer.\n  overload: System.Net.Sockets.Socket.GetSocketOption*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: \"An error occurred when attempting to access the socket.  \\n  \\n -or-  \\n  \\n <code>optionName</code> was set to the unsupported value <xref href=\\\"System.Net.Sockets.SocketOptionName.MaxConnections\\\"></xref>.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Handle\n  commentId: P:System.Net.Sockets.Socket.Handle\n  id: Handle\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Handle\n  nameWithType: Socket.Handle\n  fullName: Socket.Handle\n  type: Property\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Gets the operating system handle for the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  syntax:\n    content: public IntPtr Handle { get; }\n    return:\n      type: System.IntPtr\n      description: An <xref href=\"System.IntPtr\"></xref> that represents the operating system handle for the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  overload: System.Net.Sockets.Socket.Handle*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])\n  commentId: M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])\n  id: IOControl(System.Int32,System.Byte[],System.Byte[])\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: IOControl(Int32, Byte[], Byte[])\n  nameWithType: Socket.IOControl(Int32, Byte[], Byte[])\n  fullName: Socket.IOControl(Int32, Byte[], Byte[])\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sets low-level operating modes for the <xref href=\"System.Net.Sockets.Socket\"></xref> using numerical control codes.\n  remarks: \"The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class. For more information, see the WSAIoctl documentation in the MSDN library.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example compares the results of FIONREAD and the Available property.  \\n  \\n [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]\\n [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]\"\n  syntax:\n    content: public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);\n    parameters:\n    - id: ioControlCode\n      type: System.Int32\n      description: An <xref href=\"System.Int32\"></xref> value that specifies the control code of the operation to perform.\n    - id: optionInValue\n      type: System.Byte[]\n      description: A <xref href=\"System.Byte\"></xref> array that contains the input data required by the operation.\n    - id: optionOutValue\n      type: System.Byte[]\n      description: A <xref href=\"System.Byte\"></xref> array that contains the output data returned by the operation.\n    return:\n      type: System.Int32\n      description: The number of bytes in the <code>optionOutValue</code> parameter.\n  overload: System.Net.Sockets.Socket.IOControl*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: An attempt was made to change the blocking mode without using the <xref href=\"System.Net.Sockets.Socket.Blocking\"></xref> property.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller in the call stack does not have the required permissions.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])\n  commentId: M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])\n  id: IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: IOControl(IOControlCode, Byte[], Byte[])\n  nameWithType: Socket.IOControl(IOControlCode, Byte[], Byte[])\n  fullName: Socket.IOControl(IOControlCode, Byte[], Byte[])\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sets low-level operating modes for the <xref href=\"System.Net.Sockets.Socket\"></xref> using the <xref href=\"System.Net.Sockets.IOControlCode\"></xref> enumeration to specify control codes.\n  remarks: \"This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class. For more, see the WSAIoctl documentation in the MSDN library.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example compares the results of calling <xref:System.Net.Sockets.Socket.IOControl%2A> with <xref:System.Net.Sockets.IOControlCode.DataToRead> and the <xref:System.Net.Sockets.Socket.Available%2A> property.  \\n  \\n [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]\\n [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]\"\n  syntax:\n    content: public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);\n    parameters:\n    - id: ioControlCode\n      type: System.Net.Sockets.IOControlCode\n      description: A <xref href=\"System.Net.Sockets.IOControlCode\"></xref> value that specifies the control code of the operation to perform.\n    - id: optionInValue\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the input data required by the operation.\n    - id: optionOutValue\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the output data returned by the operation.\n    return:\n      type: System.Int32\n      description: The number of bytes in the <code>optionOutValue</code> parameter.\n  overload: System.Net.Sockets.Socket.IOControl*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: An attempt was made to change the blocking mode without using the <xref href=\"System.Net.Sockets.Socket.Blocking\"></xref> property.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.IsBound\n  commentId: P:System.Net.Sockets.Socket.IsBound\n  id: IsBound\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: IsBound\n  nameWithType: Socket.IsBound\n  fullName: Socket.IsBound\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets a value that indicates whether the <xref href=\"System.Net.Sockets.Socket\"></xref> is bound to a specific local port.\n  remarks: A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them.\n  example:\n  - \"The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.IsBound%2A> property.  \\n  \\n [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]\\n [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]\"\n  syntax:\n    content: public bool IsBound { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> is bound to a local port; otherwise, `false`.'\n  overload: System.Net.Sockets.Socket.IsBound*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.LingerState\n  commentId: P:System.Net.Sockets.Socket.LingerState\n  id: LingerState\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: LingerState\n  nameWithType: Socket.LingerState\n  fullName: Socket.LingerState\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets or sets a value that specifies whether the <xref href=\"System.Net.Sockets.Socket\"></xref> will delay closing a socket in an attempt to send all pending data.\n  remarks: \"The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves. This property when set modifies the conditions under which the connection can be reset by Winsock. Connection resets can still occur based on the IP protocol behavior.  \\n  \\n This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent.  \\n  \\n When you call methods to send data to a peer, this data is placed in the outgoing network buffer. This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.  \\n  \\n To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance.  \\n  \\n The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property.  \\n  \\n|LingerState.Enabled|LingerState.LingerTime|Behavior|  \\n|-------------------------|----------------------------|--------------|  \\n|`false` (disabled), the default value|The time-out is not applicable, (default).|Attempts to send pending data until the default IP protocol time-out expires.|  \\n|`true` (enabled)|A nonzero time-out|Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.|  \\n|`true` (enabled)|A zero timeout.|Discards any pending data. For connection-oriented socket (TCP, for example), Winsock resets the connection.|  \\n  \\n The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection. In most cases, the time-out computed by the stack is more relevant than one defined by an application. This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.  \\n  \\n When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.\"\n  example:\n  - \"The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.LingerState%2A> property.  \\n  \\n [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]\\n [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]\"\n  syntax:\n    content: public System.Net.Sockets.LingerOption LingerState { get; set; }\n    return:\n      type: System.Net.Sockets.LingerOption\n      description: A <xref href=\"System.Net.Sockets.LingerOption\"></xref> that specifies how to linger while closing a socket.\n  overload: System.Net.Sockets.Socket.LingerState*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Listen(System.Int32)\n  commentId: M:System.Net.Sockets.Socket.Listen(System.Int32)\n  id: Listen(System.Int32)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Listen(Int32)\n  nameWithType: Socket.Listen(Int32)\n  fullName: Socket.Listen(Int32)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Places a <xref href=\"System.Net.Sockets.Socket\"></xref> in a listening state.\n  remarks: \"<xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts. The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance. To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value. <xref:System.Net.Sockets.Socket.Listen%2A> does not block.  \\n  \\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error. Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.  \\n  \\n> [!NOTE]\\n>  You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).  \\n  \\n> [!NOTE]\\n>  The backlog parameter is limited to different values depending on the Operating System. You may specify a higher value, but the backlog will be limited based on the Operating System.\"\n  example:\n  - \"The following code example uses <xref:System.Net.Sockets.Socket> to listen for incoming connections.  \\n  \\n [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]\\n [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]\"\n  syntax:\n    content: public void Listen (int backlog);\n    parameters:\n    - id: backlog\n      type: System.Int32\n      description: The maximum length of the pending connections queue.\n  overload: System.Net.Sockets.Socket.Listen*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.LocalEndPoint\n  commentId: P:System.Net.Sockets.Socket.LocalEndPoint\n  id: LocalEndPoint\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: LocalEndPoint\n  nameWithType: Socket.LocalEndPoint\n  fullName: Socket.LocalEndPoint\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets the local endpoint.\n  remarks: \"The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound. You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information. You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> method to retrieve the local port number.  \\n  \\n The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation. For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. For connectionless protocols, the first I/O operation would be any of the send or receive calls.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example retrieves and displays the local and remote endpoints.  \\n  \\n [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]\\n [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]\\n [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]\"\n  syntax:\n    content: public System.Net.EndPoint LocalEndPoint { get; }\n    return:\n      type: System.Net.EndPoint\n      description: The <xref href=\"System.Net.EndPoint\"></xref> that the <xref href=\"System.Net.Sockets.Socket\"></xref> is using for communications.\n  overload: System.Net.Sockets.Socket.LocalEndPoint*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.MulticastLoopback\n  commentId: P:System.Net.Sockets.Socket.MulticastLoopback\n  id: MulticastLoopback\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: MulticastLoopback\n  nameWithType: Socket.MulticastLoopback\n  fullName: Socket.MulticastLoopback\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.\n  remarks: \"Multicast is a scalable method for many-to-many communication on the Internet. A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.  \\n  \\n Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.\"\n  example:\n  - \"The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> property.  \\n  \\n [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]\\n [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]\"\n  syntax:\n    content: public bool MulticastLoopback { get; set; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> receives outgoing multicast packets; otherwise, `false`.'\n  overload: System.Net.Sockets.Socket.MulticastLoopback*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.NoDelay\n  commentId: P:System.Net.Sockets.Socket.NoDelay\n  id: NoDelay\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: NoDelay\n  nameWithType: Socket.NoDelay\n  fullName: Socket.NoDelay\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets or sets a <xref href=\"System.Boolean\"></xref> value that specifies whether the stream <xref href=\"System.Net.Sockets.Socket\"></xref> is using the Nagle algorithm.\n  remarks: \"The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances. A TCP packet consists of 40 bytes of header plus the data being sent. When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion. The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.  \\n  \\n The majority of network applications should use the Nagle algorithm.  \\n  \\n Setting this property on a User Datagram Protocol (UDP) socket will have no effect.\"\n  example:\n  - \"The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.NoDelay%2A> property.  \\n  \\n [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]\\n [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]\"\n  syntax:\n    content: public bool NoDelay { get; set; }\n    return:\n      type: System.Boolean\n      description: '`false` if the <xref href=\"System.Net.Sockets.Socket\"></xref> uses the Nagle algorithm; otherwise, `true`. The default is `false`.'\n  overload: System.Net.Sockets.Socket.NoDelay*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.OSSupportsIPv4\n  commentId: P:System.Net.Sockets.Socket.OSSupportsIPv4\n  id: OSSupportsIPv4\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: OSSupportsIPv4\n  nameWithType: Socket.OSSupportsIPv4\n  fullName: Socket.OSSupportsIPv4\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).\n  remarks: The operating system may support both IPv4 and IPv6 protocols.\n  syntax:\n    content: public static bool OSSupportsIPv4 { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the operating system and network adaptors support the IPv4 protocol; otherwise, `false`.'\n  overload: System.Net.Sockets.Socket.OSSupportsIPv4*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.OSSupportsIPv6\n  commentId: P:System.Net.Sockets.Socket.OSSupportsIPv6\n  id: OSSupportsIPv6\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: OSSupportsIPv6\n  nameWithType: Socket.OSSupportsIPv6\n  fullName: Socket.OSSupportsIPv6\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).\n  remarks: The operating system may support both IPv4 and IPv6 protocols.\n  syntax:\n    content: public static bool OSSupportsIPv6 { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the operating system and network adaptors support the IPv6 protocol; otherwise, `false`.'\n  overload: System.Net.Sockets.Socket.OSSupportsIPv6*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)\n  commentId: M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)\n  id: Poll(System.Int32,System.Net.Sockets.SelectMode)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Poll(Int32, SelectMode)\n  nameWithType: Socket.Poll(Int32, SelectMode)\n  fullName: Socket.Poll(Int32, SelectMode)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Determines the status of the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: \"The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>. Specify <xref:System.Net.Sockets.SelectMode?displayProperty=fullName> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable. Specify <xref:System.Net.Sockets.SelectMode?displayProperty=fullName> to determine if the <xref:System.Net.Sockets.Socket> is writable. Use <xref:System.Net.Sockets.SelectMode?displayProperty=fullName> to detect an error condition. <xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses. Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response. If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully. You must attempt to send or receive data to detect these kinds of errors.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example creates a socket, connects to a server, and uses <xref:System.Net.Sockets.Socket.Poll%2A> to check the status of the socket.  \\n  \\n [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]\\n [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]\\n [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]\"\n  syntax:\n    content: public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);\n    parameters:\n    - id: microSeconds\n      type: System.Int32\n      description: The time to wait for a response, in microseconds.\n    - id: mode\n      type: System.Net.Sockets.SelectMode\n      description: One of the <xref href=\"System.Net.Sockets.SelectMode\"></xref> values.\n    return:\n      type: System.Boolean\n      description: \"The status of the <xref href=\\\"System.Net.Sockets.Socket\\\"></xref> based on the polling mode value passed in the <code>mode</code> parameter.  \\n  \\n <table><thead><tr><th> Mode  \\n  \\n </th><th> Return Value  \\n  \\n </th></tr></thead><tbody><tr><td><xref href=\\\"System.Net.Sockets.SelectMode.SelectRead\\\"></xref></td><td>`true` if <xref href=\\\"System.Net.Sockets.Socket.Listen(System.Int32)\\\"></xref> has been called and a connection is pending;  \\n  \\n -or-  \\n  \\n `true` if data is available for reading;  \\n  \\n -or-  \\n  \\n `true` if the connection has been closed, reset, or terminated;  \\n  \\n otherwise, returns `false`.  \\n  \\n </td></tr><tr><td><xref href=\\\"System.Net.Sockets.SelectMode.SelectWrite\\\"></xref></td><td>`true`, if processing a <xref href=\\\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\\\"></xref>, and the connection has succeeded;  \\n  \\n -or-  \\n  \\n `true` if data can be sent;  \\n  \\n otherwise, returns `false`.  \\n  \\n </td></tr><tr><td><xref href=\\\"System.Net.Sockets.SelectMode.SelectError\\\"></xref></td><td>`true` if processing a <xref href=\\\"System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\\\"></xref> that does not block, and the connection has failed;  \\n  \\n -or-  \\n  \\n `true` if <xref href=\\\"System.Net.Sockets.SocketOptionName.OutOfBandInline\\\"></xref> is not set and out-of-band data is available;  \\n  \\n otherwise, returns `false`.  \\n  \\n </td></tr></tbody></table>\"\n  overload: System.Net.Sockets.Socket.Poll*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The <code>mode</code> parameter is not one of the <xref href=\"System.Net.Sockets.SelectMode\"></xref> values.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket. See remarks below.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.ProtocolType\n  commentId: P:System.Net.Sockets.Socket.ProtocolType\n  id: ProtocolType\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: ProtocolType\n  nameWithType: Socket.ProtocolType\n  fullName: Socket.ProtocolType\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets the protocol type of the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>.\n  example:\n  - \"The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.  \\n  \\n [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]\\n [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]\\n [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]\"\n  syntax:\n    content: public System.Net.Sockets.ProtocolType ProtocolType { get; }\n    return:\n      type: System.Net.Sockets.ProtocolType\n      description: One of the <xref href=\"System.Net.Sockets.ProtocolType\"></xref> values.\n  overload: System.Net.Sockets.Socket.ProtocolType*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  id: Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Receive(Byte[], Int32, Int32, SocketFlags, SocketError)\n  nameWithType: Socket.Receive(Byte[], Int32, Int32, SocketFlags, SocketError)\n  fullName: Socket.Receive(Byte[], Int32, Int32, SocketFlags, SocketError)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into a receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.\n  remarks: \"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.  \\n  \\n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \\n  \\n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. An error occurred when attempting to access the socket. See Remarks below. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \\n  \\n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \\n  \\n If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  syntax:\n    content: public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.\n    - id: offset\n      type: System.Int32\n      description: The position in the <code>buffer</code> parameter to store the received data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to receive.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: errorCode\n      type: System.Net.Sockets.SocketError\n      description: A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.Receive*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>offset</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>offset</code> is greater than the length of <code>buffer</code>.  \\n  \\n -or-  \\n  \\n <code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: \"<code>socketFlags</code> is not a valid combination of values.  \\n  \\n -or-  \\n  \\n The <xref href=\\\"System.Net.Sockets.Socket.LocalEndPoint\\\"></xref> property is not set.  \\n  \\n -or-  \\n  \\n An operating system error occurs while accessing the <xref href=\\\"System.Net.Sockets.Socket\\\"></xref>.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller in the call stack does not have the required permissions.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)\n  commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)\n  id: Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Receive(Byte[], Int32, Int32, SocketFlags)\n  nameWithType: Socket.Receive(Byte[], Int32, Int32, SocketFlags)\n  fullName: Socket.Receive(Byte[], Int32, Int32, SocketFlags)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Receives the specified number of bytes from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into the specified offset position of the receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.\n  remarks: \"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.  \\n  \\n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \\n  \\n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. An error occurred when attempting to access the socket. See Remarks below. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \\n  \\n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \\n  \\n If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <xref:System.Net.Sockets.Socket>.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]\\n [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]\\n [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]\"\n  syntax:\n    content: public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data.\n    - id: offset\n      type: System.Int32\n      description: The location in <code>buffer</code> to store the received data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to receive.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.Receive*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>offset</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>offset</code> is greater than the length of <code>buffer</code>.  \\n  \\n -or-  \\n  \\n <code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: \"<code>socketFlags</code> is not a valid combination of values.  \\n  \\n -or-  \\n  \\n The <xref href=\\\"System.Net.Sockets.Socket.LocalEndPoint\\\"></xref> property was not set.  \\n  \\n -or-  \\n  \\n An operating system error occurs while accessing the <xref href=\\\"System.Net.Sockets.Socket\\\"></xref>.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller in the call stack does not have the required permissions.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  commentId: M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  id: Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Receive(IList<ArraySegment<Byte>>, SocketFlags, SocketError)\n  nameWithType: Socket.Receive(IList<ArraySegment<Byte>>, SocketFlags, SocketError)\n  fullName: Socket.Receive(IList<ArraySegment<Byte>>, SocketFlags, SocketError)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into the list of receive buffers, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.\n  remarks: \"This method reads data into the `buffers` parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.  \\n  \\n This overload requires you to provide one or more receive buffers. The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.  \\n  \\n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \\n  \\n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \\n  \\n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \\n  \\n If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      public int Receive (System.Collections.Generic.IList<ArraySegment<byte>> buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);\n    parameters:\n    - id: buffers\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the received data.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: errorCode\n      type: System.Net.Sockets.SocketError\n      description: A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.Receive*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>buffers</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>buffers</code>.Count is zero.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred while attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  attributes:\n  - type: System.CLSCompliantAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  altCompliant: System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\n  commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\n  id: Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Receive(Byte[], Int32, SocketFlags)\n  nameWithType: Socket.Receive(Byte[], Int32, SocketFlags)\n  fullName: Socket.Receive(Byte[], Int32, SocketFlags)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Receives the specified number of bytes of data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into a receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.\n  remarks: \"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.  \\n  \\n This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>.  \\n  \\n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \\n  \\n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.  \\n  \\n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \\n  \\n If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following receives the data found into `buffer`, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.  \\n  \\n [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]\\n [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]\\n [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]\"\n  syntax:\n    content: public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to receive.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.Receive*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>size</code> exceeds the size of <code>buffer</code>.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller in the call stack does not have the required permissions.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  commentId: M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  id: Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Receive(IList<ArraySegment<Byte>>)\n  nameWithType: Socket.Receive(IList<ArraySegment<Byte>>)\n  fullName: Socket.Receive(IList<ArraySegment<Byte>>)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into the list of receive buffers.\n  remarks: \"This method reads data into the buffers parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.  \\n  \\n This overload requires you to provide one or more receive buffers.  \\n  \\n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \\n  \\n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \\n  \\n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \\n  \\n If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n **Note** This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  syntax:\n    content: public int Receive (System.Collections.Generic.IList<ArraySegment<byte>> buffers);\n    parameters:\n    - id: buffers\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the received data.\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.Receive*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>buffer</code> parameter is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred while attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  altCompliant: System.Net.Sockets.Socket.Receive(System.Byte[])\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\n  commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\n  id: Receive(System.Byte[],System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Receive(Byte[], SocketFlags)\n  nameWithType: Socket.Receive(Byte[], SocketFlags)\n  fullName: Socket.Receive(Byte[], SocketFlags)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into a receive buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.\n  remarks: \"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.  \\n  \\n This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>. The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.  \\n  \\n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \\n  \\n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A>method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.  \\n  \\n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \\n  \\n If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example specifies a data buffer, and <xref:System.Net.Sockets.SocketFlags> for receiving data on a connected <xref:System.Net.Sockets.Socket>.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]\\n [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]\\n [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]\"\n  syntax:\n    content: public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.Receive*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller in the call stack does not have the required permissions.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Receive(System.Byte[])\n  commentId: M:System.Net.Sockets.Socket.Receive(System.Byte[])\n  id: Receive(System.Byte[])\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Receive(Byte[])\n  nameWithType: Socket.Receive(Byte[])\n  fullName: Socket.Receive(Byte[])\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into a receive buffer.\n  remarks: \"The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read. You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.  \\n  \\n This overload only requires you to provide a receive buffer. The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.  \\n  \\n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \\n  \\n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \\n  \\n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \\n  \\n If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example receives data on a connected <xref:System.Net.Sockets.Socket>.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]\\n [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]\\n [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]\"\n  syntax:\n    content: public int Receive (byte[] buffer);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.Receive*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller in the call stack does not have the required permissions.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\n  commentId: M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\n  id: Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Receive(IList<ArraySegment<Byte>>, SocketFlags)\n  nameWithType: Socket.Receive(IList<ArraySegment<Byte>>, SocketFlags)\n  fullName: Socket.Receive(IList<ArraySegment<Byte>>, SocketFlags)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Receives data from a bound <xref href=\"System.Net.Sockets.Socket\"></xref> into the list of receive buffers, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.\n  remarks: \"This method reads data into the `buffers` parameter and returns the number of bytes successfully read. You can call from both connection-oriented and connectionless sockets.  \\n  \\n This overload requires you to provide one or more receive buffers. The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.  \\n  \\n If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>. The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.  \\n  \\n If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \\n  \\n If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.  \\n  \\n If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method. If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example demonstrates how to receive data on a connected <xref:System.Net.Sockets.Socket>.  \\n  \\n [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]\\n [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      public int Receive (System.Collections.Generic.IList<ArraySegment<byte>> buffers, System.Net.Sockets.SocketFlags socketFlags);\n    parameters:\n    - id: buffers\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the received data.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.Receive*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>buffers</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>buffers</code>.Count is zero.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred while attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  attributes:\n  - type: System.CLSCompliantAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  altCompliant: System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  commentId: M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  id: ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: ReceiveAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.ReceiveAsync(SocketAsyncEventArgs)\n  fullName: Socket.ReceiveAsync(SocketAsyncEventArgs)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Begins an asynchronous request to receive data from a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object.\n  remarks: \"The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data. The socket's local address must be known.  \\n  \\n For bound connectionless sockets, this function restricts the addresses from which received messages are accepted. The function only returns messages from the remote address specified in the connection. Messages from other addresses are silently discarded.  \\n  \\n The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request. For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=fullName>.  \\n  \\n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \\n  \\n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \\n  \\n For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.  \\n  \\n For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter. If the message is larger than the buffer, the buffer is filled with the first part of the message.  \\n  \\n For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented. For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read. For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure. In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.\"\n  syntax:\n    content: public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);\n    parameters:\n    - id: e\n      type: System.Net.Sockets.SocketAsyncEventArgs\n      description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.\n    return:\n      type: System.Boolean\n      description: \"Returns `true` if the I/O operation is pending. The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \\n  \\n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.\"\n  overload: System.Net.Sockets.Socket.ReceiveAsync*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: An argument was invalid. The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\"></xref> or <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> properties on the <code>e</code> parameter must reference valid buffers. One or the other of these properties may be set, but not both at the same time.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows XP or later is required for this method.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.ReceiveBufferSize\n  commentId: P:System.Net.Sockets.Socket.ReceiveBufferSize\n  id: ReceiveBufferSize\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: ReceiveBufferSize\n  nameWithType: Socket.ReceiveBufferSize\n  fullName: Socket.ReceiveBufferSize\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets or sets a value that specifies the size of the receive buffer of the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties. Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)\n  example:\n  - \"The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> property.  \\n  \\n [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]\\n [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]\"\n  syntax:\n    content: public int ReceiveBufferSize { get; set; }\n    return:\n      type: System.Int32\n      description: An <xref href=\"System.Int32\"></xref> that contains the size, in bytes, of the receive buffer. The default is 8192.\n  overload: System.Net.Sockets.Socket.ReceiveBufferSize*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The value specified for a set operation is less than 0.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)\n  commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)\n  id: ReceiveFrom(System.Byte[],System.Net.EndPoint@)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: ReceiveFrom(Byte[], EndPoint)\n  nameWithType: Socket.ReceiveFrom(Byte[], EndPoint)\n  fullName: Socket.ReceiveFrom(Byte[], EndPoint)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Receives a datagram into the data buffer and stores the endpoint.\n  remarks: \"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.  \\n  \\n This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host. The buffer offset defaults to 0. The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>.  \\n  \\n> [!NOTE]\\n>  Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.  \\n  \\n If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \\n  \\n Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.  \\n  \\n With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example receives a connectionless datagram from a remote host.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]\\n [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]\\n [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]\"\n  syntax:\n    content: public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data.\n    - id: remoteEP\n      type: System.Net.EndPoint\n      description: An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server.\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.ReceiveFrom*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>buffer</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>remoteEP</code> is `null`.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller in the call stack does not have the required permissions.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  id: ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: ReceiveFrom(Byte[], SocketFlags, EndPoint)\n  nameWithType: Socket.ReceiveFrom(Byte[], SocketFlags, EndPoint)\n  fullName: Socket.ReceiveFrom(Byte[], SocketFlags, EndPoint)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Receives a datagram into the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint.\n  remarks: \"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.  \\n  \\n This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host. The offset defaults to 0 and the size defaults to the length of the buffer parameter.  \\n  \\n> [!NOTE]\\n>  Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.  \\n  \\n If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When<xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \\n  \\n Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.  \\n  \\n With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example receives a connectionless datagram from a remote host. <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]\\n [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]\\n [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]\"\n  syntax:\n    content: public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for the received data.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: remoteEP\n      type: System.Net.EndPoint\n      description: An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server.\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.ReceiveFrom*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>buffer</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>remoteEP</code> is `null`.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller in the call stack does not have the required permissions.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  id: ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: ReceiveFrom(Byte[], Int32, SocketFlags, EndPoint)\n  nameWithType: Socket.ReceiveFrom(Byte[], Int32, SocketFlags, EndPoint)\n  fullName: Socket.ReceiveFrom(Byte[], Int32, SocketFlags, EndPoint)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Receives the specified number of bytes into the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint.\n  remarks: \"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.  \\n  \\n This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host. The buffer offset defaults to 0.  \\n  \\n With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.  \\n  \\n If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \\n  \\n Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.  \\n  \\n With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.  \\n  \\n> [!NOTE]\\n>  Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example receives a connectionless datagram from a remote host. The buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]\\n [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]\\n [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]\"\n  syntax:\n    content: public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to receive.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: remoteEP\n      type: System.Net.EndPoint\n      description: An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server.\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.ReceiveFrom*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>buffer</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>remoteEP</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of <code>buffer</code>.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: \"<code>socketFlags</code> is not a valid combination of values.  \\n  \\n -or-  \\n  \\n The <xref href=\\\"System.Net.Sockets.Socket.LocalEndPoint\\\"></xref> property was not set.  \\n  \\n -or-  \\n  \\n An operating system error occurs while accessing the <xref href=\\\"System.Net.Sockets.Socket\\\"></xref>.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller in the call stack does not have the required permissions.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  commentId: M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  id: ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: ReceiveFrom(Byte[], Int32, Int32, SocketFlags, EndPoint)\n  nameWithType: Socket.ReceiveFrom(Byte[], Int32, Int32, SocketFlags, EndPoint)\n  fullName: Socket.ReceiveFrom(Byte[], Int32, Int32, SocketFlags, EndPoint)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint.\n  remarks: \"The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent. This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.  \\n  \\n With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer. If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>. If you are using an unreliable protocol, the excess data will be lost. If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.  \\n  \\n If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available. If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>. You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading. When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.  \\n  \\n Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well. If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method. In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.  \\n  \\n With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter. If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.  \\n  \\n> [!NOTE]\\n>  Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method. If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the<xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example receives a connectionless datagram from a remote host. The offset, buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]\\n [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]\\n [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]\"\n  syntax:\n    content: public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data.\n    - id: offset\n      type: System.Int32\n      description: The position in the <code>buffer</code> parameter to store the received data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to receive.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: remoteEP\n      type: System.Net.EndPoint\n      description: An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server.\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.ReceiveFrom*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>buffer</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>remoteEP</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>offset</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>offset</code> is greater than the length of <code>buffer</code>.  \\n  \\n -or-  \\n  \\n <code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of the <code>buffer</code> minus the value of the offset parameter.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: \"<code>socketFlags</code> is not a valid combination of values.  \\n  \\n -or-  \\n  \\n The <xref href=\\\"System.Net.Sockets.Socket.LocalEndPoint\\\"></xref> property was not set.  \\n  \\n -or-  \\n  \\n An error occurred when attempting to access the socket.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  commentId: M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  id: ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: ReceiveFromAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.ReceiveFromAsync(SocketAsyncEventArgs)\n  fullName: Socket.ReceiveFromAsync(SocketAsyncEventArgs)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Begins to asynchronously receive data from a specified network device.\n  remarks: \"The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket. The socket's local address must be known.  \\n  \\n The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.  \\n  \\n The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request. For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=fullName>.  \\n  \\n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \\n  \\n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \\n  \\n For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer. The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data.  \\n  \\n For byte streamstyle sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted. The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data.\"\n  syntax:\n    content: public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);\n    parameters:\n    - id: e\n      type: System.Net.Sockets.SocketAsyncEventArgs\n      description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.\n    return:\n      type: System.Boolean\n      description: \"Returns `true` if the I/O operation is pending. The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \\n  \\n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.\"\n  overload: System.Net.Sockets.Socket.ReceiveFromAsync*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows XP or later is required for this method.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\n  commentId: M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\n  id: ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: ReceiveMessageFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, IPPacketInformation)\n  nameWithType: Socket.ReceiveMessageFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, IPPacketInformation)\n  fullName: Socket.ReceiveMessageFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, IPPacketInformation)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>, and stores the endpoint and packet information.\n  remarks: \"The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.  \\n  \\n The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket. The socket's local address must be known. This method can only be used with datagram and raw sockets. The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method. This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.  \\n  \\n For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter. The `offset` parameter determines where in the `buffer` the data is placed. The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.  \\n  \\n The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>. However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set. If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.  \\n  \\n To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.  \\n  \\n An application can examine the `ipPacketInformation` parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  syntax:\n    content: >-\n      [System.MonoTODO(\"Not implemented\")]\n\n      public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that is the storage location for received data.\n    - id: offset\n      type: System.Int32\n      description: The position in the <code>buffer</code> parameter to store the received data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to receive.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: remoteEP\n      type: System.Net.EndPoint\n      description: An <xref href=\"System.Net.EndPoint\"></xref>, passed by reference, that represents the remote server.\n    - id: ipPacketInformation\n      type: System.Net.Sockets.IPPacketInformation\n      description: An <xref href=\"System.Net.Sockets.IPPacketInformation\"></xref> holding address and interface information.\n    return:\n      type: System.Int32\n      description: The number of bytes received.\n  overload: System.Net.Sockets.Socket.ReceiveMessageFrom*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>buffer</code> is `null`.  \\n  \\n \\\\- or-  \\n  \\n <code>remoteEP</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>offset</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>offset</code> is greater than the length of <code>buffer</code>.  \\n  \\n -or-  \\n  \\n <code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of the <code>buffer</code> minus the value of the offset parameter.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: \"<code>socketFlags</code> is not a valid combination of values.  \\n  \\n -or-  \\n  \\n The <xref href=\\\"System.Net.Sockets.Socket.LocalEndPoint\\\"></xref> property was not set.  \\n  \\n -or-  \\n  \\n The .NET Framework is running on an AMD 64-bit processor.  \\n  \\n -or-  \\n  \\n An error occurred when attempting to access the socket.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The operating system is Windows 2000 or earlier, and this method requires Windows XP.\n  attributes:\n  - type: System.MonoTODO\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  commentId: M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  id: ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: ReceiveMessageFromAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.ReceiveMessageFromAsync(SocketAsyncEventArgs)\n  fullName: Socket.ReceiveMessageFromAsync(SocketAsyncEventArgs)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.SocketFlags\"></xref>, and stores the endpoint and packet information.\n  remarks: \"The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket. The socket's local address must be known. This method can only be used with datagram and raw sockets. The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method. This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.  \\n  \\n The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.  \\n  \\n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \\n  \\n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \\n  \\n For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer. The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> properties determine where in the buffer the data is placed and the amount of data.  \\n  \\n The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>. However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set. If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.  \\n  \\n To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to`true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.  \\n  \\n An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.\"\n  syntax:\n    content: >-\n      [System.MonoTODO(\"Not implemented\")]\n\n      public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);\n    parameters:\n    - id: e\n      type: System.Net.Sockets.SocketAsyncEventArgs\n      description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.\n    return:\n      type: System.Boolean\n      description: \"Returns `true` if the I/O operation is pending. The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \\n  \\n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.\"\n  overload: System.Net.Sockets.Socket.ReceiveMessageFromAsync*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows XP or later is required for this method.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  attributes:\n  - type: System.MonoTODO\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.ReceiveTimeout\n  commentId: P:System.Net.Sockets.Socket.ReceiveTimeout\n  id: ReceiveTimeout\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: ReceiveTimeout\n  nameWithType: Socket.ReceiveTimeout\n  fullName: Socket.ReceiveTimeout\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets or sets a value that specifies the amount of time after which a synchronous <xref href=\"System.Net.Sockets.Socket.Receive*\"></xref> call will time out.\n  remarks: This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only. If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.\n  example:\n  - \"The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> property.  \\n  \\n [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]\\n [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]\"\n  syntax:\n    content: public int ReceiveTimeout { get; set; }\n    return:\n      type: System.Int32\n      description: The time-out value, in milliseconds. The default value is 0, which indicates an infinite time-out period. Specifying -1 also indicates an infinite time-out period.\n  overload: System.Net.Sockets.Socket.ReceiveTimeout*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The value specified for a set operation is less than -1.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.RemoteEndPoint\n  commentId: P:System.Net.Sockets.Socket.RemoteEndPoint\n  id: RemoteEndPoint\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: RemoteEndPoint\n  nameWithType: Socket.RemoteEndPoint\n  fullName: Socket.RemoteEndPoint\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets the remote endpoint.\n  remarks: \"If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected. If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate. You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information. You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=fullName> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=fullName> method to retrieve the remote port number.  \\n  \\n The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>. If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example retrieves and displays the local and remote endpoints.  \\n  \\n [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]\\n [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]\\n [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]\"\n  syntax:\n    content: public System.Net.EndPoint RemoteEndPoint { get; }\n    return:\n      type: System.Net.EndPoint\n      description: The <xref href=\"System.Net.EndPoint\"></xref> with which the <xref href=\"System.Net.Sockets.Socket\"></xref> is communicating.\n  overload: System.Net.Sockets.Socket.RemoteEndPoint*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)\n  commentId: M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)\n  id: Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Select(IList, IList, IList, Int32)\n  nameWithType: Socket.Select(IList, IList, IList, Int32)\n  fullName: Socket.Select(IList, IList, IList, Int32)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Determines the status of one or more sockets.\n  remarks: \"<xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances. You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method. Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter. To check your sockets for writability, use the `checkWrite` parameter. For detecting error conditions, use `checkError`. After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions.  \\n  \\n If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking. If you have already accepted the connection, readability means that data is available for reading. In these cases, all receive operations will succeed without blocking. Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.  \\n  \\n <xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first. Setting `microSeconds` to -1 specifies an infinite time-out.  \\n  \\n If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully. If you already have a connection established, writability means that all send operations will succeed without blocking.  \\n  \\n If you have made a non-blocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, the `checkerror` parameter identifies sockets that have not connected successfully.  \\n  \\n> [!NOTE]\\n>  Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>.  \\n  \\n> [!NOTE]\\n>  This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully. You must attempt to send or receive data to detect these kinds of errors.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.\"\n  example:\n  - \"The following code example uses <xref:System.Net.Sockets.Socket.Select%2A> to determine which listening sockets have a connection request.  \\n  \\n [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]\\n [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]\\n [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]\"\n  syntax:\n    content: public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);\n    parameters:\n    - id: checkRead\n      type: System.Collections.IList\n      description: An <xref href=\"System.Collections.IList\"></xref> of <xref href=\"System.Net.Sockets.Socket\"></xref> instances to check for readability.\n    - id: checkWrite\n      type: System.Collections.IList\n      description: An <xref href=\"System.Collections.IList\"></xref> of <xref href=\"System.Net.Sockets.Socket\"></xref> instances to check for writability.\n    - id: checkError\n      type: System.Collections.IList\n      description: An <xref href=\"System.Collections.IList\"></xref> of <xref href=\"System.Net.Sockets.Socket\"></xref> instances to check for errors.\n    - id: microSeconds\n      type: System.Int32\n      description: The time-out value, in microseconds. A -1 value indicates an infinite time-out.\n  overload: System.Net.Sockets.Socket.Select*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"The <code>checkRead</code> parameter is `null` or empty.  \\n  \\n -and-  \\n  \\n The <code>checkWrite</code> parameter is `null` or empty  \\n  \\n -and-  \\n  \\n The <code>checkError</code> parameter is `null` or empty.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Send(System.Byte[])\n  commentId: M:System.Net.Sockets.Socket.Send(System.Byte[])\n  id: Send(System.Byte[])\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Send(Byte[])\n  nameWithType: Socket.Send(Byte[])\n  fullName: Socket.Send(Byte[])\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: \"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.  \\n  \\n This overload requires a buffer that contains the data you want to send. The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.  \\n  \\n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \\n  \\n If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \\n  \\n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]\\n [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]\\n [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]\"\n  syntax:\n    content: public int Send (byte[] buffer);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.\n    return:\n      type: System.Int32\n      description: The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  overload: System.Net.Sockets.Socket.Send*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  commentId: M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  id: Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Send(IList<ArraySegment<Byte>>)\n  nameWithType: Socket.Send(IList<ArraySegment<Byte>>)\n  fullName: Socket.Send(IList<ArraySegment<Byte>>)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends the set of buffers in the list to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: \"<xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.  \\n  \\n This overload requires at least one buffer that contains the data you want to send.  \\n  \\n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \\n  \\n If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \\n  \\n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  syntax:\n    content: public int Send (System.Collections.Generic.IList<ArraySegment<byte>> buffers);\n    parameters:\n    - id: buffers\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.\n    return:\n      type: System.Int32\n      description: The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  overload: System.Net.Sockets.Socket.Send*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffers</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>buffers</code> is empty.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket. See remarks section below.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  altCompliant: System.Net.Sockets.Socket.Send(System.Byte[])\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)\n  commentId: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)\n  id: Send(System.Byte[],System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Send(Byte[], SocketFlags)\n  nameWithType: Socket.Send(Byte[], SocketFlags)\n  fullName: Socket.Send(Byte[], SocketFlags)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.\n  remarks: \"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.  \\n  \\n This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>. The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed.  \\n  \\n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \\n  \\n If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \\n  \\n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n> [!NOTE]\\n>  You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see[Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]\\n [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]\\n [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]\"\n  syntax:\n    content: public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    return:\n      type: System.Int32\n      description: The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  overload: System.Net.Sockets.Socket.Send*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\n  commentId: M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\n  id: Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Send(IList<ArraySegment<Byte>>, SocketFlags)\n  nameWithType: Socket.Send(IList<ArraySegment<Byte>>, SocketFlags)\n  fullName: Socket.Send(IList<ArraySegment<Byte>>, SocketFlags)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends the set of buffers in the list to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.\n  remarks: \"This overload requires at least one buffer that contains the data you want to send. The <xref:System.Net.Sockets.SocketFlags> value defaults to 0. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.  \\n  \\n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \\n  \\n If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \\n  \\n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  syntax:\n    content: public int Send (System.Collections.Generic.IList<ArraySegment<byte>> buffers, System.Net.Sockets.SocketFlags socketFlags);\n    parameters:\n    - id: buffers\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    return:\n      type: System.Int32\n      description: The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  overload: System.Net.Sockets.Socket.Send*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffers</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>buffers</code> is empty.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  altCompliant: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\n  commentId: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\n  id: Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Send(Byte[], Int32, SocketFlags)\n  nameWithType: Socket.Send(Byte[], Int32, SocketFlags)\n  fullName: Socket.Send(Byte[], Int32, SocketFlags)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends the specified number of bytes of data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.\n  remarks: \"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.  \\n  \\n This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \\n  \\n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \\n  \\n If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \\n  \\n With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n> [!NOTE]\\n>  You must ensure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example sends the data found in buffer, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]\\n [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]\\n [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]\"\n  syntax:\n    content: public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to send.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    return:\n      type: System.Int32\n      description: The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  overload: System.Net.Sockets.Socket.Send*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>size</code> is less than 0 or exceeds the size of the buffer.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: \"<code>socketFlags</code> is not a valid combination of values.  \\n  \\n -or-  \\n  \\n An operating system error occurs while accessing the socket.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  commentId: M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  id: Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Send(IList<ArraySegment<Byte>>, SocketFlags, SocketError)\n  nameWithType: Socket.Send(IList<ArraySegment<Byte>>, SocketFlags, SocketError)\n  fullName: Socket.Send(IList<ArraySegment<Byte>>, SocketFlags, SocketError)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends the set of buffers in the list to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.\n  remarks: \"This overload requires at least one buffer that contains the data you want to send. The <xref:System.Net.Sockets.SocketFlags> value defaults to 0. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.  \\n  \\n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \\n  \\n If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method. If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \\n  \\n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      public int Send (System.Collections.Generic.IList<ArraySegment<byte>> buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);\n    parameters:\n    - id: buffers\n      type: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n      description: A list of <xref href=\"System.ArraySegment`1\"></xref>s of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: errorCode\n      type: System.Net.Sockets.SocketError\n      description: A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.\n    return:\n      type: System.Int32\n      description: The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  overload: System.Net.Sockets.Socket.Send*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffers</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>buffers</code> is empty.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  attributes:\n  - type: System.CLSCompliantAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  altCompliant: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)\n  commentId: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)\n  id: Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Send(Byte[], Int32, Int32, SocketFlags)\n  nameWithType: Socket.Send(Byte[], Int32, Int32, SocketFlags)\n  fullName: Socket.Send(Byte[], Int32, Int32, SocketFlags)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends the specified number of bytes of data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, starting at the specified offset, and using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.\n  remarks: \"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.  \\n  \\n In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \\n  \\n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \\n  \\n If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>. If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \\n  \\n You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]\\n [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]\\n [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]\"\n  syntax:\n    content: public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.\n    - id: offset\n      type: System.Int32\n      description: The position in the data buffer at which to begin sending data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to send.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    return:\n      type: System.Int32\n      description: The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  overload: System.Net.Sockets.Socket.Send*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>offset</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>offset</code> is greater than the length of <code>buffer</code>.  \\n  \\n -or-  \\n  \\n <code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: \"<code>socketFlags</code> is not a valid combination of values.  \\n  \\n -or-  \\n  \\n An operating system error occurs while accessing the <xref href=\\\"System.Net.Sockets.Socket\\\"></xref>.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  commentId: M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  id: Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Send(Byte[], Int32, Int32, SocketFlags, SocketError)\n  nameWithType: Socket.Send(Byte[], Int32, Int32, SocketFlags, SocketError)\n  fullName: Socket.Send(Byte[], Int32, Int32, SocketFlags, SocketError)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends the specified number of bytes of data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref>, starting at the specified offset, and using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>\n  remarks: \"<xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent. <xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.  \\n  \\n In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \\n  \\n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a<xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \\n  \\n If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>. If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>. It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>. You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.  \\n  \\n You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=fullName>. If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>. In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  The successful completion of a send does not indicate that the data was successfully delivered. If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see[Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]\\n [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]\\n [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]\"\n  syntax:\n    content: public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.\n    - id: offset\n      type: System.Int32\n      description: The position in the data buffer at which to begin sending data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to send.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: errorCode\n      type: System.Net.Sockets.SocketError\n      description: A <xref href=\"System.Net.Sockets.SocketError\"></xref> object that stores the socket error.\n    return:\n      type: System.Int32\n      description: The number of bytes sent to the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  overload: System.Net.Sockets.Socket.Send*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>offset</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>offset</code> is greater than the length of <code>buffer</code>.  \\n  \\n -or-  \\n  \\n <code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: \"<code>socketFlags</code> is not a valid combination of values.  \\n  \\n -or-  \\n  \\n An operating system error occurs while accessing the <xref href=\\\"System.Net.Sockets.Socket\\\"></xref>.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  commentId: M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  id: SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SendAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.SendAsync(SocketAsyncEventArgs)\n  fullName: Socket.SendAsync(SocketAsyncEventArgs)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends data asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object.\n  remarks: \"The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket. This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.  \\n  \\n The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.  \\n  \\n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName> is set  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \\n  \\n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \\n  \\n The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.  \\n  \\n Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread.  \\n  \\n For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider. If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=fullName> set to the native Winsock WSAEMSGSIZE error code (10040).  \\n  \\n Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered.\"\n  syntax:\n    content: public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);\n    parameters:\n    - id: e\n      type: System.Net.Sockets.SocketAsyncEventArgs\n      description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.\n    return:\n      type: System.Boolean\n      description: \"Returns `true` if the I/O operation is pending. The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \\n  \\n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.\"\n  overload: System.Net.Sockets.Socket.SendAsync*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.Buffer\"></xref> or <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.BufferList\"></xref> properties on the <code>e</code> parameter must reference valid buffers. One or the other of these properties may be set, but not both at the same time.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows XP or later is required for this method.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> is not yet connected or was not obtained via an <xref href=\"System.Net.Sockets.Socket.Accept\"></xref>, <xref href=\"System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\"></xref>,or <xref href=\"System.Net.Sockets.Socket.BeginAccept*\"></xref>, method.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SendBufferSize\n  commentId: P:System.Net.Sockets.Socket.SendBufferSize\n  id: SendBufferSize\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SendBufferSize\n  nameWithType: Socket.SendBufferSize\n  fullName: Socket.SendBufferSize\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets or sets a value that specifies the size of the send buffer of the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: A larger buffer size might delay the recognition of connection difficulties. Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)\n  example:\n  - \"The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendBufferSize%2A> property.  \\n  \\n [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]\\n [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]\"\n  syntax:\n    content: public int SendBufferSize { get; set; }\n    return:\n      type: System.Int32\n      description: An <xref href=\"System.Int32\"></xref> that contains the size, in bytes, of the send buffer. The default is 8192.\n  overload: System.Net.Sockets.Socket.SendBufferSize*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The value specified for a set operation is less than 0.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SendFile(System.String)\n  commentId: M:System.Net.Sockets.Socket.SendFile(System.String)\n  id: SendFile(System.String)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SendFile(String)\n  nameWithType: Socket.SendFile(String)\n  fullName: Socket.SendFile(String)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Sends the file <code>fileName</code> to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object with the <xref href=\"System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread\"></xref> transmit flag.\n  remarks: \"This overload sends the file `fileName` to the connected socket. The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`. If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards (\\\"..\\\\\\\\\\\\myfile.txt\\\") and UNC share names (\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\shared directory\\\\\\\\\\\\myfile.txt\\\") are supported. If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.  \\n  \\n This method uses the `TransmitFile` function found in the Windows Sockets 2 API. For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.  \\n  \\n <xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. <xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.  \\n  \\n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \\n  \\n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent. In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example creates and connects a socket and then sends a file to the remote host. The file \\\"test.txt\\\" is located in the root directory of the local machine.  \\n  \\n [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]\\n [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]\"\n  syntax:\n    content: public void SendFile (string fileName);\n    parameters:\n    - id: fileName\n      type: System.String\n      description: A <xref href=\"System.String\"></xref> that contains the path and name of the file to be sent. This parameter can be `null`.\n  overload: System.Net.Sockets.Socket.SendFile*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The socket is not connected to a remote host.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object is not in blocking mode and cannot accept this synchronous call.\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: The file <code>fileName</code> was not found.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)\n  commentId: M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)\n  id: SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SendFile(String, Byte[], Byte[], TransmitFileOptions)\n  nameWithType: Socket.SendFile(String, Byte[], Byte[], TransmitFileOptions)\n  fullName: Socket.SendFile(String, Byte[], Byte[], TransmitFileOptions)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Sends the file <code>fileName</code> and buffers of data to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object using the specified <xref href=\"System.Net.Sockets.TransmitFileOptions\"></xref> value.\n  remarks: \"This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values. The `preBuffer` parameter contains any data you want to precede the file. `postBuffer` contains data you want to follow the file. If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards (\\\"..\\\\\\\\\\\\myfile.txt\\\") and UNC share names (\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\shared directory\\\\\\\\\\\\myfile.txt\\\") are supported.  \\n  \\n The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer. For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.  \\n  \\n This method uses the `TransmitFile` function found in the Windows Sockets 2 API. For more information about the `TransmitFile` function and its flags, see the Windows Sockets documentation in the MSDN Library.  \\n  \\n <xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method. <xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.  \\n  \\n If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>. If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.  \\n  \\n If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent. In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent. There is no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example creates and connects a socket. The file \\\"test.txt\\\" is located in the root directory of the local machine. In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file. The default <xref:System.Net.Sockets.TransmitFileOptions> are used.  \\n  \\n [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]\\n [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]\"\n  syntax:\n    content: public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);\n    parameters:\n    - id: fileName\n      type: System.String\n      description: A <xref href=\"System.String\"></xref> that contains the path and name of the file to be sent. This parameter can be `null`.\n    - id: preBuffer\n      type: System.Byte[]\n      description: A <xref href=\"System.Byte\"></xref> array that contains data to be sent before the file is sent. This parameter can be `null`.\n    - id: postBuffer\n      type: System.Byte[]\n      description: A <xref href=\"System.Byte\"></xref> array that contains data to be sent after the file is sent. This parameter can be `null`.\n    - id: flags\n      type: System.Net.Sockets.TransmitFileOptions\n      description: One or more of <xref href=\"System.Net.Sockets.TransmitFileOptions\"></xref> values.\n  overload: System.Net.Sockets.Socket.SendFile*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: \"The operating system is not Windows NT or later.  \\n  \\n \\\\- or -  \\n  \\n The socket is not connected to a remote host.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object is not in blocking mode and cannot accept this synchronous call.\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: The file <code>fileName</code> was not found.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  commentId: M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  id: SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SendPacketsAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.SendPacketsAsync(SocketAsyncEventArgs)\n  fullName: Socket.SendPacketsAsync(SocketAsyncEventArgs)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends a collection of files or in memory data buffers asynchronously to a connected <xref href=\"System.Net.Sockets.Socket\"></xref> object.\n  remarks: \"The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host. The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.  \\n  \\n If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=fullName> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified. Wildcards and UNC share names are supported. If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.  \\n  \\n To be notified of completion, you must create a callback method that implements the EventHandler\\\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.  \\n  \\n The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=fullName> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer. For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.  \\n  \\n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \\n  \\n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \\n  \\n This method uses the TransmitPackets function found in the Windows Sockets 2 API. For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.  \\n  \\n Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host. With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider. If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.  \\n  \\n The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used. On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.  \\n  \\n On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization.  \\n  \\n Use of the <xref:System.Net.Sockets.TransmitFileOptions?displayProperty=fullName> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=fullName> property on the `e` parameter can deliver significant performance benefits. If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching. Note that there is a difference between kernel and user-mode APCs. Kernel APCs launch when a thread is in a wait state. User-mode APCs launch when a thread is in an alertable wait state\"\n  syntax:\n    content: >-\n      [System.MonoTODO(\"Not implemented\")]\n\n      public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);\n    parameters:\n    - id: e\n      type: System.Net.Sockets.SocketAsyncEventArgs\n      description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.\n    return:\n      type: System.Boolean\n      description: \"Returns `true` if the I/O operation is pending. The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \\n  \\n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.\"\n  overload: System.Net.Sockets.Socket.SendPacketsAsync*\n  exceptions:\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: The file specified in the <xref href=\"System.Net.Sockets.SendPacketsElement.FilePath\"></xref> property was not found.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows XP or later is required for this method. This exception also occurs if the <xref href=\"System.Net.Sockets.Socket\"></xref> is not connected to a remote host.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: A connectionless <xref href=\"System.Net.Sockets.Socket\"></xref> is being used and the file being sent exceeds the maximum packet size of the underlying transport.\n  attributes:\n  - type: System.MonoTODO\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SendTimeout\n  commentId: P:System.Net.Sockets.Socket.SendTimeout\n  id: SendTimeout\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SendTimeout\n  nameWithType: Socket.SendTimeout\n  fullName: Socket.SendTimeout\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets or sets a value that specifies the amount of time after which a synchronous <xref href=\"System.Net.Sockets.Socket.Send*\"></xref> call will time out.\n  remarks: This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only. If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.\n  example:\n  - \"The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendTimeout%2A> property.  \\n  \\n [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]\\n [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]\"\n  syntax:\n    content: public int SendTimeout { get; set; }\n    return:\n      type: System.Int32\n      description: The time-out value, in milliseconds. If you set the property with a value between 1 and 499, the value will be changed to 500. The default value is 0, which indicates an infinite time-out period. Specifying -1 also indicates an infinite time-out period.\n  overload: System.Net.Sockets.Socket.SendTimeout*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The value specified for a set operation is less than -1.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)\n  commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)\n  id: SendTo(System.Byte[],System.Net.EndPoint)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SendTo(Byte[], EndPoint)\n  nameWithType: Socket.SendTo(Byte[], EndPoint)\n  fullName: Socket.SendTo(Byte[], EndPoint)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends data to the specified endpoint.\n  remarks: \"In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the `buffer` parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to 0.  \\n  \\n If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.  \\n  \\n Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method. In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.  \\n  \\n Blocking sockets will block until the all of the bytes in the buffer are sent. Since a nonblocking<xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example sends a connectionless datagram to the specified remote host.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]\\n [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]\\n [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]\"\n  syntax:\n    content: public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.\n    - id: remoteEP\n      type: System.Net.EndPoint\n      description: The <xref href=\"System.Net.EndPoint\"></xref> that represents the destination for the data.\n    return:\n      type: System.Int32\n      description: The number of bytes sent.\n  overload: System.Net.Sockets.Socket.SendTo*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>buffer</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>remoteEP</code> is `null`.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  id: SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SendTo(Byte[], SocketFlags, EndPoint)\n  nameWithType: Socket.SendTo(Byte[], SocketFlags, EndPoint)\n  fullName: Socket.SendTo(Byte[], SocketFlags, EndPoint)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends data to a specific endpoint using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.\n  remarks: \"In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \\n  \\n If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.  \\n  \\n Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method. In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.  \\n  \\n Blocking sockets will block until the requested all of the bytes in the `buffer` are sent. Since a nonblocking<xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example sends a connectionless datagram to the specified remote host. <xref:System.Net.Sockets.SocketFlags> are passed to the<xref:System.Net.Sockets.Socket.SendTo%2A> method.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]\\n [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]\\n [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]\"\n  syntax:\n    content: public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: remoteEP\n      type: System.Net.EndPoint\n      description: The <xref href=\"System.Net.EndPoint\"></xref> that represents the destination location for the data.\n    return:\n      type: System.Int32\n      description: The number of bytes sent.\n  overload: System.Net.Sockets.Socket.SendTo*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>buffer</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>remoteEP</code> is `null`.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  id: SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SendTo(Byte[], Int32, SocketFlags, EndPoint)\n  nameWithType: Socket.SendTo(Byte[], Int32, SocketFlags, EndPoint)\n  fullName: Socket.SendTo(Byte[], Int32, SocketFlags, EndPoint)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends the specified number of bytes of data to the specified endpoint using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.\n  remarks: \"In this overload, the buffer offset defaults to 0. If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \\n  \\n If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.  \\n  \\n Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method. In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.  \\n  \\n Blocking sockets will block until the requested number of bytes are sent. Since a nonblocking<xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation. It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example sends a connectionless datagram to the specified remote host. The size and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]\\n [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]\\n [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]\"\n  syntax:\n    content: public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to send.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: remoteEP\n      type: System.Net.EndPoint\n      description: The <xref href=\"System.Net.EndPoint\"></xref> that represents the destination location for the data.\n    return:\n      type: System.Int32\n      description: The number of bytes sent.\n  overload: System.Net.Sockets.Socket.SendTo*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>buffer</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>remoteEP</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The specified <code>size</code> exceeds the size of <code>buffer</code>.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  commentId: M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  id: SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SendTo(Byte[], Int32, Int32, SocketFlags, EndPoint)\n  nameWithType: Socket.SendTo(Byte[], Int32, Int32, SocketFlags, EndPoint)\n  fullName: Socket.SendTo(Byte[], Int32, Int32, SocketFlags, EndPoint)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <xref href=\"System.Net.Sockets.SocketFlags\"></xref>.\n  remarks: \"In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.  \\n  \\n If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method. If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number. If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.  \\n  \\n Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols. If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method. If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>. You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method. In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.  \\n  \\n Blocking sockets will block until the requested number of bytes are sent. Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation. It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes. There is also no guarantee that the data you send will appear on the network immediately. To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected. A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.  \\n  \\n If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent. If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName>. You must also be sure that the size does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example sends a connectionless datagram to the specified remote host. The offset, size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.  \\n  \\n [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]\\n [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]\\n [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]\"\n  syntax:\n    content: public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);\n    parameters:\n    - id: buffer\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that contains the data to be sent.\n    - id: offset\n      type: System.Int32\n      description: The position in the data buffer at which to begin sending data.\n    - id: size\n      type: System.Int32\n      description: The number of bytes to send.\n    - id: socketFlags\n      type: System.Net.Sockets.SocketFlags\n      description: A bitwise combination of the <xref href=\"System.Net.Sockets.SocketFlags\"></xref> values.\n    - id: remoteEP\n      type: System.Net.EndPoint\n      description: The <xref href=\"System.Net.EndPoint\"></xref> that represents the destination location for the data.\n    return:\n      type: System.Int32\n      description: The number of bytes sent.\n  overload: System.Net.Sockets.Socket.SendTo*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>buffer</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>remoteEP</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>offset</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>offset</code> is greater than the length of <code>buffer</code>.  \\n  \\n -or-  \\n  \\n <code>size</code> is less than 0.  \\n  \\n -or-  \\n  \\n <code>size</code> is greater than the length of <code>buffer</code> minus the value of the <code>offset</code> parameter.\"\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: \"<code>socketFlags</code> is not a valid combination of values.  \\n  \\n -or-  \\n  \\n An operating system error occurs while accessing the <xref href=\\\"System.Net.Sockets.Socket\\\"></xref>.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: A caller in the call stack does not have the required permissions.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  commentId: M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  id: SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SendToAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.SendToAsync(SocketAsyncEventArgs)\n  fullName: Socket.SendToAsync(SocketAsyncEventArgs)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sends data asynchronously to a specific remote host.\n  remarks: \"The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property of the `e` parameter. Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread. Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols.  \\n  \\n To be notified of completion, you must create a callback method that implements the EventHandler\\\\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event.  \\n  \\n The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=fullName> object are required to successfully call this method:  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName>  \\n  \\n-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName>  \\n  \\n The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=fullName> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method. If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.  \\n  \\n If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method. Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>. When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property and send data to the <xref:System.Net.EndPoint?displayProperty=fullName> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.  \\n  \\n If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>. You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods. If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=fullName> property will override the specified default remote host for that send operation only. You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method. In this case, the underlying service provider will assign the most appropriate local network IP address and port number. Use a port number of zero if you want the underlying service provider to select a free port. If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=fullName> event is signaled and the associated delegates are called.  \\n  \\n If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName?displayProperty=fullName> to true. You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider. If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.  \\n  \\n If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=fullName> property, the data you are sending will not be routed.  \\n  \\n For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport. If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>. The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.\"\n  syntax:\n    content: public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);\n    parameters:\n    - id: e\n      type: System.Net.Sockets.SocketAsyncEventArgs\n      description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object to use for this asynchronous socket operation.\n    return:\n      type: System.Boolean\n      description: \"Returns `true` if the I/O operation is pending. The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will be raised upon completion of the operation.  \\n  \\n Returns `false` if the I/O operation completed synchronously. In this case, The <xref href=\\\"System.Net.Sockets.SocketAsyncEventArgs.Completed\\\"></xref> event on the <code>e</code> parameter will not be raised and the <code>e</code> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.\"\n  overload: System.Net.Sockets.Socket.SendToAsync*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <xref href=\"System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint\"></xref> cannot be null.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: A socket operation was already in progress using the <xref href=\"System.Net.Sockets.SocketAsyncEventArgs\"></xref> object specified in the <code>e</code> parameter.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Windows XP or later is required for this method.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: The protocol specified is connection-oriented, but the <xref href=\"System.Net.Sockets.Socket\"></xref> is not yet connected.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)\n  commentId: M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)\n  id: SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SetIPProtectionLevel(IPProtectionLevel)\n  nameWithType: Socket.SetIPProtectionLevel(IPProtectionLevel)\n  fullName: Socket.SetIPProtectionLevel(IPProtectionLevel)\n  type: Method\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Set the IP protection level on a socket.\n  remarks: \"The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix. This socket option enables applications to place access restrictions on IPv6 or IP sockets. Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks. This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.  \\n  \\n This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration.  \\n  \\n The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance. NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.  \\n  \\n When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, or <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, this explicitly disables NAT traversal for a <xref:System.Net.Sockets.Socket> instance.  \\n  \\n When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, this may allow NAT traversal for a <xref:System.Net.Sockets.Socket> depending on firewall rules in place on the system.\"\n  syntax:\n    content: public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);\n    parameters:\n    - id: level\n      type: System.Net.Sockets.IPProtectionLevel\n      description: The IP protection level to set on this socket.\n  overload: System.Net.Sockets.Socket.SetIPProtectionLevel*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The <code>level</code> parameter cannot be <xref href=\"System.Net.Sockets.IPProtectionLevel.Unspecified\"></xref>. The IP protection level cannot be set to unspecified.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The <xref href=\"System.Net.Sockets.AddressFamily\"></xref> of the socket must be either <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref>.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)\n  commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)\n  id: SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SetSocketOption(SocketOptionLevel, SocketOptionName, Boolean)\n  nameWithType: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Boolean)\n  fullName: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Boolean)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sets the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option to the specified <xref href=\"System.Boolean\"></xref> value.\n  remarks: \"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Set `optionValue` to `true` to enable the option, or to `false` to disable the option.  \\n  \\n <xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.  \\n  \\n Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload. These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value. If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter. The option you choose to set must be specified in the `optionName` parameter. If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.  \\n  \\n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.Debug>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  \\n  \\n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  \\n  \\n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  \\n  \\n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  \\n  \\n For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.\"\n  example:\n  - \"The following code example opens a socket and enables the `DontLinger` and the `OutOfBandInline` socket options.  \\n  \\n [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]\\n [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]\"\n  syntax:\n    content: public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);\n    parameters:\n    - id: optionLevel\n      type: System.Net.Sockets.SocketOptionLevel\n      description: One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values.\n    - id: optionName\n      type: System.Net.Sockets.SocketOptionName\n      description: One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values.\n    - id: optionValue\n      type: System.Boolean\n      description: The value of the option, represented as a <xref href=\"System.Boolean\"></xref>.\n  overload: System.Net.Sockets.Socket.SetSocketOption*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> object has been closed.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])\n  commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])\n  id: SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SetSocketOption(SocketOptionLevel, SocketOptionName, Byte[])\n  nameWithType: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Byte[])\n  fullName: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Byte[])\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sets the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option to the specified value, represented as a byte array.\n  remarks: \"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.  \\n  \\n [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]\\n [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]\\n [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]\"\n  syntax:\n    content: public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);\n    parameters:\n    - id: optionLevel\n      type: System.Net.Sockets.SocketOptionLevel\n      description: One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values.\n    - id: optionName\n      type: System.Net.Sockets.SocketOptionName\n      description: One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values.\n    - id: optionValue\n      type: System.Byte[]\n      description: An array of type <xref href=\"System.Byte\"></xref> that represents the value of the option.\n  overload: System.Net.Sockets.Socket.SetSocketOption*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\n  commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\n  id: SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SetSocketOption(SocketOptionLevel, SocketOptionName, Int32)\n  nameWithType: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Int32)\n  fullName: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Int32)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sets the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option to the specified integer value.\n  remarks: \"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option. For an option with an integer data type, specify the appropriate value. <xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.  \\n  \\n Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload. These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>. If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter. The option you choose to set must be specified in the `optionName` parameter. If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.  \\n  \\n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.Debug>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.Error>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.Type>  \\n  \\n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  \\n  \\n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  \\n  \\n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  \\n  \\n <xref:System.Net.Sockets.SocketOptionLevel?displayProperty=fullName> options that can be set using this overload.  \\n  \\n-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  \\n  \\n For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.  \\n  \\n [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]\\n [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]\\n [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]\"\n  syntax:\n    content: public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);\n    parameters:\n    - id: optionLevel\n      type: System.Net.Sockets.SocketOptionLevel\n      description: One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values.\n    - id: optionName\n      type: System.Net.Sockets.SocketOptionName\n      description: One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values.\n    - id: optionValue\n      type: System.Int32\n      description: A value of the option.\n  overload: System.Net.Sockets.Socket.SetSocketOption*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)\n  commentId: M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)\n  id: SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SetSocketOption(SocketOptionLevel, SocketOptionName, Object)\n  nameWithType: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Object)\n  fullName: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Object)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Sets the specified <xref href=\"System.Net.Sockets.Socket\"></xref> option to the specified value, represented as an object.\n  remarks: \"<xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>. Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options. For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter. For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>. If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.\"\n  example:\n  - \"The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time out values.  \\n  \\n [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]\\n [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]\\n [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]\"\n  syntax:\n    content: public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);\n    parameters:\n    - id: optionLevel\n      type: System.Net.Sockets.SocketOptionLevel\n      description: One of the <xref href=\"System.Net.Sockets.SocketOptionLevel\"></xref> values.\n    - id: optionName\n      type: System.Net.Sockets.SocketOptionName\n      description: One of the <xref href=\"System.Net.Sockets.SocketOptionName\"></xref> values.\n    - id: optionValue\n      type: System.Object\n      description: A <xref href=\"System.Net.Sockets.LingerOption\"></xref> or <xref href=\"System.Net.Sockets.MulticastOption\"></xref> that contains the value of the option.\n  overload: System.Net.Sockets.Socket.SetSocketOption*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>optionValue</code> is `null`.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\n  commentId: M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\n  id: Shutdown(System.Net.Sockets.SocketShutdown)\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Shutdown(SocketShutdown)\n  nameWithType: Socket.Shutdown(SocketShutdown)\n  fullName: Socket.Shutdown(SocketShutdown)\n  type: Method\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Disables sends and receives on a <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: \"When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>. This ensures that all data is sent and received on the connected socket before it is closed.  \\n  \\n Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>. Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.  \\n  \\n The following table shows the <xref:System.Net.Sockets.SocketShutdown> enumeration values that are valid for the `how` parameter.  \\n  \\n|Value|Description|  \\n|-----------|-----------------|  \\n|Send|Disable sending on this <xref:System.Net.Sockets.Socket>.|  \\n|Receive|Disable receiving on this <xref:System.Net.Sockets.Socket>.|  \\n|Both|Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>.|  \\n  \\n Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed. If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect.  \\n  \\n Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed. This has no effect on lower protocol layers. If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :  \\n  \\n-   Data is in the incoming network buffer waiting to be received.  \\n  \\n-   More data has arrived.  \\n  \\n If you are using a connectionless protocol, datagrams are accepted and queued. However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender. Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.  \\n  \\n Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Both> disables both sends and receives as described above.  \\n  \\n> [!NOTE]\\n>  If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.  \\n  \\n> [!NOTE]\\n>  This member outputs trace information when you enable network tracing in your application. For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).\"\n  example:\n  - \"The following code example uses <xref:System.Net.Sockets.Socket.Shutdown%2A> to disable the <xref:System.Net.Sockets.Socket>.  \\n  \\n [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]\\n [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]\"\n  syntax:\n    content: public void Shutdown (System.Net.Sockets.SocketShutdown how);\n    parameters:\n    - id: how\n      type: System.Net.Sockets.SocketShutdown\n      description: One of the <xref href=\"System.Net.Sockets.SocketShutdown\"></xref> values that specifies the operation that will no longer be allowed.\n  overload: System.Net.Sockets.Socket.Shutdown*\n  exceptions:\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SocketType\n  commentId: P:System.Net.Sockets.Socket.SocketType\n  id: SocketType\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SocketType\n  nameWithType: Socket.SocketType\n  fullName: Socket.SocketType\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets the type of the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: <xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.\n  example:\n  - \"The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.  \\n  \\n [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]\\n [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]\\n [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]\"\n  syntax:\n    content: public System.Net.Sockets.SocketType SocketType { get; }\n    return:\n      type: System.Net.Sockets.SocketType\n      description: One of the <xref href=\"System.Net.Sockets.SocketType\"></xref> values.\n  overload: System.Net.Sockets.Socket.SocketType*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SupportsIPv4\n  commentId: P:System.Net.Sockets.Socket.SupportsIPv4\n  id: SupportsIPv4\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SupportsIPv4\n  nameWithType: Socket.SupportsIPv4\n  fullName: Socket.SupportsIPv4\n  type: Property\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Gets a value indicating whether IPv4 support is available and enabled on the current host.\n  remarks: The operating system may support both IPv4 and IPv6 protocols.\n  syntax:\n    content: >-\n      [System.Obsolete(\"Use OSSupportsIPv4 instead\")]\n\n      public static bool SupportsIPv4 { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current host supports the IPv4 protocol; otherwise, `false`.'\n  overload: System.Net.Sockets.Socket.SupportsIPv4*\n  exceptions: []\n  attributes:\n  - type: System.ObsoleteAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.SupportsIPv6\n  commentId: P:System.Net.Sockets.Socket.SupportsIPv6\n  id: SupportsIPv6\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: SupportsIPv6\n  nameWithType: Socket.SupportsIPv6\n  fullName: Socket.SupportsIPv6\n  type: Property\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <xref href=\"System.Net.Dns\"></xref> members.\n  remarks: The operating system may support both IPv4 and IPv6 protocols.\n  syntax:\n    content: >-\n      [System.Obsolete(\"Use OSSupportsIPv6 instead\")]\n\n      public static bool SupportsIPv6 { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the Framework supports IPv6 for certain obsolete <xref href=\"System.Net.Dns\"></xref> methods; otherwise, `false`.'\n  overload: System.Net.Sockets.Socket.SupportsIPv6*\n  exceptions: []\n  attributes:\n  - type: System.ObsoleteAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.Ttl\n  commentId: P:System.Net.Sockets.Socket.Ttl\n  id: Ttl\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: Ttl\n  nameWithType: Socket.Ttl\n  fullName: Socket.Ttl\n  type: Property\n  assemblies:\n  - System.Net.Sockets\n  - System\n  - netstandard\n  namespace: System.Net.Sockets\n  summary: Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <xref href=\"System.Net.Sockets.Socket\"></xref>.\n  remarks: \"The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) \\\"TTL exceeded\\\" error message is returned to the sender.  \\n  \\n The TTL value may be set to a value from 0 to 255. When this property is not set, the default TTL value for a socket is 32.  \\n  \\n Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.  \\n  \\n If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=fullName> property to obtain the specific error code. After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.\"\n  example:\n  - \"The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.Ttl%2A> property.  \\n  \\n [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]\\n [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]\"\n  syntax:\n    content: public short Ttl { get; set; }\n    return:\n      type: System.Int16\n      description: The TTL value.\n  overload: System.Net.Sockets.Socket.Ttl*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The TTL value can't be set to a negative number.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: This property can be set only for sockets in the <xref href=\"System.Net.Sockets.AddressFamily.InterNetwork\"></xref> or <xref href=\"System.Net.Sockets.AddressFamily.InterNetworkV6\"></xref> families.\n  - type: System.Net.Sockets.SocketException\n    commentId: T:System.Net.Sockets.SocketException\n    description: An error occurred when attempting to access the socket. This error is also returned when an attempt was made to set TTL to a value higher than 255.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Net.Sockets.Socket\"></xref> has been closed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\n- uid: System.Net.Sockets.Socket.UseOnlyOverlappedIO\n  commentId: P:System.Net.Sockets.Socket.UseOnlyOverlappedIO\n  id: UseOnlyOverlappedIO\n  parent: System.Net.Sockets.Socket\n  langs:\n  - csharp\n  name: UseOnlyOverlappedIO\n  nameWithType: Socket.UseOnlyOverlappedIO\n  fullName: Socket.UseOnlyOverlappedIO\n  type: Property\n  assemblies:\n  - System\n  - netstandard\n  - System.Net.Sockets\n  namespace: System.Net.Sockets\n  summary: Specifies whether the socket should only use Overlapped I/O mode.\n  remarks: Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>. Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.\n  syntax:\n    content: >-\n      [System.MonoTODO(\"This doesn't do anything on Mono yet\")]\n\n      public bool UseOnlyOverlappedIO { get; set; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Net.Sockets.Socket\"></xref> uses only overlapped I/O; otherwise, `false`. The default is `false`.'\n  overload: System.Net.Sockets.Socket.UseOnlyOverlappedIO*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The socket has been bound to a completion port.\n  attributes:\n  - type: System.MonoTODO\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n  ms.author: bobdel\n  manager: markl\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.Net.Sockets.SocketException\n  parent: System.Net.Sockets\n  isExternal: false\n  name: SocketException\n  nameWithType: SocketException\n  fullName: System.Net.Sockets.SocketException\n- uid: System.ObjectDisposedException\n  parent: System\n  isExternal: false\n  name: ObjectDisposedException\n  nameWithType: ObjectDisposedException\n  fullName: System.ObjectDisposedException\n- uid: System.InvalidOperationException\n  parent: System\n  isExternal: false\n  name: InvalidOperationException\n  nameWithType: InvalidOperationException\n  fullName: System.InvalidOperationException\n- uid: System.ArgumentException\n  parent: System\n  isExternal: false\n  name: ArgumentException\n  nameWithType: ArgumentException\n  fullName: System.ArgumentException\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.NotSupportedException\n  parent: System\n  isExternal: false\n  name: NotSupportedException\n  nameWithType: NotSupportedException\n  fullName: System.NotSupportedException\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.Security.SecurityException\n  parent: System.Security\n  isExternal: false\n  name: SecurityException\n  nameWithType: SecurityException\n  fullName: System.Security.SecurityException\n- uid: System.IO.FileNotFoundException\n  parent: System.IO\n  isExternal: false\n  name: FileNotFoundException\n  nameWithType: FileNotFoundException\n  fullName: System.IO.FileNotFoundException\n- uid: System.PlatformNotSupportedException\n  parent: System\n  isExternal: false\n  name: PlatformNotSupportedException\n  nameWithType: PlatformNotSupportedException\n  fullName: System.PlatformNotSupportedException\n- uid: System.Net.WebException\n  parent: System.Net\n  isExternal: false\n  name: WebException\n  nameWithType: WebException\n  fullName: System.Net.WebException\n- uid: System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Socket(SocketInformation)\n  nameWithType: Socket.Socket(SocketInformation)\n  fullName: Socket.Socket(SocketInformation)\n- uid: System.Net.Sockets.SocketInformation\n  parent: System.Net.Sockets\n  isExternal: false\n  name: SocketInformation\n  nameWithType: SocketInformation\n  fullName: System.Net.Sockets.SocketInformation\n- uid: System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Socket(SocketType, ProtocolType)\n  nameWithType: Socket.Socket(SocketType, ProtocolType)\n  fullName: Socket.Socket(SocketType, ProtocolType)\n- uid: System.Net.Sockets.SocketType\n  parent: System.Net.Sockets\n  isExternal: false\n  name: SocketType\n  nameWithType: SocketType\n  fullName: System.Net.Sockets.SocketType\n- uid: System.Net.Sockets.ProtocolType\n  parent: System.Net.Sockets\n  isExternal: false\n  name: ProtocolType\n  nameWithType: ProtocolType\n  fullName: System.Net.Sockets.ProtocolType\n- uid: System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Socket(AddressFamily, SocketType, ProtocolType)\n  nameWithType: Socket.Socket(AddressFamily, SocketType, ProtocolType)\n  fullName: Socket.Socket(AddressFamily, SocketType, ProtocolType)\n- uid: System.Net.Sockets.AddressFamily\n  parent: System.Net.Sockets\n  isExternal: false\n  name: AddressFamily\n  nameWithType: AddressFamily\n  fullName: System.Net.Sockets.AddressFamily\n- uid: System.Net.Sockets.Socket.Accept\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Accept()\n  nameWithType: Socket.Accept()\n  fullName: Socket.Accept()\n- uid: System.Net.Sockets.Socket\n  parent: System.Net.Sockets\n  isExternal: false\n  name: Socket\n  nameWithType: Socket\n  fullName: System.Net.Sockets.Socket\n- uid: System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: AcceptAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.AcceptAsync(SocketAsyncEventArgs)\n  fullName: Socket.AcceptAsync(SocketAsyncEventArgs)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Net.Sockets.SocketAsyncEventArgs\n  parent: System.Net.Sockets\n  isExternal: false\n  name: SocketAsyncEventArgs\n  nameWithType: SocketAsyncEventArgs\n  fullName: System.Net.Sockets.SocketAsyncEventArgs\n- uid: System.Net.Sockets.Socket.AddressFamily\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: AddressFamily\n  nameWithType: Socket.AddressFamily\n  fullName: Socket.AddressFamily\n- uid: System.Net.Sockets.Socket.Available\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Available\n  nameWithType: Socket.Available\n  fullName: Socket.Available\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginAccept(Socket, Int32, AsyncCallback, Object)\n  nameWithType: Socket.BeginAccept(Socket, Int32, AsyncCallback, Object)\n  fullName: Socket.BeginAccept(Socket, Int32, AsyncCallback, Object)\n- uid: System.IAsyncResult\n  parent: System\n  isExternal: false\n  name: IAsyncResult\n  nameWithType: IAsyncResult\n  fullName: System.IAsyncResult\n- uid: System.AsyncCallback\n  parent: System\n  isExternal: false\n  name: AsyncCallback\n  nameWithType: AsyncCallback\n  fullName: System.AsyncCallback\n- uid: System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginAccept(Int32, AsyncCallback, Object)\n  nameWithType: Socket.BeginAccept(Int32, AsyncCallback, Object)\n  fullName: Socket.BeginAccept(Int32, AsyncCallback, Object)\n- uid: System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginAccept(AsyncCallback, Object)\n  nameWithType: Socket.BeginAccept(AsyncCallback, Object)\n  fullName: Socket.BeginAccept(AsyncCallback, Object)\n- uid: System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginConnect(EndPoint, AsyncCallback, Object)\n  nameWithType: Socket.BeginConnect(EndPoint, AsyncCallback, Object)\n  fullName: Socket.BeginConnect(EndPoint, AsyncCallback, Object)\n- uid: System.Net.EndPoint\n  parent: System.Net\n  isExternal: false\n  name: EndPoint\n  nameWithType: EndPoint\n  fullName: System.Net.EndPoint\n- uid: System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginConnect(IPAddress, Int32, AsyncCallback, Object)\n  nameWithType: Socket.BeginConnect(IPAddress, Int32, AsyncCallback, Object)\n  fullName: Socket.BeginConnect(IPAddress, Int32, AsyncCallback, Object)\n- uid: System.Net.IPAddress\n  parent: System.Net\n  isExternal: false\n  name: IPAddress\n  nameWithType: IPAddress\n  fullName: System.Net.IPAddress\n- uid: System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginConnect(IPAddress[], Int32, AsyncCallback, Object)\n  nameWithType: Socket.BeginConnect(IPAddress[], Int32, AsyncCallback, Object)\n  fullName: Socket.BeginConnect(IPAddress[], Int32, AsyncCallback, Object)\n- uid: System.Net.IPAddress[]\n  parent: System.Net\n  isExternal: false\n  name: IPAddress[]\n  nameWithType: IPAddress[]\n  fullName: System.Net.IPAddress[]\n  spec.csharp:\n  - uid: System.Net.IPAddress\n    name: IPAddress\n    nameWithType: IPAddress\n    fullName: System.Net.IPAddress\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginConnect(String, Int32, AsyncCallback, Object)\n  nameWithType: Socket.BeginConnect(String, Int32, AsyncCallback, Object)\n  fullName: Socket.BeginConnect(String, Int32, AsyncCallback, Object)\n- uid: System.String\n  parent: System\n  isExternal: false\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginDisconnect(Boolean, AsyncCallback, Object)\n  nameWithType: Socket.BeginDisconnect(Boolean, AsyncCallback, Object)\n  fullName: Socket.BeginDisconnect(Boolean, AsyncCallback, Object)\n- uid: System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginReceive(Byte[], Int32, Int32, SocketFlags, SocketError, AsyncCallback, Object)\n  nameWithType: Socket.BeginReceive(Byte[], Int32, Int32, SocketFlags, SocketError, AsyncCallback, Object)\n  fullName: Socket.BeginReceive(Byte[], Int32, Int32, SocketFlags, SocketError, AsyncCallback, Object)\n- uid: System.Byte\n  name: Byte\n  nameWithType: Byte\n  fullName: System.Byte\n- uid: System.Byte[]\n  parent: System\n  isExternal: false\n  name: Byte[]\n  nameWithType: Byte[]\n  fullName: System.Byte[]\n  spec.csharp:\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: System.Byte\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Net.Sockets.SocketFlags\n  parent: System.Net.Sockets\n  isExternal: false\n  name: SocketFlags\n  nameWithType: SocketFlags\n  fullName: System.Net.Sockets.SocketFlags\n- uid: System.Net.Sockets.SocketError\n  parent: System.Net.Sockets\n  isExternal: false\n  name: SocketError\n  nameWithType: SocketError\n  fullName: System.Net.Sockets.SocketError\n- uid: System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginReceive(Byte[], Int32, Int32, SocketFlags, AsyncCallback, Object)\n  nameWithType: Socket.BeginReceive(Byte[], Int32, Int32, SocketFlags, AsyncCallback, Object)\n  fullName: Socket.BeginReceive(Byte[], Int32, Int32, SocketFlags, AsyncCallback, Object)\n- uid: System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginReceive(IList<ArraySegment<Byte>>, SocketFlags, AsyncCallback, Object)\n  nameWithType: Socket.BeginReceive(IList<ArraySegment<Byte>>, SocketFlags, AsyncCallback, Object)\n  fullName: Socket.BeginReceive(IList<ArraySegment<Byte>>, SocketFlags, AsyncCallback, Object)\n- uid: System.Collections.Generic.IList`1\n  name: IList<T>\n  nameWithType: IList<T>\n  fullName: System.Collections.Generic.IList<T>\n- uid: System.ArraySegment`1\n  name: ArraySegment<T>\n  nameWithType: ArraySegment<T>\n  fullName: System.ArraySegment<T>\n- uid: System.Collections.Generic.IList{System.ArraySegment{System.Byte}}\n  parent: System.Collections.Generic\n  isExternal: false\n  name: IList<ArraySegment<Byte>>\n  nameWithType: IList<ArraySegment<Byte>>\n  fullName: System.Collections.Generic.IList<System.ArraySegment<System.Byte>>\n  spec.csharp:\n  - uid: System.Collections.Generic.IList`1\n    name: IList\n    nameWithType: IList\n    fullName: System.Collections.Generic.IList\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.ArraySegment`1\n    name: ArraySegment\n    nameWithType: ArraySegment\n    fullName: System.ArraySegment\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: System.Byte\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginReceive(IList<ArraySegment<Byte>>, SocketFlags, SocketError, AsyncCallback, Object)\n  nameWithType: Socket.BeginReceive(IList<ArraySegment<Byte>>, SocketFlags, SocketError, AsyncCallback, Object)\n  fullName: Socket.BeginReceive(IList<ArraySegment<Byte>>, SocketFlags, SocketError, AsyncCallback, Object)\n- uid: System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginReceiveFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  nameWithType: Socket.BeginReceiveFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  fullName: Socket.BeginReceiveFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n- uid: System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginReceiveMessageFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  nameWithType: Socket.BeginReceiveMessageFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  fullName: Socket.BeginReceiveMessageFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n- uid: System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginSend(IList<ArraySegment<Byte>>, SocketFlags, AsyncCallback, Object)\n  nameWithType: Socket.BeginSend(IList<ArraySegment<Byte>>, SocketFlags, AsyncCallback, Object)\n  fullName: Socket.BeginSend(IList<ArraySegment<Byte>>, SocketFlags, AsyncCallback, Object)\n- uid: System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginSend(IList<ArraySegment<Byte>>, SocketFlags, SocketError, AsyncCallback, Object)\n  nameWithType: Socket.BeginSend(IList<ArraySegment<Byte>>, SocketFlags, SocketError, AsyncCallback, Object)\n  fullName: Socket.BeginSend(IList<ArraySegment<Byte>>, SocketFlags, SocketError, AsyncCallback, Object)\n- uid: System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginSend(Byte[], Int32, Int32, SocketFlags, AsyncCallback, Object)\n  nameWithType: Socket.BeginSend(Byte[], Int32, Int32, SocketFlags, AsyncCallback, Object)\n  fullName: Socket.BeginSend(Byte[], Int32, Int32, SocketFlags, AsyncCallback, Object)\n- uid: System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginSend(Byte[], Int32, Int32, SocketFlags, SocketError, AsyncCallback, Object)\n  nameWithType: Socket.BeginSend(Byte[], Int32, Int32, SocketFlags, SocketError, AsyncCallback, Object)\n  fullName: Socket.BeginSend(Byte[], Int32, Int32, SocketFlags, SocketError, AsyncCallback, Object)\n- uid: System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginSendFile(String, AsyncCallback, Object)\n  nameWithType: Socket.BeginSendFile(String, AsyncCallback, Object)\n  fullName: Socket.BeginSendFile(String, AsyncCallback, Object)\n- uid: System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginSendFile(String, Byte[], Byte[], TransmitFileOptions, AsyncCallback, Object)\n  nameWithType: Socket.BeginSendFile(String, Byte[], Byte[], TransmitFileOptions, AsyncCallback, Object)\n  fullName: Socket.BeginSendFile(String, Byte[], Byte[], TransmitFileOptions, AsyncCallback, Object)\n- uid: System.Net.Sockets.TransmitFileOptions\n  parent: System.Net.Sockets\n  isExternal: false\n  name: TransmitFileOptions\n  nameWithType: TransmitFileOptions\n  fullName: System.Net.Sockets.TransmitFileOptions\n- uid: System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginSendTo(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  nameWithType: Socket.BeginSendTo(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n  fullName: Socket.BeginSendTo(Byte[], Int32, Int32, SocketFlags, EndPoint, AsyncCallback, Object)\n- uid: System.Net.Sockets.Socket.Bind(System.Net.EndPoint)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Bind(EndPoint)\n  nameWithType: Socket.Bind(EndPoint)\n  fullName: Socket.Bind(EndPoint)\n- uid: System.Net.Sockets.Socket.Blocking\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Blocking\n  nameWithType: Socket.Blocking\n  fullName: Socket.Blocking\n- uid: System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: CancelConnectAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.CancelConnectAsync(SocketAsyncEventArgs)\n  fullName: Socket.CancelConnectAsync(SocketAsyncEventArgs)\n- uid: System.Net.Sockets.Socket.Close(System.Int32)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Close(Int32)\n  nameWithType: Socket.Close(Int32)\n  fullName: Socket.Close(Int32)\n- uid: System.Net.Sockets.Socket.Close\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Close()\n  nameWithType: Socket.Close()\n  fullName: Socket.Close()\n- uid: System.Net.Sockets.Socket.Connect(System.Net.EndPoint)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Connect(EndPoint)\n  nameWithType: Socket.Connect(EndPoint)\n  fullName: Socket.Connect(EndPoint)\n- uid: System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Connect(IPAddress, Int32)\n  nameWithType: Socket.Connect(IPAddress, Int32)\n  fullName: Socket.Connect(IPAddress, Int32)\n- uid: System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Connect(IPAddress[], Int32)\n  nameWithType: Socket.Connect(IPAddress[], Int32)\n  fullName: Socket.Connect(IPAddress[], Int32)\n- uid: System.Net.Sockets.Socket.Connect(System.String,System.Int32)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Connect(String, Int32)\n  nameWithType: Socket.Connect(String, Int32)\n  fullName: Socket.Connect(String, Int32)\n- uid: System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ConnectAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.ConnectAsync(SocketAsyncEventArgs)\n  fullName: Socket.ConnectAsync(SocketAsyncEventArgs)\n- uid: System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ConnectAsync(SocketType, ProtocolType, SocketAsyncEventArgs)\n  nameWithType: Socket.ConnectAsync(SocketType, ProtocolType, SocketAsyncEventArgs)\n  fullName: Socket.ConnectAsync(SocketType, ProtocolType, SocketAsyncEventArgs)\n- uid: System.Net.Sockets.Socket.Connected\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Connected\n  nameWithType: Socket.Connected\n  fullName: Socket.Connected\n- uid: System.Net.Sockets.Socket.Disconnect(System.Boolean)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Disconnect(Boolean)\n  nameWithType: Socket.Disconnect(Boolean)\n  fullName: Socket.Disconnect(Boolean)\n- uid: System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: DisconnectAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.DisconnectAsync(SocketAsyncEventArgs)\n  fullName: Socket.DisconnectAsync(SocketAsyncEventArgs)\n- uid: System.Net.Sockets.Socket.Dispose\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Dispose()\n  nameWithType: Socket.Dispose()\n  fullName: Socket.Dispose()\n- uid: System.Net.Sockets.Socket.Dispose(System.Boolean)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Dispose(Boolean)\n  nameWithType: Socket.Dispose(Boolean)\n  fullName: Socket.Dispose(Boolean)\n- uid: System.Net.Sockets.Socket.DontFragment\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: DontFragment\n  nameWithType: Socket.DontFragment\n  fullName: Socket.DontFragment\n- uid: System.Net.Sockets.Socket.DualMode\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: DualMode\n  nameWithType: Socket.DualMode\n  fullName: Socket.DualMode\n- uid: System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: DuplicateAndClose(Int32)\n  nameWithType: Socket.DuplicateAndClose(Int32)\n  fullName: Socket.DuplicateAndClose(Int32)\n- uid: System.Net.Sockets.Socket.EnableBroadcast\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EnableBroadcast\n  nameWithType: Socket.EnableBroadcast\n  fullName: Socket.EnableBroadcast\n- uid: System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndAccept(Byte[], Int32, IAsyncResult)\n  nameWithType: Socket.EndAccept(Byte[], Int32, IAsyncResult)\n  fullName: Socket.EndAccept(Byte[], Int32, IAsyncResult)\n- uid: System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndAccept(IAsyncResult)\n  nameWithType: Socket.EndAccept(IAsyncResult)\n  fullName: Socket.EndAccept(IAsyncResult)\n- uid: System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndAccept(Byte[], IAsyncResult)\n  nameWithType: Socket.EndAccept(Byte[], IAsyncResult)\n  fullName: Socket.EndAccept(Byte[], IAsyncResult)\n- uid: System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndConnect(IAsyncResult)\n  nameWithType: Socket.EndConnect(IAsyncResult)\n  fullName: Socket.EndConnect(IAsyncResult)\n- uid: System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndDisconnect(IAsyncResult)\n  nameWithType: Socket.EndDisconnect(IAsyncResult)\n  fullName: Socket.EndDisconnect(IAsyncResult)\n- uid: System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndReceive(IAsyncResult)\n  nameWithType: Socket.EndReceive(IAsyncResult)\n  fullName: Socket.EndReceive(IAsyncResult)\n- uid: System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndReceive(IAsyncResult, SocketError)\n  nameWithType: Socket.EndReceive(IAsyncResult, SocketError)\n  fullName: Socket.EndReceive(IAsyncResult, SocketError)\n- uid: System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndReceiveFrom(IAsyncResult, EndPoint)\n  nameWithType: Socket.EndReceiveFrom(IAsyncResult, EndPoint)\n  fullName: Socket.EndReceiveFrom(IAsyncResult, EndPoint)\n- uid: System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndReceiveMessageFrom(IAsyncResult, SocketFlags, EndPoint, IPPacketInformation)\n  nameWithType: Socket.EndReceiveMessageFrom(IAsyncResult, SocketFlags, EndPoint, IPPacketInformation)\n  fullName: Socket.EndReceiveMessageFrom(IAsyncResult, SocketFlags, EndPoint, IPPacketInformation)\n- uid: System.Net.Sockets.IPPacketInformation\n  parent: System.Net.Sockets\n  isExternal: false\n  name: IPPacketInformation\n  nameWithType: IPPacketInformation\n  fullName: System.Net.Sockets.IPPacketInformation\n- uid: System.Net.Sockets.Socket.EndSend(System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndSend(IAsyncResult)\n  nameWithType: Socket.EndSend(IAsyncResult)\n  fullName: Socket.EndSend(IAsyncResult)\n- uid: System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndSend(IAsyncResult, SocketError)\n  nameWithType: Socket.EndSend(IAsyncResult, SocketError)\n  fullName: Socket.EndSend(IAsyncResult, SocketError)\n- uid: System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndSendFile(IAsyncResult)\n  nameWithType: Socket.EndSendFile(IAsyncResult)\n  fullName: Socket.EndSendFile(IAsyncResult)\n- uid: System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndSendTo(IAsyncResult)\n  nameWithType: Socket.EndSendTo(IAsyncResult)\n  fullName: Socket.EndSendTo(IAsyncResult)\n- uid: System.Net.Sockets.Socket.ExclusiveAddressUse\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ExclusiveAddressUse\n  nameWithType: Socket.ExclusiveAddressUse\n  fullName: Socket.ExclusiveAddressUse\n- uid: System.Net.Sockets.Socket.Finalize\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Finalize()\n  nameWithType: Socket.Finalize()\n  fullName: Socket.Finalize()\n- uid: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: GetSocketOption(SocketOptionLevel, SocketOptionName, Int32)\n  nameWithType: Socket.GetSocketOption(SocketOptionLevel, SocketOptionName, Int32)\n  fullName: Socket.GetSocketOption(SocketOptionLevel, SocketOptionName, Int32)\n- uid: System.Net.Sockets.SocketOptionLevel\n  parent: System.Net.Sockets\n  isExternal: false\n  name: SocketOptionLevel\n  nameWithType: SocketOptionLevel\n  fullName: System.Net.Sockets.SocketOptionLevel\n- uid: System.Net.Sockets.SocketOptionName\n  parent: System.Net.Sockets\n  isExternal: false\n  name: SocketOptionName\n  nameWithType: SocketOptionName\n  fullName: System.Net.Sockets.SocketOptionName\n- uid: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: GetSocketOption(SocketOptionLevel, SocketOptionName, Byte[])\n  nameWithType: Socket.GetSocketOption(SocketOptionLevel, SocketOptionName, Byte[])\n  fullName: Socket.GetSocketOption(SocketOptionLevel, SocketOptionName, Byte[])\n- uid: System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: GetSocketOption(SocketOptionLevel, SocketOptionName)\n  nameWithType: Socket.GetSocketOption(SocketOptionLevel, SocketOptionName)\n  fullName: Socket.GetSocketOption(SocketOptionLevel, SocketOptionName)\n- uid: System.Net.Sockets.Socket.Handle\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Handle\n  nameWithType: Socket.Handle\n  fullName: Socket.Handle\n- uid: System.IntPtr\n  parent: System\n  isExternal: false\n  name: IntPtr\n  nameWithType: IntPtr\n  fullName: System.IntPtr\n- uid: System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: IOControl(Int32, Byte[], Byte[])\n  nameWithType: Socket.IOControl(Int32, Byte[], Byte[])\n  fullName: Socket.IOControl(Int32, Byte[], Byte[])\n- uid: System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: IOControl(IOControlCode, Byte[], Byte[])\n  nameWithType: Socket.IOControl(IOControlCode, Byte[], Byte[])\n  fullName: Socket.IOControl(IOControlCode, Byte[], Byte[])\n- uid: System.Net.Sockets.IOControlCode\n  parent: System.Net.Sockets\n  isExternal: false\n  name: IOControlCode\n  nameWithType: IOControlCode\n  fullName: System.Net.Sockets.IOControlCode\n- uid: System.Net.Sockets.Socket.IsBound\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: IsBound\n  nameWithType: Socket.IsBound\n  fullName: Socket.IsBound\n- uid: System.Net.Sockets.Socket.LingerState\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: LingerState\n  nameWithType: Socket.LingerState\n  fullName: Socket.LingerState\n- uid: System.Net.Sockets.LingerOption\n  parent: System.Net.Sockets\n  isExternal: false\n  name: LingerOption\n  nameWithType: LingerOption\n  fullName: System.Net.Sockets.LingerOption\n- uid: System.Net.Sockets.Socket.Listen(System.Int32)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Listen(Int32)\n  nameWithType: Socket.Listen(Int32)\n  fullName: Socket.Listen(Int32)\n- uid: System.Net.Sockets.Socket.LocalEndPoint\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: LocalEndPoint\n  nameWithType: Socket.LocalEndPoint\n  fullName: Socket.LocalEndPoint\n- uid: System.Net.Sockets.Socket.MulticastLoopback\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: MulticastLoopback\n  nameWithType: Socket.MulticastLoopback\n  fullName: Socket.MulticastLoopback\n- uid: System.Net.Sockets.Socket.NoDelay\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: NoDelay\n  nameWithType: Socket.NoDelay\n  fullName: Socket.NoDelay\n- uid: System.Net.Sockets.Socket.OSSupportsIPv4\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: OSSupportsIPv4\n  nameWithType: Socket.OSSupportsIPv4\n  fullName: Socket.OSSupportsIPv4\n- uid: System.Net.Sockets.Socket.OSSupportsIPv6\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: OSSupportsIPv6\n  nameWithType: Socket.OSSupportsIPv6\n  fullName: Socket.OSSupportsIPv6\n- uid: System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Poll(Int32, SelectMode)\n  nameWithType: Socket.Poll(Int32, SelectMode)\n  fullName: Socket.Poll(Int32, SelectMode)\n- uid: System.Net.Sockets.SelectMode\n  parent: System.Net.Sockets\n  isExternal: false\n  name: SelectMode\n  nameWithType: SelectMode\n  fullName: System.Net.Sockets.SelectMode\n- uid: System.Net.Sockets.Socket.ProtocolType\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ProtocolType\n  nameWithType: Socket.ProtocolType\n  fullName: Socket.ProtocolType\n- uid: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Receive(Byte[], Int32, Int32, SocketFlags, SocketError)\n  nameWithType: Socket.Receive(Byte[], Int32, Int32, SocketFlags, SocketError)\n  fullName: Socket.Receive(Byte[], Int32, Int32, SocketFlags, SocketError)\n- uid: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Receive(Byte[], Int32, Int32, SocketFlags)\n  nameWithType: Socket.Receive(Byte[], Int32, Int32, SocketFlags)\n  fullName: Socket.Receive(Byte[], Int32, Int32, SocketFlags)\n- uid: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Receive(IList<ArraySegment<Byte>>, SocketFlags, SocketError)\n  nameWithType: Socket.Receive(IList<ArraySegment<Byte>>, SocketFlags, SocketError)\n  fullName: Socket.Receive(IList<ArraySegment<Byte>>, SocketFlags, SocketError)\n- uid: System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Receive(Byte[], Int32, SocketFlags)\n  nameWithType: Socket.Receive(Byte[], Int32, SocketFlags)\n  fullName: Socket.Receive(Byte[], Int32, SocketFlags)\n- uid: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Receive(IList<ArraySegment<Byte>>)\n  nameWithType: Socket.Receive(IList<ArraySegment<Byte>>)\n  fullName: Socket.Receive(IList<ArraySegment<Byte>>)\n- uid: System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Receive(Byte[], SocketFlags)\n  nameWithType: Socket.Receive(Byte[], SocketFlags)\n  fullName: Socket.Receive(Byte[], SocketFlags)\n- uid: System.Net.Sockets.Socket.Receive(System.Byte[])\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Receive(Byte[])\n  nameWithType: Socket.Receive(Byte[])\n  fullName: Socket.Receive(Byte[])\n- uid: System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Receive(IList<ArraySegment<Byte>>, SocketFlags)\n  nameWithType: Socket.Receive(IList<ArraySegment<Byte>>, SocketFlags)\n  fullName: Socket.Receive(IList<ArraySegment<Byte>>, SocketFlags)\n- uid: System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.ReceiveAsync(SocketAsyncEventArgs)\n  fullName: Socket.ReceiveAsync(SocketAsyncEventArgs)\n- uid: System.Net.Sockets.Socket.ReceiveBufferSize\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveBufferSize\n  nameWithType: Socket.ReceiveBufferSize\n  fullName: Socket.ReceiveBufferSize\n- uid: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveFrom(Byte[], EndPoint)\n  nameWithType: Socket.ReceiveFrom(Byte[], EndPoint)\n  fullName: Socket.ReceiveFrom(Byte[], EndPoint)\n- uid: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveFrom(Byte[], SocketFlags, EndPoint)\n  nameWithType: Socket.ReceiveFrom(Byte[], SocketFlags, EndPoint)\n  fullName: Socket.ReceiveFrom(Byte[], SocketFlags, EndPoint)\n- uid: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveFrom(Byte[], Int32, SocketFlags, EndPoint)\n  nameWithType: Socket.ReceiveFrom(Byte[], Int32, SocketFlags, EndPoint)\n  fullName: Socket.ReceiveFrom(Byte[], Int32, SocketFlags, EndPoint)\n- uid: System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveFrom(Byte[], Int32, Int32, SocketFlags, EndPoint)\n  nameWithType: Socket.ReceiveFrom(Byte[], Int32, Int32, SocketFlags, EndPoint)\n  fullName: Socket.ReceiveFrom(Byte[], Int32, Int32, SocketFlags, EndPoint)\n- uid: System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveFromAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.ReceiveFromAsync(SocketAsyncEventArgs)\n  fullName: Socket.ReceiveFromAsync(SocketAsyncEventArgs)\n- uid: System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveMessageFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, IPPacketInformation)\n  nameWithType: Socket.ReceiveMessageFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, IPPacketInformation)\n  fullName: Socket.ReceiveMessageFrom(Byte[], Int32, Int32, SocketFlags, EndPoint, IPPacketInformation)\n- uid: System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveMessageFromAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.ReceiveMessageFromAsync(SocketAsyncEventArgs)\n  fullName: Socket.ReceiveMessageFromAsync(SocketAsyncEventArgs)\n- uid: System.Net.Sockets.Socket.ReceiveTimeout\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveTimeout\n  nameWithType: Socket.ReceiveTimeout\n  fullName: Socket.ReceiveTimeout\n- uid: System.Net.Sockets.Socket.RemoteEndPoint\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: RemoteEndPoint\n  nameWithType: Socket.RemoteEndPoint\n  fullName: Socket.RemoteEndPoint\n- uid: System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Select(IList, IList, IList, Int32)\n  nameWithType: Socket.Select(IList, IList, IList, Int32)\n  fullName: Socket.Select(IList, IList, IList, Int32)\n- uid: System.Collections.IList\n  parent: System.Collections\n  isExternal: false\n  name: IList\n  nameWithType: IList\n  fullName: System.Collections.IList\n- uid: System.Net.Sockets.Socket.Send(System.Byte[])\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Send(Byte[])\n  nameWithType: Socket.Send(Byte[])\n  fullName: Socket.Send(Byte[])\n- uid: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Send(IList<ArraySegment<Byte>>)\n  nameWithType: Socket.Send(IList<ArraySegment<Byte>>)\n  fullName: Socket.Send(IList<ArraySegment<Byte>>)\n- uid: System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Send(Byte[], SocketFlags)\n  nameWithType: Socket.Send(Byte[], SocketFlags)\n  fullName: Socket.Send(Byte[], SocketFlags)\n- uid: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Send(IList<ArraySegment<Byte>>, SocketFlags)\n  nameWithType: Socket.Send(IList<ArraySegment<Byte>>, SocketFlags)\n  fullName: Socket.Send(IList<ArraySegment<Byte>>, SocketFlags)\n- uid: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Send(Byte[], Int32, SocketFlags)\n  nameWithType: Socket.Send(Byte[], Int32, SocketFlags)\n  fullName: Socket.Send(Byte[], Int32, SocketFlags)\n- uid: System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Send(IList<ArraySegment<Byte>>, SocketFlags, SocketError)\n  nameWithType: Socket.Send(IList<ArraySegment<Byte>>, SocketFlags, SocketError)\n  fullName: Socket.Send(IList<ArraySegment<Byte>>, SocketFlags, SocketError)\n- uid: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Send(Byte[], Int32, Int32, SocketFlags)\n  nameWithType: Socket.Send(Byte[], Int32, Int32, SocketFlags)\n  fullName: Socket.Send(Byte[], Int32, Int32, SocketFlags)\n- uid: System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Send(Byte[], Int32, Int32, SocketFlags, SocketError)\n  nameWithType: Socket.Send(Byte[], Int32, Int32, SocketFlags, SocketError)\n  fullName: Socket.Send(Byte[], Int32, Int32, SocketFlags, SocketError)\n- uid: System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.SendAsync(SocketAsyncEventArgs)\n  fullName: Socket.SendAsync(SocketAsyncEventArgs)\n- uid: System.Net.Sockets.Socket.SendBufferSize\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendBufferSize\n  nameWithType: Socket.SendBufferSize\n  fullName: Socket.SendBufferSize\n- uid: System.Net.Sockets.Socket.SendFile(System.String)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendFile(String)\n  nameWithType: Socket.SendFile(String)\n  fullName: Socket.SendFile(String)\n- uid: System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendFile(String, Byte[], Byte[], TransmitFileOptions)\n  nameWithType: Socket.SendFile(String, Byte[], Byte[], TransmitFileOptions)\n  fullName: Socket.SendFile(String, Byte[], Byte[], TransmitFileOptions)\n- uid: System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendPacketsAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.SendPacketsAsync(SocketAsyncEventArgs)\n  fullName: Socket.SendPacketsAsync(SocketAsyncEventArgs)\n- uid: System.Net.Sockets.Socket.SendTimeout\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendTimeout\n  nameWithType: Socket.SendTimeout\n  fullName: Socket.SendTimeout\n- uid: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendTo(Byte[], EndPoint)\n  nameWithType: Socket.SendTo(Byte[], EndPoint)\n  fullName: Socket.SendTo(Byte[], EndPoint)\n- uid: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendTo(Byte[], SocketFlags, EndPoint)\n  nameWithType: Socket.SendTo(Byte[], SocketFlags, EndPoint)\n  fullName: Socket.SendTo(Byte[], SocketFlags, EndPoint)\n- uid: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendTo(Byte[], Int32, SocketFlags, EndPoint)\n  nameWithType: Socket.SendTo(Byte[], Int32, SocketFlags, EndPoint)\n  fullName: Socket.SendTo(Byte[], Int32, SocketFlags, EndPoint)\n- uid: System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendTo(Byte[], Int32, Int32, SocketFlags, EndPoint)\n  nameWithType: Socket.SendTo(Byte[], Int32, Int32, SocketFlags, EndPoint)\n  fullName: Socket.SendTo(Byte[], Int32, Int32, SocketFlags, EndPoint)\n- uid: System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendToAsync(SocketAsyncEventArgs)\n  nameWithType: Socket.SendToAsync(SocketAsyncEventArgs)\n  fullName: Socket.SendToAsync(SocketAsyncEventArgs)\n- uid: System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SetIPProtectionLevel(IPProtectionLevel)\n  nameWithType: Socket.SetIPProtectionLevel(IPProtectionLevel)\n  fullName: Socket.SetIPProtectionLevel(IPProtectionLevel)\n- uid: System.Net.Sockets.IPProtectionLevel\n  parent: System.Net.Sockets\n  isExternal: false\n  name: IPProtectionLevel\n  nameWithType: IPProtectionLevel\n  fullName: System.Net.Sockets.IPProtectionLevel\n- uid: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SetSocketOption(SocketOptionLevel, SocketOptionName, Boolean)\n  nameWithType: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Boolean)\n  fullName: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Boolean)\n- uid: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SetSocketOption(SocketOptionLevel, SocketOptionName, Byte[])\n  nameWithType: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Byte[])\n  fullName: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Byte[])\n- uid: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SetSocketOption(SocketOptionLevel, SocketOptionName, Int32)\n  nameWithType: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Int32)\n  fullName: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Int32)\n- uid: System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SetSocketOption(SocketOptionLevel, SocketOptionName, Object)\n  nameWithType: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Object)\n  fullName: Socket.SetSocketOption(SocketOptionLevel, SocketOptionName, Object)\n- uid: System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Shutdown(SocketShutdown)\n  nameWithType: Socket.Shutdown(SocketShutdown)\n  fullName: Socket.Shutdown(SocketShutdown)\n- uid: System.Net.Sockets.SocketShutdown\n  parent: System.Net.Sockets\n  isExternal: false\n  name: SocketShutdown\n  nameWithType: SocketShutdown\n  fullName: System.Net.Sockets.SocketShutdown\n- uid: System.Net.Sockets.Socket.SocketType\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SocketType\n  nameWithType: Socket.SocketType\n  fullName: Socket.SocketType\n- uid: System.Net.Sockets.Socket.SupportsIPv4\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SupportsIPv4\n  nameWithType: Socket.SupportsIPv4\n  fullName: Socket.SupportsIPv4\n- uid: System.Net.Sockets.Socket.SupportsIPv6\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SupportsIPv6\n  nameWithType: Socket.SupportsIPv6\n  fullName: Socket.SupportsIPv6\n- uid: System.Net.Sockets.Socket.Ttl\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Ttl\n  nameWithType: Socket.Ttl\n  fullName: Socket.Ttl\n- uid: System.Int16\n  parent: System\n  isExternal: false\n  name: Int16\n  nameWithType: Int16\n  fullName: System.Int16\n- uid: System.Net.Sockets.Socket.UseOnlyOverlappedIO\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: UseOnlyOverlappedIO\n  nameWithType: Socket.UseOnlyOverlappedIO\n  fullName: Socket.UseOnlyOverlappedIO\n- uid: System.Net.Sockets.Socket.#ctor*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Socket\n  nameWithType: Socket.Socket\n  fullName: Socket.Socket\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  - netcore-1.0\n  - netcore-1.1\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Accept*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Accept\n  nameWithType: Socket.Accept\n  fullName: Socket.Accept\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.AcceptAsync*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: AcceptAsync\n  nameWithType: Socket.AcceptAsync\n  fullName: Socket.AcceptAsync\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.AddressFamily*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: AddressFamily\n  nameWithType: Socket.AddressFamily\n  fullName: Socket.AddressFamily\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Available*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Available\n  nameWithType: Socket.Available\n  fullName: Socket.Available\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.BeginAccept*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginAccept\n  nameWithType: Socket.BeginAccept\n  fullName: Socket.BeginAccept\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.BeginConnect*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginConnect\n  nameWithType: Socket.BeginConnect\n  fullName: Socket.BeginConnect\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.BeginDisconnect*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginDisconnect\n  nameWithType: Socket.BeginDisconnect\n  fullName: Socket.BeginDisconnect\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.BeginReceive*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginReceive\n  nameWithType: Socket.BeginReceive\n  fullName: Socket.BeginReceive\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.BeginReceiveFrom*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginReceiveFrom\n  nameWithType: Socket.BeginReceiveFrom\n  fullName: Socket.BeginReceiveFrom\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.BeginReceiveMessageFrom*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginReceiveMessageFrom\n  nameWithType: Socket.BeginReceiveMessageFrom\n  fullName: Socket.BeginReceiveMessageFrom\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.BeginSend*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginSend\n  nameWithType: Socket.BeginSend\n  fullName: Socket.BeginSend\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.BeginSendFile*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginSendFile\n  nameWithType: Socket.BeginSendFile\n  fullName: Socket.BeginSendFile\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.BeginSendTo*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: BeginSendTo\n  nameWithType: Socket.BeginSendTo\n  fullName: Socket.BeginSendTo\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Bind*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Bind\n  nameWithType: Socket.Bind\n  fullName: Socket.Bind\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Blocking*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Blocking\n  nameWithType: Socket.Blocking\n  fullName: Socket.Blocking\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.CancelConnectAsync*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: CancelConnectAsync\n  nameWithType: Socket.CancelConnectAsync\n  fullName: Socket.CancelConnectAsync\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Close*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Close\n  nameWithType: Socket.Close\n  fullName: Socket.Close\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Connect*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Connect\n  nameWithType: Socket.Connect\n  fullName: Socket.Connect\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.ConnectAsync*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ConnectAsync\n  nameWithType: Socket.ConnectAsync\n  fullName: Socket.ConnectAsync\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Connected*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Connected\n  nameWithType: Socket.Connected\n  fullName: Socket.Connected\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Disconnect*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Disconnect\n  nameWithType: Socket.Disconnect\n  fullName: Socket.Disconnect\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.DisconnectAsync*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: DisconnectAsync\n  nameWithType: Socket.DisconnectAsync\n  fullName: Socket.DisconnectAsync\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Dispose*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Dispose\n  nameWithType: Socket.Dispose\n  fullName: Socket.Dispose\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.DontFragment*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: DontFragment\n  nameWithType: Socket.DontFragment\n  fullName: Socket.DontFragment\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.DualMode*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: DualMode\n  nameWithType: Socket.DualMode\n  fullName: Socket.DualMode\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.DuplicateAndClose*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: DuplicateAndClose\n  nameWithType: Socket.DuplicateAndClose\n  fullName: Socket.DuplicateAndClose\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.EnableBroadcast*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EnableBroadcast\n  nameWithType: Socket.EnableBroadcast\n  fullName: Socket.EnableBroadcast\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.EndAccept*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndAccept\n  nameWithType: Socket.EndAccept\n  fullName: Socket.EndAccept\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.EndConnect*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndConnect\n  nameWithType: Socket.EndConnect\n  fullName: Socket.EndConnect\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.EndDisconnect*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndDisconnect\n  nameWithType: Socket.EndDisconnect\n  fullName: Socket.EndDisconnect\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.EndReceive*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndReceive\n  nameWithType: Socket.EndReceive\n  fullName: Socket.EndReceive\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.EndReceiveFrom*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndReceiveFrom\n  nameWithType: Socket.EndReceiveFrom\n  fullName: Socket.EndReceiveFrom\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.EndReceiveMessageFrom*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndReceiveMessageFrom\n  nameWithType: Socket.EndReceiveMessageFrom\n  fullName: Socket.EndReceiveMessageFrom\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.EndSend*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndSend\n  nameWithType: Socket.EndSend\n  fullName: Socket.EndSend\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.EndSendFile*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndSendFile\n  nameWithType: Socket.EndSendFile\n  fullName: Socket.EndSendFile\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.EndSendTo*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: EndSendTo\n  nameWithType: Socket.EndSendTo\n  fullName: Socket.EndSendTo\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.ExclusiveAddressUse*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ExclusiveAddressUse\n  nameWithType: Socket.ExclusiveAddressUse\n  fullName: Socket.ExclusiveAddressUse\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Finalize*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Finalize\n  nameWithType: Socket.Finalize\n  fullName: Socket.Finalize\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.GetSocketOption*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: GetSocketOption\n  nameWithType: Socket.GetSocketOption\n  fullName: Socket.GetSocketOption\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Handle*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Handle\n  nameWithType: Socket.Handle\n  fullName: Socket.Handle\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.IOControl*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: IOControl\n  nameWithType: Socket.IOControl\n  fullName: Socket.IOControl\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.IsBound*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: IsBound\n  nameWithType: Socket.IsBound\n  fullName: Socket.IsBound\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.LingerState*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: LingerState\n  nameWithType: Socket.LingerState\n  fullName: Socket.LingerState\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Listen*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Listen\n  nameWithType: Socket.Listen\n  fullName: Socket.Listen\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.LocalEndPoint*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: LocalEndPoint\n  nameWithType: Socket.LocalEndPoint\n  fullName: Socket.LocalEndPoint\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.MulticastLoopback*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: MulticastLoopback\n  nameWithType: Socket.MulticastLoopback\n  fullName: Socket.MulticastLoopback\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.NoDelay*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: NoDelay\n  nameWithType: Socket.NoDelay\n  fullName: Socket.NoDelay\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.OSSupportsIPv4*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: OSSupportsIPv4\n  nameWithType: Socket.OSSupportsIPv4\n  fullName: Socket.OSSupportsIPv4\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.OSSupportsIPv6*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: OSSupportsIPv6\n  nameWithType: Socket.OSSupportsIPv6\n  fullName: Socket.OSSupportsIPv6\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Poll*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Poll\n  nameWithType: Socket.Poll\n  fullName: Socket.Poll\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.ProtocolType*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ProtocolType\n  nameWithType: Socket.ProtocolType\n  fullName: Socket.ProtocolType\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Receive*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Receive\n  nameWithType: Socket.Receive\n  fullName: Socket.Receive\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.ReceiveAsync*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveAsync\n  nameWithType: Socket.ReceiveAsync\n  fullName: Socket.ReceiveAsync\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.ReceiveBufferSize*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveBufferSize\n  nameWithType: Socket.ReceiveBufferSize\n  fullName: Socket.ReceiveBufferSize\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.ReceiveFrom*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveFrom\n  nameWithType: Socket.ReceiveFrom\n  fullName: Socket.ReceiveFrom\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.ReceiveFromAsync*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveFromAsync\n  nameWithType: Socket.ReceiveFromAsync\n  fullName: Socket.ReceiveFromAsync\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.ReceiveMessageFrom*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveMessageFrom\n  nameWithType: Socket.ReceiveMessageFrom\n  fullName: Socket.ReceiveMessageFrom\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.ReceiveMessageFromAsync*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveMessageFromAsync\n  nameWithType: Socket.ReceiveMessageFromAsync\n  fullName: Socket.ReceiveMessageFromAsync\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.ReceiveTimeout*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: ReceiveTimeout\n  nameWithType: Socket.ReceiveTimeout\n  fullName: Socket.ReceiveTimeout\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.RemoteEndPoint*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: RemoteEndPoint\n  nameWithType: Socket.RemoteEndPoint\n  fullName: Socket.RemoteEndPoint\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Select*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Select\n  nameWithType: Socket.Select\n  fullName: Socket.Select\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Send*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Send\n  nameWithType: Socket.Send\n  fullName: Socket.Send\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.SendAsync*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendAsync\n  nameWithType: Socket.SendAsync\n  fullName: Socket.SendAsync\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.SendBufferSize*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendBufferSize\n  nameWithType: Socket.SendBufferSize\n  fullName: Socket.SendBufferSize\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.SendFile*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendFile\n  nameWithType: Socket.SendFile\n  fullName: Socket.SendFile\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.SendPacketsAsync*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendPacketsAsync\n  nameWithType: Socket.SendPacketsAsync\n  fullName: Socket.SendPacketsAsync\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.SendTimeout*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendTimeout\n  nameWithType: Socket.SendTimeout\n  fullName: Socket.SendTimeout\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.SendTo*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendTo\n  nameWithType: Socket.SendTo\n  fullName: Socket.SendTo\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.SendToAsync*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SendToAsync\n  nameWithType: Socket.SendToAsync\n  fullName: Socket.SendToAsync\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.SetIPProtectionLevel*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SetIPProtectionLevel\n  nameWithType: Socket.SetIPProtectionLevel\n  fullName: Socket.SetIPProtectionLevel\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.SetSocketOption*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SetSocketOption\n  nameWithType: Socket.SetSocketOption\n  fullName: Socket.SetSocketOption\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Shutdown*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Shutdown\n  nameWithType: Socket.Shutdown\n  fullName: Socket.Shutdown\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.SocketType*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SocketType\n  nameWithType: Socket.SocketType\n  fullName: Socket.SocketType\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.SupportsIPv4*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SupportsIPv4\n  nameWithType: Socket.SupportsIPv4\n  fullName: Socket.SupportsIPv4\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.SupportsIPv6*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: SupportsIPv6\n  nameWithType: Socket.SupportsIPv6\n  fullName: Socket.SupportsIPv6\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.Ttl*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: Ttl\n  nameWithType: Socket.Ttl\n  fullName: Socket.Ttl\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Net.Sockets.Socket.UseOnlyOverlappedIO*\n  parent: System.Net.Sockets.Socket\n  isExternal: false\n  name: UseOnlyOverlappedIO\n  nameWithType: Socket.UseOnlyOverlappedIO\n  fullName: Socket.UseOnlyOverlappedIO\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Net.Sockets/Socket.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.Net.Sockets.SocketTaskExtensions.AcceptAsync(System.Net.Sockets.Socket)\n  parent: System.Net.Sockets.SocketTaskExtensions\n  isExternal: false\n  name: AcceptAsync(Socket)\n  nameWithType: SocketTaskExtensions.AcceptAsync(Socket)\n  fullName: SocketTaskExtensions.AcceptAsync(Socket)\n- uid: System.Net.Sockets.SocketTaskExtensions.AcceptAsync(System.Net.Sockets.Socket,System.Net.Sockets.Socket)\n  parent: System.Net.Sockets.SocketTaskExtensions\n  isExternal: false\n  name: AcceptAsync(Socket, Socket)\n  nameWithType: SocketTaskExtensions.AcceptAsync(Socket, Socket)\n  fullName: SocketTaskExtensions.AcceptAsync(Socket, Socket)\n- uid: System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.Net.EndPoint)\n  parent: System.Net.Sockets.SocketTaskExtensions\n  isExternal: false\n  name: ConnectAsync(Socket, EndPoint)\n  nameWithType: SocketTaskExtensions.ConnectAsync(Socket, EndPoint)\n  fullName: SocketTaskExtensions.ConnectAsync(Socket, EndPoint)\n- uid: System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.Net.IPAddress,System.Int32)\n  parent: System.Net.Sockets.SocketTaskExtensions\n  isExternal: false\n  name: ConnectAsync(Socket, IPAddress, Int32)\n  nameWithType: SocketTaskExtensions.ConnectAsync(Socket, IPAddress, Int32)\n  fullName: SocketTaskExtensions.ConnectAsync(Socket, IPAddress, Int32)\n- uid: System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.Net.IPAddress[],System.Int32)\n  parent: System.Net.Sockets.SocketTaskExtensions\n  isExternal: false\n  name: ConnectAsync(Socket, IPAddress[], Int32)\n  nameWithType: SocketTaskExtensions.ConnectAsync(Socket, IPAddress[], Int32)\n  fullName: SocketTaskExtensions.ConnectAsync(Socket, IPAddress[], Int32)\n- uid: System.Net.Sockets.SocketTaskExtensions.ConnectAsync(System.Net.Sockets.Socket,System.String,System.Int32)\n  parent: System.Net.Sockets.SocketTaskExtensions\n  isExternal: false\n  name: ConnectAsync(Socket, String, Int32)\n  nameWithType: SocketTaskExtensions.ConnectAsync(Socket, String, Int32)\n  fullName: SocketTaskExtensions.ConnectAsync(Socket, String, Int32)\n- uid: System.Net.Sockets.SocketTaskExtensions.ReceiveAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.SocketTaskExtensions\n  isExternal: false\n  name: ReceiveAsync(Socket, ArraySegment<Byte>, SocketFlags)\n  nameWithType: SocketTaskExtensions.ReceiveAsync(Socket, ArraySegment<Byte>, SocketFlags)\n  fullName: SocketTaskExtensions.ReceiveAsync(Socket, ArraySegment<Byte>, SocketFlags)\n- uid: System.Net.Sockets.SocketTaskExtensions.ReceiveAsync(System.Net.Sockets.Socket,System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.SocketTaskExtensions\n  isExternal: false\n  name: ReceiveAsync(Socket, IList<ArraySegment<Byte>>, SocketFlags)\n  nameWithType: SocketTaskExtensions.ReceiveAsync(Socket, IList<ArraySegment<Byte>>, SocketFlags)\n  fullName: SocketTaskExtensions.ReceiveAsync(Socket, IList<ArraySegment<Byte>>, SocketFlags)\n- uid: System.Net.Sockets.SocketTaskExtensions.ReceiveFromAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  parent: System.Net.Sockets.SocketTaskExtensions\n  isExternal: false\n  name: ReceiveFromAsync(Socket, ArraySegment<Byte>, SocketFlags, EndPoint)\n  nameWithType: SocketTaskExtensions.ReceiveFromAsync(Socket, ArraySegment<Byte>, SocketFlags, EndPoint)\n  fullName: SocketTaskExtensions.ReceiveFromAsync(Socket, ArraySegment<Byte>, SocketFlags, EndPoint)\n- uid: System.Net.Sockets.SocketTaskExtensions.ReceiveMessageFromAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  parent: System.Net.Sockets.SocketTaskExtensions\n  isExternal: false\n  name: ReceiveMessageFromAsync(Socket, ArraySegment<Byte>, SocketFlags, EndPoint)\n  nameWithType: SocketTaskExtensions.ReceiveMessageFromAsync(Socket, ArraySegment<Byte>, SocketFlags, EndPoint)\n  fullName: SocketTaskExtensions.ReceiveMessageFromAsync(Socket, ArraySegment<Byte>, SocketFlags, EndPoint)\n- uid: System.Net.Sockets.SocketTaskExtensions.SendAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.SocketTaskExtensions\n  isExternal: false\n  name: SendAsync(Socket, ArraySegment<Byte>, SocketFlags)\n  nameWithType: SocketTaskExtensions.SendAsync(Socket, ArraySegment<Byte>, SocketFlags)\n  fullName: SocketTaskExtensions.SendAsync(Socket, ArraySegment<Byte>, SocketFlags)\n- uid: System.Net.Sockets.SocketTaskExtensions.SendAsync(System.Net.Sockets.Socket,System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)\n  parent: System.Net.Sockets.SocketTaskExtensions\n  isExternal: false\n  name: SendAsync(Socket, IList<ArraySegment<Byte>>, SocketFlags)\n  nameWithType: SocketTaskExtensions.SendAsync(Socket, IList<ArraySegment<Byte>>, SocketFlags)\n  fullName: SocketTaskExtensions.SendAsync(Socket, IList<ArraySegment<Byte>>, SocketFlags)\n- uid: System.Net.Sockets.SocketTaskExtensions.SendToAsync(System.Net.Sockets.Socket,System.ArraySegment{System.Byte},System.Net.Sockets.SocketFlags,System.Net.EndPoint)\n  parent: System.Net.Sockets.SocketTaskExtensions\n  isExternal: false\n  name: SendToAsync(Socket, ArraySegment<Byte>, SocketFlags, EndPoint)\n  nameWithType: SocketTaskExtensions.SendToAsync(Socket, ArraySegment<Byte>, SocketFlags, EndPoint)\n  fullName: SocketTaskExtensions.SendToAsync(Socket, ArraySegment<Byte>, SocketFlags, EndPoint)\n- uid: System.IDisposable\n  parent: System\n  isExternal: false\n  name: IDisposable\n  nameWithType: IDisposable\n  fullName: System.IDisposable\n"}