{"nodes":[{"content":"Represents an object that handles the low-level work of queuing tasks onto threads.","nodes":[{"pos":[0,83],"content":"Represents an object that handles the low-level work of queuing tasks onto threads.","nodes":[{"content":"Represents an object that handles the low-level work of queuing tasks onto threads.","pos":[0,83]}]}],"pos":[1240,1324],"yaml":true},{"content":"An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler. A task scheduler ensures that the work of a task is eventually executed.  \n  \n The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance. It should be sufficient for most scenarios.  \n  \n The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.  This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers. If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.  \n  \n In this topic:  \n[The default task scheduler and the thread pool](#Default)  \n [The global queue vs. local queues](#Queues)  \n [Work stealing](#Stealing)  \n [Long-running tasks](#LongRunning)  \n [Task inlining](#Inlining)  \n[Specifying a synchronization context](#Sync)  \n  \n<a name=\"Default\"></a>   \n## The default task scheduler and the thread pool  \n The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work. The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.  \n  \n<a name=\"Queues\"></a>   \n### The global queue vs. local queues  \n The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain. Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=fullName> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=fullName>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available. Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class. By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items. This performance benefit is available to all programs that use the thread pool.  \n  \n Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item. However, nested or child tasks, which are created in the context of another task, are handled quite differently. A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing. The parent task may be a top-level task or it also may be the child of another task. When this thread is ready for more work, it first looks in the local queue. If work items are waiting there, they can be accessed quickly. The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention. For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  \n  \n The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality. Work items in the local queue frequently reference data structures that are physically near one another in memory. In these cases, the data is already in the cache after the first task has run and can be accessed quickly. Both [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.  \n  \n<a name=\"Stealing\"></a>   \n### Work stealing  \n Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues. When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads. If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently. If it can, it de-queues the work item from the tail (in FIFO order). This reduces contention on each local queue and preserves data locality. This architecture helps the  thread pool load-balance work more efficiently than past versions did.  \n  \n<a name=\"LongRunning\"></a>   \n### Long-running tasks  \n You may want to explicitly prevent a task from being put on a local queue. For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue. In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue. By using this option you avoid the thread pool completely, including the global and local queues.  \n  \n<a name=\"Inlining\"></a>   \n### Task inlining  \n In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation. This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise. To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.  \n  \n<a name=\"Sync\"></a>   \n## Specifying a synchronization context  \n You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=fullName> method to specify that a task should be scheduled to run on a particular thread. This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created. For more information, see How to: Schedule Work on the User Interface (UI) Thread.  \n  \n The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=fullName> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.   The example creates a mosaic of images that are randomly selected from a specified directory. The WPF objects are used to load and resize the images. The raw pixels are then passed to a task that uses a `For` loop to write the pixel data into a large single-byte array. No synchronization is required because no two tiles occupy the same array elements. The tiles can also be written in any order because their position is calculated independently of any other tile. The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.  \n  \n The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread. This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast. Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=fullName> control and add images to it. The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles. However, this work can only be performed on the UI thread.  \n  \n [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]\n [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  \n  \n To create the example, crate a WPF application project in Visual Studio and assign it a name of your choice. Then do the following:  \n  \n1.  In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** to the design surface. In XAML view, specify the horizontal alignment as \"Left.\" The size does not matter because the control is be dynamically resized at run time. Accept the default name, \"image\".  \n  \n2.  Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window. Double-click the button to add a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event handler. In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as \"Make a Mosaic\" and specify its horizontal alignment as \"Left\". Accept the default name, \"button\".  \n  \n3.  Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example. Make sure that the name of the workspace matches the project name.  \n  \n4.  The example reads JPEG images from a directory named C:\\Users\\Public\\Pictures\\Sample Pictures\\\\. Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.  \n  \n This example has some limitations. For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation. Also, the source images must all be larger than the tile size. As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.","nodes":[{"pos":[0,170],"content":"An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler. A task scheduler ensures that the work of a task is eventually executed.","nodes":[{"content":"An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler. A task scheduler ensures that the work of a task is eventually executed.","pos":[0,170],"nodes":[{"content":"An instance of the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> class represents a task scheduler.","pos":[0,97],"source":"An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler."},{"content":"A task scheduler ensures that the work of a task is eventually executed.","pos":[98,170]}]}]},{"pos":[177,424],"content":"The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance. It should be sufficient for most scenarios.","nodes":[{"content":"The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance. It should be sufficient for most scenarios.","pos":[0,247],"nodes":[{"content":"The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.","pos":[0,203]},{"content":"It should be sufficient for most scenarios.","pos":[204,247]}]}]},{"pos":[431,803],"content":"The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.  This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers. If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.","nodes":[{"content":"The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.  This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers. If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.","pos":[0,372],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> class also serves as the extension point for all customizable scheduling logic.","pos":[0,127],"source":"The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic."},{"content":"This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.","pos":[129,255]},{"content":"If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.","pos":[256,372]}]}]},{"pos":[810,1079],"content":"In this topic:  \n[The default task scheduler and the thread pool](#Default)  \n [The global queue vs. local queues](#Queues)  \n [Work stealing](#Stealing)  \n [Long-running tasks](#LongRunning)  \n [Task inlining](#Inlining)  \n[Specifying a synchronization context](#Sync)","nodes":[{"content":"In this topic:","pos":[0,14]},{"content":"<bpt id=\"p1\">[</bpt>The default task scheduler and the thread pool<ept id=\"p1\">](#Default)</ept>","pos":[17,75],"source":"[The default task scheduler and the thread pool](#Default)"},{"content":"<bpt id=\"p1\"> [</bpt>The global queue vs. local queues<ept id=\"p1\">](#Queues)</ept>","pos":[78,123],"source":" [The global queue vs. local queues](#Queues)"},{"content":"<bpt id=\"p1\"> [</bpt>Work stealing<ept id=\"p1\">](#Stealing)</ept>","pos":[126,153],"source":" [Work stealing](#Stealing)"},{"content":"<bpt id=\"p1\"> [</bpt>Long-running tasks<ept id=\"p1\">](#LongRunning)</ept>","pos":[156,191],"source":" [Long-running tasks](#LongRunning)"},{"content":"<bpt id=\"p1\"> [</bpt>Task inlining<ept id=\"p1\">](#Inlining)</ept>","pos":[194,221],"source":" [Task inlining](#Inlining)"},{"content":"<bpt id=\"p1\">[</bpt>Specifying a synchronization context<ept id=\"p1\">](#Sync)</ept>","pos":[224,269],"source":"[Specifying a synchronization context](#Sync)"}]},{"pos":[1114,1160],"content":"The default task scheduler and the thread pool","linkify":"The default task scheduler and the thread pool","nodes":[{"content":"The default task scheduler and the thread pool","pos":[0,46]}]},{"pos":[1164,1593],"content":"The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work. The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.","nodes":[{"content":"The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work. The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.","pos":[0,429],"nodes":[{"content":"The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool&gt;</ph> class, to queue and execute work.","pos":[0,195],"source":"The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work."},{"content":"The thread pool uses the information that is provided by the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.","pos":[196,429],"source":" The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent."}]}]},{"pos":[1628,1661],"content":"The global queue vs. local queues","linkify":"The global queue vs. local queues","nodes":[{"content":"The global queue vs. local queues","pos":[0,33]}]},{"pos":[1665,2465],"content":"The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain. Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=fullName> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=fullName>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available. Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class. By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items. This performance benefit is available to all programs that use the thread pool.","nodes":[{"content":"The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain. Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=fullName> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=fullName>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available. Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class. By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items. This performance benefit is available to all programs that use the thread pool.","pos":[0,800],"nodes":[{"content":"The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.","pos":[0,112]},{"content":"Whenever a program calls the <ph id=\"ph1\">&lt;xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=fullName&gt;</ph> (or <ph id=\"ph2\">&lt;xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=fullName&gt;</ph>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.","pos":[113,429],"source":" Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=fullName> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=fullName>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available."},{"content":"Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <ph id=\"ph1\">&lt;xref:System.Collections.Concurrent.ConcurrentQueue%601&gt;</ph> class.","pos":[430,606],"source":" Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class."},{"content":"By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.","pos":[607,720]},{"content":"This performance benefit is available to all programs that use the thread pool.","pos":[721,800]}]}]},{"pos":[2472,3358],"content":"Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item. However, nested or child tasks, which are created in the context of another task, are handled quite differently. A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing. The parent task may be a top-level task or it also may be the child of another task. When this thread is ready for more work, it first looks in the local queue. If work items are waiting there, they can be accessed quickly. The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention. For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).","nodes":[{"content":"Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.","pos":[0,144]},{"content":"However, nested or child tasks, which are created in the context of another task, are handled quite differently.","pos":[145,257]},{"content":"A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.","pos":[258,374]},{"content":"The parent task may be a top-level task or it also may be the child of another task.","pos":[375,459]},{"content":"When this thread is ready for more work, it first looks in the local queue.","pos":[460,535]},{"content":"If work items are waiting there, they can be accessed quickly.","pos":[536,598]},{"content":"The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.","pos":[599,713]},{"content":"For more information about child tasks and nested tasks, see <bpt id=\"p1\">[</bpt>Attached and Detached Child Tasks<ept id=\"p1\">](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)</ept>.","pos":[714,886],"source":" For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md)."}]},{"pos":[3365,3954],"content":"The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality. Work items in the local queue frequently reference data structures that are physically near one another in memory. In these cases, the data is already in the cache after the first task has run and can be accessed quickly. Both [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.","nodes":[{"content":"The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.","pos":[0,113]},{"content":"Work items in the local queue frequently reference data structures that are physically near one another in memory.","pos":[114,228]},{"content":"In these cases, the data is already in the cache after the first task has run and can be accessed quickly.","pos":[229,335]},{"content":"Both <bpt id=\"p1\">[</bpt>Parallel LINQ (PLINQ)<ept id=\"p1\">](~/docs/standard/parallel-programming/parallel-linq-plinq.md)</ept> and the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Parallel&gt;</ph> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.","pos":[336,589],"source":" Both [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues."}]},{"pos":[3991,4004],"content":"Work stealing","linkify":"Work stealing","nodes":[{"content":"Work stealing","pos":[0,13]}]},{"pos":[4008,4749],"content":"Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues. When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads. If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently. If it can, it de-queues the work item from the tail (in FIFO order). This reduces contention on each local queue and preserves data locality. This architecture helps the  thread pool load-balance work more efficiently than past versions did.","nodes":[{"content":"Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues. When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads. If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently. If it can, it de-queues the work item from the tail (in FIFO order). This reduces contention on each local queue and preserves data locality. This architecture helps the  thread pool load-balance work more efficiently than past versions did.","pos":[0,741],"nodes":[{"content":"Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.","pos":[0,188]},{"content":"When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.","pos":[189,358]},{"content":"If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.","pos":[359,499]},{"content":"If it can, it de-queues the work item from the tail (in FIFO order).","pos":[500,568]},{"content":"This reduces contention on each local queue and preserves data locality.","pos":[569,641]},{"content":"This architecture helps the  thread pool load-balance work more efficiently than past versions did.","pos":[642,741]}]}]},{"pos":[4789,4807],"content":"Long-running tasks","linkify":"Long-running tasks","nodes":[{"content":"Long-running tasks","pos":[0,18]}]},{"pos":[4811,5448],"content":"You may want to explicitly prevent a task from being put on a local queue. For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue. In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue. By using this option you avoid the thread pool completely, including the global and local queues.","nodes":[{"content":"You may want to explicitly prevent a task from being put on a local queue. For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue. In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue. By using this option you avoid the thread pool completely, including the global and local queues.","pos":[0,637],"nodes":[{"content":"You may want to explicitly prevent a task from being put on a local queue.","pos":[0,74]},{"content":"For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.","pos":[75,228]},{"content":"In this case, you can specify the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName&gt;</ph> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.","pos":[229,539],"source":" In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue."},{"content":"By using this option you avoid the thread pool completely, including the global and local queues.","pos":[540,637]}]}]},{"pos":[5485,5498],"content":"Task inlining","linkify":"Task inlining","nodes":[{"content":"Task inlining","pos":[0,13]}]},{"pos":[5502,5938],"content":"In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation. This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise. To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.","nodes":[{"content":"In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation. This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise. To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.","pos":[0,436],"nodes":[{"content":"In some cases when a <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> is waited on, it may be executed synchronously on the thread that is performing the wait operation.","pos":[0,155],"source":"In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation."},{"content":"This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.","pos":[156,304]},{"content":"To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.","pos":[305,436]}]}]},{"pos":[5970,6006],"content":"Specifying a synchronization context","linkify":"Specifying a synchronization context","nodes":[{"content":"Specifying a synchronization context","pos":[0,36]}]},{"pos":[6010,6520],"content":"You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=fullName> method to specify that a task should be scheduled to run on a particular thread. This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created. For more information, see How to: Schedule Work on the User Interface (UI) Thread.","nodes":[{"content":"You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=fullName> method to specify that a task should be scheduled to run on a particular thread. This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created. For more information, see How to: Schedule Work on the User Interface (UI) Thread.","pos":[0,510],"nodes":[{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=fullName&gt;</ph> method to specify that a task should be scheduled to run on a particular thread.","pos":[0,202],"source":"You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=fullName> method to specify that a task should be scheduled to run on a particular thread."},{"content":"This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.","pos":[203,427]},{"content":"For more information, see How to: Schedule Work on the User Interface (UI) Thread.","pos":[428,510]}]}]},{"pos":[6527,7400],"content":"The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=fullName> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.   The example creates a mosaic of images that are randomly selected from a specified directory. The WPF objects are used to load and resize the images. The raw pixels are then passed to a task that uses a `For` loop to write the pixel data into a large single-byte array. No synchronization is required because no two tiles occupy the same array elements. The tiles can also be written in any order because their position is calculated independently of any other tile. The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.","nodes":[{"content":"The following example uses the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=fullName&gt;</ph> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.","pos":[0,281],"source":"The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=fullName> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on."},{"content":"The example creates a mosaic of images that are randomly selected from a specified directory.","pos":[284,377]},{"content":"The WPF objects are used to load and resize the images.","pos":[378,433]},{"content":"The raw pixels are then passed to a task that uses a <ph id=\"ph1\">`For`</ph> loop to write the pixel data into a large single-byte array.","pos":[434,553],"source":" The raw pixels are then passed to a task that uses a `For` loop to write the pixel data into a large single-byte array."},{"content":"No synchronization is required because no two tiles occupy the same array elements.","pos":[554,637]},{"content":"The tiles can also be written in any order because their position is calculated independently of any other tile.","pos":[638,750]},{"content":"The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.","pos":[751,873]}]},{"pos":[7407,8063],"content":"The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread. This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast. Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=fullName> control and add images to it. The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles. However, this work can only be performed on the UI thread.","nodes":[{"content":"The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread. This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast. Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=fullName> control and add images to it. The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles. However, this work can only be performed on the UI thread.","pos":[0,656],"nodes":[{"content":"The example moves data off the UI thread, modifies it by using parallel loops and <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> objects, and then passes it back to a task that runs on the UI thread.","pos":[0,187],"source":"The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread."},{"content":"This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.","pos":[188,356]},{"content":"Another way to create an image mosaic in WPF is to use a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.WrapPanel?displayProperty=fullName&gt;</ph> control and add images to it.","pos":[357,509],"source":" Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=fullName> control and add images to it."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Controls.WrapPanel&gt;</ph> handles the work of positioning the tiles.","pos":[510,597],"source":" The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles."},{"content":"However, this work can only be performed on the UI thread.","pos":[598,656]}]}]},{"pos":[8070,8311],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>TPL_SyncContext#01<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>TPL_SyncContext#01<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]\n [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]"},{"pos":[8318,8449],"content":"To create the example, crate a WPF application project in Visual Studio and assign it a name of your choice. Then do the following:","nodes":[{"content":"To create the example, crate a WPF application project in Visual Studio and assign it a name of your choice. Then do the following:","pos":[0,131],"nodes":[{"content":"To create the example, crate a WPF application project in Visual Studio and assign it a name of your choice.","pos":[0,108]},{"content":"Then do the following:","pos":[109,131]}]}]},{"pos":[8459,8747],"content":"In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** to the design surface. In XAML view, specify the horizontal alignment as \"Left.\" The size does not matter because the control is be dynamically resized at run time. Accept the default name, \"image\".","nodes":[{"content":"In design view, drag an <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Image&gt;</ph> control from the <bpt id=\"p1\">**</bpt>Toolbox<ept id=\"p1\">**</ept> to the design surface.","pos":[0,112],"source":"In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** to the design surface."},{"content":"In XAML view, specify the horizontal alignment as \"Left.\"","pos":[113,170]},{"content":"The size does not matter because the control is be dynamically resized at run time.","pos":[171,254]},{"content":"Accept the default name, \"image\".","pos":[255,288]}]},{"pos":[8757,9195],"content":"Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window. Double-click the button to add a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event handler. In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as \"Make a Mosaic\" and specify its horizontal alignment as \"Left\". Accept the default name, \"button\".","nodes":[{"content":"Drag a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Button&gt;</ph> control from the <bpt id=\"p1\">**</bpt>Toolbox<ept id=\"p1\">**</ept> to the lower left part of the application window.","pos":[0,123],"source":"Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window."},{"content":"Double-click the button to add a <ph id=\"ph1\">&lt;xref:System.Windows.Controls.Primitives.ButtonBase.Click&gt;</ph> event handler.","pos":[124,230],"source":" Double-click the button to add a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event handler."},{"content":"In XAML view, specify the <ph id=\"ph1\">&lt;xref:System.Windows.Controls.ContentControl.Content%2A&gt;</ph> property of the button as \"Make a Mosaic\" and specify its horizontal alignment as \"Left\".","pos":[231,403],"source":" In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as \"Make a Mosaic\" and specify its horizontal alignment as \"Left\"."},{"content":"Accept the default name, \"button\".","pos":[404,438]}]},{"pos":[9205,9385],"content":"Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example. Make sure that the name of the workspace matches the project name.","nodes":[{"content":"Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example. Make sure that the name of the workspace matches the project name.","pos":[0,180],"nodes":[{"content":"Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.","pos":[0,113]},{"content":"Make sure that the name of the workspace matches the project name.","pos":[114,180]}]}]},{"pos":[9395,9622],"content":"The example reads JPEG images from a directory named C:\\Users\\Public\\Pictures\\Sample Pictures\\\\. Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.","nodes":[{"content":"The example reads JPEG images from a directory named C:\\Users\\Public\\Pictures\\Sample Pictures\\\\. Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.","pos":[0,227],"nodes":[{"content":"The example reads JPEG images from a directory named C:\\Users\\Public\\Pictures\\Sample Pictures<ph id=\"ph1\">\\\\</ph>.","pos":[0,96],"source":"The example reads JPEG images from a directory named C:\\Users\\Public\\Pictures\\Sample Pictures\\\\."},{"content":"Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.","pos":[97,227]}]}]},{"pos":[9629,10013],"content":"This example has some limitations. For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation. Also, the source images must all be larger than the tile size. As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.","nodes":[{"content":"This example has some limitations. For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation. Also, the source images must all be larger than the tile size. As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.","pos":[0,384],"nodes":[{"content":"This example has some limitations.","pos":[0,34]},{"content":"For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.BitmapImage&gt;</ph> object during the resizing operation.","pos":[35,223],"source":" For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation."},{"content":"Also, the source images must all be larger than the tile size.","pos":[224,286]},{"content":"As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.","pos":[287,384]}]}]}],"pos":[1335,11438],"yaml":true,"extradata":"MT"},{"content":"Initializes the <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref>.","nodes":[{"pos":[0,74],"content":"Initializes the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.TaskScheduler\"&gt;&lt;/xref&gt;</ph>.","source":"Initializes the <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref>."}],"pos":[14185,14260],"yaml":true},{"content":"Gets the <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> associated with the currently executing task.","nodes":[{"pos":[0,112],"content":"Gets the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.TaskScheduler\"&gt;&lt;/xref&gt;</ph> associated with the currently executing task.","source":"Gets the <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> associated with the currently executing task."}],"pos":[15874,15987],"yaml":true},{"content":"When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler.  \n  \n For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).","nodes":[{"pos":[0,172],"content":"When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler.","nodes":[{"content":"When not called from within a task, <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler.Current%2A&gt;</ph> will return the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskScheduler.Default%2A&gt;</ph> scheduler.","pos":[0,172],"source":"When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler."}]},{"pos":[179,295],"content":"For more information, see <bpt id=\"p1\">[</bpt>Task Schedulers<ept id=\"p1\">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.","source":"For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)."}],"pos":[15998,16298],"yaml":true,"extradata":"MT"},{"content":"Returns the <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> associated with the currently executing task.","nodes":[{"pos":[0,115],"content":"Returns the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.TaskScheduler\"&gt;&lt;/xref&gt;</ph> associated with the currently executing task.","source":"Returns the <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> associated with the currently executing task."}],"pos":[16469,16585],"yaml":true},{"content":"Gets the default <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> instance that is provided by the .NET Framework.","nodes":[{"pos":[0,123],"content":"Gets the default <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.TaskScheduler\"&gt;&lt;/xref&gt;</ph> instance that is provided by the .NET Framework.","source":"Gets the default <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> instance that is provided by the .NET Framework."}],"pos":[18131,18255],"yaml":true},{"content":"For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).","nodes":[{"pos":[0,116],"content":"For more information, see <bpt id=\"p1\">[</bpt>Task Schedulers<ept id=\"p1\">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.","source":"For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)."}],"pos":[18266,18383],"yaml":true,"extradata":"MT"},{"content":"Returns the default <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> instance.","nodes":[{"pos":[0,87],"content":"Returns the default <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.TaskScheduler\"&gt;&lt;/xref&gt;</ph> instance.","source":"Returns the default <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> instance."}],"pos":[18554,18642],"yaml":true},{"content":"Creates a <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> associated with the current <xref href=\"System.Threading.SynchronizationContext\"></xref>.","nodes":[{"pos":[0,157],"content":"Creates a <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.TaskScheduler\"&gt;&lt;/xref&gt;</ph> associated with the current <ph id=\"ph2\">&lt;xref href=\"System.Threading.SynchronizationContext\"&gt;&lt;/xref&gt;</ph>.","source":"Creates a <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> associated with the current <xref href=\"System.Threading.SynchronizationContext\"></xref>."}],"pos":[20348,20506],"yaml":true},{"content":"All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context.  \n  \n For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).","nodes":[{"pos":[0,199],"content":"All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context.","nodes":[{"content":"All <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances queued to the returned scheduler will be executed through a call to the <ph id=\"ph2\">&lt;xref:System.Threading.SynchronizationContext.Post%2A&gt;</ph> method on that context.","pos":[0,199],"source":"All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context."}]},{"pos":[206,322],"content":"For more information, see <bpt id=\"p1\">[</bpt>Task Schedulers<ept id=\"p1\">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.","source":"For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)."}],"pos":[20517,20844],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> associated with the current <xref href=\"System.Threading.SynchronizationContext\"></xref>, as determined by <xref href=\"System.Threading.SynchronizationContext.Current\"></xref>.","nodes":[{"pos":[0,236],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.TaskScheduler\"&gt;&lt;/xref&gt;</ph> associated with the current <ph id=\"ph2\">&lt;xref href=\"System.Threading.SynchronizationContext\"&gt;&lt;/xref&gt;</ph>, as determined by <ph id=\"ph3\">&lt;xref href=\"System.Threading.SynchronizationContext.Current\"&gt;&lt;/xref&gt;</ph>.","source":"A <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> associated with the current <xref href=\"System.Threading.SynchronizationContext\"></xref>, as determined by <xref href=\"System.Threading.SynchronizationContext.Current\"></xref>."}],"pos":[21055,21292],"yaml":true},{"content":"The current SynchronizationContext may not be used as a TaskScheduler.","nodes":[{"pos":[0,70],"content":"The current SynchronizationContext may not be used as a TaskScheduler.","nodes":[{"content":"The current SynchronizationContext may not be used as a TaskScheduler.","pos":[0,70]}]}],"pos":[21500,21571],"yaml":true},{"content":"For debugger support only, generates an enumerable of <xref href=\"System.Threading.Tasks.Task\"></xref> instances currently queued to the scheduler waiting to be executed.","nodes":[{"pos":[0,170],"content":"For debugger support only, generates an enumerable of <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.Task\"&gt;&lt;/xref&gt;</ph> instances currently queued to the scheduler waiting to be executed.","source":"For debugger support only, generates an enumerable of <xref href=\"System.Threading.Tasks.Task\"></xref> instances currently queued to the scheduler waiting to be executed."}],"pos":[23106,23277],"yaml":true},{"content":"A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers. This method will only be invoked by the .NET Framework when the debugger requests access to the data. The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.  \n  \n It is important to note that, when this method is called, all other threads in the process will be frozen. Therefore, it's important to avoid synchronization with other threads that may lead to blocking. If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang. The following example shows one possible approach in C#:  \n  \n```  \nprotected override IEnumerable<Task> GetScheduledTasks()  \n{  \n    bool lockTaken = false;  \n    try  \n    {  \n        Monitor.TryEnter(_syncObj, ref lockTaken);  \n        if (lockTaken)  \n        {  \n            return _tasks.ToArray();  \n        }  \n        else throw new NotSupportedException();  \n    }  \n    finally  \n    {  \n    if (lockTaken) Monitor.Exit(_syncObj);  \n    }}  \n```  \n  \n Additionally, this method and the enumerable returned must not modify any globally visible state.  \n  \n The returned enumerable should never be null. If there are currently no queued tasks, an empty enumerable should be returned instead.  \n  \n Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`. This wrapper method returns an array of tasks instead of an enumerable. To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`. This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances. You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks.","nodes":[{"pos":[0,451],"content":"A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers. This method will only be invoked by the .NET Framework when the debugger requests access to the data. The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.","nodes":[{"content":"A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers. This method will only be invoked by the .NET Framework when the debugger requests access to the data. The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.","pos":[0,451],"nodes":[{"content":"A class derived from <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this method in order to support integration with debuggers.","pos":[0,135],"source":"A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers."},{"content":"This method will only be invoked by the .NET Framework when the debugger requests access to the data.","pos":[136,237]},{"content":"The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.","pos":[238,451]}]}]},{"pos":[458,877],"content":"It is important to note that, when this method is called, all other threads in the process will be frozen. Therefore, it's important to avoid synchronization with other threads that may lead to blocking. If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang. The following example shows one possible approach in C#:","nodes":[{"content":"It is important to note that, when this method is called, all other threads in the process will be frozen. Therefore, it's important to avoid synchronization with other threads that may lead to blocking. If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang. The following example shows one possible approach in C#:","pos":[0,419],"nodes":[{"content":"It is important to note that, when this method is called, all other threads in the process will be frozen.","pos":[0,106]},{"content":"Therefore, it's important to avoid synchronization with other threads that may lead to blocking.","pos":[107,203]},{"content":"If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang.","pos":[204,362]},{"content":"The following example shows one possible approach in C#:","pos":[363,419]}]}]},{"pos":[1285,1382],"content":"Additionally, this method and the enumerable returned must not modify any globally visible state.","nodes":[{"content":"Additionally, this method and the enumerable returned must not modify any globally visible state.","pos":[0,97]}]},{"pos":[1389,1522],"content":"The returned enumerable should never be null. If there are currently no queued tasks, an empty enumerable should be returned instead.","nodes":[{"content":"The returned enumerable should never be null. If there are currently no queued tasks, an empty enumerable should be returned instead.","pos":[0,133],"nodes":[{"content":"The returned enumerable should never be null.","pos":[0,45]},{"content":"If there are currently no queued tasks, an empty enumerable should be returned instead.","pos":[46,133]}]}]},{"pos":[1529,2171],"content":"Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`. This wrapper method returns an array of tasks instead of an enumerable. To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`. This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances. You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks.","nodes":[{"content":"Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method <ph id=\"ph1\">`GetScheduledTasksForDebugger`</ph> instead: <ph id=\"ph2\">`internal Task[] GetScheduledTasksForDebugger()`</ph>.","pos":[0,218],"source":"Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`."},{"content":"This wrapper method returns an array of tasks instead of an enumerable.","pos":[219,290]},{"content":"To retrieve a list of active schedulers, use the internal method <ph id=\"ph1\">`internal static TaskScheduler[] GetTaskSchedulersForDebugger()`</ph>.","pos":[291,421],"source":" To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`."},{"content":"This static method returns an array of all active <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> instances.","pos":[422,526],"source":" This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances."},{"content":"You can then use <ph id=\"ph1\">`GetScheduledTasksForDebugger`</ph> on each scheduler instance to retrieve its list of scheduled tasks.","pos":[527,642],"source":" You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks."}]}],"pos":[23288,25489],"yaml":true,"extradata":"MT"},{"content":"An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.","nodes":[{"pos":[0,94],"content":"An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.","nodes":[{"content":"An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.","pos":[0,94]}]}],"pos":[25802,25897],"yaml":true},{"content":"This scheduler is unable to generate a list of queued tasks at this time.","nodes":[{"pos":[0,73],"content":"This scheduler is unable to generate a list of queued tasks at this time.","nodes":[{"content":"This scheduler is unable to generate a list of queued tasks at this time.","pos":[0,73]}]}],"pos":[26081,26155],"yaml":true},{"content":"Gets the unique ID for this <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref>.","nodes":[{"pos":[0,86],"content":"Gets the unique ID for this <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.TaskScheduler\"&gt;&lt;/xref&gt;</ph>.","source":"Gets the unique ID for this <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref>."}],"pos":[27662,27749],"yaml":true},{"content":"For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).","nodes":[{"pos":[0,116],"content":"For more information, see <bpt id=\"p1\">[</bpt>Task Schedulers<ept id=\"p1\">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.","source":"For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)."}],"pos":[27760,27877],"yaml":true,"extradata":"MT"},{"content":"Returns the unique ID for this <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref>.","nodes":[{"pos":[0,89],"content":"Returns the unique ID for this <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.TaskScheduler\"&gt;&lt;/xref&gt;</ph>.","source":"Returns the unique ID for this <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref>."}],"pos":[27979,28069],"yaml":true},{"content":"Indicates the maximum concurrency level this <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> is able to support.","nodes":[{"pos":[0,122],"content":"Indicates the maximum concurrency level this <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.TaskScheduler\"&gt;&lt;/xref&gt;</ph> is able to support.","source":"Indicates the maximum concurrency level this <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> is able to support."}],"pos":[29706,29829],"yaml":true},{"content":"For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).","nodes":[{"pos":[0,116],"content":"For more information, see <bpt id=\"p1\">[</bpt>Task Schedulers<ept id=\"p1\">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.","source":"For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)."}],"pos":[29840,29957],"yaml":true,"extradata":"MT"},{"content":"Returns an integer that represents the maximum concurrency level. The default scheduler returns <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,139],"content":"Returns an integer that represents the maximum concurrency level. The default scheduler returns <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"content":"Returns an integer that represents the maximum concurrency level.","pos":[0,65]},{"content":"The default scheduler returns <ph id=\"ph1\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","pos":[66,139],"source":" The default scheduler returns <xref href=\"System.Int32.MaxValue\"></xref>."}]}],"pos":[30088,30228],"yaml":true},{"content":"Queues a <xref href=\"System.Threading.Tasks.Task\"></xref> to the scheduler.","nodes":[{"pos":[0,75],"content":"Queues a <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.Task\"&gt;&lt;/xref&gt;</ph> to the scheduler.","source":"Queues a <xref href=\"System.Threading.Tasks.Task\"></xref> to the scheduler."}],"pos":[31905,31981],"yaml":true},{"content":"A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler.  \n  \n A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.  \n  \n This method is only meant to be called by the .NET Framework and should not be called directly by the derived class. This is necessary for maintaining the consistency of the system.","nodes":[{"pos":[0,137],"content":"A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler.","nodes":[{"content":"A class derived from <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this method to accept tasks being scheduled on the scheduler.","pos":[0,137],"source":"A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler."}]},{"pos":[144,314],"content":"A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.","nodes":[{"content":"A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.","pos":[0,170]}]},{"pos":[321,502],"content":"This method is only meant to be called by the .NET Framework and should not be called directly by the derived class. This is necessary for maintaining the consistency of the system.","nodes":[{"content":"This method is only meant to be called by the .NET Framework and should not be called directly by the derived class. This is necessary for maintaining the consistency of the system.","pos":[0,181],"nodes":[{"content":"This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.","pos":[0,116]},{"content":"This is necessary for maintaining the consistency of the system.","pos":[117,181]}]}]}],"pos":[31992,32501],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Threading.Tasks.Task\"></xref> to be queued.","nodes":[{"pos":[0,66],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.Task\"&gt;&lt;/xref&gt;</ph> to be queued.","source":"The <xref href=\"System.Threading.Tasks.Task\"></xref> to be queued."}],"pos":[32735,32802],"yaml":true},{"content":"The <code>task</code> argument is null.","nodes":[{"pos":[0,39],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">task</ph><ept id=\"p1\">&lt;/code&gt;</ept> argument is null.","source":"The <code>task</code> argument is null."}],"pos":[32978,33018],"yaml":true},{"content":"Attempts to dequeue a <xref href=\"System.Threading.Tasks.Task\"></xref> that was previously queued to this scheduler.","nodes":[{"pos":[0,116],"content":"Attempts to dequeue a <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.Task\"&gt;&lt;/xref&gt;</ph> that was previously queued to this scheduler.","source":"Attempts to dequeue a <xref href=\"System.Threading.Tasks.Task\"></xref> that was previously queued to this scheduler."}],"pos":[34676,34793],"yaml":true},{"content":"For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  \n  \n This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner.","nodes":[{"pos":[0,116],"content":"For more information, see <bpt id=\"p1\">[</bpt>Task Schedulers<ept id=\"p1\">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.","source":"For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)."},{"pos":[123,347],"content":"This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner.","nodes":[{"content":"This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <ph id=\"ph1\">&lt;xref:System.Threading.CancellationTokenRegistration&gt;</ph> objects can be disposed of in a timely manner.","pos":[0,224],"source":"This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner."}]}],"pos":[34804,35156],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Threading.Tasks.Task\"></xref> to be dequeued.","nodes":[{"pos":[0,68],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.Task\"&gt;&lt;/xref&gt;</ph> to be dequeued.","source":"The <xref href=\"System.Threading.Tasks.Task\"></xref> to be dequeued."}],"pos":[35390,35459],"yaml":true},{"content":"A Boolean denoting whether the <code>task</code> argument was successfully dequeued.","nodes":[{"pos":[0,84],"content":"A Boolean denoting whether the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">task</ph><ept id=\"p1\">&lt;/code&gt;</ept> argument was successfully dequeued.","source":"A Boolean denoting whether the <code>task</code> argument was successfully dequeued."}],"pos":[35517,35602],"yaml":true},{"content":"The <code>task</code> argument is null.","nodes":[{"pos":[0,39],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">task</ph><ept id=\"p1\">&lt;/code&gt;</ept> argument is null.","source":"The <code>task</code> argument is null."}],"pos":[35779,35819],"yaml":true},{"content":"Attempts to execute the provided <xref href=\"System.Threading.Tasks.Task\"></xref> on this scheduler.","nodes":[{"pos":[0,100],"content":"Attempts to execute the provided <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.Task\"&gt;&lt;/xref&gt;</ph> on this scheduler.","source":"Attempts to execute the provided <xref href=\"System.Threading.Tasks.Task\"></xref> on this scheduler."}],"pos":[37501,37602],"yaml":true},{"content":"Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method. When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so. TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.  \n  \n <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure. It should not be used to execute arbitrary tasks obtained through custom mechanisms.","nodes":[{"pos":[0,568],"content":"Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method. When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so. TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.","nodes":[{"content":"Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method. When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so. TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.","pos":[0,568],"nodes":[{"content":"Scheduler implementations are provided with <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.Task&gt;</ph> instances to be executed through either the <ph id=\"ph2\">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> method or the <ph id=\"ph3\">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A&gt;</ph> method.","pos":[0,269],"source":"Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method."},{"content":"When the scheduler deems it appropriate to run the provided task, <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> should be used to do so.","pos":[270,422],"source":" When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so."},{"content":"TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.","pos":[423,568]}]}]},{"pos":[575,814],"content":"<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure. It should not be used to execute arbitrary tasks obtained through custom mechanisms.","nodes":[{"content":"<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure. It should not be used to execute arbitrary tasks obtained through custom mechanisms.","pos":[0,239],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.","pos":[0,154],"source":"<xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure."},{"content":"It should not be used to execute arbitrary tasks obtained through custom mechanisms.","pos":[155,239]}]}]}],"pos":[37613,38432],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Threading.Tasks.Task\"></xref> object to be executed.","nodes":[{"pos":[0,73],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.Task\"&gt;&lt;/xref&gt;</ph> object to be executed.","source":"A <xref href=\"System.Threading.Tasks.Task\"></xref> object to be executed."}],"pos":[38662,38736],"yaml":true},{"content":"A Boolean that is true if <code>task</code> was successfully executed, false if it was not. A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.","nodes":[{"pos":[0,233],"content":"A Boolean that is true if <code>task</code> was successfully executed, false if it was not. A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.","nodes":[{"content":"A Boolean that is true if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">task</ph><ept id=\"p1\">&lt;/code&gt;</ept> was successfully executed, false if it was not.","pos":[0,91],"source":"A Boolean that is true if <code>task</code> was successfully executed, false if it was not."},{"content":"A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.","pos":[92,233]}]}],"pos":[38794,39028],"yaml":true},{"content":"The <code>task</code> is not associated with this scheduler.","nodes":[{"pos":[0,60],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">task</ph><ept id=\"p1\">&lt;/code&gt;</ept> is not associated with this scheduler.","source":"The <code>task</code> is not associated with this scheduler."}],"pos":[39217,39278],"yaml":true},{"content":"Determines whether the provided <xref href=\"System.Threading.Tasks.Task\"></xref> can be executed synchronously in this call, and if it can, executes it.","nodes":[{"pos":[0,152],"content":"Determines whether the provided <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.Task\"&gt;&lt;/xref&gt;</ph> can be executed synchronously in this call, and if it can, executes it.","source":"Determines whether the provided <xref href=\"System.Threading.Tasks.Task\"></xref> can be executed synchronously in this call, and if it can, executes it."}],"pos":[41068,41221],"yaml":true},{"content":"A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object. Inline execution is optional, and the request may be rejected by returning false. However, the more tasks that can be inlined, the better the scheduler will scale. In fact, a scheduler that inlines too little may be prone to deadlocks. A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline. For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.  \n  \n If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value. It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request. Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.  \n  \n The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.  \n  \n For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).","nodes":[{"pos":[0,678],"content":"A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object. Inline execution is optional, and the request may be rejected by returning false. However, the more tasks that can be inlined, the better the scheduler will scale. In fact, a scheduler that inlines too little may be prone to deadlocks. A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline. For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.","nodes":[{"content":"A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object. Inline execution is optional, and the request may be rejected by returning false. However, the more tasks that can be inlined, the better the scheduler will scale. In fact, a scheduler that inlines too little may be prone to deadlocks. A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline. For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.","pos":[0,678],"nodes":[{"content":"A class derived from <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler&gt;</ph> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.","pos":[0,182],"source":"A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object."},{"content":"Inline execution is optional, and the request may be rejected by returning false.","pos":[183,264]},{"content":"However, the more tasks that can be inlined, the better the scheduler will scale.","pos":[265,346]},{"content":"In fact, a scheduler that inlines too little may be prone to deadlocks.","pos":[347,418]},{"content":"A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.","pos":[419,553]},{"content":"For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.","pos":[554,678]}]}]},{"pos":[685,1275],"content":"If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value. It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request. Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.","nodes":[{"content":"If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value. It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request. Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.","pos":[0,590],"nodes":[{"content":"If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A&gt;</ph> method with the provided task object, propagating the return value.","pos":[0,240],"source":"If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value."},{"content":"It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.","pos":[241,390]},{"content":"Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A&gt;</ph> method.","pos":[391,590],"source":" Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method."}]}]},{"pos":[1282,1466],"content":"The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.","nodes":[{"content":"The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.","pos":[0,184]}]},{"pos":[1473,1589],"content":"For more information, see <bpt id=\"p1\">[</bpt>Task Schedulers<ept id=\"p1\">](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)</ept>.","source":"For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65)."}],"pos":[41232,42830],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Threading.Tasks.Task\"></xref> to be executed.","nodes":[{"pos":[0,68],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.Tasks.Task\"&gt;&lt;/xref&gt;</ph> to be executed.","source":"The <xref href=\"System.Threading.Tasks.Task\"></xref> to be executed."}],"pos":[43105,43174],"yaml":true},{"content":"A Boolean denoting whether or not task has previously been queued. If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.","nodes":[{"pos":[0,294],"content":"A Boolean denoting whether or not task has previously been queued. If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.","nodes":[{"content":"A Boolean denoting whether or not task has previously been queued. If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.","pos":[0,294],"nodes":[{"content":"A Boolean denoting whether or not task has previously been queued.","pos":[0,66]},{"content":"If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.","pos":[67,294]}]}]}],"pos":[43254,43549],"yaml":true},{"content":"A Boolean value indicating whether the task was executed inline.","nodes":[{"pos":[0,64],"content":"A Boolean value indicating whether the task was executed inline.","nodes":[{"content":"A Boolean value indicating whether the task was executed inline.","pos":[0,64]}]}],"pos":[43607,43672],"yaml":true},{"content":"The <code>task</code> argument is null.","nodes":[{"pos":[0,39],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">task</ph><ept id=\"p1\">&lt;/code&gt;</ept> argument is null.","source":"The <code>task</code> argument is null."}],"pos":[43859,43899],"yaml":true},{"content":"The <code>task</code> was already executed.","nodes":[{"pos":[0,43],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">task</ph><ept id=\"p1\">&lt;/code&gt;</ept> was already executed.","source":"The <code>task</code> was already executed."}],"pos":[44009,44053],"yaml":true},{"content":"Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.","nodes":[{"pos":[0,146],"content":"Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.","nodes":[{"content":"Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.","pos":[0,146]}]}],"pos":[45683,45830],"yaml":true},{"content":"This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.  \n  \n To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions. Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default. Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception. This behavior can be configured. Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the  configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:  \n  \n```xml  \n<configuration>   \n   <runtime>   \n      <ThrowUnobservedTaskExceptions enabled=\"true\"/>   \n   </runtime>   \n</configuration>  \n  \n```","nodes":[{"pos":[0,155],"content":"This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.","nodes":[{"content":"This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.","pos":[0,155]}]},{"pos":[162,914],"content":"To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions. Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default. Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception. This behavior can be configured. Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the  configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:","nodes":[{"content":"To make it easier for developers to write asynchronous code based on tasks, the <ph id=\"ph1\">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph> changes the default exception behavior for unobserved exceptions.","pos":[0,191],"source":"To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions."},{"content":"Although unobserved exceptions still raise the <ph id=\"ph1\">&lt;xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException&gt;</ph> exception, the process does not terminate by default.","pos":[192,360],"source":" Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default."},{"content":"Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.","pos":[361,499]},{"content":"This behavior can be configured.","pos":[500,532]},{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v45](~/includes/net-v45-md.md)]</ph>, you can use the  configuration element to revert to the behavior of the <ph id=\"ph2\">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph> and terminate the process:","pos":[533,752],"source":" Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the  configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:"}]}],"pos":[45841,46920],"yaml":true,"extradata":"MT"}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.Tasks.TaskScheduler\n  commentId: T:System.Threading.Tasks.TaskScheduler\n  id: TaskScheduler\n  children:\n  - System.Threading.Tasks.TaskScheduler.#ctor\n  - System.Threading.Tasks.TaskScheduler.Current\n  - System.Threading.Tasks.TaskScheduler.Default\n  - System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext\n  - System.Threading.Tasks.TaskScheduler.GetScheduledTasks\n  - System.Threading.Tasks.TaskScheduler.Id\n  - System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel\n  - System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)\n  - System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)\n  - System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)\n  - System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)\n  - System.Threading.Tasks.TaskScheduler.UnobservedTaskException\n  langs:\n  - csharp\n  name: TaskScheduler\n  nameWithType: TaskScheduler\n  fullName: System.Threading.Tasks.TaskScheduler\n  type: Class\n  assemblies:\n  - System.Threading.Tasks\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading.Tasks\n  summary: Represents an object that handles the low-level work of queuing tasks onto threads.\n  remarks: \"An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler. A task scheduler ensures that the work of a task is eventually executed.  \\n  \\n The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance. It should be sufficient for most scenarios.  \\n  \\n The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.  This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers. If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.  \\n  \\n In this topic:  \\n[The default task scheduler and the thread pool](#Default)  \\n [The global queue vs. local queues](#Queues)  \\n [Work stealing](#Stealing)  \\n [Long-running tasks](#LongRunning)  \\n [Task inlining](#Inlining)  \\n[Specifying a synchronization context](#Sync)  \\n  \\n<a name=\\\"Default\\\"></a>   \\n## The default task scheduler and the thread pool  \\n The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work. The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.  \\n  \\n<a name=\\\"Queues\\\"></a>   \\n### The global queue vs. local queues  \\n The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain. Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=fullName> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=fullName>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available. Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class. By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items. This performance benefit is available to all programs that use the thread pool.  \\n  \\n Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item. However, nested or child tasks, which are created in the context of another task, are handled quite differently. A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing. The parent task may be a top-level task or it also may be the child of another task. When this thread is ready for more work, it first looks in the local queue. If work items are waiting there, they can be accessed quickly. The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention. For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).  \\n  \\n The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality. Work items in the local queue frequently reference data structures that are physically near one another in memory. In these cases, the data is already in the cache after the first task has run and can be accessed quickly. Both [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.  \\n  \\n<a name=\\\"Stealing\\\"></a>   \\n### Work stealing  \\n Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues. When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads. If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently. If it can, it de-queues the work item from the tail (in FIFO order). This reduces contention on each local queue and preserves data locality. This architecture helps the  thread pool load-balance work more efficiently than past versions did.  \\n  \\n<a name=\\\"LongRunning\\\"></a>   \\n### Long-running tasks  \\n You may want to explicitly prevent a task from being put on a local queue. For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue. In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=fullName> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue. By using this option you avoid the thread pool completely, including the global and local queues.  \\n  \\n<a name=\\\"Inlining\\\"></a>   \\n### Task inlining  \\n In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation. This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise. To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.  \\n  \\n<a name=\\\"Sync\\\"></a>   \\n## Specifying a synchronization context  \\n You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=fullName> method to specify that a task should be scheduled to run on a particular thread. This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created. For more information, see How to: Schedule Work on the User Interface (UI) Thread.  \\n  \\n The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=fullName> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.   The example creates a mosaic of images that are randomly selected from a specified directory. The WPF objects are used to load and resize the images. The raw pixels are then passed to a task that uses a `For` loop to write the pixel data into a large single-byte array. No synchronization is required because no two tiles occupy the same array elements. The tiles can also be written in any order because their position is calculated independently of any other tile. The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.  \\n  \\n The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread. This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast. Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=fullName> control and add images to it. The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles. However, this work can only be performed on the UI thread.  \\n  \\n [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]\\n [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  \\n  \\n To create the example, crate a WPF application project in Visual Studio and assign it a name of your choice. Then do the following:  \\n  \\n1.  In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** to the design surface. In XAML view, specify the horizontal alignment as \\\"Left.\\\" The size does not matter because the control is be dynamically resized at run time. Accept the default name, \\\"image\\\".  \\n  \\n2.  Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window. Double-click the button to add a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event handler. In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as \\\"Make a Mosaic\\\" and specify its horizontal alignment as \\\"Left\\\". Accept the default name, \\\"button\\\".  \\n  \\n3.  Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example. Make sure that the name of the workspace matches the project name.  \\n  \\n4.  The example reads JPEG images from a directory named C:\\\\Users\\\\Public\\\\Pictures\\\\Sample Pictures\\\\\\\\. Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.  \\n  \\n This example has some limitations. For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation. Also, the source images must all be larger than the tile size. As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.\"\n  example:\n  - \"The following example is taken from the [Samples for Parallel Programming with the .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717) on the MSDN Code Gallery Web site.  It creates a custom task scheduler that limits the number of threads used by the app. It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.  \\n  \\n [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]\\n [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  \\n  \\n In addition, several sample task schedulers are available on Code Gallery: [Samples for Parallel Programming with the .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717).\"\n  syntax:\n    content: public abstract class TaskScheduler\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Tasks.TaskScheduler.#ctor\n  commentId: M:System.Threading.Tasks.TaskScheduler.#ctor\n  id: '#ctor'\n  parent: System.Threading.Tasks.TaskScheduler\n  langs:\n  - csharp\n  name: TaskScheduler()\n  nameWithType: TaskScheduler.TaskScheduler()\n  fullName: TaskScheduler.TaskScheduler()\n  type: Constructor\n  assemblies:\n  - System.Threading.Tasks\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading.Tasks\n  summary: Initializes the <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref>.\n  syntax:\n    content: protected TaskScheduler ();\n    parameters: []\n  overload: System.Threading.Tasks.TaskScheduler.#ctor*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Tasks.TaskScheduler.Current\n  commentId: P:System.Threading.Tasks.TaskScheduler.Current\n  id: Current\n  parent: System.Threading.Tasks.TaskScheduler\n  langs:\n  - csharp\n  name: Current\n  nameWithType: TaskScheduler.Current\n  fullName: TaskScheduler.Current\n  type: Property\n  assemblies:\n  - System.Threading.Tasks\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading.Tasks\n  summary: Gets the <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> associated with the currently executing task.\n  remarks: \"When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler.  \\n  \\n For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).\"\n  syntax:\n    content: public static System.Threading.Tasks.TaskScheduler Current { get; }\n    return:\n      type: System.Threading.Tasks.TaskScheduler\n      description: Returns the <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> associated with the currently executing task.\n  overload: System.Threading.Tasks.TaskScheduler.Current*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Tasks.TaskScheduler.Default\n  commentId: P:System.Threading.Tasks.TaskScheduler.Default\n  id: Default\n  parent: System.Threading.Tasks.TaskScheduler\n  langs:\n  - csharp\n  name: Default\n  nameWithType: TaskScheduler.Default\n  fullName: TaskScheduler.Default\n  type: Property\n  assemblies:\n  - System.Threading.Tasks\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading.Tasks\n  summary: Gets the default <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> instance that is provided by the .NET Framework.\n  remarks: For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).\n  syntax:\n    content: public static System.Threading.Tasks.TaskScheduler Default { get; }\n    return:\n      type: System.Threading.Tasks.TaskScheduler\n      description: Returns the default <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> instance.\n  overload: System.Threading.Tasks.TaskScheduler.Default*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext\n  commentId: M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext\n  id: FromCurrentSynchronizationContext\n  parent: System.Threading.Tasks.TaskScheduler\n  langs:\n  - csharp\n  name: FromCurrentSynchronizationContext()\n  nameWithType: TaskScheduler.FromCurrentSynchronizationContext()\n  fullName: TaskScheduler.FromCurrentSynchronizationContext()\n  type: Method\n  assemblies:\n  - System.Threading.Tasks\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading.Tasks\n  summary: Creates a <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> associated with the current <xref href=\"System.Threading.SynchronizationContext\"></xref>.\n  remarks: \"All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context.  \\n  \\n For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).\"\n  syntax:\n    content: public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();\n    parameters: []\n    return:\n      type: System.Threading.Tasks.TaskScheduler\n      description: A <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> associated with the current <xref href=\"System.Threading.SynchronizationContext\"></xref>, as determined by <xref href=\"System.Threading.SynchronizationContext.Current\"></xref>.\n  overload: System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current SynchronizationContext may not be used as a TaskScheduler.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Tasks.TaskScheduler.GetScheduledTasks\n  commentId: M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks\n  id: GetScheduledTasks\n  parent: System.Threading.Tasks.TaskScheduler\n  langs:\n  - csharp\n  name: GetScheduledTasks()\n  nameWithType: TaskScheduler.GetScheduledTasks()\n  fullName: TaskScheduler.GetScheduledTasks()\n  type: Method\n  assemblies:\n  - System.Threading.Tasks\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading.Tasks\n  summary: For debugger support only, generates an enumerable of <xref href=\"System.Threading.Tasks.Task\"></xref> instances currently queued to the scheduler waiting to be executed.\n  remarks: \"A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers. This method will only be invoked by the .NET Framework when the debugger requests access to the data. The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.  \\n  \\n It is important to note that, when this method is called, all other threads in the process will be frozen. Therefore, it's important to avoid synchronization with other threads that may lead to blocking. If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang. The following example shows one possible approach in C#:  \\n  \\n```  \\nprotected override IEnumerable<Task> GetScheduledTasks()  \\n{  \\n    bool lockTaken = false;  \\n    try  \\n    {  \\n        Monitor.TryEnter(_syncObj, ref lockTaken);  \\n        if (lockTaken)  \\n        {  \\n            return _tasks.ToArray();  \\n        }  \\n        else throw new NotSupportedException();  \\n    }  \\n    finally  \\n    {  \\n    if (lockTaken) Monitor.Exit(_syncObj);  \\n    }}  \\n```  \\n  \\n Additionally, this method and the enumerable returned must not modify any globally visible state.  \\n  \\n The returned enumerable should never be null. If there are currently no queued tasks, an empty enumerable should be returned instead.  \\n  \\n Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`. This wrapper method returns an array of tasks instead of an enumerable. To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`. This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances. You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      protected abstract System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task> GetScheduledTasks ();\n    parameters: []\n    return:\n      type: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task}\n      description: An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.\n  overload: System.Threading.Tasks.TaskScheduler.GetScheduledTasks*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: This scheduler is unable to generate a list of queued tasks at this time.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Tasks.TaskScheduler.Id\n  commentId: P:System.Threading.Tasks.TaskScheduler.Id\n  id: Id\n  parent: System.Threading.Tasks.TaskScheduler\n  langs:\n  - csharp\n  name: Id\n  nameWithType: TaskScheduler.Id\n  fullName: TaskScheduler.Id\n  type: Property\n  assemblies:\n  - System.Threading.Tasks\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading.Tasks\n  summary: Gets the unique ID for this <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref>.\n  remarks: For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).\n  syntax:\n    content: public int Id { get; }\n    return:\n      type: System.Int32\n      description: Returns the unique ID for this <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref>.\n  overload: System.Threading.Tasks.TaskScheduler.Id*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel\n  commentId: P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel\n  id: MaximumConcurrencyLevel\n  parent: System.Threading.Tasks.TaskScheduler\n  langs:\n  - csharp\n  name: MaximumConcurrencyLevel\n  nameWithType: TaskScheduler.MaximumConcurrencyLevel\n  fullName: TaskScheduler.MaximumConcurrencyLevel\n  type: Property\n  assemblies:\n  - System.Threading.Tasks\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading.Tasks\n  summary: Indicates the maximum concurrency level this <xref href=\"System.Threading.Tasks.TaskScheduler\"></xref> is able to support.\n  remarks: For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).\n  syntax:\n    content: public virtual int MaximumConcurrencyLevel { get; }\n    return:\n      type: System.Int32\n      description: Returns an integer that represents the maximum concurrency level. The default scheduler returns <xref href=\"System.Int32.MaxValue\"></xref>.\n  overload: System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)\n  commentId: M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)\n  id: QueueTask(System.Threading.Tasks.Task)\n  parent: System.Threading.Tasks.TaskScheduler\n  langs:\n  - csharp\n  name: QueueTask(Task)\n  nameWithType: TaskScheduler.QueueTask(Task)\n  fullName: TaskScheduler.QueueTask(Task)\n  type: Method\n  assemblies:\n  - System.Threading.Tasks\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading.Tasks\n  summary: Queues a <xref href=\"System.Threading.Tasks.Task\"></xref> to the scheduler.\n  remarks: \"A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler.  \\n  \\n A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.  \\n  \\n This method is only meant to be called by the .NET Framework and should not be called directly by the derived class. This is necessary for maintaining the consistency of the system.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      protected abstract void QueueTask (System.Threading.Tasks.Task task);\n    parameters:\n    - id: task\n      type: System.Threading.Tasks.Task\n      description: The <xref href=\"System.Threading.Tasks.Task\"></xref> to be queued.\n  overload: System.Threading.Tasks.TaskScheduler.QueueTask*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>task</code> argument is null.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)\n  commentId: M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)\n  id: TryDequeue(System.Threading.Tasks.Task)\n  parent: System.Threading.Tasks.TaskScheduler\n  langs:\n  - csharp\n  name: TryDequeue(Task)\n  nameWithType: TaskScheduler.TryDequeue(Task)\n  fullName: TaskScheduler.TryDequeue(Task)\n  type: Method\n  assemblies:\n  - System.Threading.Tasks\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading.Tasks\n  summary: Attempts to dequeue a <xref href=\"System.Threading.Tasks.Task\"></xref> that was previously queued to this scheduler.\n  remarks: \"For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).  \\n  \\n This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      protected virtual bool TryDequeue (System.Threading.Tasks.Task task);\n    parameters:\n    - id: task\n      type: System.Threading.Tasks.Task\n      description: The <xref href=\"System.Threading.Tasks.Task\"></xref> to be dequeued.\n    return:\n      type: System.Boolean\n      description: A Boolean denoting whether the <code>task</code> argument was successfully dequeued.\n  overload: System.Threading.Tasks.TaskScheduler.TryDequeue*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>task</code> argument is null.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)\n  commentId: M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)\n  id: TryExecuteTask(System.Threading.Tasks.Task)\n  parent: System.Threading.Tasks.TaskScheduler\n  langs:\n  - csharp\n  name: TryExecuteTask(Task)\n  nameWithType: TaskScheduler.TryExecuteTask(Task)\n  fullName: TaskScheduler.TryExecuteTask(Task)\n  type: Method\n  assemblies:\n  - System.Threading.Tasks\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading.Tasks\n  summary: Attempts to execute the provided <xref href=\"System.Threading.Tasks.Task\"></xref> on this scheduler.\n  remarks: \"Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method. When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so. TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.  \\n  \\n <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure. It should not be used to execute arbitrary tasks obtained through custom mechanisms.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      protected bool TryExecuteTask (System.Threading.Tasks.Task task);\n    parameters:\n    - id: task\n      type: System.Threading.Tasks.Task\n      description: A <xref href=\"System.Threading.Tasks.Task\"></xref> object to be executed.\n    return:\n      type: System.Boolean\n      description: A Boolean that is true if <code>task</code> was successfully executed, false if it was not. A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.\n  overload: System.Threading.Tasks.TaskScheduler.TryExecuteTask*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <code>task</code> is not associated with this scheduler.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)\n  commentId: M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)\n  id: TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)\n  parent: System.Threading.Tasks.TaskScheduler\n  langs:\n  - csharp\n  name: TryExecuteTaskInline(Task, Boolean)\n  nameWithType: TaskScheduler.TryExecuteTaskInline(Task, Boolean)\n  fullName: TaskScheduler.TryExecuteTaskInline(Task, Boolean)\n  type: Method\n  assemblies:\n  - System.Threading.Tasks\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading.Tasks\n  summary: Determines whether the provided <xref href=\"System.Threading.Tasks.Task\"></xref> can be executed synchronously in this call, and if it can, executes it.\n  remarks: \"A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object. Inline execution is optional, and the request may be rejected by returning false. However, the more tasks that can be inlined, the better the scheduler will scale. In fact, a scheduler that inlines too little may be prone to deadlocks. A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline. For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.  \\n  \\n If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value. It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request. Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.  \\n  \\n The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.  \\n  \\n For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);\n    parameters:\n    - id: task\n      type: System.Threading.Tasks.Task\n      description: The <xref href=\"System.Threading.Tasks.Task\"></xref> to be executed.\n    - id: taskWasPreviouslyQueued\n      type: System.Boolean\n      description: A Boolean denoting whether or not task has previously been queued. If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.\n    return:\n      type: System.Boolean\n      description: A Boolean value indicating whether the task was executed inline.\n  overload: System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: The <code>task</code> argument is null.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <code>task</code> was already executed.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Tasks.TaskScheduler.UnobservedTaskException\n  commentId: E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException\n  id: UnobservedTaskException\n  parent: System.Threading.Tasks.TaskScheduler\n  langs:\n  - csharp\n  name: UnobservedTaskException\n  nameWithType: TaskScheduler.UnobservedTaskException\n  fullName: TaskScheduler.UnobservedTaskException\n  type: Event\n  assemblies:\n  - System.Threading.Tasks\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading.Tasks\n  summary: Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.\n  remarks: \"This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.  \\n  \\n To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions. Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default. Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception. This behavior can be configured. Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the  configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:  \\n  \\n```xml  \\n<configuration>   \\n   <runtime>   \\n      <ThrowUnobservedTaskExceptions enabled=\\\"true\\\"/>   \\n   </runtime>   \\n</configuration>  \\n  \\n```\"\n  syntax:\n    content: >-\n      [add: System.Security.SecurityCritical]\n\n      [remove: System.Security.SecurityCritical]\n\n      public static event EventHandler<System.Threading.Tasks.UnobservedTaskExceptionEventArgs> UnobservedTaskException;\n    return:\n      type: System.EventHandler{System.Threading.Tasks.UnobservedTaskExceptionEventArgs}\n      description: ''\n  exceptions: []\n  attributes:\n  - type: 'add: System.Security.SecurityCritical'\n  - type: 'remove: System.Security.SecurityCritical'\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.InvalidOperationException\n  parent: System\n  isExternal: false\n  name: InvalidOperationException\n  nameWithType: InvalidOperationException\n  fullName: System.InvalidOperationException\n- uid: System.NotSupportedException\n  parent: System\n  isExternal: false\n  name: NotSupportedException\n  nameWithType: NotSupportedException\n  fullName: System.NotSupportedException\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.Threading.Tasks.TaskScheduler.#ctor\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: TaskScheduler()\n  nameWithType: TaskScheduler.TaskScheduler()\n  fullName: TaskScheduler.TaskScheduler()\n- uid: System.Threading.Tasks.TaskScheduler.Current\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: Current\n  nameWithType: TaskScheduler.Current\n  fullName: TaskScheduler.Current\n- uid: System.Threading.Tasks.TaskScheduler\n  parent: System.Threading.Tasks\n  isExternal: false\n  name: TaskScheduler\n  nameWithType: TaskScheduler\n  fullName: System.Threading.Tasks.TaskScheduler\n- uid: System.Threading.Tasks.TaskScheduler.Default\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: Default\n  nameWithType: TaskScheduler.Default\n  fullName: TaskScheduler.Default\n- uid: System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: FromCurrentSynchronizationContext()\n  nameWithType: TaskScheduler.FromCurrentSynchronizationContext()\n  fullName: TaskScheduler.FromCurrentSynchronizationContext()\n- uid: System.Threading.Tasks.TaskScheduler.GetScheduledTasks\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: GetScheduledTasks()\n  nameWithType: TaskScheduler.GetScheduledTasks()\n  fullName: TaskScheduler.GetScheduledTasks()\n- uid: System.Collections.Generic.IEnumerable`1\n  name: IEnumerable<T>\n  nameWithType: IEnumerable<T>\n  fullName: System.Collections.Generic.IEnumerable<T>\n- uid: System.Threading.Tasks.Task\n  name: Task\n  nameWithType: Task\n  fullName: System.Threading.Tasks.Task\n- uid: System.Collections.Generic.IEnumerable{System.Threading.Tasks.Task}\n  parent: System.Collections.Generic\n  isExternal: false\n  name: IEnumerable<Task>\n  nameWithType: IEnumerable<Task>\n  fullName: System.Collections.Generic.IEnumerable<System.Threading.Tasks.Task>\n  spec.csharp:\n  - uid: System.Collections.Generic.IEnumerable`1\n    name: IEnumerable\n    nameWithType: IEnumerable\n    fullName: System.Collections.Generic.IEnumerable\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.Threading.Tasks.Task\n    name: Task\n    nameWithType: Task\n    fullName: System.Threading.Tasks.Task\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.Threading.Tasks.TaskScheduler.Id\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: Id\n  nameWithType: TaskScheduler.Id\n  fullName: TaskScheduler.Id\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: MaximumConcurrencyLevel\n  nameWithType: TaskScheduler.MaximumConcurrencyLevel\n  fullName: TaskScheduler.MaximumConcurrencyLevel\n- uid: System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: QueueTask(Task)\n  nameWithType: TaskScheduler.QueueTask(Task)\n  fullName: TaskScheduler.QueueTask(Task)\n- uid: System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: TryDequeue(Task)\n  nameWithType: TaskScheduler.TryDequeue(Task)\n  fullName: TaskScheduler.TryDequeue(Task)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: TryExecuteTask(Task)\n  nameWithType: TaskScheduler.TryExecuteTask(Task)\n  fullName: TaskScheduler.TryExecuteTask(Task)\n- uid: System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: TryExecuteTaskInline(Task, Boolean)\n  nameWithType: TaskScheduler.TryExecuteTaskInline(Task, Boolean)\n  fullName: TaskScheduler.TryExecuteTaskInline(Task, Boolean)\n- uid: System.Threading.Tasks.TaskScheduler.UnobservedTaskException\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: UnobservedTaskException\n  nameWithType: TaskScheduler.UnobservedTaskException\n  fullName: TaskScheduler.UnobservedTaskException\n- uid: System.EventHandler`1\n  name: EventHandler<TEventArgs>\n  nameWithType: EventHandler<TEventArgs>\n  fullName: System.EventHandler<TEventArgs>\n- uid: System.Threading.Tasks.UnobservedTaskExceptionEventArgs\n  name: UnobservedTaskExceptionEventArgs\n  nameWithType: UnobservedTaskExceptionEventArgs\n  fullName: System.Threading.Tasks.UnobservedTaskExceptionEventArgs\n- uid: System.EventHandler{System.Threading.Tasks.UnobservedTaskExceptionEventArgs}\n  parent: System\n  isExternal: false\n  name: EventHandler<UnobservedTaskExceptionEventArgs>\n  nameWithType: EventHandler<UnobservedTaskExceptionEventArgs>\n  fullName: System.EventHandler<System.Threading.Tasks.UnobservedTaskExceptionEventArgs>\n  spec.csharp:\n  - uid: System.EventHandler`1\n    name: EventHandler\n    nameWithType: EventHandler\n    fullName: System.EventHandler\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.Threading.Tasks.UnobservedTaskExceptionEventArgs\n    name: UnobservedTaskExceptionEventArgs\n    nameWithType: UnobservedTaskExceptionEventArgs\n    fullName: System.Threading.Tasks.UnobservedTaskExceptionEventArgs\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.Threading.Tasks.TaskScheduler.#ctor*\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: TaskScheduler\n  nameWithType: TaskScheduler.TaskScheduler\n  fullName: TaskScheduler.TaskScheduler\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n- uid: System.Threading.Tasks.TaskScheduler.Current*\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: Current\n  nameWithType: TaskScheduler.Current\n  fullName: TaskScheduler.Current\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n- uid: System.Threading.Tasks.TaskScheduler.Default*\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: Default\n  nameWithType: TaskScheduler.Default\n  fullName: TaskScheduler.Default\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n- uid: System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext*\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: FromCurrentSynchronizationContext\n  nameWithType: TaskScheduler.FromCurrentSynchronizationContext\n  fullName: TaskScheduler.FromCurrentSynchronizationContext\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n- uid: System.Threading.Tasks.TaskScheduler.GetScheduledTasks*\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: GetScheduledTasks\n  nameWithType: TaskScheduler.GetScheduledTasks\n  fullName: TaskScheduler.GetScheduledTasks\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n- uid: System.Threading.Tasks.TaskScheduler.Id*\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: Id\n  nameWithType: TaskScheduler.Id\n  fullName: TaskScheduler.Id\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n- uid: System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel*\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: MaximumConcurrencyLevel\n  nameWithType: TaskScheduler.MaximumConcurrencyLevel\n  fullName: TaskScheduler.MaximumConcurrencyLevel\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n- uid: System.Threading.Tasks.TaskScheduler.QueueTask*\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: QueueTask\n  nameWithType: TaskScheduler.QueueTask\n  fullName: TaskScheduler.QueueTask\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n- uid: System.Threading.Tasks.TaskScheduler.TryDequeue*\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: TryDequeue\n  nameWithType: TaskScheduler.TryDequeue\n  fullName: TaskScheduler.TryDequeue\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n- uid: System.Threading.Tasks.TaskScheduler.TryExecuteTask*\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: TryExecuteTask\n  nameWithType: TaskScheduler.TryExecuteTask\n  fullName: TaskScheduler.TryExecuteTask\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n- uid: System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline*\n  parent: System.Threading.Tasks.TaskScheduler\n  isExternal: false\n  name: TryExecuteTaskInline\n  nameWithType: TaskScheduler.TryExecuteTaskInline\n  fullName: TaskScheduler.TryExecuteTaskInline\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading.Tasks/TaskScheduler.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n"}