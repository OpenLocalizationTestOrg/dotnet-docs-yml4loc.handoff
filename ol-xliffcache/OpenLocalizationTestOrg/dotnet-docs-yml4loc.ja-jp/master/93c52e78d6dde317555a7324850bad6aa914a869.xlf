<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">93c52e78d6dde317555a7324850bad6aa914a869</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Collections.Generic.List-1.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5ca025b7bd63a1e27cced2847c21d9d9ccd77249</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5c5fa9ad6507b6da08b248494e3ebec960179a3c</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Represents a strongly typed list of objects that can be accessed by index.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>Provides methods to search, sort, and manipulate lists.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>To view the .NET Framework source code for this type, see the <bpt id="p1">[</bpt>Reference Source<ept id="p1">](http://referencesource.microsoft.com/#mscorlib/system/collections/generic/list.cs#cf7f4095e4de7646)</ept>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class is the generic equivalent of the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>It implements the <ph id="ph1">&lt;xref:System.Collections.Generic.IList%601&gt;</ph> generic interface by using an array whose size is dynamically increased as required.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can add items to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> by using the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Add%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.AddRange%2A&gt;</ph> methods.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class uses both an equality comparer and an ordering comparer.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>Methods such as <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.IndexOf%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.LastIndexOf%2A&gt;</ph>, and <ph id="ph4">&lt;xref:System.Collections.Generic.Dictionary%602.Remove%2A&gt;</ph> use an equality comparer for the list elements.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default equality comparer for type <ph id="ph1">`T`</ph> is determined as follows.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source>If type <ph id="ph1">`T`</ph> implements the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> generic interface, then the equality comparer is the <ph id="ph3">&lt;xref:System.IEquatable%601.Equals%28%600%29&gt;</ph> method of that interface; otherwise, the default equality comparer is <ph id="ph4">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>Methods such as <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> use an ordering comparer for the list elements.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default comparer for type <ph id="ph1">`T`</ph> is determined as follows.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>If type <ph id="ph1">`T`</ph> implements the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface, then the default comparer is the <ph id="ph3">&lt;xref:System.IComparable%601.CompareTo%28%600%29&gt;</ph> method of that interface; otherwise, if type <ph id="ph4">`T`</ph> implements the nongeneric <ph id="ph5">&lt;xref:System.IComparable&gt;</ph> interface, then the default comparer is the <ph id="ph6">&lt;xref:System.IComparable.CompareTo%28System.Object%29&gt;</ph> method of that interface.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>If type <ph id="ph1">`T`</ph> implements neither interface, then there is no default comparer, and a comparer or comparison delegate must be provided explicitly.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is not guaranteed to be sorted.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>You must sort the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> before performing operations (such as <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph>) that require the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> to be sorted.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>Elements in this collection can be accessed using an integer index.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>Indexes in this collection are zero-based.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>For very large <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the <ph id="ph2">`enabled`</ph> attribute of the  configuration element to <ph id="ph3">`true`</ph> in the run-time environment.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value for reference types and allows duplicate elements.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>For an immutable version of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class, see <ph id="ph2">&lt;xref:System.Collections.Immutable.ImmutableList%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Performance Considerations</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>In deciding whether to use the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> class, both of which have similar functionality, remember that the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class performs better in most cases and is type safe.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a reference type is used for type <ph id="ph1">`T`</ph> of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class, the behavior of the two classes is identical.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if a value type is used for type <ph id="ph1">`T`</ph>, you need to consider implementation and boxing issues.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a value type is used for type <ph id="ph1">`T`</ph>, the compiler generates an implementation of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class specifically for that value type.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>That means a list element of a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object does not have to be boxed before the element can be used, and after about 500 list elements are created the memory saved not boxing list elements is greater than the memory used to generate the class implementation.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>Make certain the value type used for type <ph id="ph1">`T`</ph> implements the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>If not, methods such as <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Contains%2A&gt;</ph> must call the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method, which boxes the affected list element.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value type implements the <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> interface and you own the source code, also implement the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface to prevent the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> methods from boxing list elements.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do not own the source code, pass an <ph id="ph1">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> object to the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.BinarySearch%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Sort%2A&gt;</ph> methods</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is to your advantage to use the type-specific implementation of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class instead of using the <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> class or writing a strongly typed wrapper collection yourself.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>The reason is your implementation must do what the .NET Framework does for you already, and the common language runtime can share Microsoft intermediate language code and metadata, which your implementation cannot.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>F# Considerations</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class is used infrequently in F# code.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, <bpt id="p1">[</bpt>Lists<ept id="p1">](http://msdn.microsoft.com/library/83102799-f251-42e1-93ef-64232e8c5b1d)</ept>, which are immutable, singly-linked lists, are typically preferred.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>An F# List provides an ordered, immutable series of values, and is supported for use in functional-style development.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>When used from F#, the<ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class is typically referred to by the  <bpt id="p1">[</bpt>ResizeArray<ph id="ph2">\&lt;</ph>'T&gt;<ept id="p1">](https://msdn.microsoft.com/library/ee353447.aspx)</ept> type abbreviation to avoid naming conflicts with F# Lists</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve">
          <source>The type of elements in the list.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> class that is empty and has the default initial capacity.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> can hold.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the size of the collection can be estimated, using the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.%23ctor%28System.Int32%29&gt;</ph> constructor and specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity can be decreased by calling the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method or by setting the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property explicitly.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>Decreasing the capacity reallocates memory and copies all the elements in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> class that contains elements copied from the specified collection and has sufficient capacity to accommodate the number of elements copied.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are copied onto the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> in the same order they are read by the enumerator of the collection.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is the number of elements in <ph id="ph3">`collection`</ph>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>The collection whose elements are copied to the new list.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;collection&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> class that is empty and has the specified initial capacity.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity of a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> can hold.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>As elements are added to a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, the capacity is automatically increased as required by reallocating the internal array.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the size of the collection can be estimated, specifying the initial capacity eliminates the need to perform a number of resizing operations while adding elements to the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity can be decreased by calling the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method or by setting the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property explicitly.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>Decreasing the capacity reallocates memory and copies all the elements in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">`capacity`</ph>.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>The number of elements that the new list can initially store.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;capacity&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>Adds an object to the end of the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value for reference types and allows duplicate elements.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> already equals <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> is less than <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, this method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the capacity needs to be increased to accommodate the new element, this method becomes an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve">
          <source>The object to be added to the end of the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph> for reference types.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Adds the elements of the specified collection to the end of the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>The order of the elements in the collection is preserved in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the new <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> (the current <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> plus the size of the collection) will be greater than <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is increased by automatically reallocating the internal array to accommodate the new elements, and the existing elements are copied to the new array before the new elements are added.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> can accommodate the new elements without increasing the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, this method is an O(<bpt id="p1">*</bpt><ph id="ph3">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph4">n</ph><ept id="p2">*</ept> is the number of elements to be added.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the capacity needs to be increased to accommodate the new elements, this method becomes an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept><ph id="ph2"> + </ph><bpt id="p2">*</bpt>m<ept id="p2">*</ept>) operation, where <bpt id="p3">*</bpt><ph id="ph3">n</ph><ept id="p3">*</ept> is the number of elements to be added and <bpt id="p4">*</bpt>m<ept id="p4">*</ept> is <ph id="ph4">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The collection whose elements should be added to the end of the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>The collection itself cannot be <ph id="ph1">`null`</ph>, but it can contain elements that are <ph id="ph2">`null`</ph>, if type <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">T</ph><ept id="p1">&lt;/code&gt;</ept> is a reference type.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;collection&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>Returns a read-only <ph id="ph1">&lt;xref href="System.Collections.ObjectModel.ReadOnlyCollection`1"&gt;&lt;/xref&gt;</ph> wrapper for the current collection.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>To prevent any modifications to the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object, expose it only through this wrapper.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>A  <ph id="ph1">&lt;xref:System.Collections.ObjectModel.ReadOnlyCollection%601&gt;</ph> object does not expose methods that modify the collection.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if changes are made to the underlying <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> object, the read-only collection reflects those changes.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve">
          <source>An object that acts as a read-only wrapper around the current <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve">
          <source>Searches the entire sorted <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> for an element using the default comparer and returns the zero-based index of the element.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the default comparer <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> for type <ph id="ph2">`T`</ph> to determine the order of list elements.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> property checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface and uses that implementation, if available.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>If not, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>If type <ph id="ph1">`T`</ph> does not implement either interface, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> must already be sorted according to the comparer implementation; otherwise, the result is incorrect.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>Comparing <ph id="ph1">`null`</ph> with any reference type is allowed and does not generate an exception when using the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(log <bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is the number of elements in the range.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve">
          <source>The object to locate.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph> for reference types.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>The zero-based index of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">item</ph><ept id="p1">&lt;/code&gt;</ept> in the sorted <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>, if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">item</ph><ept id="p2">&lt;/code&gt;</ept> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">item</ph><ept id="p3">&lt;/code&gt;</ept> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;xref href="System.Collections.Generic.List`1.Count"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve">
          <source>The default comparer <ph id="ph1">&lt;xref href="System.Collections.Generic.Comparer`1.Default"&gt;&lt;/xref&gt;</ph> cannot find an implementation of the <ph id="ph2">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface or the <ph id="ph3">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface for type <bpt id="p1">&lt;code&gt;</bpt><ph id="ph4">T</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve">
          <source>Searches the entire sorted <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> for an element using the specified comparer and returns the zero-based index of the element.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer customizes how the elements are compared.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instance as the comparer to perform case-insensitive string searches.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are compared to the specified value using the specified <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the default comparer <ph id="ph3">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> checks whether type <ph id="ph4">`T`</ph> implements the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface and uses that implementation, if available.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source>If not, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>If type <ph id="ph1">`T`</ph> does not implement either interface, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> throws <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> must already be sorted according to the comparer implementation; otherwise, the result is incorrect.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source>Comparing <ph id="ph1">`null`</ph> with any reference type is allowed and does not generate an exception when using the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(log <bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is the number of elements in the range.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>The object to locate.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph> for reference types.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> implementation to use when comparing elements.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`null`</ph> to use the default comparer <ph id="ph2">&lt;xref href="System.Collections.Generic.Comparer`1.Default"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>The zero-based index of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">item</ph><ept id="p1">&lt;/code&gt;</ept> in the sorted <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>, if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">item</ph><ept id="p2">&lt;/code&gt;</ept> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">item</ph><ept id="p3">&lt;/code&gt;</ept> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;xref href="System.Collections.Generic.List`1.Count"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and the default comparer <ph id="ph3">&lt;xref href="System.Collections.Generic.Comparer`1.Default"&gt;&lt;/xref&gt;</ph> cannot find an implementation of the <ph id="ph4">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface or the <ph id="ph5">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface for type <ph id="ph6">&lt;code&gt;T&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>Searches a range of elements in the sorted <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> for an element using the specified comparer and returns the zero-based index of the element.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>The comparer customizes how the elements are compared.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you can use a <ph id="ph1">&lt;xref:System.Collections.CaseInsensitiveComparer&gt;</ph> instance as the comparer to perform case-insensitive string searches.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are compared to the specified value using the specified <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the default comparer <ph id="ph3">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> checks whether type <ph id="ph4">`T`</ph> implements the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface and uses that implementation, if available.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>If not, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>If type <ph id="ph1">`T`</ph> does not implement either interface, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> throws <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> must already be sorted according to the comparer implementation; otherwise, the result is incorrect.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT">
          <source>Comparing <ph id="ph1">`null`</ph> with any reference type is allowed and does not generate an exception when using the <ph id="ph2">&lt;xref:System.IComparable%601&gt;</ph> generic interface.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>When sorting, <ph id="ph1">`null`</ph> is considered to be less than any other object.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> contains more than one element with the same value, the method returns only one of the occurrences, and it might return any one of the occurrences, not necessarily the first one.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> does not contain the specified value, the method returns a negative integer.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can apply the bitwise complement operation (~) to this negative integer to get the index of the first element that is larger than the search value.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT">
          <source>When inserting the value into the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, this index should be used as the insertion point to maintain the sort order.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(log <bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is the number of elements in the range.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the range to search.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve">
          <source>The length of the range to search.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve">
          <source>The object to locate.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph> for reference types.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> implementation to use when comparing elements, or <ph id="ph2">`null`</ph> to use the default comparer <ph id="ph3">&lt;xref href="System.Collections.Generic.Comparer`1.Default"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve">
          <source>The zero-based index of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">item</ph><ept id="p1">&lt;/code&gt;</ept> in the sorted <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>, if <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">item</ph><ept id="p2">&lt;/code&gt;</ept> is found; otherwise, a negative number that is the bitwise complement of the index of the next element that is larger than <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">item</ph><ept id="p3">&lt;/code&gt;</ept> or, if there is no larger element, the bitwise complement of <ph id="ph5">&lt;xref href="System.Collections.Generic.List`1.Count"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range in the <ph id="ph3">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and the default comparer <ph id="ph3">&lt;xref href="System.Collections.Generic.Comparer`1.Default"&gt;&lt;/xref&gt;</ph> cannot find an implementation of the <ph id="ph4">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface or the <ph id="ph5">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface for type <ph id="ph6">&lt;code&gt;T&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>Gets or sets the total number of elements the internal data structure can hold without resizing.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> can store before resizing is required, whereas <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> is the number of elements that are actually in the <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> is always greater than or equal to <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> exceeds <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the capacity is significantly larger than the count and you want to reduce the memory used by the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>,  you can  decrease capacity by calling the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method or by setting the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property explicitly to a lower value.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the value of <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> is set explicitly, the internal array is also reallocated to accommodate the specified capacity, and all the elements are copied.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is the new capacity.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>The number of elements that the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> can contain before resizing is required.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Collections.Generic.List`1.Capacity"&gt;&lt;/xref&gt;</ph> is set to a value that is less than <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1.Count"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>There is not enough memory available on the system.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>Removes all elements from the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> is set to 0, and references to other objects from elements of the collection are also released.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> remains unchanged.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>To reset the capacity of the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method or set the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property directly.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>Decreasing the capacity reallocates memory and copies all the elements in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>Trimming an empty <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> sets the capacity of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> to the default capacity.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>Determines whether an element is in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method determines equality by using the default equality comparer, as defined by the object's implementation of the <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=fullName&gt;</ph> method for <ph id="ph2">`T`</ph> (the type of values in the list).</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>The object to locate in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph> for reference types.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">item</ph><ept id="p1">&lt;/code&gt;</ept> is found in the <ph id="ph3">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>Converts the elements in the current <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> to another type, and returns a list containing the converted elements.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Converter%602&gt;</ph> is a delegate to a method that converts an object to the target type.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Converter%602&gt;</ph> delegate, and the converted elements are saved in the new <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> remains unchanged.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Converter`2"&gt;&lt;/xref&gt;</ph> delegate that converts each element from one type to another type.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve">
          <source>The type of the elements of the target array.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> of the target type containing the converted elements from the current <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;converter&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve">
          <source>Copies the entire <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> to a compatible one-dimensional array, starting at the specified index of the target array.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=fullName&gt;</ph> to copy the elements.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> must have zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve">
          <source>The zero-based index in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept> at which copying begins.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;arrayIndex&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>The number of elements in the source <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> is greater than the available space from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">arrayIndex</ph><ept id="p1">&lt;/code&gt;</ept> to the end of the destination <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve">
          <source>Copies a range of elements from the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> to a compatible one-dimensional array, starting at the specified index of the target array.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=fullName&gt;</ph> to copy the elements.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">`count`</ph>.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve">
          <source>The zero-based index in the source <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> at which copying begins.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> must have zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>The zero-based index in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept> at which copying begins.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve">
          <source>The number of elements to copy.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;arrayIndex&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is equal to or greater than the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1.Count"&gt;&lt;/xref&gt;</ph> of the source <ph id="ph3">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>The number of elements from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">index</ph><ept id="p1">&lt;/code&gt;</ept> to the end of the source <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> is greater than the available space from <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">arrayIndex</ph><ept id="p2">&lt;/code&gt;</ept> to the end of the destination <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">array</ph><ept id="p3">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve">
          <source>Copies the entire <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> to a compatible one-dimensional array, starting at the beginning of the target array.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=fullName&gt;</ph> to copy the elements.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are copied to the <ph id="ph1">&lt;xref:System.Array&gt;</ph> in the same order in which the enumerator iterates through the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> must have zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source>The number of elements in the source <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> is greater than the number of elements that the destination <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p1">&lt;/code&gt;</ept> can contain.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Gets the number of elements contained in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> is the number of elements that the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> can store before resizing is required.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> is the number of elements that are actually in the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> is always greater than or equal to <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> exceeds <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> while adding elements, the capacity is increased by automatically reallocating the internal array before copying the old elements and adding the new elements.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve">
          <source>The number of elements contained in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source>Determines whether the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> contains elements that match the conditions defined by the specified predicate.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate, and processing is stopped when a match is found.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> delegate that defines the conditions of the elements to search for.</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> contains one or more elements that match the conditions defined by the specified predicate; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the first occurrence within the entire <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate, moving forward in the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, starting with the first element and ending with the last element.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>Processing is stopped when a match is found.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>When searching a list containing value types, make sure the default value for the type does not satisfy the search predicate.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, there is no way to distinguish between a default value indicating that no match was found and a list element that happens to have the default value for the type.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the default value satisfies the search predicate, use the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.FindIndex%2A&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> delegate that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve">
          <source>The first element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">T</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve">
          <source>Retrieves all the elements that match the conditions defined by the specified predicate.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate, and the elements that match the conditions are saved in the returned <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> delegate that defines the conditions of the elements to search for.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> containing all the elements that match the conditions defined by the specified predicate, if found; otherwise, an empty <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the entire <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched forward starting at the first element and ending at the last element.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>The delegate has the signature:</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> delegate that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">match</ph><ept id="p1">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> that extends from the specified index to the last element.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at the last element.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>The delegate has the signature:</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is the number of elements from <ph id="ph3">`startIndex`</ph> to the end of the <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the search.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> delegate that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">match</ph><ept id="p1">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> that starts at the specified index and contains the specified number of elements.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched forward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> plus <ph id="ph4">`count`</ph> minus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source>The delegate has the signature:</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">`count`</ph>.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the search.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>The number of elements in the section to search.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> delegate that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>The zero-based index of the first occurrence of an element that matches the conditions defined by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">match</ph><ept id="p1">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not specify a valid section in the <ph id="ph3">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the last occurrence within the entire <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate, moving backward in the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>, starting with the last element and ending with the first element.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>Processing is stopped when a match is found.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>When searching a list containing value types, make sure the default value for the type does not satisfy the search predicate.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, there is no way to distinguish between a default value indicating that no match was found and a list element that happens to have the default value for the type.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the default value satisfies the search predicate, use the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.FindLastIndex%2A&gt;</ph> method instead.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> delegate that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve">
          <source>The last element that matches the conditions defined by the specified predicate, if found; otherwise, the default value for type <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">T</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the entire <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> delegate that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">match</ph><ept id="p1">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> that extends from the first element to the specified index.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at the first element.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is the number of elements from the beginning of the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> to <ph id="ph4">`startIndex`</ph>.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the backward search.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> delegate that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">match</ph><ept id="p1">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Searches for an element that matches the conditions defined by the specified predicate, and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched backward starting at <ph id="ph2">`startIndex`</ph> and ending at <ph id="ph3">`startIndex`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">`count`</ph>.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the backward search.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve">
          <source>The number of elements in the section to search.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> delegate that defines the conditions of the element to search for.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve">
          <source>The zero-based index of the last occurrence of an element that matches the conditions defined by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">match</ph><ept id="p1">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;startIndex&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not specify a valid section in the <ph id="ph3">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source>Performs the specified action on each element of the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> is a delegate to a method that performs an action on the object passed to it.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Action%601&gt;</ph> delegate.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>Modifying the underlying collection in the body of the <ph id="ph1">&lt;xref:System.Action%601&gt;</ph> delegate is not supported and causes undefined behavior.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Action`1"&gt;&lt;/xref&gt;</ph> delegate to perform on each element of the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;action&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>An element in the collection has been modified.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>Returns an enumerator that iterates through the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>At this position, the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> property is undefined.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you must call the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> method to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> property returns the same object until <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> to the next element.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> is undefined.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot set <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Enumerator.Current%2A&gt;</ph> to the first element of the collection again; you must create a new enumerator instance instead.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=fullName&gt;</ph> namespace are not synchronized.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1.Enumerator"&gt;&lt;/xref&gt;</ph> for the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>Creates a shallow copy of a range of elements in the source <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>A shallow copy of a collection of reference types, or a subset of that collection, contains only the references to the elements of the collection.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>The objects themselves are not copied.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>The references in the new list point to the same objects as the references in the original list.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source>A shallow copy of a collection of value types, or a subset of that collection, contains the elements of the collection.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if the elements of the collection contain references to other objects, those objects are not copied.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source>The references in the elements of the new collection point to the same objects as the references in the elements of the original collection.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a deep copy of a collection copies the elements and everything directly or indirectly referenced by the elements.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">`count`</ph>.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve">
          <source>The zero-based <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> index at which the range starts.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>The number of elements in the range.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>A shallow copy of a range of elements in the source <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>Searches for the specified object and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> that extends from the specified index to the last element.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched forward starting at <ph id="ph2">`index`</ph> and ending at the last element.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is the number of elements from <ph id="ph3">`index`</ph> to the end of the <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>The object to locate in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph> for reference types.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the search.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>0 (zero) is valid in an empty list.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>The zero-based index of the first occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">item</ph><ept id="p1">&lt;/code&gt;</ept> within the range of elements in the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> that extends from <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">index</ph><ept id="p2">&lt;/code&gt;</ept> to the last element, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve">
          <source>Searches for the specified object and returns the zero-based index of the first occurrence within the range of elements in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> that starts at the specified index and contains the specified number of elements.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched forward starting at <ph id="ph2">`index`</ph> and ending at <ph id="ph3">`index`</ph> plus <ph id="ph4">`count`</ph> minus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">`count`</ph>.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve">
          <source>The object to locate in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph> for reference types.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the search.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>0 (zero) is valid in an empty list.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve">
          <source>The number of elements in the section to search.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve">
          <source>The zero-based index of the first occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">item</ph><ept id="p1">&lt;/code&gt;</ept> within the range of elements in the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> that starts at <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">index</ph><ept id="p2">&lt;/code&gt;</ept> and contains <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">count</ph><ept id="p3">&lt;/code&gt;</ept> number of elements, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not specify a valid section in the <ph id="ph3">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>Searches for the specified object and returns the zero-based index of the first occurrence within the entire <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched forward starting at the first element and ending at the last element.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>The object to locate in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph> for reference types.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve">
          <source>The zero-based index of the first occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">item</ph><ept id="p1">&lt;/code&gt;</ept> within the entire <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>Inserts an element into the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> at the specified index.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value for reference types and allows duplicate elements.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> already equals <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is increased by automatically reallocating the internal array, and the existing elements are copied to the new array before the new element is added.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`index`</ph> is equal to <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>, <ph id="ph3">`item`</ph> is added to the end of <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>The zero-based index at which <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">item</ph><ept id="p1">&lt;/code&gt;</ept> should be inserted.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve">
          <source>The object to insert.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph> for reference types.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is greater than <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1.Count"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve">
          <source>Inserts the elements of a collection into the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> at the specified index.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value for reference types and allows duplicate elements.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the new <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> (the current <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> plus the size of the collection) will be greater than <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, the capacity of the <ph id="ph4">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is increased by automatically reallocating the internal array to accommodate the new elements, and the existing elements are copied to the new array before the new elements are added.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`index`</ph> is equal to <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>, the elements are added to the end of <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>The order of the elements in the collection is preserved in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept><ph id="ph2"> + </ph><bpt id="p2">*</bpt>m<ept id="p2">*</ept>) operation, where <bpt id="p3">*</bpt><ph id="ph3">n</ph><ept id="p3">*</ept> is the number of elements to be added and <bpt id="p4">*</bpt>m<ept id="p4">*</ept> is <ph id="ph4">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>The zero-based index at which the new elements should be inserted.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve">
          <source>The collection whose elements should be inserted into the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve">
          <source>The collection itself cannot be <ph id="ph1">`null`</ph>, but it can contain elements that are <ph id="ph2">`null`</ph>, if type <bpt id="p1">&lt;code&gt;</bpt><ph id="ph3">T</ph><ept id="p1">&lt;/code&gt;</ept> is a reference type.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;collection&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is greater than <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1.Count"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>Gets or sets the element at the specified index.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> accepts <ph id="ph2">`null`</ph> as a valid value for reference types and allows duplicate elements.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property provides the ability to access a specific element in the collection by using the following syntax: <ph id="ph1">`myCollection[index]`</ph>.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>The zero-based index of the element to get or set.</source>
        </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve">
          <source>The element at the specified index.</source>
        </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is equal to or greater than <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1.Count"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve">
          <source>Searches for the specified object and returns the zero-based index of the last occurrence within the entire <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched backward starting at the last element and ending at the first element.</source>
        </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
        </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve">
          <source>The object to locate in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph> for reference types.</source>
        </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve">
          <source>The zero-based index of the last occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">item</ph><ept id="p1">&lt;/code&gt;</ept> within the entire the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve">
          <source>Searches for the specified object and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> that extends from the first element to the specified index.</source>
        </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched backward starting at <ph id="ph2">`index`</ph> and ending at the first element.</source>
        </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
        </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is the number of elements from the beginning of the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph> to <ph id="ph4">`index`</ph>.</source>
        </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve">
          <source>The object to locate in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph> for reference types.</source>
        </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the backward search.</source>
        </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve">
          <source>The zero-based index of the last occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">item</ph><ept id="p1">&lt;/code&gt;</ept> within the range of elements in the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> that extends from the first element to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">index</ph><ept id="p2">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve">
          <source>Searches for the specified object and returns the zero-based index of the last occurrence within the range of elements in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> that contains the specified number of elements and ends at the specified index.</source>
        </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> is searched backward starting at <ph id="ph2">`index`</ph> and ending at <ph id="ph3">`index`</ph> minus <ph id="ph4">`count`</ph> plus 1, if <ph id="ph5">`count`</ph> is greater than 0.</source>
        </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
        </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">`count`</ph>.</source>
        </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve">
          <source>The object to locate in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph> for reference types.</source>
        </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the backward search.</source>
        </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve">
          <source>The number of elements in the section to search.</source>
        </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve">
          <source>The zero-based index of the last occurrence of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">item</ph><ept id="p1">&lt;/code&gt;</ept> within the range of elements in the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> that contains <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">count</ph><ept id="p2">&lt;/code&gt;</ept> number of elements and ends at <bpt id="p3">&lt;code&gt;</bpt><ph id="ph4">index</ph><ept id="p3">&lt;/code&gt;</ept>, if found; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is outside the range of valid indexes for the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not specify a valid section in the <ph id="ph3">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve">
          <source>Removes the first occurrence of a specific object from the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT">
          <source>If type <ph id="ph1">`T`</ph> implements the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> generic interface, the equality comparer is the <ph id="ph3">&lt;xref:System.IEquatable%601.Equals%2A&gt;</ph> method of that interface; otherwise, the default equality comparer is <ph id="ph4">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve">
          <source>The object to remove from the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve">
          <source>The value can be <ph id="ph1">`null`</ph> for reference types.</source>
        </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">item</ph><ept id="p1">&lt;/code&gt;</ept> is successfully removed; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve">
          <source>This method also returns <ph id="ph1">`false`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">item</ph><ept id="p1">&lt;/code&gt;</ept> was not found in the <ph id="ph3">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve">
          <source>Removes all the elements that match the conditions defined by the specified predicate.</source>
        </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate, and the elements that match the conditions are removed from the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> delegate that defines the conditions of the elements to remove.</source>
        </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve">
          <source>The number of elements removed from the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> .</source>
        </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve">
          <source>Removes the element at the specified index of the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you call <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.RemoveAt%2A&gt;</ph> to remove an item, the remaining items in the list are renumbered to replace the removed item.</source>
        </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if you remove the item at index 3, the item at index 4 is moved to the 3 position.</source>
        </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, the number of items in the list (as represented by the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> property) is reduced by 1.</source>
        </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is (<ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph><ph id="ph4"> - </ph><ph id="ph5">`index`</ph>).</source>
        </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve">
          <source>The zero-based index of the element to remove.</source>
        </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is equal to or greater than <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1.Count"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve">
          <source>Removes a range of elements from the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT">
          <source>The items are removed and all the elements following them in the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> have their indexes reduced by <ph id="ph2">`count`</ph>.</source>
        </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the range of elements to remove.</source>
        </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve">
          <source>The number of elements to remove.</source>
        </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve">
          <source>Reverses the order of the elements in the entire <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=fullName&gt;</ph> to reverse the order of the elements.</source>
        </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve">
          <source>Reverses the order of the elements in the specified range.</source>
        </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Reverse%2A?displayProperty=fullName&gt;</ph> to reverse the order of the elements.</source>
        </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the range to reverse.</source>
        </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve">
          <source>The number of elements in the range to reverse.</source>
        </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range of elements in the <ph id="ph3">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve">
          <source>Sorts the elements in the entire <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> using the specified <ph id="ph2">&lt;xref href="System.Comparison`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparison`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are sorted using the method represented by the delegate.</source>
        </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparison`</ph> is <ph id="ph2">`null`</ph>, an <ph id="ph3">&lt;xref:System.ArgumentNullException&gt;</ph> is thrown.</source>
        </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=fullName&gt;</ph>, which applies the introspective sort as follows:</source>
        </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an insertion sort algorithm</source>
        </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 log <bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a Quicksort algorithm.</source>
        </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT">
          <source>On average, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept> log <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept>) operation, where <bpt id="p3">*</bpt><ph id="ph3">n</ph><ept id="p3">*</ept> is <ph id="ph4">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>; in the worst case it is an O(<bpt id="p4">*</bpt><ph id="ph5">n</ph><ept id="p4">*</ept><bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept>) operation.</source>
        </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Comparison`1"&gt;&lt;/xref&gt;</ph> to use when comparing elements.</source>
        </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparison&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve">
          <source>The implementation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparison</ph><ept id="p1">&lt;/code&gt;</ept> caused an error during the sort.</source>
        </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparison</ph><ept id="p1">&lt;/code&gt;</ept> might not return 0 when comparing an item with itself.</source>
        </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve">
          <source>Sorts the elements in a range of elements in <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> using the specified comparer.</source>
        </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are sorted using the specified <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the default comparer <ph id="ph3">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> checks whether type <ph id="ph4">`T`</ph> implements the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface and uses that implementation, if available.</source>
        </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT">
          <source>If not, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT">
          <source>If type <ph id="ph1">`T`</ph> does not implement either interface, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=fullName&gt;</ph>, which applies the introspective sort as follows:</source>
        </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an insertion sort algorithm</source>
        </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 log <bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is the range of the input array, it uses a <bpt id="p3">[</bpt>Heapsort<ept id="p3">](http://en.wikipedia.org/wiki/Heapsort)</ept> algorithm.</source>
        </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a Quicksort algorithm.</source>
        </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT">
          <source>On average, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept> log <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept>) operation, where <bpt id="p3">*</bpt><ph id="ph3">n</ph><ept id="p3">*</ept> is <ph id="ph4">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>; in the worst case it is an O(<bpt id="p4">*</bpt><ph id="ph5">n</ph><ept id="p4">*</ept><bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept>) operation.</source>
        </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve">
          <source>The zero-based starting index of the range to sort.</source>
        </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve">
          <source>The length of the range to sort.</source>
        </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> implementation to use when comparing elements, or <ph id="ph2">`null`</ph> to use the default comparer <ph id="ph3">&lt;xref href="System.Collections.Generic.Comparer`1.Default"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;count&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id="ph2">&lt;code&gt;count&lt;/code&gt;</ph> do not specify a valid range in the <ph id="ph3">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve">
          <source>The implementation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> caused an error during the sort.</source>
        </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> might not return 0 when comparing an item with itself.</source>
        </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and the default comparer <ph id="ph3">&lt;xref href="System.Collections.Generic.Comparer`1.Default"&gt;&lt;/xref&gt;</ph> cannot find implementation of the <ph id="ph4">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface or the <ph id="ph5">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface for type <ph id="ph6">&lt;code&gt;T&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve">
          <source>Sorts the elements in the entire <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> using the default comparer.</source>
        </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the default comparer <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> for type <ph id="ph2">`T`</ph> to determine the order of list elements.</source>
        </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> property checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable%601&gt;</ph> generic interface and uses that implementation, if available.</source>
        </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT">
          <source>If not, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT">
          <source>If type <ph id="ph1">`T`</ph> does not implement either interface, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=fullName&gt;</ph> method, which applies the introspective sort as follows:</source>
        </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an insertion sort algorithm.</source>
        </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 log <bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is the range of the input array, it uses a Heapsort algorithm.</source>
        </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a Quicksort algorithm.</source>
        </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT">
          <source>On average, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept> log <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept>) operation, where <bpt id="p3">*</bpt><ph id="ph3">n</ph><ept id="p3">*</ept> is <ph id="ph4">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>; in the worst case it is an O(<bpt id="p4">*</bpt><ph id="ph5">n</ph><ept id="p4">*</ept><bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept>) operation.</source>
        </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve">
          <source>The default comparer <ph id="ph1">&lt;xref href="System.Collections.Generic.Comparer`1.Default"&gt;&lt;/xref&gt;</ph> cannot find an implementation of the <ph id="ph2">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface or the <ph id="ph3">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface for type <bpt id="p1">&lt;code&gt;</bpt><ph id="ph4">T</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve">
          <source>Sorts the elements in the entire <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> using the specified comparer.</source>
        </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is provided, the elements of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are sorted using the specified <ph id="ph3">&lt;xref:System.Collections.Generic.IComparer%601&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`comparer`</ph> is <ph id="ph2">`null`</ph>, the default comparer <ph id="ph3">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> checks whether type <ph id="ph4">`T`</ph> implements the <ph id="ph5">&lt;xref:System.IComparable%601&gt;</ph> generic interface and uses that implementation, if available.</source>
        </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT">
          <source>If not, <ph id="ph1">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> checks whether type <ph id="ph2">`T`</ph> implements the <ph id="ph3">&lt;xref:System.IComparable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT">
          <source>If type <ph id="ph1">`T`</ph> does not implement either interface, <ph id="ph2">&lt;xref:System.Collections.Generic.Comparer%601.Default%2A?displayProperty=fullName&gt;</ph> throws an <ph id="ph3">&lt;xref:System.InvalidOperationException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method uses the <ph id="ph1">&lt;xref:System.Array.Sort%2A?displayProperty=fullName&gt;</ph> method, which applies the introspective sort as follows:</source>
        </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the partition size is fewer than 16 elements, it uses an insertion sort algorithm.</source>
        </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the number of partitions exceeds 2 log <bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is the range of the input array, it uses a Heapsort algorithm.</source>
        </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, it uses a Quicksort algorithm.</source>
        </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation performs an unstable sort; that is, if two elements are equal, their order might not be preserved.</source>
        </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT">
          <source>In contrast, a stable sort preserves the order of elements that are equal.</source>
        </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT">
          <source>On average, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept> log <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept>) operation, where <bpt id="p3">*</bpt><ph id="ph3">n</ph><ept id="p3">*</ept> is <ph id="ph4">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>; in the worst case it is an O(<bpt id="p4">*</bpt><ph id="ph5">n</ph><ept id="p4">*</ept><bpt id="p5">&lt;sup&gt;</bpt>2<ept id="p5">&lt;/sup&gt;</ept>) operation.</source>
        </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Collections.Generic.IComparer`1"&gt;&lt;/xref&gt;</ph> implementation to use when comparing elements, or <ph id="ph2">`null`</ph> to use the default comparer <ph id="ph3">&lt;xref href="System.Collections.Generic.Comparer`1.Default"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;comparer&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>, and the default comparer <ph id="ph3">&lt;xref href="System.Collections.Generic.Comparer`1.Default"&gt;&lt;/xref&gt;</ph> cannot find implementation of the <ph id="ph4">&lt;xref href="System.IComparable`1"&gt;&lt;/xref&gt;</ph> generic interface or the <ph id="ph5">&lt;xref href="System.IComparable"&gt;&lt;/xref&gt;</ph> interface for type <ph id="ph6">&lt;code&gt;T&lt;/code&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve">
          <source>The implementation of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> caused an error during the sort.</source>
        </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve">
          <source>For example, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">comparer</ph><ept id="p1">&lt;/code&gt;</ept> might not return 0 when comparing an item with itself.</source>
        </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve">
          <source>Copies the elements of the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> to a new array.</source>
        </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are copied using <ph id="ph1">&lt;xref:System.Array.Copy%2A?displayProperty=fullName&gt;</ph>, which is an O(<bpt id="p1">*</bpt><ph id="ph2">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph3">n</ph><ept id="p2">*</ept> is <ph id="ph4">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve">
          <source>An array containing copies of the elements of the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve">
          <source>Sets the capacity to the actual number of elements in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>, if that number is less than a threshold value.</source>
        </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method can be used to minimize a collection's memory overhead if no new elements will be added to the collection.</source>
        </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT">
          <source>The cost of reallocating and copying a large <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> can be considerable, however, so the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method does nothing if the list is at more than 90 percent of capacity.</source>
        </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT">
          <source>This avoids incurring a large reallocation cost for a relatively small gain.</source>
        </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT">
          <source>The current threshold of 90 percent might change in future releases.</source>
        </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT">
          <source>To reset a <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> to its initial state, call the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Clear%2A&gt;</ph> method before calling the <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.TrimExcess%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT">
          <source>Trimming an empty <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> sets the capacity of the <ph id="ph2">&lt;xref:System.Collections.Generic.List%601&gt;</ph> to the default capacity.</source>
        </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT">
          <source>The capacity can also be set using the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve">
          <source>Determines whether every element in the <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> matches the conditions defined by the specified predicate.</source>
        </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Predicate%601&gt;</ph> is a delegate to a method that returns <ph id="ph2">`true`</ph> if the object passed to it matches the conditions defined in the delegate.</source>
        </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the current <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> are individually passed to the <ph id="ph2">&lt;xref:System.Predicate%601&gt;</ph> delegate, and processing is stopped when the delegate returns <ph id="ph3">`false`</ph> for any element.</source>
        </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements are processed in order, and all calls are made on a single thread.</source>
        </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Predicate`1"&gt;&lt;/xref&gt;</ph> delegate that defines the conditions to check against the elements.</source>
        </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if every element in the <ph id="ph2">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph> matches the conditions defined by the specified predicate; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve">
          <source>If the list has no elements, the return value is <ph id="ph1">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;match&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Collections.Generic.ICollection`1"&gt;&lt;/xref&gt;</ph> is read-only.</source>
        </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
        </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
        </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Collections.Generic.ICollection`1"&gt;&lt;/xref&gt;</ph> is read-only; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve">
          <source>In the default implementation of <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve">
          <source>Returns an enumerator that iterates through a collection.</source>
        </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
        </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
        </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
        </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
        </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT">
          <source>At this position, the <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> property is undefined.</source>
        </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you must call the <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> method to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> property returns the same object until <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> to the next element.</source>
        </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> is undefined.</source>
        </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot set <ph id="ph1">&lt;xref:System.Collections.Generic.IEnumerator%601.Current%2A&gt;</ph> to the first element of the collection again; you must create a new enumerator instance instead.</source>
        </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
        </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
        </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
        </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
        </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
        </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=fullName&gt;</ph> namespace are not synchronized.</source>
        </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.Generic.IEnumerator`1"&gt;&lt;/xref&gt;</ph> that can be used to iterate through the collection.</source>
        </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve">
          <source>Copies the elements of the <ph id="ph1">&lt;xref href="System.Collections.ICollection"&gt;&lt;/xref&gt;</ph> to an <ph id="ph2">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph>, starting at a particular <ph id="ph3">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> index.</source>
        </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the type of the source <ph id="ph1">&lt;xref:System.Collections.ICollection&gt;</ph> cannot be cast automatically to the type of the destination <ph id="ph2">`array`</ph>, the nongeneric implementations of <ph id="ph3">&lt;xref:System.Collections.ICollection.CopyTo%2A?displayProperty=fullName&gt;</ph> throw <ph id="ph4">&lt;xref:System.InvalidCastException&gt;</ph>, whereas the generic implementations throw <ph id="ph5">&lt;xref:System.ArgumentException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve">
          <source>The one-dimensional <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> that is the destination of the elements copied from <ph id="ph2">&lt;xref href="System.Collections.ICollection"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Array"&gt;&lt;/xref&gt;</ph> must have zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve">
          <source>The zero-based index in <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">array</ph><ept id="p1">&lt;/code&gt;</ept> at which copying begins.</source>
        </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;arrayIndex&lt;/code&gt;</ph> is less than 0.</source>
        </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> is multidimensional.</source>
        </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;array&lt;/code&gt;</ph> does not have zero-based indexing.</source>
        </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve">
          <source>The number of elements in the source <ph id="ph1">&lt;xref href="System.Collections.ICollection"&gt;&lt;/xref&gt;</ph> is greater than the available space from <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">arrayIndex</ph><ept id="p1">&lt;/code&gt;</ept> to the end of the destination <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">array</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve">
          <source>The type of the source <ph id="ph1">&lt;xref href="System.Collections.ICollection"&gt;&lt;/xref&gt;</ph> cannot be cast automatically to the type of the destination <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">array</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether access to the <ph id="ph1">&lt;xref href="System.Collections.ICollection"&gt;&lt;/xref&gt;</ph> is synchronized (thread safe).</source>
        </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=fullName&gt;</ph> namespace are not synchronized.</source>
        </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
        </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the rare case where enumeration contends with write accesses, you can lock the collection during the entire enumeration.</source>
        </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
        </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> returns an object that can be used to synchronize access to the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT">
          <source>Synchronization is effective only if all threads lock this object before accessing the collection.</source>
        </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if access to the <ph id="ph2">&lt;xref href="System.Collections.ICollection"&gt;&lt;/xref&gt;</ph> is synchronized (thread safe); otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve">
          <source>In the default implementation of <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve">
          <source>Gets an object that can be used to synchronize access to the <ph id="ph1">&lt;xref href="System.Collections.ICollection"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=fullName&gt;</ph> namespace are not synchronized.</source>
        </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerating through a collection is intrinsically not a thread-safe procedure.</source>
        </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
        </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
        </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> returns an object that can be used to synchronize access to the <ph id="ph2">&lt;xref:System.Collections.ICollection&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT">
          <source>Synchronization is effective only if all threads lock this object before accessing the collection.</source>
        </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following code shows the use of the <ph id="ph1">&lt;xref:System.Collections.ICollection.SyncRoot%2A&gt;</ph> property for C#, C++, and Visual Basic.</source>
        </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve">
          <source>An object that can be used to synchronize access to the <ph id="ph1">&lt;xref href="System.Collections.ICollection"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve">
          <source>In the default implementation of <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>, this property always returns the current instance.</source>
        </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve">
          <source>Returns an enumerator that iterates through a collection.</source>
        </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`foreach`</ph> statement of the C# language (<ph id="ph2">`for each`</ph> in C++, <ph id="ph3">`For Each`</ph> in Visual Basic) hides the complexity of the enumerators.</source>
        </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using <ph id="ph1">`foreach`</ph> is recommended, instead of directly manipulating the enumerator.</source>
        </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</source>
        </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT">
          <source>Initially, the enumerator is positioned before the first element in the collection.</source>
        </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> also brings the enumerator back to this position.</source>
        </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT">
          <source>At this position, the <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> property is undefined.</source>
        </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, you must call the <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> method to advance the enumerator to the first element of the collection before reading the value of <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> property returns the same object until either <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> is called.</source>
        </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> sets <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the next element.</source>
        </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> passes the end of the collection, the enumerator is positioned after the last element in the collection and <ph id="ph2">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returns <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT">
          <source>When the enumerator is at this position, subsequent calls to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> also return <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the last call to <ph id="ph1">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph> returned <ph id="ph2">`false`</ph>, <ph id="ph3">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> is undefined.</source>
        </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT">
          <source>To set <ph id="ph1">&lt;xref:System.Collections.IEnumerator.Current%2A&gt;</ph> to the first element of the collection again, you can call <ph id="ph2">&lt;xref:System.Collections.IEnumerator.Reset%2A&gt;</ph> followed by <ph id="ph3">&lt;xref:System.Collections.IEnumerator.MoveNext%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT">
          <source>An enumerator remains valid as long as the collection remains unchanged.</source>
        </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT">
          <source>If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</source>
        </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT">
          <source>The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</source>
        </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT">
          <source>To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</source>
        </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT">
          <source>To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</source>
        </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT">
          <source>Default implementations of collections in the <ph id="ph1">&lt;xref:System.Collections.Generic?displayProperty=fullName&gt;</ph> namespace are not synchronized.</source>
        </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">&lt;xref href="System.Collections.IEnumerator"&gt;&lt;/xref&gt;</ph> that can be used to iterate through the collection.</source>
        </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve">
          <source>Adds an item to the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph> is less than <ph id="ph2">&lt;xref:System.Collections.Generic.List%601.Capacity%2A&gt;</ph>, this method is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the capacity needs to be increased to accommodate the new element, this method becomes an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph> to add to the <ph id="ph2">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve">
          <source>The position into which the new element was inserted.</source>
        </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;item&lt;/code&gt;</ph> is of a type that is not assignable to the <ph id="ph2">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve">
          <source>Determines whether the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> contains a specific value.</source>
        </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
        </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph> to locate in the <ph id="ph2">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">item</ph><ept id="p1">&lt;/code&gt;</ept> is found in the <ph id="ph3">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve">
          <source>Determines the index of a specific item in the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
        </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve">
          <source>The object to locate in the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve">
          <source>The index of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">item</ph><ept id="p1">&lt;/code&gt;</ept> if found in the list; otherwise, –1.</source>
        </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;item&lt;/code&gt;</ph> is of a type that is not assignable to the <ph id="ph2">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve">
          <source>Inserts an item to the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> at the specified index.</source>
        </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`index`</ph> equals the number of items in the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph>, then <ph id="ph3">`item`</ph> is appended to the end.</source>
        </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve">
          <source>The zero-based index at which <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">item</ph><ept id="p1">&lt;/code&gt;</ept> should be inserted.</source>
        </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve">
          <source>The object to insert into the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is not a valid index in the <ph id="ph2">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;item&lt;/code&gt;</ph> is of a type that is not assignable to the <ph id="ph2">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> has a fixed size.</source>
        </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection with a fixed size does not allow the addition or removal of elements after the collection is created, but it allows the modification of existing elements.</source>
        </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection with a fixed size is simply a collection with a wrapper that prevents adding and removing elements; therefore, if changes are made to the underlying collection, including the addition or removal of elements, the fixed-size collection reflects those changes.</source>
        </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> has a fixed size; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve">
          <source>In the default implementation of <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> is read-only.</source>
        </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection that is read-only does not allow the addition, removal, or modification of elements after the collection is created.</source>
        </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT">
          <source>A collection that is read-only is simply a collection with a wrapper that prevents modifying the collection; therefore, if changes are made to the underlying collection, the read-only collection reflects those changes.</source>
        </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph> is read-only; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve">
          <source>In the default implementation of <ph id="ph1">&lt;xref href="System.Collections.Generic.List`1"&gt;&lt;/xref&gt;</ph>, this property always returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve">
          <source>Gets or sets the element at the specified index.</source>
        </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT">
          <source>The C# language uses the <bpt id="p1">[</bpt>this<ept id="p1">](~/docs/csharp/language-reference/keywords/this.md)</ept> keyword to define the indexers instead of implementing the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual Basic implements <ph id="ph1">&lt;xref:System.Collections.Generic.List%601.System%23Collections%23IList%23Item%2A&gt;</ph> as a default property, which provides the same indexing functionality.</source>
        </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT">
          <source>Retrieving the value of this property is an O(1) operation; setting the property is also an O(1) operation.</source>
        </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve">
          <source>The zero-based index of the element to get or set.</source>
        </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve">
          <source>The element at the specified index.</source>
        </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;index&lt;/code&gt;</ph> is not a valid index in the <ph id="ph2">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve">
          <source>The property is set and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">value</ph><ept id="p1">&lt;/code&gt;</ept> is of a type that is not assignable to the <ph id="ph2">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve">
          <source>Removes the first occurrence of a specific object from the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method determines equality using the default equality comparer <ph id="ph1">&lt;xref:System.Collections.Generic.EqualityComparer%601.Default%2A?displayProperty=fullName&gt;</ph> for <ph id="ph2">`T`</ph>, the type of values in the list.</source>
        </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method performs a linear search; therefore, this method is an O(<bpt id="p1">*</bpt><ph id="ph1">n</ph><ept id="p1">*</ept>) operation, where <bpt id="p2">*</bpt><ph id="ph2">n</ph><ept id="p2">*</ept> is <ph id="ph3">&lt;xref:System.Collections.Generic.List%601.Count%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve">
          <source>The object to remove from the <ph id="ph1">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;item&lt;/code&gt;</ph> is of a type that is not assignable to the <ph id="ph2">&lt;xref href="System.Collections.IList"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>