{"nodes":[{"content":"Provides a managed representation of a Win32 <code>OVERLAPPED</code> structure, including methods to transfer information from an <xref href=\"System.Threading.Overlapped\"></xref> instance to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.","nodes":[{"pos":[0,258],"content":"Provides a managed representation of a Win32 <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">OVERLAPPED</ph><ept id=\"p1\">&lt;/code&gt;</ept> structure, including methods to transfer information from an <ph id=\"ph2\">&lt;xref href=\"System.Threading.Overlapped\"&gt;&lt;/xref&gt;</ph> instance to a <ph id=\"ph3\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;&lt;/xref&gt;</ph> structure.","source":"Provides a managed representation of a Win32 <code>OVERLAPPED</code> structure, including methods to transfer information from an <xref href=\"System.Threading.Overlapped\"></xref> instance to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure."}],"pos":[1329,1588],"yaml":true},{"content":"The <xref:System.Threading.Overlapped.Pack%2A> and <xref:System.Threading.Overlapped.UnsafePack%2A> methods transfer information from an <xref:System.Threading.Overlapped> object to a <xref:System.Threading.NativeOverlapped> structure that can be passed to Win32 API functions for asynchronous file I/O. The <xref:System.Threading.Overlapped.Unpack%2A> method transfers information from a <xref:System.Threading.NativeOverlapped> structure to an instance of the <xref:System.Threading.Overlapped> class.  \n  \n Changes to the properties of an <xref:System.Threading.Overlapped> object affect its associated <xref:System.Threading.NativeOverlapped> structure, and vice versa.","nodes":[{"pos":[0,503],"content":"The <xref:System.Threading.Overlapped.Pack%2A> and <xref:System.Threading.Overlapped.UnsafePack%2A> methods transfer information from an <xref:System.Threading.Overlapped> object to a <xref:System.Threading.NativeOverlapped> structure that can be passed to Win32 API functions for asynchronous file I/O. The <xref:System.Threading.Overlapped.Unpack%2A> method transfers information from a <xref:System.Threading.NativeOverlapped> structure to an instance of the <xref:System.Threading.Overlapped> class.","nodes":[{"content":"The <xref:System.Threading.Overlapped.Pack%2A> and <xref:System.Threading.Overlapped.UnsafePack%2A> methods transfer information from an <xref:System.Threading.Overlapped> object to a <xref:System.Threading.NativeOverlapped> structure that can be passed to Win32 API functions for asynchronous file I/O. The <xref:System.Threading.Overlapped.Unpack%2A> method transfers information from a <xref:System.Threading.NativeOverlapped> structure to an instance of the <xref:System.Threading.Overlapped> class.","pos":[0,503],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped.Pack%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Threading.Overlapped.UnsafePack%2A&gt;</ph> methods transfer information from an <ph id=\"ph3\">&lt;xref:System.Threading.Overlapped&gt;</ph> object to a <ph id=\"ph4\">&lt;xref:System.Threading.NativeOverlapped&gt;</ph> structure that can be passed to Win32 API functions for asynchronous file I/O.","pos":[0,303],"source":"The <xref:System.Threading.Overlapped.Pack%2A> and <xref:System.Threading.Overlapped.UnsafePack%2A> methods transfer information from an <xref:System.Threading.Overlapped> object to a <xref:System.Threading.NativeOverlapped> structure that can be passed to Win32 API functions for asynchronous file I/O."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped.Unpack%2A&gt;</ph> method transfers information from a <ph id=\"ph2\">&lt;xref:System.Threading.NativeOverlapped&gt;</ph> structure to an instance of the <ph id=\"ph3\">&lt;xref:System.Threading.Overlapped&gt;</ph> class.","pos":[304,503],"source":" The <xref:System.Threading.Overlapped.Unpack%2A> method transfers information from a <xref:System.Threading.NativeOverlapped> structure to an instance of the <xref:System.Threading.Overlapped> class."}]}]},{"pos":[510,673],"content":"Changes to the properties of an <xref:System.Threading.Overlapped> object affect its associated <xref:System.Threading.NativeOverlapped> structure, and vice versa.","nodes":[{"content":"Changes to the properties of an <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped&gt;</ph> object affect its associated <ph id=\"ph2\">&lt;xref:System.Threading.NativeOverlapped&gt;</ph> structure, and vice versa.","pos":[0,163],"source":"Changes to the properties of an <xref:System.Threading.Overlapped> object affect its associated <xref:System.Threading.NativeOverlapped> structure, and vice versa."}]}],"pos":[1599,2277],"yaml":true,"extradata":"MT"},{"content":"Initializes a new, empty instance of the <xref href=\"System.Threading.Overlapped\"></xref> class.","nodes":[{"pos":[0,96],"content":"Initializes a new, empty instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;&lt;/xref&gt;</ph> class.","source":"Initializes a new, empty instance of the <xref href=\"System.Threading.Overlapped\"></xref> class."}],"pos":[3928,4025],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Threading.Overlapped\"></xref> class with the specified file position, the 32-bit integer handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation.","nodes":[{"pos":[0,284],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;&lt;/xref&gt;</ph> class with the specified file position, the 32-bit integer handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation.","source":"Initializes a new instance of the <xref href=\"System.Threading.Overlapped\"></xref> class with the specified file position, the 32-bit integer handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation."}],"pos":[5551,5836],"yaml":true},{"content":"Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class.  \n  \n Your implementation of <xref:System.IAsyncResult> provides status information on the I/O operation. Pass it to the constructor in the `ar` parameter, and retrieve it later with the <xref:System.Threading.Overlapped.AsyncResult%2A> property. If a callback method is specified for the <xref:System.Threading.Overlapped.Pack%2A> or <xref:System.Threading.Overlapped.UnsafePack%2A> method, the callback can retrieve your <xref:System.IAsyncResult> by unpacking the <xref:System.Threading.NativeOverlapped> structure it receives.","nodes":[{"pos":[0,205],"content":"Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class.","nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName&gt;</ph> property to get the handle of any managed synchronization event that derives from the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle&gt;</ph> class.","pos":[0,205],"source":"Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class."}]},{"pos":[212,736],"content":"Your implementation of <xref:System.IAsyncResult> provides status information on the I/O operation. Pass it to the constructor in the `ar` parameter, and retrieve it later with the <xref:System.Threading.Overlapped.AsyncResult%2A> property. If a callback method is specified for the <xref:System.Threading.Overlapped.Pack%2A> or <xref:System.Threading.Overlapped.UnsafePack%2A> method, the callback can retrieve your <xref:System.IAsyncResult> by unpacking the <xref:System.Threading.NativeOverlapped> structure it receives.","nodes":[{"content":"Your implementation of <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> provides status information on the I/O operation.","pos":[0,99],"source":"Your implementation of <xref:System.IAsyncResult> provides status information on the I/O operation."},{"content":"Pass it to the constructor in the <ph id=\"ph1\">`ar`</ph> parameter, and retrieve it later with the <ph id=\"ph2\">&lt;xref:System.Threading.Overlapped.AsyncResult%2A&gt;</ph> property.","pos":[100,240],"source":" Pass it to the constructor in the `ar` parameter, and retrieve it later with the <xref:System.Threading.Overlapped.AsyncResult%2A> property."},{"content":"If a callback method is specified for the <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped.Pack%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Overlapped.UnsafePack%2A&gt;</ph> method, the callback can retrieve your <ph id=\"ph3\">&lt;xref:System.IAsyncResult&gt;</ph> by unpacking the <ph id=\"ph4\">&lt;xref:System.Threading.NativeOverlapped&gt;</ph> structure it receives.","pos":[241,524],"source":" If a callback method is specified for the <xref:System.Threading.Overlapped.Pack%2A> or <xref:System.Threading.Overlapped.UnsafePack%2A> method, the callback can retrieve your <xref:System.IAsyncResult> by unpacking the <xref:System.Threading.NativeOverlapped> structure it receives."}]}],"pos":[5847,6588],"yaml":true,"extradata":"MT"},{"content":"The low word of the file position at which to start the transfer.","nodes":[{"pos":[0,65],"content":"The low word of the file position at which to start the transfer.","nodes":[{"content":"The low word of the file position at which to start the transfer.","pos":[0,65]}]}],"pos":[6893,6959],"yaml":true},{"content":"The high word of the file position at which to start the transfer.","nodes":[{"pos":[0,66],"content":"The high word of the file position at which to start the transfer.","nodes":[{"content":"The high word of the file position at which to start the transfer.","pos":[0,66]}]}],"pos":[7022,7089],"yaml":true},{"content":"The handle to an event that is signaled when the I/O operation is complete.","nodes":[{"pos":[0,75],"content":"The handle to an event that is signaled when the I/O operation is complete.","nodes":[{"content":"The handle to an event that is signaled when the I/O operation is complete.","pos":[0,75]}]}],"pos":[7150,7226],"yaml":true},{"content":"An object that implements the <xref href=\"System.IAsyncResult\"></xref> interface and provides status information on the I/O operation.","nodes":[{"pos":[0,134],"content":"An object that implements the <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> interface and provides status information on the I/O operation.","source":"An object that implements the <xref href=\"System.IAsyncResult\"></xref> interface and provides status information on the I/O operation."}],"pos":[7290,7425],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Threading.Overlapped\"></xref> class with the specified file position, the handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation.","nodes":[{"pos":[0,269],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;&lt;/xref&gt;</ph> class with the specified file position, the handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation.","source":"Initializes a new instance of the <xref href=\"System.Threading.Overlapped\"></xref> class with the specified file position, the handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation."}],"pos":[8942,9212],"yaml":true},{"content":"To get the handle of a managed synchronization object that derives from the <xref:System.Threading.WaitHandle> class, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> property to get a <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object, and then call the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.  \n  \n Your implementation of <xref:System.IAsyncResult> provides status information on the I/O operation. Pass it to the constructor in the `ar` parameter, and retrieve it later with the <xref:System.Threading.Overlapped.AsyncResult%2A> property. If a callback method is specified for the <xref:System.Threading.Overlapped.Pack%2A> or <xref:System.Threading.Overlapped.UnsafePack%2A> method, the callback can retrieve your <xref:System.IAsyncResult> by unpacking the <xref:System.Threading.NativeOverlapped> structure it receives.","nodes":[{"pos":[0,376],"content":"To get the handle of a managed synchronization object that derives from the <xref:System.Threading.WaitHandle> class, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> property to get a <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object, and then call the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.","nodes":[{"content":"To get the handle of a managed synchronization object that derives from the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> class, use the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName&gt;</ph> property to get a <ph id=\"ph3\">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> object, and then call the <ph id=\"ph4\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt;</ph> method.","pos":[0,376],"source":"To get the handle of a managed synchronization object that derives from the <xref:System.Threading.WaitHandle> class, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> property to get a <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object, and then call the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method."}]},{"pos":[383,907],"content":"Your implementation of <xref:System.IAsyncResult> provides status information on the I/O operation. Pass it to the constructor in the `ar` parameter, and retrieve it later with the <xref:System.Threading.Overlapped.AsyncResult%2A> property. If a callback method is specified for the <xref:System.Threading.Overlapped.Pack%2A> or <xref:System.Threading.Overlapped.UnsafePack%2A> method, the callback can retrieve your <xref:System.IAsyncResult> by unpacking the <xref:System.Threading.NativeOverlapped> structure it receives.","nodes":[{"content":"Your implementation of <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> provides status information on the I/O operation.","pos":[0,99],"source":"Your implementation of <xref:System.IAsyncResult> provides status information on the I/O operation."},{"content":"Pass it to the constructor in the <ph id=\"ph1\">`ar`</ph> parameter, and retrieve it later with the <ph id=\"ph2\">&lt;xref:System.Threading.Overlapped.AsyncResult%2A&gt;</ph> property.","pos":[100,240],"source":" Pass it to the constructor in the `ar` parameter, and retrieve it later with the <xref:System.Threading.Overlapped.AsyncResult%2A> property."},{"content":"If a callback method is specified for the <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped.Pack%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.Overlapped.UnsafePack%2A&gt;</ph> method, the callback can retrieve your <ph id=\"ph3\">&lt;xref:System.IAsyncResult&gt;</ph> by unpacking the <ph id=\"ph4\">&lt;xref:System.Threading.NativeOverlapped&gt;</ph> structure it receives.","pos":[241,524],"source":" If a callback method is specified for the <xref:System.Threading.Overlapped.Pack%2A> or <xref:System.Threading.Overlapped.UnsafePack%2A> method, the callback can retrieve your <xref:System.IAsyncResult> by unpacking the <xref:System.Threading.NativeOverlapped> structure it receives."}]}],"pos":[9223,10135],"yaml":true,"extradata":"MT"},{"content":"The low word of the file position at which to start the transfer.","nodes":[{"pos":[0,65],"content":"The low word of the file position at which to start the transfer.","nodes":[{"content":"The low word of the file position at which to start the transfer.","pos":[0,65]}]}],"pos":[10317,10383],"yaml":true},{"content":"The high word of the file position at which to start the transfer.","nodes":[{"pos":[0,66],"content":"The high word of the file position at which to start the transfer.","nodes":[{"content":"The high word of the file position at which to start the transfer.","pos":[0,66]}]}],"pos":[10446,10513],"yaml":true},{"content":"The handle to an event that is signaled when the I/O operation is complete.","nodes":[{"pos":[0,75],"content":"The handle to an event that is signaled when the I/O operation is complete.","nodes":[{"content":"The handle to an event that is signaled when the I/O operation is complete.","pos":[0,75]}]}],"pos":[10575,10651],"yaml":true},{"content":"An object that implements the <xref href=\"System.IAsyncResult\"></xref> interface and provides status information on the I/O operation.","nodes":[{"pos":[0,134],"content":"An object that implements the <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> interface and provides status information on the I/O operation.","source":"An object that implements the <xref href=\"System.IAsyncResult\"></xref> interface and provides status information on the I/O operation."}],"pos":[10715,10850],"yaml":true},{"content":"Gets or sets the object that provides status information on the I/O operation.","nodes":[{"pos":[0,78],"content":"Gets or sets the object that provides status information on the I/O operation.","nodes":[{"content":"Gets or sets the object that provides status information on the I/O operation.","pos":[0,78]}]}],"pos":[12043,12122],"yaml":true},{"content":"An object that implements the <xref href=\"System.IAsyncResult\"></xref> interface.","nodes":[{"pos":[0,81],"content":"An object that implements the <ph id=\"ph1\">&lt;xref href=\"System.IAsyncResult\"&gt;&lt;/xref&gt;</ph> interface.","source":"An object that implements the <xref href=\"System.IAsyncResult\"></xref> interface."}],"pos":[12254,12336],"yaml":true},{"content":"Gets or sets the 32-bit integer handle to a synchronization event that is signaled when the I/O operation is complete.","nodes":[{"pos":[0,118],"content":"Gets or sets the 32-bit integer handle to a synchronization event that is signaled when the I/O operation is complete.","nodes":[{"content":"Gets or sets the 32-bit integer handle to a synchronization event that is signaled when the I/O operation is complete.","pos":[0,118]}]}],"pos":[13535,13654],"yaml":true},{"content":"This property cannot be used on 64-bit platforms. Use the <xref:System.Threading.Overlapped.EventHandleIntPtr%2A> property instead.  \n  \n Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class.","nodes":[{"pos":[0,131],"content":"This property cannot be used on 64-bit platforms. Use the <xref:System.Threading.Overlapped.EventHandleIntPtr%2A> property instead.","nodes":[{"content":"This property cannot be used on 64-bit platforms. Use the <xref:System.Threading.Overlapped.EventHandleIntPtr%2A> property instead.","pos":[0,131],"nodes":[{"content":"This property cannot be used on 64-bit platforms.","pos":[0,49]},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped.EventHandleIntPtr%2A&gt;</ph> property instead.","pos":[50,131],"source":" Use the <xref:System.Threading.Overlapped.EventHandleIntPtr%2A> property instead."}]}]},{"pos":[138,343],"content":"Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class.","nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName&gt;</ph> property to get the handle of any managed synchronization event that derives from the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle&gt;</ph> class.","pos":[0,205],"source":"Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class."}]}],"pos":[13665,14013],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Int32\"></xref> value representing the handle of the synchronization event.","nodes":[{"pos":[0,96],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Int32\"&gt;&lt;/xref&gt;</ph> value representing the handle of the synchronization event.","source":"An <xref href=\"System.Int32\"></xref> value representing the handle of the synchronization event."}],"pos":[14220,14317],"yaml":true},{"content":"Gets or sets the handle to the synchronization event that is signaled when the I/O operation is complete.","nodes":[{"pos":[0,105],"content":"Gets or sets the handle to the synchronization event that is signaled when the I/O operation is complete.","nodes":[{"content":"Gets or sets the handle to the synchronization event that is signaled when the I/O operation is complete.","pos":[0,105]}]}],"pos":[15601,15707],"yaml":true},{"content":"To get the handle of a managed synchronization object that derives from the <xref:System.Threading.WaitHandle> class, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> property to get a <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object, and then call the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.","nodes":[{"pos":[0,376],"content":"To get the handle of a managed synchronization object that derives from the <xref:System.Threading.WaitHandle> class, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> property to get a <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object, and then call the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.","nodes":[{"content":"To get the handle of a managed synchronization object that derives from the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> class, use the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName&gt;</ph> property to get a <ph id=\"ph3\">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> object, and then call the <ph id=\"ph4\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt;</ph> method.","pos":[0,376],"source":"To get the handle of a managed synchronization object that derives from the <xref:System.Threading.WaitHandle> class, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> property to get a <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object, and then call the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method."}]}],"pos":[15718,16095],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.IntPtr\"></xref> representing the handle of the event.","nodes":[{"pos":[0,75],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IntPtr\"&gt;&lt;/xref&gt;</ph> representing the handle of the event.","source":"An <xref href=\"System.IntPtr\"></xref> representing the handle of the event."}],"pos":[16288,16364],"yaml":true},{"content":"Frees the unmanaged memory associated with a native overlapped structure allocated by the <xref href=\"System.Threading.Overlapped.Pack*\"></xref> method.","nodes":[{"pos":[0,152],"content":"Frees the unmanaged memory associated with a native overlapped structure allocated by the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Overlapped.Pack*\"&gt;&lt;/xref&gt;</ph> method.","source":"Frees the unmanaged memory associated with a native overlapped structure allocated by the <xref href=\"System.Threading.Overlapped.Pack*\"></xref> method."}],"pos":[17765,17918],"yaml":true},{"content":"You must call the <xref:System.Threading.Overlapped.Free%2A> method exactly once on every <xref:System.Threading.NativeOverlapped> pointer you receive from the <xref:System.Threading.Overlapped.Pack%2A> method. If you don't call the <xref:System.Threading.Overlapped.Free%2A> method, you will leak memory. If you call the <xref:System.Threading.Overlapped.Free%2A> method more than once, memory will be corrupted.","nodes":[{"pos":[0,413],"content":"You must call the <xref:System.Threading.Overlapped.Free%2A> method exactly once on every <xref:System.Threading.NativeOverlapped> pointer you receive from the <xref:System.Threading.Overlapped.Pack%2A> method. If you don't call the <xref:System.Threading.Overlapped.Free%2A> method, you will leak memory. If you call the <xref:System.Threading.Overlapped.Free%2A> method more than once, memory will be corrupted.","nodes":[{"content":"You must call the <xref:System.Threading.Overlapped.Free%2A> method exactly once on every <xref:System.Threading.NativeOverlapped> pointer you receive from the <xref:System.Threading.Overlapped.Pack%2A> method. If you don't call the <xref:System.Threading.Overlapped.Free%2A> method, you will leak memory. If you call the <xref:System.Threading.Overlapped.Free%2A> method more than once, memory will be corrupted.","pos":[0,413],"nodes":[{"content":"You must call the <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped.Free%2A&gt;</ph> method exactly once on every <ph id=\"ph2\">&lt;xref:System.Threading.NativeOverlapped&gt;</ph> pointer you receive from the <ph id=\"ph3\">&lt;xref:System.Threading.Overlapped.Pack%2A&gt;</ph> method.","pos":[0,210],"source":"You must call the <xref:System.Threading.Overlapped.Free%2A> method exactly once on every <xref:System.Threading.NativeOverlapped> pointer you receive from the <xref:System.Threading.Overlapped.Pack%2A> method."},{"content":"If you don't call the <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped.Free%2A&gt;</ph> method, you will leak memory.","pos":[211,305],"source":" If you don't call the <xref:System.Threading.Overlapped.Free%2A> method, you will leak memory."},{"content":"If you call the <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped.Free%2A&gt;</ph> method more than once, memory will be corrupted.","pos":[306,413],"source":" If you call the <xref:System.Threading.Overlapped.Free%2A> method more than once, memory will be corrupted."}]}]}],"pos":[17929,18343],"yaml":true,"extradata":"MT"},{"content":"A pointer to the <xref href=\"System.Threading.NativeOverlapped\"></xref> structure to be freed.","nodes":[{"pos":[0,94],"content":"A pointer to the <ph id=\"ph1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;&lt;/xref&gt;</ph> structure to be freed.","source":"A pointer to the <xref href=\"System.Threading.NativeOverlapped\"></xref> structure to be freed."}],"pos":[18605,18700],"yaml":true},{"content":"<code>nativeOverlappedPtr</code> is `null`.","nodes":[{"pos":[0,43],"content":"<ph id=\"ph1\">&lt;code&gt;nativeOverlappedPtr&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>nativeOverlappedPtr</code> is `null`."}],"pos":[18862,18906],"yaml":true},{"content":"Gets or sets the high-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.","nodes":[{"pos":[0,148],"content":"Gets or sets the high-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.","nodes":[{"content":"Gets or sets the high-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.","pos":[0,148],"nodes":[{"content":"Gets or sets the high-order word of the file position at which to start the transfer.","pos":[0,85]},{"content":"The file position is a byte offset from the start of the file.","pos":[86,148]}]}]}],"pos":[20082,20231],"yaml":true},{"content":"An <xref href=\"System.Int32\"></xref> value representing the high word of the file position.","nodes":[{"pos":[0,91],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Int32\"&gt;&lt;/xref&gt;</ph> value representing the high word of the file position.","source":"An <xref href=\"System.Int32\"></xref> value representing the high word of the file position."}],"pos":[20346,20438],"yaml":true},{"content":"Gets or sets the low-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.","nodes":[{"pos":[0,147],"content":"Gets or sets the low-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.","nodes":[{"content":"Gets or sets the low-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.","pos":[0,147],"nodes":[{"content":"Gets or sets the low-order word of the file position at which to start the transfer.","pos":[0,84]},{"content":"The file position is a byte offset from the start of the file.","pos":[85,147]}]}]}],"pos":[21624,21772],"yaml":true},{"content":"An <xref href=\"System.Int32\"></xref> value representing the low word of the file position.","nodes":[{"pos":[0,90],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Int32\"&gt;&lt;/xref&gt;</ph> value representing the low word of the file position.","source":"An <xref href=\"System.Int32\"></xref> value representing the low word of the file position."}],"pos":[21886,21977],"yaml":true},{"content":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying the delegate to be invoked when the asynchronous I/O operation is complete.","nodes":[{"pos":[0,186],"content":"Packs the current instance into a <ph id=\"ph1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;&lt;/xref&gt;</ph> structure, specifying the delegate to be invoked when the asynchronous I/O operation is complete.","source":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying the delegate to be invoked when the asynchronous I/O operation is complete."}],"pos":[23313,23500],"yaml":true},{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.  \n  \n> [!IMPORTANT]\n>  The caller is responsible for pinning the buffer. If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address. For this reason, it is better to use the <xref:System.Threading.Overlapped.Pack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer.","nodes":[{"pos":[0,258],"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.","nodes":[{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.","pos":[0,258],"nodes":[{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations.","pos":[0,113]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.NativeOverlapped&gt;</ph> structure is fixed in physical memory until <ph id=\"ph2\">&lt;xref:System.Threading.Overlapped.Unpack%2A&gt;</ph> is called.","pos":[114,258],"source":" The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called."}]}]},{"pos":[266,704],"content":"[!IMPORTANT]\n The caller is responsible for pinning the buffer. If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address. For this reason, it is better to use the <xref:System.Threading.Overlapped.Pack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer.","leadings":["","> "],"nodes":[{"content":" The caller is responsible for pinning the buffer. If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address. For this reason, it is better to use the <xref:System.Threading.Overlapped.Pack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer.","pos":[13,436],"nodes":[{"content":"The caller is responsible for pinning the buffer.","pos":[1,50]},{"content":"If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address.","pos":[51,228]},{"content":"For this reason, it is better to use the <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped.Pack%28System.Threading.IOCompletionCallback%2CSystem.Object%29&gt;</ph> method overload, in which the runtime pins the buffer.","pos":[229,423],"source":" For this reason, it is better to use the <xref:System.Threading.Overlapped.Pack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer."}]}]}],"pos":[23511,24221],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes.","nodes":[{"pos":[0,161],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Threading.IOCompletionCallback\"&gt;&lt;/xref&gt;</ph> delegate that represents the callback method invoked when the asynchronous I/O operation completes.","source":"An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes."}],"pos":[24543,24705],"yaml":true},{"content":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.","nodes":[{"pos":[0,91],"content":"An unmanaged pointer to a <ph id=\"ph1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;&lt;/xref&gt;</ph> structure.","source":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure."}],"pos":[24783,24875],"yaml":true},{"content":"The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed.","nodes":[{"pos":[0,85],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;&lt;/xref&gt;</ph> has already been packed.","source":"The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed."}],"pos":[25045,25131],"yaml":true},{"content":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying a delegate that is invoked when the asynchronous I/O operation is complete and a managed object that serves as a buffer.","nodes":[{"pos":[0,231],"content":"Packs the current instance into a <ph id=\"ph1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;&lt;/xref&gt;</ph> structure, specifying a delegate that is invoked when the asynchronous I/O operation is complete and a managed object that serves as a buffer.","source":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying a delegate that is invoked when the asynchronous I/O operation is complete and a managed object that serves as a buffer."}],"pos":[26553,26785],"yaml":true},{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.  \n  \n The buffer or buffers specified in `userData` must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O.  \n  \n> [!NOTE]\n>  The runtime pins the buffer or buffers specified in `userData` for the duration of the I/O operation. If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.","nodes":[{"pos":[0,258],"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.","nodes":[{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.","pos":[0,258],"nodes":[{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations.","pos":[0,113]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.NativeOverlapped&gt;</ph> structure is fixed in physical memory until <ph id=\"ph2\">&lt;xref:System.Threading.Overlapped.Unpack%2A&gt;</ph> is called.","pos":[114,258],"source":" The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called."}]}]},{"pos":[265,422],"content":"The buffer or buffers specified in <ph id=\"ph1\">`userData`</ph> must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O.","source":"The buffer or buffers specified in `userData` must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O."},{"pos":[430,652],"content":"[!NOTE]\n The runtime pins the buffer or buffers specified in `userData` for the duration of the I/O operation. If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.","leadings":["","> "],"nodes":[{"content":" The runtime pins the buffer or buffers specified in `userData` for the duration of the I/O operation. If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.","pos":[8,220],"nodes":[{"content":"The runtime pins the buffer or buffers specified in <ph id=\"ph1\">`userData`</ph> for the duration of the I/O operation.","pos":[1,102],"source":" The runtime pins the buffer or buffers specified in `userData` for the duration of the I/O operation."},{"content":"If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.","pos":[103,212]}]}]}],"pos":[26796,27456],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes.","nodes":[{"pos":[0,161],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Threading.IOCompletionCallback\"&gt;&lt;/xref&gt;</ph> delegate that represents the callback method invoked when the asynchronous I/O operation completes.","source":"An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes."}],"pos":[27792,27954],"yaml":true},{"content":"An object or array of objects representing the input or output buffer for the operation. Each object represents a buffer, for example an array of bytes.","nodes":[{"pos":[0,152],"content":"An object or array of objects representing the input or output buffer for the operation. Each object represents a buffer, for example an array of bytes.","nodes":[{"content":"An object or array of objects representing the input or output buffer for the operation. Each object represents a buffer, for example an array of bytes.","pos":[0,152],"nodes":[{"content":"An object or array of objects representing the input or output buffer for the operation.","pos":[0,88]},{"content":"Each object represents a buffer, for example an array of bytes.","pos":[89,152]}]}]}],"pos":[28018,28171],"yaml":true},{"content":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.","nodes":[{"pos":[0,91],"content":"An unmanaged pointer to a <ph id=\"ph1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;&lt;/xref&gt;</ph> structure.","source":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure."}],"pos":[28249,28341],"yaml":true},{"content":"The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed.","nodes":[{"pos":[0,85],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;&lt;/xref&gt;</ph> has already been packed.","source":"The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed."}],"pos":[28511,28597],"yaml":true},{"content":"Unpacks the specified unmanaged <xref href=\"System.Threading.NativeOverlapped\"></xref> structure into a managed <xref href=\"System.Threading.Overlapped\"></xref> object.","nodes":[{"pos":[0,168],"content":"Unpacks the specified unmanaged <ph id=\"ph1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;&lt;/xref&gt;</ph> structure into a managed <ph id=\"ph2\">&lt;xref href=\"System.Threading.Overlapped\"&gt;&lt;/xref&gt;</ph> object.","source":"Unpacks the specified unmanaged <xref href=\"System.Threading.NativeOverlapped\"></xref> structure into a managed <xref href=\"System.Threading.Overlapped\"></xref> object."}],"pos":[29973,30142],"yaml":true},{"content":"The <xref:System.Threading.NativeOverlapped> structure is not freed from physical memory until you call the <xref:System.Threading.Overlapped.Free%2A> method.","nodes":[{"pos":[0,158],"content":"The <xref:System.Threading.NativeOverlapped> structure is not freed from physical memory until you call the <xref:System.Threading.Overlapped.Free%2A> method.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.NativeOverlapped&gt;</ph> structure is not freed from physical memory until you call the <ph id=\"ph2\">&lt;xref:System.Threading.Overlapped.Free%2A&gt;</ph> method.","pos":[0,158],"source":"The <xref:System.Threading.NativeOverlapped> structure is not freed from physical memory until you call the <xref:System.Threading.Overlapped.Free%2A> method."}]}],"pos":[30153,30312],"yaml":true,"extradata":"MT"},{"content":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.","nodes":[{"pos":[0,91],"content":"An unmanaged pointer to a <ph id=\"ph1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;&lt;/xref&gt;</ph> structure.","source":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure."}],"pos":[30599,30691],"yaml":true},{"content":"An <xref href=\"System.Threading.Overlapped\"></xref> object containing the information unpacked from the native structure.","nodes":[{"pos":[0,121],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;&lt;/xref&gt;</ph> object containing the information unpacked from the native structure.","source":"An <xref href=\"System.Threading.Overlapped\"></xref> object containing the information unpacked from the native structure."}],"pos":[30762,30884],"yaml":true},{"content":"<code>nativeOverlappedPtr</code> is `null`.","nodes":[{"pos":[0,43],"content":"<ph id=\"ph1\">&lt;code&gt;nativeOverlappedPtr&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>nativeOverlappedPtr</code> is `null`."}],"pos":[31048,31092],"yaml":true},{"content":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure specifying the delegate to invoke when the asynchronous I/O operation is complete. Does not propagate the calling stack.","nodes":[{"pos":[0,219],"content":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure specifying the delegate to invoke when the asynchronous I/O operation is complete. Does not propagate the calling stack.","nodes":[{"content":"Packs the current instance into a <ph id=\"ph1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;&lt;/xref&gt;</ph> structure specifying the delegate to invoke when the asynchronous I/O operation is complete.","pos":[0,181],"source":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure specifying the delegate to invoke when the asynchronous I/O operation is complete."},{"content":"Does not propagate the calling stack.","pos":[182,219]}]}],"pos":[32449,32669],"yaml":true},{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.  \n  \n The caller is responsible for pinning the buffer. If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address. For this reason, it is better to use the <xref:System.Threading.Overlapped.UnsafePack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer.  \n  \n> [!CAUTION]\n>  Using the <xref:System.Threading.Overlapped.UnsafePack%2A> method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. The <xref:System.Threading.Overlapped.UnsafePack%2A> method does not propagate the calling stack. Malicious code might be able to exploit this to avoid permission checks.","nodes":[{"pos":[0,258],"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.","nodes":[{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.","pos":[0,258],"nodes":[{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations.","pos":[0,113]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.NativeOverlapped&gt;</ph> structure is fixed in physical memory until <ph id=\"ph2\">&lt;xref:System.Threading.Overlapped.Unpack%2A&gt;</ph> is called.","pos":[114,258],"source":" The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called."}]}]},{"pos":[265,693],"content":"The caller is responsible for pinning the buffer. If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address. For this reason, it is better to use the <xref:System.Threading.Overlapped.UnsafePack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer.","nodes":[{"content":"The caller is responsible for pinning the buffer. If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address. For this reason, it is better to use the <xref:System.Threading.Overlapped.UnsafePack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer.","pos":[0,428],"nodes":[{"content":"The caller is responsible for pinning the buffer.","pos":[0,49]},{"content":"If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address.","pos":[50,227]},{"content":"For this reason, it is better to use the <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped.UnsafePack%28System.Threading.IOCompletionCallback%2CSystem.Object%29&gt;</ph> method overload, in which the runtime pins the buffer.","pos":[228,428],"source":" For this reason, it is better to use the <xref:System.Threading.Overlapped.UnsafePack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer."}]}]},{"pos":[701,1097],"content":"[!CAUTION]\n Using the <xref:System.Threading.Overlapped.UnsafePack%2A> method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. The <xref:System.Threading.Overlapped.UnsafePack%2A> method does not propagate the calling stack. Malicious code might be able to exploit this to avoid permission checks.","leadings":["","> "],"nodes":[{"content":" Using the <xref:System.Threading.Overlapped.UnsafePack%2A> method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. The <xref:System.Threading.Overlapped.UnsafePack%2A> method does not propagate the calling stack. Malicious code might be able to exploit this to avoid permission checks.","pos":[11,394],"nodes":[{"content":"Using the <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped.UnsafePack%2A&gt;</ph> method could inadvertently open up a security hole.","pos":[1,111],"source":" Using the <xref:System.Threading.Overlapped.UnsafePack%2A> method could inadvertently open up a security hole."},{"content":"Code access security bases its permission checks on the permissions of all the callers on the stack.","pos":[112,212]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped.UnsafePack%2A&gt;</ph> method does not propagate the calling stack.","pos":[213,310],"source":" The <xref:System.Threading.Overlapped.UnsafePack%2A> method does not propagate the calling stack."},{"content":"Malicious code might be able to exploit this to avoid permission checks.","pos":[311,383]}]}]}],"pos":[32680,33785],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes.","nodes":[{"pos":[0,161],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Threading.IOCompletionCallback\"&gt;&lt;/xref&gt;</ph> delegate that represents the callback method invoked when the asynchronous I/O operation completes.","source":"An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes."}],"pos":[34119,34281],"yaml":true},{"content":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.","nodes":[{"pos":[0,91],"content":"An unmanaged pointer to a <ph id=\"ph1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;&lt;/xref&gt;</ph> structure.","source":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure."}],"pos":[34359,34451],"yaml":true},{"content":"The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed.","nodes":[{"pos":[0,85],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;&lt;/xref&gt;</ph> has already been packed.","source":"The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed."}],"pos":[34627,34713],"yaml":true},{"content":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying the delegate to invoke when the asynchronous I/O operation is complete and the managed object that serves as a buffer. Does not propagate the calling stack.","nodes":[{"pos":[0,267],"content":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying the delegate to invoke when the asynchronous I/O operation is complete and the managed object that serves as a buffer. Does not propagate the calling stack.","nodes":[{"content":"Packs the current instance into a <ph id=\"ph1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;&lt;/xref&gt;</ph> structure, specifying the delegate to invoke when the asynchronous I/O operation is complete and the managed object that serves as a buffer.","pos":[0,229],"source":"Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying the delegate to invoke when the asynchronous I/O operation is complete and the managed object that serves as a buffer."},{"content":"Does not propagate the calling stack.","pos":[230,267]}]}],"pos":[36171,36439],"yaml":true},{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.  \n  \n The buffer or buffers specified in `userData` must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O.  \n  \n The runtime pins the buffer or buffers specified in`userData` for the duration of the I/O operation. If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.  \n  \n> [!CAUTION]\n>  Using the <xref:System.Threading.Overlapped.UnsafePack%2A> method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. The <xref:System.Threading.Overlapped.UnsafePack%2A> method does not propagate the calling stack. Malicious code might be able to exploit this to avoid permission checks.","nodes":[{"pos":[0,258],"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.","nodes":[{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.","pos":[0,258],"nodes":[{"content":"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations.","pos":[0,113]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.NativeOverlapped&gt;</ph> structure is fixed in physical memory until <ph id=\"ph2\">&lt;xref:System.Threading.Overlapped.Unpack%2A&gt;</ph> is called.","pos":[114,258],"source":" The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called."}]}]},{"pos":[265,422],"content":"The buffer or buffers specified in <ph id=\"ph1\">`userData`</ph> must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O.","source":"The buffer or buffers specified in `userData` must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O."},{"pos":[429,639],"content":"The runtime pins the buffer or buffers specified in`userData` for the duration of the I/O operation. If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.","nodes":[{"content":"The runtime pins the buffer or buffers specified in<ph id=\"ph1\">`userData`</ph> for the duration of the I/O operation.","pos":[0,100],"source":"The runtime pins the buffer or buffers specified in`userData` for the duration of the I/O operation."},{"content":"If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.","pos":[101,210]}]},{"pos":[647,1043],"content":"[!CAUTION]\n Using the <xref:System.Threading.Overlapped.UnsafePack%2A> method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. The <xref:System.Threading.Overlapped.UnsafePack%2A> method does not propagate the calling stack. Malicious code might be able to exploit this to avoid permission checks.","leadings":["","> "],"nodes":[{"content":" Using the <xref:System.Threading.Overlapped.UnsafePack%2A> method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. The <xref:System.Threading.Overlapped.UnsafePack%2A> method does not propagate the calling stack. Malicious code might be able to exploit this to avoid permission checks.","pos":[11,394],"nodes":[{"content":"Using the <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped.UnsafePack%2A&gt;</ph> method could inadvertently open up a security hole.","pos":[1,111],"source":" Using the <xref:System.Threading.Overlapped.UnsafePack%2A> method could inadvertently open up a security hole."},{"content":"Code access security bases its permission checks on the permissions of all the callers on the stack.","pos":[112,212]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Overlapped.UnsafePack%2A&gt;</ph> method does not propagate the calling stack.","pos":[213,310],"source":" The <xref:System.Threading.Overlapped.UnsafePack%2A> method does not propagate the calling stack."},{"content":"Malicious code might be able to exploit this to avoid permission checks.","pos":[311,383]}]}]}],"pos":[36450,37503],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes.","nodes":[{"pos":[0,161],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Threading.IOCompletionCallback\"&gt;&lt;/xref&gt;</ph> delegate that represents the callback method invoked when the asynchronous I/O operation completes.","source":"An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes."}],"pos":[37845,38007],"yaml":true},{"content":"An object or array of objects representing the input or output buffer for the operation. Each object represents a buffer, for example an array of bytes.","nodes":[{"pos":[0,152],"content":"An object or array of objects representing the input or output buffer for the operation. Each object represents a buffer, for example an array of bytes.","nodes":[{"content":"An object or array of objects representing the input or output buffer for the operation. Each object represents a buffer, for example an array of bytes.","pos":[0,152],"nodes":[{"content":"An object or array of objects representing the input or output buffer for the operation.","pos":[0,88]},{"content":"Each object represents a buffer, for example an array of bytes.","pos":[89,152]}]}]}],"pos":[38071,38224],"yaml":true},{"content":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.","nodes":[{"pos":[0,91],"content":"An unmanaged pointer to a <ph id=\"ph1\">&lt;xref href=\"System.Threading.NativeOverlapped\"&gt;&lt;/xref&gt;</ph> structure.","source":"An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure."}],"pos":[38302,38394],"yaml":true},{"content":"The caller does not have the required permission.","nodes":[{"pos":[0,49],"content":"The caller does not have the required permission.","nodes":[{"content":"The caller does not have the required permission.","pos":[0,49]}]}],"pos":[38572,38622],"yaml":true},{"content":"The current <xref href=\"System.Threading.Overlapped\"></xref> is already packed.","nodes":[{"pos":[0,79],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Threading.Overlapped\"&gt;&lt;/xref&gt;</ph> is already packed.","source":"The current <xref href=\"System.Threading.Overlapped\"></xref> is already packed."}],"pos":[38732,38812],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.Overlapped\n  commentId: T:System.Threading.Overlapped\n  id: Overlapped\n  children:\n  - System.Threading.Overlapped.#ctor\n  - System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)\n  - System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)\n  - System.Threading.Overlapped.AsyncResult\n  - System.Threading.Overlapped.EventHandle\n  - System.Threading.Overlapped.EventHandleIntPtr\n  - System.Threading.Overlapped.Free(System.Threading.NativeOverlapped*)\n  - System.Threading.Overlapped.OffsetHigh\n  - System.Threading.Overlapped.OffsetLow\n  - System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback)\n  - System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback,System.Object)\n  - System.Threading.Overlapped.Unpack(System.Threading.NativeOverlapped*)\n  - System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback)\n  - System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback,System.Object)\n  langs:\n  - csharp\n  name: Overlapped\n  nameWithType: Overlapped\n  fullName: System.Threading.Overlapped\n  type: Class\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Provides a managed representation of a Win32 <code>OVERLAPPED</code> structure, including methods to transfer information from an <xref href=\"System.Threading.Overlapped\"></xref> instance to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.\n  remarks: \"The <xref:System.Threading.Overlapped.Pack%2A> and <xref:System.Threading.Overlapped.UnsafePack%2A> methods transfer information from an <xref:System.Threading.Overlapped> object to a <xref:System.Threading.NativeOverlapped> structure that can be passed to Win32 API functions for asynchronous file I/O. The <xref:System.Threading.Overlapped.Unpack%2A> method transfers information from a <xref:System.Threading.NativeOverlapped> structure to an instance of the <xref:System.Threading.Overlapped> class.  \\n  \\n Changes to the properties of an <xref:System.Threading.Overlapped> object affect its associated <xref:System.Threading.NativeOverlapped> structure, and vice versa.\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public class Overlapped\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Overlapped.#ctor\n  commentId: M:System.Threading.Overlapped.#ctor\n  id: '#ctor'\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: Overlapped()\n  nameWithType: Overlapped.Overlapped()\n  fullName: Overlapped.Overlapped()\n  type: Constructor\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Initializes a new, empty instance of the <xref href=\"System.Threading.Overlapped\"></xref> class.\n  syntax:\n    content: public Overlapped ();\n    parameters: []\n  overload: System.Threading.Overlapped.#ctor*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)\n  commentId: M:System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)\n  id: '#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)'\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: Overlapped(Int32, Int32, Int32, IAsyncResult)\n  nameWithType: Overlapped.Overlapped(Int32, Int32, Int32, IAsyncResult)\n  fullName: Overlapped.Overlapped(Int32, Int32, Int32, IAsyncResult)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.Overlapped\"></xref> class with the specified file position, the 32-bit integer handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation.\n  remarks: \"Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class.  \\n  \\n Your implementation of <xref:System.IAsyncResult> provides status information on the I/O operation. Pass it to the constructor in the `ar` parameter, and retrieve it later with the <xref:System.Threading.Overlapped.AsyncResult%2A> property. If a callback method is specified for the <xref:System.Threading.Overlapped.Pack%2A> or <xref:System.Threading.Overlapped.UnsafePack%2A> method, the callback can retrieve your <xref:System.IAsyncResult> by unpacking the <xref:System.Threading.NativeOverlapped> structure it receives.\"\n  syntax:\n    content: >-\n      [System.Obsolete(\"Not 64bit compatible.  Please use the constructor that takes IntPtr for the event handle\")]\n\n      public Overlapped (int offsetLo, int offsetHi, int hEvent, IAsyncResult ar);\n    parameters:\n    - id: offsetLo\n      type: System.Int32\n      description: The low word of the file position at which to start the transfer.\n    - id: offsetHi\n      type: System.Int32\n      description: The high word of the file position at which to start the transfer.\n    - id: hEvent\n      type: System.Int32\n      description: The handle to an event that is signaled when the I/O operation is complete.\n    - id: ar\n      type: System.IAsyncResult\n      description: An object that implements the <xref href=\"System.IAsyncResult\"></xref> interface and provides status information on the I/O operation.\n  overload: System.Threading.Overlapped.#ctor*\n  exceptions: []\n  attributes:\n  - type: System.ObsoleteAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)\n  commentId: M:System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)\n  id: '#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)'\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: Overlapped(Int32, Int32, IntPtr, IAsyncResult)\n  nameWithType: Overlapped.Overlapped(Int32, Int32, IntPtr, IAsyncResult)\n  fullName: Overlapped.Overlapped(Int32, Int32, IntPtr, IAsyncResult)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.Overlapped\"></xref> class with the specified file position, the handle to an event that is signaled when the I/O operation is complete, and an interface through which to return the results of the operation.\n  remarks: \"To get the handle of a managed synchronization object that derives from the <xref:System.Threading.WaitHandle> class, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> property to get a <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object, and then call the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.  \\n  \\n Your implementation of <xref:System.IAsyncResult> provides status information on the I/O operation. Pass it to the constructor in the `ar` parameter, and retrieve it later with the <xref:System.Threading.Overlapped.AsyncResult%2A> property. If a callback method is specified for the <xref:System.Threading.Overlapped.Pack%2A> or <xref:System.Threading.Overlapped.UnsafePack%2A> method, the callback can retrieve your <xref:System.IAsyncResult> by unpacking the <xref:System.Threading.NativeOverlapped> structure it receives.\"\n  syntax:\n    content: public Overlapped (int offsetLo, int offsetHi, IntPtr hEvent, IAsyncResult ar);\n    parameters:\n    - id: offsetLo\n      type: System.Int32\n      description: The low word of the file position at which to start the transfer.\n    - id: offsetHi\n      type: System.Int32\n      description: The high word of the file position at which to start the transfer.\n    - id: hEvent\n      type: System.IntPtr\n      description: The handle to an event that is signaled when the I/O operation is complete.\n    - id: ar\n      type: System.IAsyncResult\n      description: An object that implements the <xref href=\"System.IAsyncResult\"></xref> interface and provides status information on the I/O operation.\n  overload: System.Threading.Overlapped.#ctor*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Overlapped.AsyncResult\n  commentId: P:System.Threading.Overlapped.AsyncResult\n  id: AsyncResult\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: AsyncResult\n  nameWithType: Overlapped.AsyncResult\n  fullName: Overlapped.AsyncResult\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Gets or sets the object that provides status information on the I/O operation.\n  syntax:\n    content: public IAsyncResult AsyncResult { get; set; }\n    return:\n      type: System.IAsyncResult\n      description: An object that implements the <xref href=\"System.IAsyncResult\"></xref> interface.\n  overload: System.Threading.Overlapped.AsyncResult*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Overlapped.EventHandle\n  commentId: P:System.Threading.Overlapped.EventHandle\n  id: EventHandle\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: EventHandle\n  nameWithType: Overlapped.EventHandle\n  fullName: Overlapped.EventHandle\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Gets or sets the 32-bit integer handle to a synchronization event that is signaled when the I/O operation is complete.\n  remarks: \"This property cannot be used on 64-bit platforms. Use the <xref:System.Threading.Overlapped.EventHandleIntPtr%2A> property instead.  \\n  \\n Use the <xref:System.Threading.WaitHandle.Handle%2A?displayProperty=fullName> property to get the handle of any managed synchronization event that derives from the <xref:System.Threading.WaitHandle> class.\"\n  syntax:\n    content: >-\n      [System.Obsolete(\"Not 64bit compatible.  Use EventHandleIntPtr instead.\")]\n\n      public int EventHandle { get; set; }\n    return:\n      type: System.Int32\n      description: An <xref href=\"System.Int32\"></xref> value representing the handle of the synchronization event.\n  overload: System.Threading.Overlapped.EventHandle*\n  exceptions: []\n  attributes:\n  - type: System.ObsoleteAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Overlapped.EventHandleIntPtr\n  commentId: P:System.Threading.Overlapped.EventHandleIntPtr\n  id: EventHandleIntPtr\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: EventHandleIntPtr\n  nameWithType: Overlapped.EventHandleIntPtr\n  fullName: Overlapped.EventHandleIntPtr\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Gets or sets the handle to the synchronization event that is signaled when the I/O operation is complete.\n  remarks: To get the handle of a managed synchronization object that derives from the <xref:System.Threading.WaitHandle> class, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A?displayProperty=fullName> property to get a <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object, and then call the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method.\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public IntPtr EventHandleIntPtr { get; set; }\n    return:\n      type: System.IntPtr\n      description: An <xref href=\"System.IntPtr\"></xref> representing the handle of the event.\n  overload: System.Threading.Overlapped.EventHandleIntPtr*\n  exceptions: []\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Overlapped.Free(System.Threading.NativeOverlapped*)\n  commentId: M:System.Threading.Overlapped.Free(System.Threading.NativeOverlapped*)\n  id: Free(System.Threading.NativeOverlapped*)\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: Free(NativeOverlapped*)\n  nameWithType: Overlapped.Free(NativeOverlapped*)\n  fullName: Overlapped.Free(NativeOverlapped*)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Frees the unmanaged memory associated with a native overlapped structure allocated by the <xref href=\"System.Threading.Overlapped.Pack*\"></xref> method.\n  remarks: You must call the <xref:System.Threading.Overlapped.Free%2A> method exactly once on every <xref:System.Threading.NativeOverlapped> pointer you receive from the <xref:System.Threading.Overlapped.Pack%2A> method. If you don't call the <xref:System.Threading.Overlapped.Free%2A> method, you will leak memory. If you call the <xref:System.Threading.Overlapped.Free%2A> method more than once, memory will be corrupted.\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      public static void Free (System.Threading.NativeOverlapped* nativeOverlappedPtr);\n    parameters:\n    - id: nativeOverlappedPtr\n      type: System.Threading.NativeOverlapped*\n      description: A pointer to the <xref href=\"System.Threading.NativeOverlapped\"></xref> structure to be freed.\n  overload: System.Threading.Overlapped.Free*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>nativeOverlappedPtr</code> is `null`.\n  attributes:\n  - type: System.CLSCompliantAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Overlapped.OffsetHigh\n  commentId: P:System.Threading.Overlapped.OffsetHigh\n  id: OffsetHigh\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: OffsetHigh\n  nameWithType: Overlapped.OffsetHigh\n  fullName: Overlapped.OffsetHigh\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Gets or sets the high-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.\n  syntax:\n    content: public int OffsetHigh { get; set; }\n    return:\n      type: System.Int32\n      description: An <xref href=\"System.Int32\"></xref> value representing the high word of the file position.\n  overload: System.Threading.Overlapped.OffsetHigh*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Overlapped.OffsetLow\n  commentId: P:System.Threading.Overlapped.OffsetLow\n  id: OffsetLow\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: OffsetLow\n  nameWithType: Overlapped.OffsetLow\n  fullName: Overlapped.OffsetLow\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Gets or sets the low-order word of the file position at which to start the transfer. The file position is a byte offset from the start of the file.\n  syntax:\n    content: public int OffsetLow { get; set; }\n    return:\n      type: System.Int32\n      description: An <xref href=\"System.Int32\"></xref> value representing the low word of the file position.\n  overload: System.Threading.Overlapped.OffsetLow*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback)\n  commentId: M:System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback)\n  id: Pack(System.Threading.IOCompletionCallback)\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: Pack(IOCompletionCallback)\n  nameWithType: Overlapped.Pack(IOCompletionCallback)\n  fullName: Overlapped.Pack(IOCompletionCallback)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying the delegate to be invoked when the asynchronous I/O operation is complete.\n  remarks: \"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.  \\n  \\n> [!IMPORTANT]\\n>  The caller is responsible for pinning the buffer. If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address. For this reason, it is better to use the <xref:System.Threading.Overlapped.Pack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      [System.Obsolete(\"Use Pack(iocb, userData) instead\")]\n\n      public System.Threading.NativeOverlapped* Pack (System.Threading.IOCompletionCallback iocb);\n    parameters:\n    - id: iocb\n      type: System.Threading.IOCompletionCallback\n      description: An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes.\n    return:\n      type: System.Threading.NativeOverlapped*\n      description: An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.\n  overload: System.Threading.Overlapped.Pack*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed.\n  attributes:\n  - type: System.CLSCompliantAttribute\n  - type: System.ObsoleteAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback,System.Object)\n  commentId: M:System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback,System.Object)\n  id: Pack(System.Threading.IOCompletionCallback,System.Object)\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: Pack(IOCompletionCallback, Object)\n  nameWithType: Overlapped.Pack(IOCompletionCallback, Object)\n  fullName: Overlapped.Pack(IOCompletionCallback, Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying a delegate that is invoked when the asynchronous I/O operation is complete and a managed object that serves as a buffer.\n  remarks: \"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.  \\n  \\n The buffer or buffers specified in `userData` must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O.  \\n  \\n> [!NOTE]\\n>  The runtime pins the buffer or buffers specified in `userData` for the duration of the I/O operation. If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public System.Threading.NativeOverlapped* Pack (System.Threading.IOCompletionCallback iocb, object userData);\n    parameters:\n    - id: iocb\n      type: System.Threading.IOCompletionCallback\n      description: An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes.\n    - id: userData\n      type: System.Object\n      description: An object or array of objects representing the input or output buffer for the operation. Each object represents a buffer, for example an array of bytes.\n    return:\n      type: System.Threading.NativeOverlapped*\n      description: An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.\n  overload: System.Threading.Overlapped.Pack*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed.\n  attributes:\n  - type: System.CLSCompliantAttribute\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Overlapped.Unpack(System.Threading.NativeOverlapped*)\n  commentId: M:System.Threading.Overlapped.Unpack(System.Threading.NativeOverlapped*)\n  id: Unpack(System.Threading.NativeOverlapped*)\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: Unpack(NativeOverlapped*)\n  nameWithType: Overlapped.Unpack(NativeOverlapped*)\n  fullName: Overlapped.Unpack(NativeOverlapped*)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Unpacks the specified unmanaged <xref href=\"System.Threading.NativeOverlapped\"></xref> structure into a managed <xref href=\"System.Threading.Overlapped\"></xref> object.\n  remarks: The <xref:System.Threading.NativeOverlapped> structure is not freed from physical memory until you call the <xref:System.Threading.Overlapped.Free%2A> method.\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      public static System.Threading.Overlapped Unpack (System.Threading.NativeOverlapped* nativeOverlappedPtr);\n    parameters:\n    - id: nativeOverlappedPtr\n      type: System.Threading.NativeOverlapped*\n      description: An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.\n    return:\n      type: System.Threading.Overlapped\n      description: An <xref href=\"System.Threading.Overlapped\"></xref> object containing the information unpacked from the native structure.\n  overload: System.Threading.Overlapped.Unpack*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>nativeOverlappedPtr</code> is `null`.\n  attributes:\n  - type: System.CLSCompliantAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback)\n  commentId: M:System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback)\n  id: UnsafePack(System.Threading.IOCompletionCallback)\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: UnsafePack(IOCompletionCallback)\n  nameWithType: Overlapped.UnsafePack(IOCompletionCallback)\n  fullName: Overlapped.UnsafePack(IOCompletionCallback)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure specifying the delegate to invoke when the asynchronous I/O operation is complete. Does not propagate the calling stack.\n  remarks: \"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.  \\n  \\n The caller is responsible for pinning the buffer. If the application domain is unloaded, however, the handle to the pinned buffer is destroyed and the buffer is released, leaving the I/O operation to write to the freed address. For this reason, it is better to use the <xref:System.Threading.Overlapped.UnsafePack%28System.Threading.IOCompletionCallback%2CSystem.Object%29> method overload, in which the runtime pins the buffer.  \\n  \\n> [!CAUTION]\\n>  Using the <xref:System.Threading.Overlapped.UnsafePack%2A> method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. The <xref:System.Threading.Overlapped.UnsafePack%2A> method does not propagate the calling stack. Malicious code might be able to exploit this to avoid permission checks.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      [System.Obsolete(\"Use UnsafePack(iocb, userData) instead\")]\n\n      public System.Threading.NativeOverlapped* UnsafePack (System.Threading.IOCompletionCallback iocb);\n    parameters:\n    - id: iocb\n      type: System.Threading.IOCompletionCallback\n      description: An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes.\n    return:\n      type: System.Threading.NativeOverlapped*\n      description: An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.\n  overload: System.Threading.Overlapped.UnsafePack*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current <xref href=\"System.Threading.Overlapped\"></xref> has already been packed.\n  attributes:\n  - type: System.CLSCompliantAttribute\n  - type: System.ObsoleteAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback,System.Object)\n  commentId: M:System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback,System.Object)\n  id: UnsafePack(System.Threading.IOCompletionCallback,System.Object)\n  parent: System.Threading.Overlapped\n  langs:\n  - csharp\n  name: UnsafePack(IOCompletionCallback, Object)\n  nameWithType: Overlapped.UnsafePack(IOCompletionCallback, Object)\n  fullName: Overlapped.UnsafePack(IOCompletionCallback, Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Threading.Overlapped\n  namespace: System.Threading\n  summary: Packs the current instance into a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure, specifying the delegate to invoke when the asynchronous I/O operation is complete and the managed object that serves as a buffer. Does not propagate the calling stack.\n  remarks: \"The unmanaged pointer returned by this method can be passed to the operating system in overlapped I/O operations. The <xref:System.Threading.NativeOverlapped> structure is fixed in physical memory until <xref:System.Threading.Overlapped.Unpack%2A> is called.  \\n  \\n The buffer or buffers specified in `userData` must be the same as those passed to the unmanaged operating system function that performs the asynchronous I/O.  \\n  \\n The runtime pins the buffer or buffers specified in`userData` for the duration of the I/O operation. If the application domain is unloaded, the runtime keeps the memory pinned until the I/O operation completes.  \\n  \\n> [!CAUTION]\\n>  Using the <xref:System.Threading.Overlapped.UnsafePack%2A> method could inadvertently open up a security hole. Code access security bases its permission checks on the permissions of all the callers on the stack. The <xref:System.Threading.Overlapped.UnsafePack%2A> method does not propagate the calling stack. Malicious code might be able to exploit this to avoid permission checks.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public System.Threading.NativeOverlapped* UnsafePack (System.Threading.IOCompletionCallback iocb, object userData);\n    parameters:\n    - id: iocb\n      type: System.Threading.IOCompletionCallback\n      description: An <xref href=\"System.Threading.IOCompletionCallback\"></xref> delegate that represents the callback method invoked when the asynchronous I/O operation completes.\n    - id: userData\n      type: System.Object\n      description: An object or array of objects representing the input or output buffer for the operation. Each object represents a buffer, for example an array of bytes.\n    return:\n      type: System.Threading.NativeOverlapped*\n      description: An unmanaged pointer to a <xref href=\"System.Threading.NativeOverlapped\"></xref> structure.\n  overload: System.Threading.Overlapped.UnsafePack*\n  exceptions:\n  - type: System.Security.SecurityException\n    commentId: T:System.Security.SecurityException\n    description: The caller does not have the required permission.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current <xref href=\"System.Threading.Overlapped\"></xref> is already packed.\n  attributes:\n  - type: System.CLSCompliantAttribute\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.InvalidOperationException\n  parent: System\n  isExternal: false\n  name: InvalidOperationException\n  nameWithType: InvalidOperationException\n  fullName: System.InvalidOperationException\n- uid: System.Security.SecurityException\n  parent: System.Security\n  isExternal: false\n  name: SecurityException\n  nameWithType: SecurityException\n  fullName: System.Security.SecurityException\n- uid: System.Threading.Overlapped.#ctor\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Overlapped()\n  nameWithType: Overlapped.Overlapped()\n  fullName: Overlapped.Overlapped()\n- uid: System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.Int32,System.IAsyncResult)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Overlapped(Int32, Int32, Int32, IAsyncResult)\n  nameWithType: Overlapped.Overlapped(Int32, Int32, Int32, IAsyncResult)\n  fullName: Overlapped.Overlapped(Int32, Int32, Int32, IAsyncResult)\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.IAsyncResult\n  parent: System\n  isExternal: false\n  name: IAsyncResult\n  nameWithType: IAsyncResult\n  fullName: System.IAsyncResult\n- uid: System.Threading.Overlapped.#ctor(System.Int32,System.Int32,System.IntPtr,System.IAsyncResult)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Overlapped(Int32, Int32, IntPtr, IAsyncResult)\n  nameWithType: Overlapped.Overlapped(Int32, Int32, IntPtr, IAsyncResult)\n  fullName: Overlapped.Overlapped(Int32, Int32, IntPtr, IAsyncResult)\n- uid: System.IntPtr\n  parent: System\n  isExternal: false\n  name: IntPtr\n  nameWithType: IntPtr\n  fullName: System.IntPtr\n- uid: System.Threading.Overlapped.AsyncResult\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: AsyncResult\n  nameWithType: Overlapped.AsyncResult\n  fullName: Overlapped.AsyncResult\n- uid: System.Threading.Overlapped.EventHandle\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: EventHandle\n  nameWithType: Overlapped.EventHandle\n  fullName: Overlapped.EventHandle\n- uid: System.Threading.Overlapped.EventHandleIntPtr\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: EventHandleIntPtr\n  nameWithType: Overlapped.EventHandleIntPtr\n  fullName: Overlapped.EventHandleIntPtr\n- uid: System.Threading.Overlapped.Free(System.Threading.NativeOverlapped*)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Free(NativeOverlapped*)\n  nameWithType: Overlapped.Free(NativeOverlapped*)\n  fullName: Overlapped.Free(NativeOverlapped*)\n- uid: System.Threading.NativeOverlapped\n  name: NativeOverlapped\n  nameWithType: NativeOverlapped\n  fullName: System.Threading.NativeOverlapped\n- uid: System.Threading.NativeOverlapped*\n  parent: System.Threading\n  isExternal: false\n  name: NativeOverlapped*\n  nameWithType: NativeOverlapped*\n  fullName: System.Threading.NativeOverlapped*\n  spec.csharp:\n  - uid: System.Threading.NativeOverlapped\n    name: NativeOverlapped\n    nameWithType: NativeOverlapped\n    fullName: System.Threading.NativeOverlapped\n  - name: '*'\n    nameWithType: '*'\n    fullName: '*'\n- uid: System.Threading.Overlapped.OffsetHigh\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: OffsetHigh\n  nameWithType: Overlapped.OffsetHigh\n  fullName: Overlapped.OffsetHigh\n- uid: System.Threading.Overlapped.OffsetLow\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: OffsetLow\n  nameWithType: Overlapped.OffsetLow\n  fullName: Overlapped.OffsetLow\n- uid: System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Pack(IOCompletionCallback)\n  nameWithType: Overlapped.Pack(IOCompletionCallback)\n  fullName: Overlapped.Pack(IOCompletionCallback)\n- uid: System.Threading.IOCompletionCallback\n  parent: System.Threading\n  isExternal: false\n  name: IOCompletionCallback\n  nameWithType: IOCompletionCallback\n  fullName: System.Threading.IOCompletionCallback\n- uid: System.Threading.Overlapped.Pack(System.Threading.IOCompletionCallback,System.Object)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Pack(IOCompletionCallback, Object)\n  nameWithType: Overlapped.Pack(IOCompletionCallback, Object)\n  fullName: Overlapped.Pack(IOCompletionCallback, Object)\n- uid: System.Threading.Overlapped.Unpack(System.Threading.NativeOverlapped*)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Unpack(NativeOverlapped*)\n  nameWithType: Overlapped.Unpack(NativeOverlapped*)\n  fullName: Overlapped.Unpack(NativeOverlapped*)\n- uid: System.Threading.Overlapped\n  parent: System.Threading\n  isExternal: false\n  name: Overlapped\n  nameWithType: Overlapped\n  fullName: System.Threading.Overlapped\n- uid: System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: UnsafePack(IOCompletionCallback)\n  nameWithType: Overlapped.UnsafePack(IOCompletionCallback)\n  fullName: Overlapped.UnsafePack(IOCompletionCallback)\n- uid: System.Threading.Overlapped.UnsafePack(System.Threading.IOCompletionCallback,System.Object)\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: UnsafePack(IOCompletionCallback, Object)\n  nameWithType: Overlapped.UnsafePack(IOCompletionCallback, Object)\n  fullName: Overlapped.UnsafePack(IOCompletionCallback, Object)\n- uid: System.Threading.Overlapped.#ctor*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Overlapped\n  nameWithType: Overlapped.Overlapped\n  fullName: Overlapped.Overlapped\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n- uid: System.Threading.Overlapped.AsyncResult*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: AsyncResult\n  nameWithType: Overlapped.AsyncResult\n  fullName: Overlapped.AsyncResult\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n- uid: System.Threading.Overlapped.EventHandle*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: EventHandle\n  nameWithType: Overlapped.EventHandle\n  fullName: Overlapped.EventHandle\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n- uid: System.Threading.Overlapped.EventHandleIntPtr*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: EventHandleIntPtr\n  nameWithType: Overlapped.EventHandleIntPtr\n  fullName: Overlapped.EventHandleIntPtr\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n- uid: System.Threading.Overlapped.Free*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Free\n  nameWithType: Overlapped.Free\n  fullName: Overlapped.Free\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n- uid: System.Threading.Overlapped.OffsetHigh*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: OffsetHigh\n  nameWithType: Overlapped.OffsetHigh\n  fullName: Overlapped.OffsetHigh\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n- uid: System.Threading.Overlapped.OffsetLow*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: OffsetLow\n  nameWithType: Overlapped.OffsetLow\n  fullName: Overlapped.OffsetLow\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n- uid: System.Threading.Overlapped.Pack*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Pack\n  nameWithType: Overlapped.Pack\n  fullName: Overlapped.Pack\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n- uid: System.Threading.Overlapped.Unpack*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: Unpack\n  nameWithType: Overlapped.Unpack\n  fullName: Overlapped.Unpack\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n- uid: System.Threading.Overlapped.UnsafePack*\n  parent: System.Threading.Overlapped\n  isExternal: false\n  name: UnsafePack\n  nameWithType: Overlapped.UnsafePack\n  fullName: Overlapped.UnsafePack\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Overlapped.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n"}