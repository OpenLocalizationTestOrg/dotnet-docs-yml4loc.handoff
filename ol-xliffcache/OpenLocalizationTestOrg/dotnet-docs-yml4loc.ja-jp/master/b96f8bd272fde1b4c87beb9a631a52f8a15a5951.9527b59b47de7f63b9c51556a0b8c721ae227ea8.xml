{"nodes":[{"content":"Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.","nodes":[{"pos":[0,154],"content":"Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.","nodes":[{"content":"Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.","pos":[0,154]}]}],"pos":[893,1048],"yaml":true},{"content":"For an example of how to use a Spin Lock, see [How to: Use SpinLock for Low-Level Synchronization](~/docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md).  \n  \n Spin locks can be used for leaf-level locks where the object allocation implied by using a <xref:System.Threading.Monitor>, in size or due to garbage collection pressure, is overly expensive. A spin lock can be useful in to avoid blocking; however, if you expect a significant amount of blocking, you should probably not use spin locks due to excessive spinning. Spinning can be beneficial when locks are fine-grained and large in number (for example, a lock per node in a linked list) and also when lock hold-times are always extremely short. In general, while holding a spin lock, one should avoid any of these actions:  \n  \n-   blocking,  \n  \n-   calling anything that itself may block,  \n  \n-   holding more than one spin lock at once,  \n  \n-   making dynamically dispatched calls (interface and virtuals),  \n  \n-   making statically dispatched calls into any code one doesn't own, or  \n  \n-   allocating memory.  \n  \n <xref:System.Threading.SpinLock> should only be used after you have been determined that doing so will improve an application's performance. It is also important to note that <xref:System.Threading.SpinLock> is a value type, for performance reasons. For this reason, you must be very careful not to accidentally copy a <xref:System.Threading.SpinLock> instance, as the two instances (the original and the copy) would then be completely independent of one another, which would likely lead to erroneous behavior of the application. If a <xref:System.Threading.SpinLock> instance must be passed around, it should be passed by reference rather than by value.  \n  \n Do not store <xref:System.Threading.SpinLock> instances in readonly fields.","nodes":[{"pos":[0,179],"content":"For an example of how to use a Spin Lock, see <bpt id=\"p1\">[</bpt>How to: Use SpinLock for Low-Level Synchronization<ept id=\"p1\">](~/docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)</ept>.","source":"For an example of how to use a Spin Lock, see [How to: Use SpinLock for Low-Level Synchronization](~/docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md)."},{"pos":[186,807],"content":"Spin locks can be used for leaf-level locks where the object allocation implied by using a <xref:System.Threading.Monitor>, in size or due to garbage collection pressure, is overly expensive. A spin lock can be useful in to avoid blocking; however, if you expect a significant amount of blocking, you should probably not use spin locks due to excessive spinning. Spinning can be beneficial when locks are fine-grained and large in number (for example, a lock per node in a linked list) and also when lock hold-times are always extremely short. In general, while holding a spin lock, one should avoid any of these actions:","nodes":[{"content":"Spin locks can be used for leaf-level locks where the object allocation implied by using a <xref:System.Threading.Monitor>, in size or due to garbage collection pressure, is overly expensive. A spin lock can be useful in to avoid blocking; however, if you expect a significant amount of blocking, you should probably not use spin locks due to excessive spinning. Spinning can be beneficial when locks are fine-grained and large in number (for example, a lock per node in a linked list) and also when lock hold-times are always extremely short. In general, while holding a spin lock, one should avoid any of these actions:","pos":[0,621],"nodes":[{"content":"Spin locks can be used for leaf-level locks where the object allocation implied by using a <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph>, in size or due to garbage collection pressure, is overly expensive.","pos":[0,191],"source":"Spin locks can be used for leaf-level locks where the object allocation implied by using a <xref:System.Threading.Monitor>, in size or due to garbage collection pressure, is overly expensive."},{"content":"A spin lock can be useful in to avoid blocking; however, if you expect a significant amount of blocking, you should probably not use spin locks due to excessive spinning.","pos":[192,362]},{"content":"Spinning can be beneficial when locks are fine-grained and large in number (for example, a lock per node in a linked list) and also when lock hold-times are always extremely short.","pos":[363,543]},{"content":"In general, while holding a spin lock, one should avoid any of these actions:","pos":[544,621]}]}]},{"pos":[817,826],"content":"blocking,","nodes":[{"content":"blocking,","pos":[0,9]}]},{"pos":[836,875],"content":"calling anything that itself may block,","nodes":[{"content":"calling anything that itself may block,","pos":[0,39]}]},{"pos":[885,925],"content":"holding more than one spin lock at once,","nodes":[{"content":"holding more than one spin lock at once,","pos":[0,40]}]},{"pos":[935,996],"content":"making dynamically dispatched calls (interface and virtuals),","nodes":[{"content":"making dynamically dispatched calls (interface and virtuals),","pos":[0,61]}]},{"pos":[1006,1074],"content":"making statically dispatched calls into any code one doesn't own, or","nodes":[{"content":"making statically dispatched calls into any code one doesn't own, or","pos":[0,68]}]},{"pos":[1084,1102],"content":"allocating memory.","nodes":[{"content":"allocating memory.","pos":[0,18]}]},{"pos":[1109,1763],"content":"<xref:System.Threading.SpinLock> should only be used after you have been determined that doing so will improve an application's performance. It is also important to note that <xref:System.Threading.SpinLock> is a value type, for performance reasons. For this reason, you must be very careful not to accidentally copy a <xref:System.Threading.SpinLock> instance, as the two instances (the original and the copy) would then be completely independent of one another, which would likely lead to erroneous behavior of the application. If a <xref:System.Threading.SpinLock> instance must be passed around, it should be passed by reference rather than by value.","nodes":[{"content":"<xref:System.Threading.SpinLock> should only be used after you have been determined that doing so will improve an application's performance. It is also important to note that <xref:System.Threading.SpinLock> is a value type, for performance reasons. For this reason, you must be very careful not to accidentally copy a <xref:System.Threading.SpinLock> instance, as the two instances (the original and the copy) would then be completely independent of one another, which would likely lead to erroneous behavior of the application. If a <xref:System.Threading.SpinLock> instance must be passed around, it should be passed by reference rather than by value.","pos":[0,654],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> should only be used after you have been determined that doing so will improve an application's performance.","pos":[0,140],"source":"<xref:System.Threading.SpinLock> should only be used after you have been determined that doing so will improve an application's performance."},{"content":"It is also important to note that <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> is a value type, for performance reasons.","pos":[141,249],"source":" It is also important to note that <xref:System.Threading.SpinLock> is a value type, for performance reasons."},{"content":"For this reason, you must be very careful not to accidentally copy a <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> instance, as the two instances (the original and the copy) would then be completely independent of one another, which would likely lead to erroneous behavior of the application.","pos":[250,529],"source":" For this reason, you must be very careful not to accidentally copy a <xref:System.Threading.SpinLock> instance, as the two instances (the original and the copy) would then be completely independent of one another, which would likely lead to erroneous behavior of the application."},{"content":"If a <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> instance must be passed around, it should be passed by reference rather than by value.","pos":[530,654],"source":" If a <xref:System.Threading.SpinLock> instance must be passed around, it should be passed by reference rather than by value."}]}]},{"pos":[1770,1845],"content":"Do not store <xref:System.Threading.SpinLock> instances in readonly fields.","nodes":[{"content":"Do not store <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> instances in readonly fields.","pos":[0,75],"source":"Do not store <xref:System.Threading.SpinLock> instances in readonly fields."}]}],"pos":[1059,2925],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Threading.SpinLock\"></xref> structure with the option to track thread IDs to improve debugging.","nodes":[{"pos":[0,148],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.SpinLock\"&gt;&lt;/xref&gt;</ph> structure with the option to track thread IDs to improve debugging.","source":"Initializes a new instance of the <xref href=\"System.Threading.SpinLock\"></xref> structure with the option to track thread IDs to improve debugging."}],"pos":[5028,5177],"yaml":true},{"content":"The default constructor for <xref:System.Threading.SpinLock> tracks thread ownership.","nodes":[{"pos":[0,85],"content":"The default constructor for <xref:System.Threading.SpinLock> tracks thread ownership.","nodes":[{"content":"The default constructor for <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> tracks thread ownership.","pos":[0,85],"source":"The default constructor for <xref:System.Threading.SpinLock> tracks thread ownership."}]}],"pos":[5188,5274],"yaml":true,"extradata":"MT"},{"content":"Whether to capture and use thread IDs for debugging purposes.","nodes":[{"pos":[0,61],"content":"Whether to capture and use thread IDs for debugging purposes.","nodes":[{"content":"Whether to capture and use thread IDs for debugging purposes.","pos":[0,61]}]}],"pos":[6334,6396],"yaml":true},{"content":"Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired.","nodes":[{"pos":[0,193],"content":"Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> can be examined reliably to determine whether the lock was acquired.","source":"Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired."}],"pos":[7908,8102],"yaml":true},{"content":"<xref:System.Threading.SpinLock> is a non-reentrant lock, meaning that if a thread holds the lock, it is not allowed to enter the lock again. If thread ownership tracking is enabled (whether it's enabled is available through <xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A>), an exception will be thrown when a thread tries to re-enter a lock it already holds. However, if thread ownership tracking is disabled, attempting to enter a lock already held will result in deadlock.  \n  \n If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted.","nodes":[{"pos":[0,492],"content":"<xref:System.Threading.SpinLock> is a non-reentrant lock, meaning that if a thread holds the lock, it is not allowed to enter the lock again. If thread ownership tracking is enabled (whether it's enabled is available through <xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A>), an exception will be thrown when a thread tries to re-enter a lock it already holds. However, if thread ownership tracking is disabled, attempting to enter a lock already held will result in deadlock.","nodes":[{"content":"<xref:System.Threading.SpinLock> is a non-reentrant lock, meaning that if a thread holds the lock, it is not allowed to enter the lock again. If thread ownership tracking is enabled (whether it's enabled is available through <xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A>), an exception will be thrown when a thread tries to re-enter a lock it already holds. However, if thread ownership tracking is disabled, attempting to enter a lock already held will result in deadlock.","pos":[0,492],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.SpinLock&gt;</ph> is a non-reentrant lock, meaning that if a thread holds the lock, it is not allowed to enter the lock again.","pos":[0,141],"source":"<xref:System.Threading.SpinLock> is a non-reentrant lock, meaning that if a thread holds the lock, it is not allowed to enter the lock again."},{"content":"If thread ownership tracking is enabled (whether it's enabled is available through <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A&gt;</ph>), an exception will be thrown when a thread tries to re-enter a lock it already holds.","pos":[142,376],"source":" If thread ownership tracking is enabled (whether it's enabled is available through <xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A>), an exception will be thrown when a thread tries to re-enter a lock it already holds."},{"content":"However, if thread ownership tracking is disabled, attempting to enter a lock already held will result in deadlock.","pos":[377,492]}]}]},{"pos":[499,702],"content":"If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted.","nodes":[{"content":"If you call <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> without having first called <ph id=\"ph2\">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph> the internal state of the <ph id=\"ph3\">&lt;xref:System.Threading.SpinLock&gt;</ph> can become corrupted.","pos":[0,203],"source":"If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted."}]}],"pos":[8113,8820],"yaml":true,"extradata":"MT"},{"content":"True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.","nodes":[{"pos":[0,129],"content":"True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.","nodes":[{"content":"True if the lock is acquired; otherwise, false.","pos":[0,47]},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> must be initialized to false prior to calling this method.","pos":[48,129],"source":"<code>lockTaken</code> must be initialized to false prior to calling this method."}]}],"pos":[8965,9095],"yaml":true},{"content":"The <code>lockTaken</code> argument must be initialized to false prior to calling Enter.","nodes":[{"pos":[0,88],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> argument must be initialized to false prior to calling Enter.","source":"The <code>lockTaken</code> argument must be initialized to false prior to calling Enter."}],"pos":[9248,9337],"yaml":true},{"content":"Thread ownership tracking is enabled, and the current thread has already acquired this lock.","nodes":[{"pos":[0,92],"content":"Thread ownership tracking is enabled, and the current thread has already acquired this lock.","nodes":[{"content":"Thread ownership tracking is enabled, and the current thread has already acquired this lock.","pos":[0,92]}]}],"pos":[9461,9554],"yaml":true},{"content":"Releases the lock.","nodes":[{"pos":[0,18],"content":"Releases the lock.","nodes":[{"content":"Releases the lock.","pos":[0,18]}]}],"pos":[10926,10945],"yaml":true},{"content":"The default overload of <xref:System.Threading.SpinLock.Exit%2A> provides the same behavior as if calling <xref:System.Threading.SpinLock.Exit%2A> using true as the argument.  \n  \n If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted.","nodes":[{"pos":[0,174],"content":"The default overload of <xref:System.Threading.SpinLock.Exit%2A> provides the same behavior as if calling <xref:System.Threading.SpinLock.Exit%2A> using true as the argument.","nodes":[{"content":"The default overload of <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> provides the same behavior as if calling <ph id=\"ph2\">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> using true as the argument.","pos":[0,174],"source":"The default overload of <xref:System.Threading.SpinLock.Exit%2A> provides the same behavior as if calling <xref:System.Threading.SpinLock.Exit%2A> using true as the argument."}]},{"pos":[181,384],"content":"If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted.","nodes":[{"content":"If you call <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> without having first called <ph id=\"ph2\">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph> the internal state of the <ph id=\"ph3\">&lt;xref:System.Threading.SpinLock&gt;</ph> can become corrupted.","pos":[0,203],"source":"If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted."}]}],"pos":[10956,11345],"yaml":true,"extradata":"MT"},{"content":"Thread ownership tracking is enabled, and the current thread is not the owner of this lock.","nodes":[{"pos":[0,91],"content":"Thread ownership tracking is enabled, and the current thread is not the owner of this lock.","nodes":[{"content":"Thread ownership tracking is enabled, and the current thread is not the owner of this lock.","pos":[0,91]}]}],"pos":[11602,11694],"yaml":true},{"content":"Releases the lock.","nodes":[{"pos":[0,18],"content":"Releases the lock.","nodes":[{"content":"Releases the lock.","pos":[0,18]}]}],"pos":[13152,13171],"yaml":true},{"content":"Calling <xref:System.Threading.SpinLock.Exit%2A> with the `useMemoryBarrier` argument set to true will improve the fairness of the lock at the expense of some performance. The default <xref:System.Threading.SpinLock.Exit%2A> overload behaves as if specifying true for `useMemoryBarrier`.  \n  \n If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted.","nodes":[{"pos":[0,287],"content":"Calling <xref:System.Threading.SpinLock.Exit%2A> with the `useMemoryBarrier` argument set to true will improve the fairness of the lock at the expense of some performance. The default <xref:System.Threading.SpinLock.Exit%2A> overload behaves as if specifying true for `useMemoryBarrier`.","nodes":[{"content":"Calling <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> with the <ph id=\"ph2\">`useMemoryBarrier`</ph> argument set to true will improve the fairness of the lock at the expense of some performance.","pos":[0,171],"source":"Calling <xref:System.Threading.SpinLock.Exit%2A> with the `useMemoryBarrier` argument set to true will improve the fairness of the lock at the expense of some performance."},{"content":"The default <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> overload behaves as if specifying true for <ph id=\"ph2\">`useMemoryBarrier`</ph>.","pos":[172,287],"source":" The default <xref:System.Threading.SpinLock.Exit%2A> overload behaves as if specifying true for `useMemoryBarrier`."}]},{"pos":[294,497],"content":"If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted.","nodes":[{"content":"If you call <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock.Exit%2A&gt;</ph> without having first called <ph id=\"ph2\">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph> the internal state of the <ph id=\"ph3\">&lt;xref:System.Threading.SpinLock&gt;</ph> can become corrupted.","pos":[0,203],"source":"If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted."}]}],"pos":[13182,13684],"yaml":true,"extradata":"MT"},{"content":"A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.","nodes":[{"pos":[0,139],"content":"A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.","nodes":[{"content":"A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.","pos":[0,139]}]}],"pos":[13838,13978],"yaml":true},{"content":"Thread ownership tracking is enabled, and the current thread is not the owner of this lock.","nodes":[{"pos":[0,91],"content":"Thread ownership tracking is enabled, and the current thread is not the owner of this lock.","nodes":[{"content":"Thread ownership tracking is enabled, and the current thread is not the owner of this lock.","pos":[0,91]}]}],"pos":[14172,14264],"yaml":true},{"content":"Gets whether the lock is currently held by any thread.","nodes":[{"pos":[0,54],"content":"Gets whether the lock is currently held by any thread.","nodes":[{"content":"Gets whether the lock is currently held by any thread.","pos":[0,54]}]}],"pos":[15661,15716],"yaml":true},{"content":"true if the lock is currently held by any thread; otherwise false.","nodes":[{"pos":[0,66],"content":"true if the lock is currently held by any thread; otherwise false.","nodes":[{"content":"true if the lock is currently held by any thread; otherwise false.","pos":[0,66]}]}],"pos":[16022,16089],"yaml":true},{"content":"Gets whether the lock is held by the current thread.","nodes":[{"pos":[0,52],"content":"Gets whether the lock is held by the current thread.","nodes":[{"content":"Gets whether the lock is held by the current thread.","pos":[0,52]}]}],"pos":[17709,17762],"yaml":true},{"content":"If the lock was initialized to track owner threads, this will return whether the lock is acquired by the current thread. It is invalid to use this property when the lock was initialized to not track thread ownership.","nodes":[{"pos":[0,216],"content":"If the lock was initialized to track owner threads, this will return whether the lock is acquired by the current thread. It is invalid to use this property when the lock was initialized to not track thread ownership.","nodes":[{"content":"If the lock was initialized to track owner threads, this will return whether the lock is acquired by the current thread. It is invalid to use this property when the lock was initialized to not track thread ownership.","pos":[0,216],"nodes":[{"content":"If the lock was initialized to track owner threads, this will return whether the lock is acquired by the current thread.","pos":[0,120]},{"content":"It is invalid to use this property when the lock was initialized to not track thread ownership.","pos":[121,216]}]}]}],"pos":[17773,17990],"yaml":true,"extradata":"MT"},{"content":"true if the lock is held by the current thread; otherwise false.","nodes":[{"pos":[0,64],"content":"true if the lock is held by the current thread; otherwise false.","nodes":[{"content":"true if the lock is held by the current thread; otherwise false.","pos":[0,64]}]}],"pos":[18311,18376],"yaml":true},{"content":"Thread ownership tracking is disabled.","nodes":[{"pos":[0,38],"content":"Thread ownership tracking is disabled.","nodes":[{"content":"Thread ownership tracking is disabled.","pos":[0,38]}]}],"pos":[18561,18600],"yaml":true},{"content":"Gets whether thread ownership tracking is enabled for this instance.","nodes":[{"pos":[0,68],"content":"Gets whether thread ownership tracking is enabled for this instance.","nodes":[{"content":"Gets whether thread ownership tracking is enabled for this instance.","pos":[0,68]}]}],"pos":[20199,20268],"yaml":true},{"content":"true if thread ownership tracking is enabled for this instance; otherwise false.","nodes":[{"pos":[0,80],"content":"true if thread ownership tracking is enabled for this instance; otherwise false.","nodes":[{"content":"true if thread ownership tracking is enabled for this instance; otherwise false.","pos":[0,80]}]}],"pos":[20596,20677],"yaml":true},{"content":"Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired.","nodes":[{"pos":[0,204],"content":"Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> can be examined reliably to determine whether the lock was acquired.","source":"Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired."}],"pos":[22317,22522],"yaml":true},{"content":"Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block waiting for the lock to be available. If the lock is not available when TryEnter is called, it will return immediately without any further spinning.","nodes":[{"pos":[0,222],"content":"Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block waiting for the lock to be available. If the lock is not available when TryEnter is called, it will return immediately without any further spinning.","nodes":[{"content":"Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block waiting for the lock to be available. If the lock is not available when TryEnter is called, it will return immediately without any further spinning.","pos":[0,222],"nodes":[{"content":"Unlike <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>, TryEnter will not block waiting for the lock to be available.","pos":[0,111],"source":"Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block waiting for the lock to be available."},{"content":"If the lock is not available when TryEnter is called, it will return immediately without any further spinning.","pos":[112,222]}]}]}],"pos":[22533,22756],"yaml":true,"extradata":"MT"},{"content":"True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.","nodes":[{"pos":[0,129],"content":"True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.","nodes":[{"content":"True if the lock is acquired; otherwise, false.","pos":[0,47]},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> must be initialized to false prior to calling this method.","pos":[48,129],"source":"<code>lockTaken</code> must be initialized to false prior to calling this method."}]}],"pos":[22904,23034],"yaml":true},{"content":"The <code>lockTaken</code> argument must be initialized to false prior to calling TryEnter.","nodes":[{"pos":[0,91],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> argument must be initialized to false prior to calling TryEnter.","source":"The <code>lockTaken</code> argument must be initialized to false prior to calling TryEnter."}],"pos":[23190,23282],"yaml":true},{"content":"Thread ownership tracking is enabled, and the current thread has already acquired this lock.","nodes":[{"pos":[0,92],"content":"Thread ownership tracking is enabled, and the current thread has already acquired this lock.","nodes":[{"content":"Thread ownership tracking is enabled, and the current thread has already acquired this lock.","pos":[0,92]}]}],"pos":[23406,23499],"yaml":true},{"content":"Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired.","nodes":[{"pos":[0,204],"content":"Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> can be examined reliably to determine whether the lock was acquired.","source":"Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired."}],"pos":[25027,25232],"yaml":true},{"content":"Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block indefinitely waiting for the lock to be available. It will block until either the lock is available or until the `millisecondsTimeout` has expired.","nodes":[{"pos":[0,221],"content":"Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block indefinitely waiting for the lock to be available. It will block until either the lock is available or until the `millisecondsTimeout` has expired.","nodes":[{"content":"Unlike <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>, TryEnter will not block indefinitely waiting for the lock to be available.","pos":[0,124],"source":"Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block indefinitely waiting for the lock to be available."},{"content":"It will block until either the lock is available or until the <ph id=\"ph1\">`millisecondsTimeout`</ph> has expired.","pos":[125,221],"source":" It will block until either the lock is available or until the `millisecondsTimeout` has expired."}]}],"pos":[25243,25465],"yaml":true,"extradata":"MT"},{"content":"The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely.","nodes":[{"pos":[0,120],"content":"The number of milliseconds to wait, or <ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (-1) to wait indefinitely.","source":"The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely."}],"pos":[25646,25767],"yaml":true},{"content":"True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.","nodes":[{"pos":[0,129],"content":"True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.","nodes":[{"content":"True if the lock is acquired; otherwise, false.","pos":[0,47]},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> must be initialized to false prior to calling this method.","pos":[48,129],"source":"<code>lockTaken</code> must be initialized to false prior to calling this method."}]}],"pos":[25833,25963],"yaml":true},{"content":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.","nodes":[{"pos":[0,107],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite time-out.","source":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out."}],"pos":[26139,26247],"yaml":true},{"content":"The <code>lockTaken</code> argument must be initialized to false prior to calling TryEnter.","nodes":[{"pos":[0,91],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> argument must be initialized to false prior to calling TryEnter.","source":"The <code>lockTaken</code> argument must be initialized to false prior to calling TryEnter."}],"pos":[26341,26433],"yaml":true},{"content":"Thread ownership tracking is enabled, and the current thread has already acquired this lock.","nodes":[{"pos":[0,92],"content":"Thread ownership tracking is enabled, and the current thread has already acquired this lock.","nodes":[{"content":"Thread ownership tracking is enabled, and the current thread has already acquired this lock.","pos":[0,92]}]}],"pos":[26557,26650],"yaml":true},{"content":"Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired.","nodes":[{"pos":[0,204],"content":"Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> can be examined reliably to determine whether the lock was acquired.","source":"Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired."}],"pos":[28196,28401],"yaml":true},{"content":"Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block indefinitely waiting for the lock to be available. It will block until either the lock is available or until the `timeout` has expired.","nodes":[{"pos":[0,209],"content":"Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block indefinitely waiting for the lock to be available. It will block until either the lock is available or until the `timeout` has expired.","nodes":[{"content":"Unlike <ph id=\"ph1\">&lt;xref:System.Threading.SpinLock.Enter%2A&gt;</ph>, TryEnter will not block indefinitely waiting for the lock to be available.","pos":[0,124],"source":"Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block indefinitely waiting for the lock to be available."},{"content":"It will block until either the lock is available or until the <ph id=\"ph1\">`timeout`</ph> has expired.","pos":[125,209],"source":" It will block until either the lock is available or until the `timeout` has expired."}]}],"pos":[28412,28622],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely.","nodes":[{"pos":[0,186],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents the number of milliseconds to wait, or a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents -1 milliseconds to wait indefinitely.","source":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely."}],"pos":[28787,28974],"yaml":true},{"content":"True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.","nodes":[{"pos":[0,129],"content":"True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.","nodes":[{"content":"True if the lock is acquired; otherwise, false.","pos":[0,47]},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> must be initialized to false prior to calling this method.","pos":[48,129],"source":"<code>lockTaken</code> must be initialized to false prior to calling this method."}]}],"pos":[29040,29170],"yaml":true},{"content":"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref> milliseconds.","nodes":[{"pos":[0,193],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph> milliseconds.","source":"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref> milliseconds."}],"pos":[29346,29540],"yaml":true},{"content":"The <code>lockTaken</code> argument must be initialized to false prior to calling TryEnter.","nodes":[{"pos":[0,91],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">lockTaken</ph><ept id=\"p1\">&lt;/code&gt;</ept> argument must be initialized to false prior to calling TryEnter.","source":"The <code>lockTaken</code> argument must be initialized to false prior to calling TryEnter."}],"pos":[29634,29726],"yaml":true},{"content":"Thread ownership tracking is enabled, and the current thread has already acquired this lock.","nodes":[{"pos":[0,92],"content":"Thread ownership tracking is enabled, and the current thread has already acquired this lock.","nodes":[{"content":"Thread ownership tracking is enabled, and the current thread has already acquired this lock.","pos":[0,92]}]}],"pos":[29850,29943],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.SpinLock\n  commentId: T:System.Threading.SpinLock\n  id: SpinLock\n  children:\n  - System.Threading.SpinLock.#ctor(System.Boolean)\n  - System.Threading.SpinLock.Enter(System.Boolean@)\n  - System.Threading.SpinLock.Exit\n  - System.Threading.SpinLock.Exit(System.Boolean)\n  - System.Threading.SpinLock.IsHeld\n  - System.Threading.SpinLock.IsHeldByCurrentThread\n  - System.Threading.SpinLock.IsThreadOwnerTrackingEnabled\n  - System.Threading.SpinLock.TryEnter(System.Boolean@)\n  - System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)\n  - System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)\n  langs:\n  - csharp\n  name: SpinLock\n  nameWithType: SpinLock\n  fullName: System.Threading.SpinLock\n  type: Struct\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Provides a mutual exclusion lock primitive where a thread trying to acquire the lock waits in a loop repeatedly checking until the lock becomes available.\n  remarks: \"For an example of how to use a Spin Lock, see [How to: Use SpinLock for Low-Level Synchronization](~/docs/standard/threading/how-to-use-spinlock-for-low-level-synchronization.md).  \\n  \\n Spin locks can be used for leaf-level locks where the object allocation implied by using a <xref:System.Threading.Monitor>, in size or due to garbage collection pressure, is overly expensive. A spin lock can be useful in to avoid blocking; however, if you expect a significant amount of blocking, you should probably not use spin locks due to excessive spinning. Spinning can be beneficial when locks are fine-grained and large in number (for example, a lock per node in a linked list) and also when lock hold-times are always extremely short. In general, while holding a spin lock, one should avoid any of these actions:  \\n  \\n-   blocking,  \\n  \\n-   calling anything that itself may block,  \\n  \\n-   holding more than one spin lock at once,  \\n  \\n-   making dynamically dispatched calls (interface and virtuals),  \\n  \\n-   making statically dispatched calls into any code one doesn't own, or  \\n  \\n-   allocating memory.  \\n  \\n <xref:System.Threading.SpinLock> should only be used after you have been determined that doing so will improve an application's performance. It is also important to note that <xref:System.Threading.SpinLock> is a value type, for performance reasons. For this reason, you must be very careful not to accidentally copy a <xref:System.Threading.SpinLock> instance, as the two instances (the original and the copy) would then be completely independent of one another, which would likely lead to erroneous behavior of the application. If a <xref:System.Threading.SpinLock> instance must be passed around, it should be passed by reference rather than by value.  \\n  \\n Do not store <xref:System.Threading.SpinLock> instances in readonly fields.\"\n  example:\n  - \"The following example shows how to use a <xref:System.Threading.SpinLock>:  \\n  \\n [!code-csharp[System.Threading.SpinLock#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.spinlock/cs/spinlock.cs#01)]\\n [!code-vb[System.Threading.SpinLock#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.spinlock/vb/spinlock.vb#01)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public struct SpinLock\n  inheritance:\n  - System.Object\n  - System.ValueType\n  implements: []\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SpinLock.#ctor(System.Boolean)\n  commentId: M:System.Threading.SpinLock.#ctor(System.Boolean)\n  id: '#ctor(System.Boolean)'\n  parent: System.Threading.SpinLock\n  langs:\n  - csharp\n  name: SpinLock(Boolean)\n  nameWithType: SpinLock.SpinLock(Boolean)\n  fullName: SpinLock.SpinLock(Boolean)\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.SpinLock\"></xref> structure with the option to track thread IDs to improve debugging.\n  remarks: The default constructor for <xref:System.Threading.SpinLock> tracks thread ownership.\n  example:\n  - \"The following example demonstrates how a SpinLock may be used.  \\n  \\n```  \\n// C#  \\npublic class MyType  \\n{  \\n    private SpinLock _spinLock = new SpinLock();  \\n  \\n    public void DoWork()  \\n    {  \\n        bool lockTaken = false;   \\n        try  \\n        {  \\n           _spinLock.Enter(ref lockTaken);  \\n           // do work here protected by the lock  \\n        }  \\n        finally  \\n        {  \\n            if (lockTaken) _spinLock.Exit();  \\n        }  \\n    }  \\n}  \\n```  \\n  \\n```  \\n' Visual Basic  \\n  \\nClass MyType  \\n   Private _spinLock As New SpinLock()  \\n  \\n   Public Sub DoWork()  \\n      Dim lockTaken As Boolean = False  \\n      Try  \\n         _spinLock.Enter(lockTaken)  \\n         ' do work here protected by the lock  \\n      Finally  \\n         If lockTaken Then _spinLock.Exit()  \\n      End Try  \\n   End Sub  \\nEnd Class  \\n```\"\n  syntax:\n    content: public SpinLock (bool enableThreadOwnerTracking);\n    parameters:\n    - id: enableThreadOwnerTracking\n      type: System.Boolean\n      description: Whether to capture and use thread IDs for debugging purposes.\n  overload: System.Threading.SpinLock.#ctor*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SpinLock.Enter(System.Boolean@)\n  commentId: M:System.Threading.SpinLock.Enter(System.Boolean@)\n  id: Enter(System.Boolean@)\n  parent: System.Threading.SpinLock\n  langs:\n  - csharp\n  name: Enter(Boolean)\n  nameWithType: SpinLock.Enter(Boolean)\n  fullName: SpinLock.Enter(Boolean)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Acquires the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired.\n  remarks: \"<xref:System.Threading.SpinLock> is a non-reentrant lock, meaning that if a thread holds the lock, it is not allowed to enter the lock again. If thread ownership tracking is enabled (whether it's enabled is available through <xref:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled%2A>), an exception will be thrown when a thread tries to re-enter a lock it already holds. However, if thread ownership tracking is disabled, attempting to enter a lock already held will result in deadlock.  \\n  \\n If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted.\"\n  syntax:\n    content: public void Enter (ref bool lockTaken);\n    parameters:\n    - id: lockTaken\n      type: System.Boolean\n      description: True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.\n  overload: System.Threading.SpinLock.Enter*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The <code>lockTaken</code> argument must be initialized to false prior to calling Enter.\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: Thread ownership tracking is enabled, and the current thread has already acquired this lock.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SpinLock.Exit\n  commentId: M:System.Threading.SpinLock.Exit\n  id: Exit\n  parent: System.Threading.SpinLock\n  langs:\n  - csharp\n  name: Exit()\n  nameWithType: SpinLock.Exit()\n  fullName: SpinLock.Exit()\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Releases the lock.\n  remarks: \"The default overload of <xref:System.Threading.SpinLock.Exit%2A> provides the same behavior as if calling <xref:System.Threading.SpinLock.Exit%2A> using true as the argument.  \\n  \\n If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted.\"\n  syntax:\n    content: public void Exit ();\n    parameters: []\n  overload: System.Threading.SpinLock.Exit*\n  exceptions:\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: Thread ownership tracking is enabled, and the current thread is not the owner of this lock.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SpinLock.Exit(System.Boolean)\n  commentId: M:System.Threading.SpinLock.Exit(System.Boolean)\n  id: Exit(System.Boolean)\n  parent: System.Threading.SpinLock\n  langs:\n  - csharp\n  name: Exit(Boolean)\n  nameWithType: SpinLock.Exit(Boolean)\n  fullName: SpinLock.Exit(Boolean)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Releases the lock.\n  remarks: \"Calling <xref:System.Threading.SpinLock.Exit%2A> with the `useMemoryBarrier` argument set to true will improve the fairness of the lock at the expense of some performance. The default <xref:System.Threading.SpinLock.Exit%2A> overload behaves as if specifying true for `useMemoryBarrier`.  \\n  \\n If you call <xref:System.Threading.SpinLock.Exit%2A> without having first called <xref:System.Threading.SpinLock.Enter%2A> the internal state of the <xref:System.Threading.SpinLock> can become corrupted.\"\n  syntax:\n    content: public void Exit (bool useMemoryBarrier);\n    parameters:\n    - id: useMemoryBarrier\n      type: System.Boolean\n      description: A Boolean value that indicates whether a memory fence should be issued in order to immediately publish the exit operation to other threads.\n  overload: System.Threading.SpinLock.Exit*\n  exceptions:\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: Thread ownership tracking is enabled, and the current thread is not the owner of this lock.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SpinLock.IsHeld\n  commentId: P:System.Threading.SpinLock.IsHeld\n  id: IsHeld\n  parent: System.Threading.SpinLock\n  langs:\n  - csharp\n  name: IsHeld\n  nameWithType: SpinLock.IsHeld\n  fullName: SpinLock.IsHeld\n  type: Property\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Gets whether the lock is currently held by any thread.\n  syntax:\n    content: >-\n      [get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]\n\n      public bool IsHeld { get; }\n    return:\n      type: System.Boolean\n      description: true if the lock is currently held by any thread; otherwise false.\n  overload: System.Threading.SpinLock.IsHeld*\n  exceptions: []\n  attributes:\n  - type: 'get: System.Runtime.ConstrainedExecution.ReliabilityContract'\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SpinLock.IsHeldByCurrentThread\n  commentId: P:System.Threading.SpinLock.IsHeldByCurrentThread\n  id: IsHeldByCurrentThread\n  parent: System.Threading.SpinLock\n  langs:\n  - csharp\n  name: IsHeldByCurrentThread\n  nameWithType: SpinLock.IsHeldByCurrentThread\n  fullName: SpinLock.IsHeldByCurrentThread\n  type: Property\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Gets whether the lock is held by the current thread.\n  remarks: If the lock was initialized to track owner threads, this will return whether the lock is acquired by the current thread. It is invalid to use this property when the lock was initialized to not track thread ownership.\n  syntax:\n    content: >-\n      [get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]\n\n      public bool IsHeldByCurrentThread { get; }\n    return:\n      type: System.Boolean\n      description: true if the lock is held by the current thread; otherwise false.\n  overload: System.Threading.SpinLock.IsHeldByCurrentThread*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: Thread ownership tracking is disabled.\n  attributes:\n  - type: 'get: System.Runtime.ConstrainedExecution.ReliabilityContract'\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SpinLock.IsThreadOwnerTrackingEnabled\n  commentId: P:System.Threading.SpinLock.IsThreadOwnerTrackingEnabled\n  id: IsThreadOwnerTrackingEnabled\n  parent: System.Threading.SpinLock\n  langs:\n  - csharp\n  name: IsThreadOwnerTrackingEnabled\n  nameWithType: SpinLock.IsThreadOwnerTrackingEnabled\n  fullName: SpinLock.IsThreadOwnerTrackingEnabled\n  type: Property\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Gets whether thread ownership tracking is enabled for this instance.\n  syntax:\n    content: >-\n      [get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]\n\n      public bool IsThreadOwnerTrackingEnabled { get; }\n    return:\n      type: System.Boolean\n      description: true if thread ownership tracking is enabled for this instance; otherwise false.\n  overload: System.Threading.SpinLock.IsThreadOwnerTrackingEnabled*\n  exceptions: []\n  attributes:\n  - type: 'get: System.Runtime.ConstrainedExecution.ReliabilityContract'\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SpinLock.TryEnter(System.Boolean@)\n  commentId: M:System.Threading.SpinLock.TryEnter(System.Boolean@)\n  id: TryEnter(System.Boolean@)\n  parent: System.Threading.SpinLock\n  langs:\n  - csharp\n  name: TryEnter(Boolean)\n  nameWithType: SpinLock.TryEnter(Boolean)\n  fullName: SpinLock.TryEnter(Boolean)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired.\n  remarks: Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block waiting for the lock to be available. If the lock is not available when TryEnter is called, it will return immediately without any further spinning.\n  syntax:\n    content: public void TryEnter (ref bool lockTaken);\n    parameters:\n    - id: lockTaken\n      type: System.Boolean\n      description: True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.\n  overload: System.Threading.SpinLock.TryEnter*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The <code>lockTaken</code> argument must be initialized to false prior to calling TryEnter.\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: Thread ownership tracking is enabled, and the current thread has already acquired this lock.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)\n  commentId: M:System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)\n  id: TryEnter(System.Int32,System.Boolean@)\n  parent: System.Threading.SpinLock\n  langs:\n  - csharp\n  name: TryEnter(Int32, Boolean)\n  nameWithType: SpinLock.TryEnter(Int32, Boolean)\n  fullName: SpinLock.TryEnter(Int32, Boolean)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired.\n  remarks: Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block indefinitely waiting for the lock to be available. It will block until either the lock is available or until the `millisecondsTimeout` has expired.\n  syntax:\n    content: public void TryEnter (int millisecondsTimeout, ref bool lockTaken);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely.\n    - id: lockTaken\n      type: System.Boolean\n      description: True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.\n  overload: System.Threading.SpinLock.TryEnter*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The <code>lockTaken</code> argument must be initialized to false prior to calling TryEnter.\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: Thread ownership tracking is enabled, and the current thread has already acquired this lock.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)\n  commentId: M:System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)\n  id: TryEnter(System.TimeSpan,System.Boolean@)\n  parent: System.Threading.SpinLock\n  langs:\n  - csharp\n  name: TryEnter(TimeSpan, Boolean)\n  nameWithType: SpinLock.TryEnter(TimeSpan, Boolean)\n  fullName: SpinLock.TryEnter(TimeSpan, Boolean)\n  type: Method\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Attempts to acquire the lock in a reliable manner, such that even if an exception occurs within the method call, <code>lockTaken</code> can be examined reliably to determine whether the lock was acquired.\n  remarks: Unlike <xref:System.Threading.SpinLock.Enter%2A>, TryEnter will not block indefinitely waiting for the lock to be available. It will block until either the lock is available or until the `timeout` has expired.\n  syntax:\n    content: public void TryEnter (TimeSpan timeout, ref bool lockTaken);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely.\n    - id: lockTaken\n      type: System.Boolean\n      description: True if the lock is acquired; otherwise, false. <code>lockTaken</code> must be initialized to false prior to calling this method.\n  overload: System.Threading.SpinLock.TryEnter*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than <xref href=\"System.Int32.MaxValue\"></xref> milliseconds.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The <code>lockTaken</code> argument must be initialized to false prior to calling TryEnter.\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: Thread ownership tracking is enabled, and the current thread has already acquired this lock.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.ValueType\n  parent: System\n  isExternal: false\n  name: ValueType\n  nameWithType: ValueType\n  fullName: System.ValueType\n- uid: System.ArgumentException\n  parent: System\n  isExternal: false\n  name: ArgumentException\n  nameWithType: ArgumentException\n  fullName: System.ArgumentException\n- uid: System.Threading.LockRecursionException\n  parent: System.Threading\n  isExternal: false\n  name: LockRecursionException\n  nameWithType: LockRecursionException\n  fullName: System.Threading.LockRecursionException\n- uid: System.Threading.SynchronizationLockException\n  parent: System.Threading\n  isExternal: false\n  name: SynchronizationLockException\n  nameWithType: SynchronizationLockException\n  fullName: System.Threading.SynchronizationLockException\n- uid: System.InvalidOperationException\n  parent: System\n  isExternal: false\n  name: InvalidOperationException\n  nameWithType: InvalidOperationException\n  fullName: System.InvalidOperationException\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.Threading.SpinLock.#ctor(System.Boolean)\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: SpinLock(Boolean)\n  nameWithType: SpinLock.SpinLock(Boolean)\n  fullName: SpinLock.SpinLock(Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Threading.SpinLock.Enter(System.Boolean@)\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: Enter(Boolean)\n  nameWithType: SpinLock.Enter(Boolean)\n  fullName: SpinLock.Enter(Boolean)\n- uid: System.Threading.SpinLock.Exit\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: Exit()\n  nameWithType: SpinLock.Exit()\n  fullName: SpinLock.Exit()\n- uid: System.Threading.SpinLock.Exit(System.Boolean)\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: Exit(Boolean)\n  nameWithType: SpinLock.Exit(Boolean)\n  fullName: SpinLock.Exit(Boolean)\n- uid: System.Threading.SpinLock.IsHeld\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: IsHeld\n  nameWithType: SpinLock.IsHeld\n  fullName: SpinLock.IsHeld\n- uid: System.Threading.SpinLock.IsHeldByCurrentThread\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: IsHeldByCurrentThread\n  nameWithType: SpinLock.IsHeldByCurrentThread\n  fullName: SpinLock.IsHeldByCurrentThread\n- uid: System.Threading.SpinLock.IsThreadOwnerTrackingEnabled\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: IsThreadOwnerTrackingEnabled\n  nameWithType: SpinLock.IsThreadOwnerTrackingEnabled\n  fullName: SpinLock.IsThreadOwnerTrackingEnabled\n- uid: System.Threading.SpinLock.TryEnter(System.Boolean@)\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: TryEnter(Boolean)\n  nameWithType: SpinLock.TryEnter(Boolean)\n  fullName: SpinLock.TryEnter(Boolean)\n- uid: System.Threading.SpinLock.TryEnter(System.Int32,System.Boolean@)\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: TryEnter(Int32, Boolean)\n  nameWithType: SpinLock.TryEnter(Int32, Boolean)\n  fullName: SpinLock.TryEnter(Int32, Boolean)\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Threading.SpinLock.TryEnter(System.TimeSpan,System.Boolean@)\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: TryEnter(TimeSpan, Boolean)\n  nameWithType: SpinLock.TryEnter(TimeSpan, Boolean)\n  fullName: SpinLock.TryEnter(TimeSpan, Boolean)\n- uid: System.TimeSpan\n  parent: System\n  isExternal: false\n  name: TimeSpan\n  nameWithType: TimeSpan\n  fullName: System.TimeSpan\n- uid: System.Threading.SpinLock.#ctor*\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: SpinLock\n  nameWithType: SpinLock.SpinLock\n  fullName: SpinLock.SpinLock\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n- uid: System.Threading.SpinLock.Enter*\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: Enter\n  nameWithType: SpinLock.Enter\n  fullName: SpinLock.Enter\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n- uid: System.Threading.SpinLock.Exit*\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: Exit\n  nameWithType: SpinLock.Exit\n  fullName: SpinLock.Exit\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n- uid: System.Threading.SpinLock.IsHeld*\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: IsHeld\n  nameWithType: SpinLock.IsHeld\n  fullName: SpinLock.IsHeld\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n- uid: System.Threading.SpinLock.IsHeldByCurrentThread*\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: IsHeldByCurrentThread\n  nameWithType: SpinLock.IsHeldByCurrentThread\n  fullName: SpinLock.IsHeldByCurrentThread\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n- uid: System.Threading.SpinLock.IsThreadOwnerTrackingEnabled*\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: IsThreadOwnerTrackingEnabled\n  nameWithType: SpinLock.IsThreadOwnerTrackingEnabled\n  fullName: SpinLock.IsThreadOwnerTrackingEnabled\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n- uid: System.Threading.SpinLock.TryEnter*\n  parent: System.Threading.SpinLock\n  isExternal: false\n  name: TryEnter\n  nameWithType: SpinLock.TryEnter\n  fullName: SpinLock.TryEnter\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/SpinLock.xml\n"}