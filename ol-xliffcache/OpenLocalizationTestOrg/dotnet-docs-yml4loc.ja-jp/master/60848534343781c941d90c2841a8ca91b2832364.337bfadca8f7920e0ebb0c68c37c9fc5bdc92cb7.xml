{"nodes":[{"content":"Provides a mechanism for releasing unmanaged resources.","nodes":[{"pos":[0,55],"content":"Provides a mechanism for releasing unmanaged resources.","nodes":[{"content":"Provides a mechanism for releasing unmanaged resources.","pos":[0,55]}]}],"pos":[367,423],"yaml":true},{"content":"> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/idisposable.cs#1f55292c3174123d). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n The primary use of this interface is to release unmanaged resources. The garbage collector automatically releases the memory allocated to a managed object when that object is no longer used. However, it is not possible to predict when garbage collection will occur. Furthermore, the garbage collector has no knowledge of unmanaged resources such as window handles, or open files and streams.  \n  \n Use the <xref:System.IDisposable.Dispose%2A> method of this interface to explicitly release unmanaged resources in conjunction with the garbage collector. The consumer of an object can call this method when the object is no longer needed.  \n  \n> [!WARNING]\n>  It is a breaking change to add the <xref:System.IDisposable> interface to an existing class. Because pre-existing consumers of your type cannot call <xref:System.IDisposable.Dispose%2A>, you cannot be certain that unmanaged resources held by your type will be released.  \n  \n Because the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation is called by the consumer of a type when the resources owned by an instance are no longer needed, you should either wrap the managed object in a <xref:System.Runtime.InteropServices.SafeHandle> (the recommended alternative), or you should override <xref:System.Object.Finalize%2A?displayProperty=fullName> to free unmanaged resources in the event that the consumer forgets to call <xref:System.IDisposable.Dispose%2A>.  \n  \n> [!IMPORTANT]\n>  In the .NET Framework, the C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the <xref:System.IDisposable.Dispose%2A> method.  \n  \n For a detailed discussion about how this interface and the <xref:System.Object.Finalize%2A?displayProperty=fullName> method are used, see the [Garbage Collection](http://msdn.microsoft.com/library/22b6cb97-0c80-4eeb-a2cf-5ed7655e37f9) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md) topics.  \n  \n## Using an object that implements IDisposable  \n Implement <xref:System.IDisposable> only if you are using unmanaged resources directly. If your app simply uses an object that implements <xref:System.IDisposable>, don't provide an <xref:System.IDisposable> implementation. Instead, you should call the object's <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation when you are finished using it. Depending on your programming language, you can do this in one of two ways:  \n  \n-   By using a language construct such as the `using` statement in C# and Visual Basic.  \n  \n-   By wrapping the call to the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation in a `try`/`catch` block.  \n  \n> [!NOTE]\n>  Documentation for types that implement <xref:System.IDisposable> note that fact and include a reminder to call its <xref:System.IDisposable.Dispose%2A> implementation.  \n  \n<a name=\"Using\"></a>   \n### The C# and Visual Basic Using statement  \n If your language supports a construct such as the [using](~/docs/csharp/language-reference/keywords/using.md) statement in C# and the [Using](~/docs/visual-basic/language-reference/statements/using-statement.md) statement in Visual Basic, you can use it instead of explicitly calling <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> yourself. The following example uses this approach in defining a `WordCount` class that preserves information about a file and the number of words in it.  \n  \n [!code-csharp[System.IDisposable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling1.cs#1)]\n [!code-vb[System.IDisposable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling1.vb#1)]  \n  \n The `using` statement is actually a syntactic convenience. At compile time, the language compiler implements the intermediate language (IL) for a `try`/`catch` block.  \n  \n For more information about the `using` statement, see the [Using Statement](~/docs/visual-basic/language-reference/statements/using-statement.md) or [using Statement](~/docs/csharp/language-reference/keywords/using-statement.md) topics.  \n  \n### The Try/Catch block  \n If your programming language does not support a construct like the `using` statement in C# or Visual Basic, or if you prefer not to use it, you can call the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation from the `finally` block of a `try`/`catch` statement. The following example replaces the `using` block in the previous example with a `try`/`catch`/`finally` block.  \n  \n [!code-csharp[System.IDisposable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling2.cs#2)]\n [!code-vb[System.IDisposable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling2.vb#2)]  \n  \n For more information about the `try`/`finally` pattern, see [Try...Catch...Finally Statement](~/docs/visual-basic/language-reference/statements/try-catch-finally-statement.md), [try-finally](~/docs/csharp/language-reference/keywords/try-finally.md), or [try-finally Statement](http://msdn.microsoft.com/library/514400c1-c322-4bf3-9e48-3047240b8a82).  \n  \n## Implementing IDisposable  \n You should implement <xref:System.IDisposable> only if your type uses unmanaged resources directly. The consumers of your type can call your <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation to free resources when the instance is no longer needed. To handle cases in which they fail to call <xref:System.IDisposable.Dispose%2A>, you should either use a class derived from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the unmanaged resources, or you should override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method for a reference type. In either case, you use the <xref:System.IDisposable.Dispose%2A> method to perform whatever cleanup is necessary after using the unmanaged resources, such as freeing, releasing, or resetting the unmanaged resources.  \n  \n> [!IMPORTANT]\n>  If you are defining a base class that uses unmanaged resources and that either has, or is likely to have, subclasses that should be disposed, you should implement the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method and provide a second overload of `Dispose`, as discussed in the next section.  \n  \n<a name=\"BaseClasses\"></a>   \n## IDisposable and the inheritance hierarchy  \n A base class with subclasses that should be disposable must implement <xref:System.IDisposable> as follows. You should use this pattern whenever you implement <xref:System.IDisposable> on any type that isn't `sealed` (`NotInheritable` in Visual Basic).  \n  \n-   It should provide one public, non-virtual <xref:System.IDisposable.Dispose> method and a protected virtual `Dispose(Boolean disposing)` method.  \n  \n-   The <xref:System.IDisposable.Dispose> method must call `Dispose(true)` and should suppress finalization for performance.  \n  \n-   The base type should not include any finalizers.  \n  \n The following code fragment reflects the dispose pattern for base classes. It assumes that your type does not override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method.  \n  \n [!code-csharp[System.IDisposable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]\n [!code-vb[System.IDisposable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  \n  \n If you do override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method, your class should implement the following pattern.  \n  \n [!code-csharp[System.IDisposable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]\n [!code-vb[System.IDisposable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  \n  \n Subclasses should implement the disposable pattern as follows:  \n  \n-   They must override `Dispose(Boolean)` and call the base class `Dispose(Boolean)` implementation.  \n  \n-   They can provide a finalizer if needed. The finalizer must call `Dispose(false)`.  \n  \n Note that derived classes do not themselves implement the <xref:System.IDisposable> interface and do not include a parameterless <xref:System.IDisposable.Dispose%2A> method. They only override the base class `Dispose(Boolean)` method.  \n  \n The following code fragment reflects the dispose pattern for derived classes. It assumes that your type does not override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method.  \n  \n [!code-csharp[System.IDisposable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]\n [!code-vb[System.IDisposable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]","nodes":[{"pos":[2,410],"content":"[!NOTE]\n To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/idisposable.cs#1f55292c3174123d). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).","leadings":["","> "],"nodes":[{"content":" To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/idisposable.cs#1f55292c3174123d). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).","pos":[8,406],"nodes":[{"content":"To view the .NET Framework source code for this type, see the <bpt id=\"p1\">[</bpt>Reference Source<ept id=\"p1\">](http://referencesource.microsoft.com/#mscorlib/system/idisposable.cs#1f55292c3174123d)</ept>.","pos":[1,169],"source":" To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/idisposable.cs#1f55292c3174123d)."},{"content":"You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id=\"p1\">[</bpt>instructions<ept id=\"p1\">](http://referencesource.microsoft.com/)</ept>.","pos":[170,398],"source":" You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/)."}]}]},{"pos":[417,808],"content":"The primary use of this interface is to release unmanaged resources. The garbage collector automatically releases the memory allocated to a managed object when that object is no longer used. However, it is not possible to predict when garbage collection will occur. Furthermore, the garbage collector has no knowledge of unmanaged resources such as window handles, or open files and streams.","nodes":[{"content":"The primary use of this interface is to release unmanaged resources. The garbage collector automatically releases the memory allocated to a managed object when that object is no longer used. However, it is not possible to predict when garbage collection will occur. Furthermore, the garbage collector has no knowledge of unmanaged resources such as window handles, or open files and streams.","pos":[0,391],"nodes":[{"content":"The primary use of this interface is to release unmanaged resources.","pos":[0,68]},{"content":"The garbage collector automatically releases the memory allocated to a managed object when that object is no longer used.","pos":[69,190]},{"content":"However, it is not possible to predict when garbage collection will occur.","pos":[191,265]},{"content":"Furthermore, the garbage collector has no knowledge of unmanaged resources such as window handles, or open files and streams.","pos":[266,391]}]}]},{"pos":[815,1053],"content":"Use the <xref:System.IDisposable.Dispose%2A> method of this interface to explicitly release unmanaged resources in conjunction with the garbage collector. The consumer of an object can call this method when the object is no longer needed.","nodes":[{"content":"Use the <xref:System.IDisposable.Dispose%2A> method of this interface to explicitly release unmanaged resources in conjunction with the garbage collector. The consumer of an object can call this method when the object is no longer needed.","pos":[0,238],"nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method of this interface to explicitly release unmanaged resources in conjunction with the garbage collector.","pos":[0,154],"source":"Use the <xref:System.IDisposable.Dispose%2A> method of this interface to explicitly release unmanaged resources in conjunction with the garbage collector."},{"content":"The consumer of an object can call this method when the object is no longer needed.","pos":[155,238]}]}]},{"pos":[1061,1344],"content":"[!WARNING]\n It is a breaking change to add the <xref:System.IDisposable> interface to an existing class. Because pre-existing consumers of your type cannot call <xref:System.IDisposable.Dispose%2A>, you cannot be certain that unmanaged resources held by your type will be released.","leadings":["","> "],"nodes":[{"content":" It is a breaking change to add the <xref:System.IDisposable> interface to an existing class. Because pre-existing consumers of your type cannot call <xref:System.IDisposable.Dispose%2A>, you cannot be certain that unmanaged resources held by your type will be released.","pos":[11,281],"nodes":[{"content":"It is a breaking change to add the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface to an existing class.","pos":[1,93],"source":" It is a breaking change to add the <xref:System.IDisposable> interface to an existing class."},{"content":"Because pre-existing consumers of your type cannot call <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>, you cannot be certain that unmanaged resources held by your type will be released.","pos":[94,270],"source":" Because pre-existing consumers of your type cannot call <xref:System.IDisposable.Dispose%2A>, you cannot be certain that unmanaged resources held by your type will be released."}]}]},{"pos":[1351,1858],"content":"Because the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation is called by the consumer of a type when the resources owned by an instance are no longer needed, you should either wrap the managed object in a <xref:System.Runtime.InteropServices.SafeHandle> (the recommended alternative), or you should override <xref:System.Object.Finalize%2A?displayProperty=fullName> to free unmanaged resources in the event that the consumer forgets to call <xref:System.IDisposable.Dispose%2A>.","nodes":[{"content":"Because the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation is called by the consumer of a type when the resources owned by an instance are no longer needed, you should either wrap the managed object in a <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> (the recommended alternative), or you should override <ph id=\"ph3\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> to free unmanaged resources in the event that the consumer forgets to call <ph id=\"ph4\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>.","pos":[0,507],"source":"Because the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation is called by the consumer of a type when the resources owned by an instance are no longer needed, you should either wrap the managed object in a <xref:System.Runtime.InteropServices.SafeHandle> (the recommended alternative), or you should override <xref:System.Object.Finalize%2A?displayProperty=fullName> to free unmanaged resources in the event that the consumer forgets to call <xref:System.IDisposable.Dispose%2A>."}]},{"pos":[1866,2059],"content":"[!IMPORTANT]\n In the .NET Framework, the C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the <xref:System.IDisposable.Dispose%2A> method.","leadings":["","> "],"nodes":[{"content":"In the .NET Framework, the C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.","pos":[14,191],"source":" In the .NET Framework, the C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the <xref:System.IDisposable.Dispose%2A> method."}]},{"pos":[2066,2404],"content":"For a detailed discussion about how this interface and the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method are used, see the <bpt id=\"p1\">[</bpt>Garbage Collection<ept id=\"p1\">](http://msdn.microsoft.com/library/22b6cb97-0c80-4eeb-a2cf-5ed7655e37f9)</ept> and <bpt id=\"p2\">[</bpt>Implementing a Dispose Method<ept id=\"p2\">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept> topics.","source":"For a detailed discussion about how this interface and the <xref:System.Object.Finalize%2A?displayProperty=fullName> method are used, see the [Garbage Collection](http://msdn.microsoft.com/library/22b6cb97-0c80-4eeb-a2cf-5ed7655e37f9) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md) topics."},{"pos":[2413,2456],"content":"Using an object that implements IDisposable","linkify":"Using an object that implements IDisposable","nodes":[{"content":"Using an object that implements IDisposable","pos":[0,43]}]},{"pos":[2460,2906],"content":"Implement <xref:System.IDisposable> only if you are using unmanaged resources directly. If your app simply uses an object that implements <xref:System.IDisposable>, don't provide an <xref:System.IDisposable> implementation. Instead, you should call the object's <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation when you are finished using it. Depending on your programming language, you can do this in one of two ways:","nodes":[{"content":"Implement <xref:System.IDisposable> only if you are using unmanaged resources directly. If your app simply uses an object that implements <xref:System.IDisposable>, don't provide an <xref:System.IDisposable> implementation. Instead, you should call the object's <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation when you are finished using it. Depending on your programming language, you can do this in one of two ways:","pos":[0,446],"nodes":[{"content":"Implement <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> only if you are using unmanaged resources directly.","pos":[0,87],"source":"Implement <xref:System.IDisposable> only if you are using unmanaged resources directly."},{"content":"If your app simply uses an object that implements <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph>, don't provide an <ph id=\"ph2\">&lt;xref:System.IDisposable&gt;</ph> implementation.","pos":[88,223],"source":" If your app simply uses an object that implements <xref:System.IDisposable>, don't provide an <xref:System.IDisposable> implementation."},{"content":"Instead, you should call the object's <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation when you are finished using it.","pos":[224,370],"source":" Instead, you should call the object's <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation when you are finished using it."},{"content":"Depending on your programming language, you can do this in one of two ways:","pos":[371,446]}]}]},{"pos":[2916,2999],"content":"By using a language construct such as the <ph id=\"ph1\">`using`</ph> statement in C# and Visual Basic.","source":"By using a language construct such as the `using` statement in C# and Visual Basic."},{"pos":[3009,3139],"content":"By wrapping the call to the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation in a <ph id=\"ph2\">`try`</ph><ph id=\"ph3\">/</ph><ph id=\"ph4\">`catch`</ph> block.","source":"By wrapping the call to the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation in a `try`/`catch` block."},{"pos":[3147,3325],"content":"[!NOTE]\n Documentation for types that implement <xref:System.IDisposable> note that fact and include a reminder to call its <xref:System.IDisposable.Dispose%2A> implementation.","leadings":["","> "],"nodes":[{"content":"Documentation for types that implement <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> note that fact and include a reminder to call its <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implementation.","pos":[9,176],"source":" Documentation for types that implement <xref:System.IDisposable> note that fact and include a reminder to call its <xref:System.IDisposable.Dispose%2A> implementation."}]},{"pos":[3359,3398],"content":"The C# and Visual Basic Using statement","linkify":"The C# and Visual Basic Using statement","nodes":[{"content":"The C# and Visual Basic Using statement","pos":[0,39]}]},{"pos":[3402,3901],"content":"If your language supports a construct such as the [using](~/docs/csharp/language-reference/keywords/using.md) statement in C# and the [Using](~/docs/visual-basic/language-reference/statements/using-statement.md) statement in Visual Basic, you can use it instead of explicitly calling <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> yourself. The following example uses this approach in defining a `WordCount` class that preserves information about a file and the number of words in it.","nodes":[{"content":"If your language supports a construct such as the <bpt id=\"p1\">[</bpt>using<ept id=\"p1\">](~/docs/csharp/language-reference/keywords/using.md)</ept> statement in C# and the <bpt id=\"p2\">[</bpt>Using<ept id=\"p2\">](~/docs/visual-basic/language-reference/statements/using-statement.md)</ept> statement in Visual Basic, you can use it instead of explicitly calling <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> yourself.","pos":[0,355],"source":"If your language supports a construct such as the [using](~/docs/csharp/language-reference/keywords/using.md) statement in C# and the [Using](~/docs/visual-basic/language-reference/statements/using-statement.md) statement in Visual Basic, you can use it instead of explicitly calling <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> yourself."},{"content":"The following example uses this approach in defining a <ph id=\"ph1\">`WordCount`</ph> class that preserves information about a file and the number of words in it.","pos":[356,499],"source":" The following example uses this approach in defining a `WordCount` class that preserves information about a file and the number of words in it."}]},{"pos":[3908,4155],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.IDisposable#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling1.cs#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.IDisposable#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling1.vb#1)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.IDisposable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling1.cs#1)]\n [!code-vb[System.IDisposable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling1.vb#1)]"},{"pos":[4162,4328],"content":"The `using` statement is actually a syntactic convenience. At compile time, the language compiler implements the intermediate language (IL) for a `try`/`catch` block.","nodes":[{"content":"The <ph id=\"ph1\">`using`</ph> statement is actually a syntactic convenience.","pos":[0,58],"source":"The `using` statement is actually a syntactic convenience."},{"content":"At compile time, the language compiler implements the intermediate language (IL) for a <ph id=\"ph1\">`try`</ph><ph id=\"ph2\">/</ph><ph id=\"ph3\">`catch`</ph> block.","pos":[59,166],"source":" At compile time, the language compiler implements the intermediate language (IL) for a `try`/`catch` block."}]},{"pos":[4335,4571],"content":"For more information about the <ph id=\"ph1\">`using`</ph> statement, see the <bpt id=\"p1\">[</bpt>Using Statement<ept id=\"p1\">](~/docs/visual-basic/language-reference/statements/using-statement.md)</ept> or <bpt id=\"p2\">[</bpt>using Statement<ept id=\"p2\">](~/docs/csharp/language-reference/keywords/using-statement.md)</ept> topics.","source":"For more information about the `using` statement, see the [Using Statement](~/docs/visual-basic/language-reference/statements/using-statement.md) or [using Statement](~/docs/csharp/language-reference/keywords/using-statement.md) topics."},{"pos":[4581,4600],"content":"The Try/Catch block","linkify":"The Try/Catch block","nodes":[{"content":"The Try/Catch block","pos":[0,19]}]},{"pos":[4604,5003],"content":"If your programming language does not support a construct like the `using` statement in C# or Visual Basic, or if you prefer not to use it, you can call the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation from the `finally` block of a `try`/`catch` statement. The following example replaces the `using` block in the previous example with a `try`/`catch`/`finally` block.","nodes":[{"content":"If your programming language does not support a construct like the <ph id=\"ph1\">`using`</ph> statement in C# or Visual Basic, or if you prefer not to use it, you can call the <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation from the <ph id=\"ph3\">`finally`</ph> block of a <ph id=\"ph4\">`try`</ph><ph id=\"ph5\">/</ph><ph id=\"ph6\">`catch`</ph> statement.","pos":[0,288],"source":"If your programming language does not support a construct like the `using` statement in C# or Visual Basic, or if you prefer not to use it, you can call the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation from the `finally` block of a `try`/`catch` statement."},{"content":"The following example replaces the <ph id=\"ph1\">`using`</ph> block in the previous example with a <ph id=\"ph2\">`try`</ph><ph id=\"ph3\">/</ph><ph id=\"ph4\">`catch`</ph><ph id=\"ph5\">/</ph><ph id=\"ph6\">`finally`</ph> block.","pos":[289,399],"source":" The following example replaces the `using` block in the previous example with a `try`/`catch`/`finally` block."}]},{"pos":[5010,5257],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.IDisposable#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling2.cs#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.IDisposable#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling2.vb#2)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.IDisposable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling2.cs#2)]\n [!code-vb[System.IDisposable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling2.vb#2)]"},{"pos":[5264,5613],"content":"For more information about the <ph id=\"ph1\">`try`</ph><ph id=\"ph2\">/</ph><ph id=\"ph3\">`finally`</ph> pattern, see <bpt id=\"p1\">[</bpt>Try...Catch...Finally Statement<ept id=\"p1\">](~/docs/visual-basic/language-reference/statements/try-catch-finally-statement.md)</ept>, <bpt id=\"p2\">[</bpt>try-finally<ept id=\"p2\">](~/docs/csharp/language-reference/keywords/try-finally.md)</ept>, or <bpt id=\"p3\">[</bpt>try-finally Statement<ept id=\"p3\">](http://msdn.microsoft.com/library/514400c1-c322-4bf3-9e48-3047240b8a82)</ept>.","source":"For more information about the `try`/`finally` pattern, see [Try...Catch...Finally Statement](~/docs/visual-basic/language-reference/statements/try-catch-finally-statement.md), [try-finally](~/docs/csharp/language-reference/keywords/try-finally.md), or [try-finally Statement](http://msdn.microsoft.com/library/514400c1-c322-4bf3-9e48-3047240b8a82)."},{"pos":[5622,5646],"content":"Implementing IDisposable","linkify":"Implementing IDisposable","nodes":[{"content":"Implementing IDisposable","pos":[0,24]}]},{"pos":[5650,6460],"content":"You should implement <xref:System.IDisposable> only if your type uses unmanaged resources directly. The consumers of your type can call your <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation to free resources when the instance is no longer needed. To handle cases in which they fail to call <xref:System.IDisposable.Dispose%2A>, you should either use a class derived from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the unmanaged resources, or you should override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method for a reference type. In either case, you use the <xref:System.IDisposable.Dispose%2A> method to perform whatever cleanup is necessary after using the unmanaged resources, such as freeing, releasing, or resetting the unmanaged resources.","nodes":[{"content":"You should implement <xref:System.IDisposable> only if your type uses unmanaged resources directly. The consumers of your type can call your <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation to free resources when the instance is no longer needed. To handle cases in which they fail to call <xref:System.IDisposable.Dispose%2A>, you should either use a class derived from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the unmanaged resources, or you should override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method for a reference type. In either case, you use the <xref:System.IDisposable.Dispose%2A> method to perform whatever cleanup is necessary after using the unmanaged resources, such as freeing, releasing, or resetting the unmanaged resources.","pos":[0,810],"nodes":[{"content":"You should implement <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> only if your type uses unmanaged resources directly.","pos":[0,99],"source":"You should implement <xref:System.IDisposable> only if your type uses unmanaged resources directly."},{"content":"The consumers of your type can call your <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation to free resources when the instance is no longer needed.","pos":[100,274],"source":" The consumers of your type can call your <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation to free resources when the instance is no longer needed."},{"content":"To handle cases in which they fail to call <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph>, you should either use a class derived from <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> to wrap the unmanaged resources, or you should override the <ph id=\"ph3\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method for a reference type.","pos":[275,594],"source":" To handle cases in which they fail to call <xref:System.IDisposable.Dispose%2A>, you should either use a class derived from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the unmanaged resources, or you should override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method for a reference type."},{"content":"In either case, you use the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method to perform whatever cleanup is necessary after using the unmanaged resources, such as freeing, releasing, or resetting the unmanaged resources.","pos":[595,810],"source":" In either case, you use the <xref:System.IDisposable.Dispose%2A> method to perform whatever cleanup is necessary after using the unmanaged resources, such as freeing, releasing, or resetting the unmanaged resources."}]}]},{"pos":[6468,6797],"content":"[!IMPORTANT]\n If you are defining a base class that uses unmanaged resources and that either has, or is likely to have, subclasses that should be disposed, you should implement the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method and provide a second overload of `Dispose`, as discussed in the next section.","leadings":["","> "],"nodes":[{"content":"If you are defining a base class that uses unmanaged resources and that either has, or is likely to have, subclasses that should be disposed, you should implement the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> method and provide a second overload of <ph id=\"ph2\">`Dispose`</ph>, as discussed in the next section.","pos":[14,327],"source":" If you are defining a base class that uses unmanaged resources and that either has, or is likely to have, subclasses that should be disposed, you should implement the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method and provide a second overload of `Dispose`, as discussed in the next section."}]},{"pos":[6836,6877],"content":"IDisposable and the inheritance hierarchy","linkify":"IDisposable and the inheritance hierarchy","nodes":[{"content":"IDisposable and the inheritance hierarchy","pos":[0,41]}]},{"pos":[6881,7133],"content":"A base class with subclasses that should be disposable must implement <xref:System.IDisposable> as follows. You should use this pattern whenever you implement <xref:System.IDisposable> on any type that isn't `sealed` (`NotInheritable` in Visual Basic).","nodes":[{"content":"A base class with subclasses that should be disposable must implement <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> as follows.","pos":[0,107],"source":"A base class with subclasses that should be disposable must implement <xref:System.IDisposable> as follows."},{"content":"You should use this pattern whenever you implement <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> on any type that isn't <ph id=\"ph2\">`sealed`</ph> (<ph id=\"ph3\">`NotInheritable`</ph> in Visual Basic).","pos":[108,252],"source":" You should use this pattern whenever you implement <xref:System.IDisposable> on any type that isn't `sealed` (`NotInheritable` in Visual Basic)."}]},{"pos":[7143,7286],"content":"It should provide one public, non-virtual <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose&gt;</ph> method and a protected virtual <ph id=\"ph2\">`Dispose(Boolean disposing)`</ph> method.","source":"It should provide one public, non-virtual <xref:System.IDisposable.Dispose> method and a protected virtual `Dispose(Boolean disposing)` method."},{"pos":[7296,7416],"content":"The <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose&gt;</ph> method must call <ph id=\"ph2\">`Dispose(true)`</ph> and should suppress finalization for performance.","source":"The <xref:System.IDisposable.Dispose> method must call `Dispose(true)` and should suppress finalization for performance."},{"pos":[7426,7474],"content":"The base type should not include any finalizers.","nodes":[{"content":"The base type should not include any finalizers.","pos":[0,48]}]},{"pos":[7481,7669],"content":"The following code fragment reflects the dispose pattern for base classes. It assumes that your type does not override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method.","nodes":[{"content":"The following code fragment reflects the dispose pattern for base classes. It assumes that your type does not override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method.","pos":[0,188],"nodes":[{"content":"The following code fragment reflects the dispose pattern for base classes.","pos":[0,74]},{"content":"It assumes that your type does not override the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method.","pos":[75,188],"source":" It assumes that your type does not override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method."}]}]},{"pos":[7676,7917],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.IDisposable#3<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.IDisposable#3<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)</ept><ept id=\"p3\">]</ept>","leadings":[""," "],"source":"[!code-csharp[System.IDisposable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]\n[!code-vb[System.IDisposable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]"},{"pos":[7924,8063],"content":"If you do override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method, your class should implement the following pattern.","nodes":[{"content":"If you do override the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method, your class should implement the following pattern.","pos":[0,139],"source":"If you do override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method, your class should implement the following pattern."}]},{"pos":[8070,8311],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.IDisposable#5<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.IDisposable#5<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)</ept><ept id=\"p3\">]</ept>","leadings":[""," "],"source":"[!code-csharp[System.IDisposable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]\n[!code-vb[System.IDisposable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]"},{"pos":[8318,8380],"content":"Subclasses should implement the disposable pattern as follows:","nodes":[{"content":"Subclasses should implement the disposable pattern as follows:","pos":[0,62]}]},{"pos":[8390,8486],"content":"They must override <ph id=\"ph1\">`Dispose(Boolean)`</ph> and call the base class <ph id=\"ph2\">`Dispose(Boolean)`</ph> implementation.","source":"They must override `Dispose(Boolean)` and call the base class `Dispose(Boolean)` implementation."},{"pos":[8496,8577],"content":"They can provide a finalizer if needed. The finalizer must call `Dispose(false)`.","nodes":[{"content":"They can provide a finalizer if needed.","pos":[0,39]},{"content":"The finalizer must call <ph id=\"ph1\">`Dispose(false)`</ph>.","pos":[40,81],"source":" The finalizer must call `Dispose(false)`."}]},{"pos":[8584,8818],"content":"Note that derived classes do not themselves implement the <xref:System.IDisposable> interface and do not include a parameterless <xref:System.IDisposable.Dispose%2A> method. They only override the base class `Dispose(Boolean)` method.","nodes":[{"content":"Note that derived classes do not themselves implement the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface and do not include a parameterless <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.","pos":[0,173],"source":"Note that derived classes do not themselves implement the <xref:System.IDisposable> interface and do not include a parameterless <xref:System.IDisposable.Dispose%2A> method."},{"content":"They only override the base class <ph id=\"ph1\">`Dispose(Boolean)`</ph> method.","pos":[174,234],"source":" They only override the base class `Dispose(Boolean)` method."}]},{"pos":[8825,9016],"content":"The following code fragment reflects the dispose pattern for derived classes. It assumes that your type does not override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method.","nodes":[{"content":"The following code fragment reflects the dispose pattern for derived classes. It assumes that your type does not override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method.","pos":[0,191],"nodes":[{"content":"The following code fragment reflects the dispose pattern for derived classes.","pos":[0,77]},{"content":"It assumes that your type does not override the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method.","pos":[78,191],"source":" It assumes that your type does not override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method."}]}]},{"pos":[9023,9270],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.IDisposable#4<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.IDisposable#4<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)</ept><ept id=\"p3\">]</ept>","leadings":[""," "],"source":"[!code-csharp[System.IDisposable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]\n[!code-vb[System.IDisposable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]"}],"pos":[434,9794],"yaml":true,"extradata":"MT"},{"content":"Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.","nodes":[{"pos":[0,104],"content":"Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.","nodes":[{"content":"Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.","pos":[0,104]}]}],"pos":[29041,29146],"yaml":true},{"content":"Use this method to close or release unmanaged resources such as files, streams, and handles held by an instance of the class that implements this interface. By convention, this method is used for all tasks associated with freeing resources held by an object, or preparing an object for reuse.  \n  \n> [!WARNING]\n>  If you are using a class that implements the <xref:System.IDisposable> interface, you should call its <xref:System.IDisposable.Dispose%2A> implementation when you are finished using the class. For more information, see the \"Using an object that implements IDisposable\" section in the <xref:System.IDisposable> topic.  \n  \n When implementing this method, ensure that all held resources are freed by propagating the call through the containment hierarchy. For example, if an object A allocates an object B, and object B allocates an object C, then A's <xref:System.IDisposable.Dispose%2A> implementation must call <xref:System.IDisposable.Dispose%2A> on B, which must in turn call <xref:System.IDisposable.Dispose%2A> on C.  \n  \n> [!IMPORTANT]\n>  The C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the <xref:System.IDisposable.Dispose%2A> method.  \n  \n An object must also call the <xref:System.IDisposable.Dispose%2A> method of its base class if the base class implements <xref:System.IDisposable>. For more information about implementing <xref:System.IDisposable> on a base class and its subclasses, see the \"IDisposable and the inheritance hierarchy\" section in the <xref:System.IDisposable> topic.  \n  \n If an object's <xref:System.IDisposable.Dispose%2A> method is called more than once, the object must ignore all calls after the first one. The object must not throw an exception if its <xref:System.IDisposable.Dispose%2A> method is called multiple times. Instance methods other than <xref:System.IDisposable.Dispose%2A> can throw an <xref:System.ObjectDisposedException> when resources are already disposed.  \n  \n Users might expect a resource type to use a particular convention to denote an allocated state versus a freed state. An example of this is stream classes, which are traditionally thought of as open or closed. The implementer of a class that has such a convention might choose to implement a public method with a customized name, such as `Close`, that calls the <xref:System.IDisposable.Dispose%2A> method.  \n  \n Because the <xref:System.IDisposable.Dispose%2A> method must be called explicitly, there is always a danger that the unmanaged resources will not be released, because the consumer of an object fails to call its <xref:System.IDisposable.Dispose%2A> method. There are two ways to avoid this:  \n  \n-   Wrap the managed resource in an object derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>. Your <xref:System.IDisposable.Dispose%2A> implementation then calls the <xref:System.IDisposable.Dispose%2A> method of the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> instances. For more information, see \"The SafeHandle alternative\" section in the <xref:System.Object.Finalize%2A?displayProperty=fullName> topic.  \n  \n-   Implement a finalizer to free resources when <xref:System.IDisposable.Dispose%2A> is not called. By default, the garbage collector automatically calls an object's finalizer before reclaiming its memory. However, if the <xref:System.IDisposable.Dispose%2A> method has been called, it is typically unnecessary for the garbage collector to call the disposed object's finalizer. To prevent automatic finalization, <xref:System.IDisposable.Dispose%2A> implementations can call the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method.  \n  \n When you use an object that accesses unmanaged resources, such as a <xref:System.IO.StreamWriter>, a good practice is to create the instance with a `using` statement. The `using` statement automatically closes the stream and calls <xref:System.IDisposable.Dispose%2A> on the object when the code that is using it has completed. For an example, see the <xref:System.IO.StreamWriter> class.","nodes":[{"pos":[0,292],"content":"Use this method to close or release unmanaged resources such as files, streams, and handles held by an instance of the class that implements this interface. By convention, this method is used for all tasks associated with freeing resources held by an object, or preparing an object for reuse.","nodes":[{"content":"Use this method to close or release unmanaged resources such as files, streams, and handles held by an instance of the class that implements this interface. By convention, this method is used for all tasks associated with freeing resources held by an object, or preparing an object for reuse.","pos":[0,292],"nodes":[{"content":"Use this method to close or release unmanaged resources such as files, streams, and handles held by an instance of the class that implements this interface.","pos":[0,156]},{"content":"By convention, this method is used for all tasks associated with freeing resources held by an object, or preparing an object for reuse.","pos":[157,292]}]}]},{"pos":[300,630],"content":"[!WARNING]\n If you are using a class that implements the <xref:System.IDisposable> interface, you should call its <xref:System.IDisposable.Dispose%2A> implementation when you are finished using the class. For more information, see the \"Using an object that implements IDisposable\" section in the <xref:System.IDisposable> topic.","leadings":["","> "],"nodes":[{"content":" If you are using a class that implements the <xref:System.IDisposable> interface, you should call its <xref:System.IDisposable.Dispose%2A> implementation when you are finished using the class. For more information, see the \"Using an object that implements IDisposable\" section in the <xref:System.IDisposable> topic.","pos":[11,328],"nodes":[{"content":"If you are using a class that implements the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface, you should call its <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implementation when you are finished using the class.","pos":[1,193],"source":" If you are using a class that implements the <xref:System.IDisposable> interface, you should call its <xref:System.IDisposable.Dispose%2A> implementation when you are finished using the class."},{"content":"For more information, see the \"Using an object that implements IDisposable\" section in the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> topic.","pos":[194,317],"source":" For more information, see the \"Using an object that implements IDisposable\" section in the <xref:System.IDisposable> topic."}]}]},{"pos":[637,1035],"content":"When implementing this method, ensure that all held resources are freed by propagating the call through the containment hierarchy. For example, if an object A allocates an object B, and object B allocates an object C, then A's <xref:System.IDisposable.Dispose%2A> implementation must call <xref:System.IDisposable.Dispose%2A> on B, which must in turn call <xref:System.IDisposable.Dispose%2A> on C.","nodes":[{"content":"When implementing this method, ensure that all held resources are freed by propagating the call through the containment hierarchy. For example, if an object A allocates an object B, and object B allocates an object C, then A's <xref:System.IDisposable.Dispose%2A> implementation must call <xref:System.IDisposable.Dispose%2A> on B, which must in turn call <xref:System.IDisposable.Dispose%2A> on C.","pos":[0,398],"nodes":[{"content":"When implementing this method, ensure that all held resources are freed by propagating the call through the containment hierarchy.","pos":[0,130]},{"content":"For example, if an object A allocates an object B, and object B allocates an object C, then A's <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implementation must call <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> on B, which must in turn call <ph id=\"ph3\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> on C.","pos":[131,398],"source":" For example, if an object A allocates an object B, and object B allocates an object C, then A's <xref:System.IDisposable.Dispose%2A> implementation must call <xref:System.IDisposable.Dispose%2A> on B, which must in turn call <xref:System.IDisposable.Dispose%2A> on C."}]}]},{"pos":[1043,1213],"content":"[!IMPORTANT]\n The C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the <xref:System.IDisposable.Dispose%2A> method.","leadings":["","> "],"nodes":[{"content":"The C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.","pos":[14,168],"source":" The C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the <xref:System.IDisposable.Dispose%2A> method."}]},{"pos":[1220,1568],"content":"An object must also call the <xref:System.IDisposable.Dispose%2A> method of its base class if the base class implements <xref:System.IDisposable>. For more information about implementing <xref:System.IDisposable> on a base class and its subclasses, see the \"IDisposable and the inheritance hierarchy\" section in the <xref:System.IDisposable> topic.","nodes":[{"content":"An object must also call the <xref:System.IDisposable.Dispose%2A> method of its base class if the base class implements <xref:System.IDisposable>. For more information about implementing <xref:System.IDisposable> on a base class and its subclasses, see the \"IDisposable and the inheritance hierarchy\" section in the <xref:System.IDisposable> topic.","pos":[0,348],"nodes":[{"content":"An object must also call the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method of its base class if the base class implements <ph id=\"ph2\">&lt;xref:System.IDisposable&gt;</ph>.","pos":[0,146],"source":"An object must also call the <xref:System.IDisposable.Dispose%2A> method of its base class if the base class implements <xref:System.IDisposable>."},{"content":"For more information about implementing <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> on a base class and its subclasses, see the \"IDisposable and the inheritance hierarchy\" section in the <ph id=\"ph2\">&lt;xref:System.IDisposable&gt;</ph> topic.","pos":[147,348],"source":" For more information about implementing <xref:System.IDisposable> on a base class and its subclasses, see the \"IDisposable and the inheritance hierarchy\" section in the <xref:System.IDisposable> topic."}]}]},{"pos":[1575,1982],"content":"If an object's <xref:System.IDisposable.Dispose%2A> method is called more than once, the object must ignore all calls after the first one. The object must not throw an exception if its <xref:System.IDisposable.Dispose%2A> method is called multiple times. Instance methods other than <xref:System.IDisposable.Dispose%2A> can throw an <xref:System.ObjectDisposedException> when resources are already disposed.","nodes":[{"content":"If an object's <xref:System.IDisposable.Dispose%2A> method is called more than once, the object must ignore all calls after the first one. The object must not throw an exception if its <xref:System.IDisposable.Dispose%2A> method is called multiple times. Instance methods other than <xref:System.IDisposable.Dispose%2A> can throw an <xref:System.ObjectDisposedException> when resources are already disposed.","pos":[0,407],"nodes":[{"content":"If an object's <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method is called more than once, the object must ignore all calls after the first one.","pos":[0,138],"source":"If an object's <xref:System.IDisposable.Dispose%2A> method is called more than once, the object must ignore all calls after the first one."},{"content":"The object must not throw an exception if its <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method is called multiple times.","pos":[139,254],"source":" The object must not throw an exception if its <xref:System.IDisposable.Dispose%2A> method is called multiple times."},{"content":"Instance methods other than <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> can throw an <ph id=\"ph2\">&lt;xref:System.ObjectDisposedException&gt;</ph> when resources are already disposed.","pos":[255,407],"source":" Instance methods other than <xref:System.IDisposable.Dispose%2A> can throw an <xref:System.ObjectDisposedException> when resources are already disposed."}]}]},{"pos":[1989,2394],"content":"Users might expect a resource type to use a particular convention to denote an allocated state versus a freed state. An example of this is stream classes, which are traditionally thought of as open or closed. The implementer of a class that has such a convention might choose to implement a public method with a customized name, such as `Close`, that calls the <xref:System.IDisposable.Dispose%2A> method.","nodes":[{"content":"Users might expect a resource type to use a particular convention to denote an allocated state versus a freed state.","pos":[0,116]},{"content":"An example of this is stream classes, which are traditionally thought of as open or closed.","pos":[117,208]},{"content":"The implementer of a class that has such a convention might choose to implement a public method with a customized name, such as <ph id=\"ph1\">`Close`</ph>, that calls the <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.","pos":[209,405],"source":" The implementer of a class that has such a convention might choose to implement a public method with a customized name, such as `Close`, that calls the <xref:System.IDisposable.Dispose%2A> method."}]},{"pos":[2401,2690],"content":"Because the <xref:System.IDisposable.Dispose%2A> method must be called explicitly, there is always a danger that the unmanaged resources will not be released, because the consumer of an object fails to call its <xref:System.IDisposable.Dispose%2A> method. There are two ways to avoid this:","nodes":[{"content":"Because the <xref:System.IDisposable.Dispose%2A> method must be called explicitly, there is always a danger that the unmanaged resources will not be released, because the consumer of an object fails to call its <xref:System.IDisposable.Dispose%2A> method. There are two ways to avoid this:","pos":[0,289],"nodes":[{"content":"Because the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method must be called explicitly, there is always a danger that the unmanaged resources will not be released, because the consumer of an object fails to call its <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method.","pos":[0,255],"source":"Because the <xref:System.IDisposable.Dispose%2A> method must be called explicitly, there is always a danger that the unmanaged resources will not be released, because the consumer of an object fails to call its <xref:System.IDisposable.Dispose%2A> method."},{"content":"There are two ways to avoid this:","pos":[256,289]}]}]},{"pos":[2700,3169],"content":"Wrap the managed resource in an object derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>. Your <xref:System.IDisposable.Dispose%2A> implementation then calls the <xref:System.IDisposable.Dispose%2A> method of the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> instances. For more information, see \"The SafeHandle alternative\" section in the <xref:System.Object.Finalize%2A?displayProperty=fullName> topic.","nodes":[{"content":"Wrap the managed resource in an object derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>. Your <xref:System.IDisposable.Dispose%2A> implementation then calls the <xref:System.IDisposable.Dispose%2A> method of the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> instances. For more information, see \"The SafeHandle alternative\" section in the <xref:System.Object.Finalize%2A?displayProperty=fullName> topic.","pos":[0,469],"nodes":[{"content":"Wrap the managed resource in an object derived from <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName&gt;</ph>.","pos":[0,126],"source":"Wrap the managed resource in an object derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>."},{"content":"Your <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implementation then calls the <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method of the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName&gt;</ph> instances.","pos":[127,334],"source":" Your <xref:System.IDisposable.Dispose%2A> implementation then calls the <xref:System.IDisposable.Dispose%2A> method of the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> instances."},{"content":"For more information, see \"The SafeHandle alternative\" section in the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> topic.","pos":[335,469],"source":" For more information, see \"The SafeHandle alternative\" section in the <xref:System.Object.Finalize%2A?displayProperty=fullName> topic."}]}]},{"pos":[3179,3724],"content":"Implement a finalizer to free resources when <xref:System.IDisposable.Dispose%2A> is not called. By default, the garbage collector automatically calls an object's finalizer before reclaiming its memory. However, if the <xref:System.IDisposable.Dispose%2A> method has been called, it is typically unnecessary for the garbage collector to call the disposed object's finalizer. To prevent automatic finalization, <xref:System.IDisposable.Dispose%2A> implementations can call the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method.","nodes":[{"content":"Implement a finalizer to free resources when <xref:System.IDisposable.Dispose%2A> is not called. By default, the garbage collector automatically calls an object's finalizer before reclaiming its memory. However, if the <xref:System.IDisposable.Dispose%2A> method has been called, it is typically unnecessary for the garbage collector to call the disposed object's finalizer. To prevent automatic finalization, <xref:System.IDisposable.Dispose%2A> implementations can call the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method.","pos":[0,545],"nodes":[{"content":"Implement a finalizer to free resources when <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> is not called.","pos":[0,96],"source":"Implement a finalizer to free resources when <xref:System.IDisposable.Dispose%2A> is not called."},{"content":"By default, the garbage collector automatically calls an object's finalizer before reclaiming its memory.","pos":[97,202]},{"content":"However, if the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method has been called, it is typically unnecessary for the garbage collector to call the disposed object's finalizer.","pos":[203,374],"source":" However, if the <xref:System.IDisposable.Dispose%2A> method has been called, it is typically unnecessary for the garbage collector to call the disposed object's finalizer."},{"content":"To prevent automatic finalization, <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> implementations can call the <ph id=\"ph2\">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=fullName&gt;</ph> method.","pos":[375,545],"source":" To prevent automatic finalization, <xref:System.IDisposable.Dispose%2A> implementations can call the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method."}]}]},{"pos":[3731,4119],"content":"When you use an object that accesses unmanaged resources, such as a <xref:System.IO.StreamWriter>, a good practice is to create the instance with a `using` statement. The `using` statement automatically closes the stream and calls <xref:System.IDisposable.Dispose%2A> on the object when the code that is using it has completed. For an example, see the <xref:System.IO.StreamWriter> class.","nodes":[{"content":"When you use an object that accesses unmanaged resources, such as a <ph id=\"ph1\">&lt;xref:System.IO.StreamWriter&gt;</ph>, a good practice is to create the instance with a <ph id=\"ph2\">`using`</ph> statement.","pos":[0,166],"source":"When you use an object that accesses unmanaged resources, such as a <xref:System.IO.StreamWriter>, a good practice is to create the instance with a `using` statement."},{"content":"The <ph id=\"ph1\">`using`</ph> statement automatically closes the stream and calls <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> on the object when the code that is using it has completed.","pos":[167,327],"source":" The `using` statement automatically closes the stream and calls <xref:System.IDisposable.Dispose%2A> on the object when the code that is using it has completed."},{"content":"For an example, see the <ph id=\"ph1\">&lt;xref:System.IO.StreamWriter&gt;</ph> class.","pos":[328,388],"source":" For an example, see the <xref:System.IO.StreamWriter> class."}]}],"pos":[29157,33307],"yaml":true,"extradata":"MT"}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.IDisposable\n  commentId: T:System.IDisposable\n  id: IDisposable\n  children:\n  - System.IDisposable.Dispose\n  langs:\n  - csharp\n  name: IDisposable\n  nameWithType: IDisposable\n  fullName: System.IDisposable\n  type: Interface\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Provides a mechanism for releasing unmanaged resources.\n  remarks: \"> [!NOTE]\\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/idisposable.cs#1f55292c3174123d). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \\n  \\n The primary use of this interface is to release unmanaged resources. The garbage collector automatically releases the memory allocated to a managed object when that object is no longer used. However, it is not possible to predict when garbage collection will occur. Furthermore, the garbage collector has no knowledge of unmanaged resources such as window handles, or open files and streams.  \\n  \\n Use the <xref:System.IDisposable.Dispose%2A> method of this interface to explicitly release unmanaged resources in conjunction with the garbage collector. The consumer of an object can call this method when the object is no longer needed.  \\n  \\n> [!WARNING]\\n>  It is a breaking change to add the <xref:System.IDisposable> interface to an existing class. Because pre-existing consumers of your type cannot call <xref:System.IDisposable.Dispose%2A>, you cannot be certain that unmanaged resources held by your type will be released.  \\n  \\n Because the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation is called by the consumer of a type when the resources owned by an instance are no longer needed, you should either wrap the managed object in a <xref:System.Runtime.InteropServices.SafeHandle> (the recommended alternative), or you should override <xref:System.Object.Finalize%2A?displayProperty=fullName> to free unmanaged resources in the event that the consumer forgets to call <xref:System.IDisposable.Dispose%2A>.  \\n  \\n> [!IMPORTANT]\\n>  In the .NET Framework, the C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the <xref:System.IDisposable.Dispose%2A> method.  \\n  \\n For a detailed discussion about how this interface and the <xref:System.Object.Finalize%2A?displayProperty=fullName> method are used, see the [Garbage Collection](http://msdn.microsoft.com/library/22b6cb97-0c80-4eeb-a2cf-5ed7655e37f9) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md) topics.  \\n  \\n## Using an object that implements IDisposable  \\n Implement <xref:System.IDisposable> only if you are using unmanaged resources directly. If your app simply uses an object that implements <xref:System.IDisposable>, don't provide an <xref:System.IDisposable> implementation. Instead, you should call the object's <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation when you are finished using it. Depending on your programming language, you can do this in one of two ways:  \\n  \\n-   By using a language construct such as the `using` statement in C# and Visual Basic.  \\n  \\n-   By wrapping the call to the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation in a `try`/`catch` block.  \\n  \\n> [!NOTE]\\n>  Documentation for types that implement <xref:System.IDisposable> note that fact and include a reminder to call its <xref:System.IDisposable.Dispose%2A> implementation.  \\n  \\n<a name=\\\"Using\\\"></a>   \\n### The C# and Visual Basic Using statement  \\n If your language supports a construct such as the [using](~/docs/csharp/language-reference/keywords/using.md) statement in C# and the [Using](~/docs/visual-basic/language-reference/statements/using-statement.md) statement in Visual Basic, you can use it instead of explicitly calling <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> yourself. The following example uses this approach in defining a `WordCount` class that preserves information about a file and the number of words in it.  \\n  \\n [!code-csharp[System.IDisposable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling1.cs#1)]\\n [!code-vb[System.IDisposable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling1.vb#1)]  \\n  \\n The `using` statement is actually a syntactic convenience. At compile time, the language compiler implements the intermediate language (IL) for a `try`/`catch` block.  \\n  \\n For more information about the `using` statement, see the [Using Statement](~/docs/visual-basic/language-reference/statements/using-statement.md) or [using Statement](~/docs/csharp/language-reference/keywords/using-statement.md) topics.  \\n  \\n### The Try/Catch block  \\n If your programming language does not support a construct like the `using` statement in C# or Visual Basic, or if you prefer not to use it, you can call the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation from the `finally` block of a `try`/`catch` statement. The following example replaces the `using` block in the previous example with a `try`/`catch`/`finally` block.  \\n  \\n [!code-csharp[System.IDisposable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling2.cs#2)]\\n [!code-vb[System.IDisposable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling2.vb#2)]  \\n  \\n For more information about the `try`/`finally` pattern, see [Try...Catch...Finally Statement](~/docs/visual-basic/language-reference/statements/try-catch-finally-statement.md), [try-finally](~/docs/csharp/language-reference/keywords/try-finally.md), or [try-finally Statement](http://msdn.microsoft.com/library/514400c1-c322-4bf3-9e48-3047240b8a82).  \\n  \\n## Implementing IDisposable  \\n You should implement <xref:System.IDisposable> only if your type uses unmanaged resources directly. The consumers of your type can call your <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation to free resources when the instance is no longer needed. To handle cases in which they fail to call <xref:System.IDisposable.Dispose%2A>, you should either use a class derived from <xref:System.Runtime.InteropServices.SafeHandle> to wrap the unmanaged resources, or you should override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method for a reference type. In either case, you use the <xref:System.IDisposable.Dispose%2A> method to perform whatever cleanup is necessary after using the unmanaged resources, such as freeing, releasing, or resetting the unmanaged resources.  \\n  \\n> [!IMPORTANT]\\n>  If you are defining a base class that uses unmanaged resources and that either has, or is likely to have, subclasses that should be disposed, you should implement the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method and provide a second overload of `Dispose`, as discussed in the next section.  \\n  \\n<a name=\\\"BaseClasses\\\"></a>   \\n## IDisposable and the inheritance hierarchy  \\n A base class with subclasses that should be disposable must implement <xref:System.IDisposable> as follows. You should use this pattern whenever you implement <xref:System.IDisposable> on any type that isn't `sealed` (`NotInheritable` in Visual Basic).  \\n  \\n-   It should provide one public, non-virtual <xref:System.IDisposable.Dispose> method and a protected virtual `Dispose(Boolean disposing)` method.  \\n  \\n-   The <xref:System.IDisposable.Dispose> method must call `Dispose(true)` and should suppress finalization for performance.  \\n  \\n-   The base type should not include any finalizers.  \\n  \\n The following code fragment reflects the dispose pattern for base classes. It assumes that your type does not override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method.  \\n  \\n [!code-csharp[System.IDisposable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]\\n [!code-vb[System.IDisposable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  \\n  \\n If you do override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method, your class should implement the following pattern.  \\n  \\n [!code-csharp[System.IDisposable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]\\n [!code-vb[System.IDisposable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  \\n  \\n Subclasses should implement the disposable pattern as follows:  \\n  \\n-   They must override `Dispose(Boolean)` and call the base class `Dispose(Boolean)` implementation.  \\n  \\n-   They can provide a finalizer if needed. The finalizer must call `Dispose(false)`.  \\n  \\n Note that derived classes do not themselves implement the <xref:System.IDisposable> interface and do not include a parameterless <xref:System.IDisposable.Dispose%2A> method. They only override the base class `Dispose(Boolean)` method.  \\n  \\n The following code fragment reflects the dispose pattern for derived classes. It assumes that your type does not override the <xref:System.Object.Finalize%2A?displayProperty=fullName> method.  \\n  \\n [!code-csharp[System.IDisposable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]\\n [!code-vb[System.IDisposable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]\"\n  example:\n  - \"The following example demonstrates how to create a resource class that implements the <xref:System.IDisposable> interface.  \\n  \\n [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]\\n [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]\\n [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public interface IDisposable\n  derivedClasses:\n  - DbLinq.Util.BaseLock\n  - Microsoft.Build.Debugging.DebuggerManager.IslandThread\n  - Microsoft.Build.Evaluation.ProjectCollection\n  - Microsoft.Build.Execution.BuildManager\n  - Microsoft.FSharp.Control.FSharpMailboxProcessor`1\n  - Microsoft.FSharp.Core.CompilerServices.ITypeProvider\n  - Microsoft.VisualBasic.Compatibility.VB6.BaseDataEnvironment\n  - Microsoft.VisualBasic.Compatibility.VB6.MBinding\n  - Microsoft.VisualBasic.Compatibility.VB6.MBindingCollection\n  - Microsoft.VisualBasic.FileIO.TextFieldParser\n  - Microsoft.Win32.RegistryKey\n  - Mono.Security.Interface.IMonoSslStream\n  - Mono.Security.Protocol.Ntlm.ChallengeResponse\n  - System.ActivationContext\n  - System.Activities.WorkflowDataContext\n  - System.Activities.Debugger.StateManager\n  - System.Activities.Presentation.EditingContext\n  - System.Activities.Presentation.Model.ModelEditingScope\n  - System.Activities.Statements.DurableTimerExtension\n  - System.AddIn.Contract.IEnumeratorContract`1\n  - System.AddIn.Pipeline.ContractHandle\n  - System.CodeDom.Compiler.TempFileCollection\n  - System.Collections.Concurrent.BlockingCollection`1\n  - System.Collections.Generic.IEnumerator`1\n  - System.ComponentModel.Component\n  - System.ComponentModel.Container\n  - System.ComponentModel.EventHandlerList\n  - System.ComponentModel.IComponent\n  - System.ComponentModel.IContainer\n  - System.ComponentModel.INestedContainer\n  - System.ComponentModel.License\n  - System.ComponentModel.MarshalByValueComponent\n  - System.ComponentModel.NestedContainer\n  - System.ComponentModel.Composition.ExportLifetimeContext`1\n  - System.ComponentModel.Composition.Hosting.AggregateExportProvider\n  - System.ComponentModel.Composition.Hosting.AtomicComposition\n  - System.ComponentModel.Composition.Hosting.CatalogExportProvider\n  - System.ComponentModel.Composition.Hosting.ComposablePartExportProvider\n  - System.ComponentModel.Composition.Hosting.CompositionContainer\n  - System.ComponentModel.Composition.Hosting.CompositionService\n  - System.ComponentModel.Composition.Hosting.ImportEngine\n  - System.ComponentModel.Composition.Primitives.ComposablePartCatalog\n  - System.ComponentModel.Design.ComponentDesigner\n  - System.ComponentModel.Design.DesignerActionService\n  - System.ComponentModel.Design.DesignerActionUIService\n  - System.ComponentModel.Design.DesignerTransaction\n  - System.ComponentModel.Design.DesignSurface\n  - System.ComponentModel.Design.DesignSurfaceManager\n  - System.ComponentModel.Design.IDesigner\n  - System.ComponentModel.Design.InheritanceService\n  - System.ComponentModel.Design.IRootDesigner\n  - System.ComponentModel.Design.ITreeDesigner\n  - System.ComponentModel.Design.LocalizationExtenderProvider\n  - System.ComponentModel.Design.MenuCommandService\n  - System.ComponentModel.Design.ServiceContainer\n  - System.ComponentModel.Design.UndoEngine\n  - System.ComponentModel.Design.Serialization.CodeDomLocalizationProvider\n  - System.ComponentModel.Design.Serialization.SerializationStore\n  - System.Composition.Export`1\n  - System.Composition.Hosting.CompositionHost\n  - System.Composition.Hosting.Core.CompositionOperation\n  - System.Composition.Hosting.Core.LifetimeContext\n  - System.Data.IDataReader\n  - System.Data.IDbCommand\n  - System.Data.IDbConnection\n  - System.Data.IDbTransaction\n  - System.Data.Common.DbCommand\n  - System.Data.Common.DbConnection\n  - System.Data.Common.DbDataReader\n  - System.Data.Common.DbTransaction\n  - System.Data.Linq.DataContext\n  - System.Data.Linq.IExecuteResult\n  - System.Data.Linq.IMultipleResults\n  - System.Data.Linq.ISingleResult`1\n  - System.Data.Linq.SqlClient.SqlProvider\n  - System.Data.Objects.ObjectContext\n  - System.Data.Objects.ObjectResult\n  - System.Data.OleDb.OleDbCommand\n  - System.Data.OleDb.OleDbConnection\n  - System.Data.Services.Client.DataServiceStreamResponse\n  - System.Data.SqlClient.SqlBulkCopy\n  - System.Data.SqlClient.SqlCommand\n  - System.Data.SqlClient.SqlConnection\n  - System.Data.SqlClient.SqlDataReader\n  - System.Data.SqlClient.SqlTransaction\n  - System.Deployment.Application.InPlaceHostingManager\n  - System.Device.Location.GeoCoordinateWatcher\n  - System.Diagnostics.DiagnosticListener\n  - System.Diagnostics.TraceListener\n  - System.Diagnostics.Eventing.EventProvider\n  - System.Diagnostics.Eventing.Reader.EventLogConfiguration\n  - System.Diagnostics.Eventing.Reader.EventLogPropertySelector\n  - System.Diagnostics.Eventing.Reader.EventLogReader\n  - System.Diagnostics.Eventing.Reader.EventLogSession\n  - System.Diagnostics.Eventing.Reader.EventLogWatcher\n  - System.Diagnostics.Eventing.Reader.EventRecord\n  - System.Diagnostics.Eventing.Reader.ProviderMetadata\n  - System.Diagnostics.PerformanceData.CounterSet\n  - System.Diagnostics.PerformanceData.CounterSetInstance\n  - System.Diagnostics.PerformanceData.CounterSetInstanceCounterDataSet\n  - System.Diagnostics.SymbolStore.SymBinder\n  - System.Diagnostics.SymbolStore.SymDocument\n  - System.Diagnostics.SymbolStore.SymDocumentWriter\n  - System.Diagnostics.SymbolStore.SymMethod\n  - System.Diagnostics.SymbolStore.SymReader\n  - System.Diagnostics.SymbolStore.SymScope\n  - System.Diagnostics.SymbolStore.SymVariable\n  - System.Diagnostics.SymbolStore.SymWriter\n  - System.Diagnostics.Tracing.EventListener\n  - System.Diagnostics.Tracing.EventSource\n  - System.DirectoryServices.SearchResultCollection\n  - System.DirectoryServices.AccountManagement.Principal\n  - System.DirectoryServices.AccountManagement.PrincipalContext\n  - System.DirectoryServices.AccountManagement.PrincipalSearcher\n  - System.DirectoryServices.AccountManagement.PrincipalSearchResult`1\n  - System.DirectoryServices.ActiveDirectory.ActiveDirectoryInterSiteTransport\n  - System.DirectoryServices.ActiveDirectory.ActiveDirectoryPartition\n  - System.DirectoryServices.ActiveDirectory.ActiveDirectorySchemaClass\n  - System.DirectoryServices.ActiveDirectory.ActiveDirectorySchemaProperty\n  - System.DirectoryServices.ActiveDirectory.ActiveDirectorySite\n  - System.DirectoryServices.ActiveDirectory.ActiveDirectorySiteLink\n  - System.DirectoryServices.ActiveDirectory.ActiveDirectorySiteLinkBridge\n  - System.DirectoryServices.ActiveDirectory.ActiveDirectorySubnet\n  - System.DirectoryServices.ActiveDirectory.DirectoryServer\n  - System.DirectoryServices.ActiveDirectory.Forest\n  - System.DirectoryServices.ActiveDirectory.ReplicationConnection\n  - System.DirectoryServices.Protocols.LdapConnection\n  - System.Drawing.Brush\n  - System.Drawing.BufferedGraphics\n  - System.Drawing.BufferedGraphicsContext\n  - System.Drawing.Font\n  - System.Drawing.FontConverter.FontNameConverter\n  - System.Drawing.FontFamily\n  - System.Drawing.Graphics\n  - System.Drawing.Icon\n  - System.Drawing.IDeviceContext\n  - System.Drawing.Image\n  - System.Drawing.Pen\n  - System.Drawing.Region\n  - System.Drawing.StringFormat\n  - System.Drawing.Drawing2D.CustomLineCap\n  - System.Drawing.Drawing2D.GraphicsPath\n  - System.Drawing.Drawing2D.GraphicsPathIterator\n  - System.Drawing.Drawing2D.Matrix\n  - System.Drawing.Imaging.EncoderParameter\n  - System.Drawing.Imaging.EncoderParameters\n  - System.Drawing.Imaging.ImageAttributes\n  - System.Drawing.Text.FontCollection\n  - System.IdentityModel.AsyncResult\n  - System.IdentityModel.Claims.WindowsClaimSet\n  - System.IdentityModel.Claims.X509CertificateClaimSet\n  - System.IdentityModel.Selectors.X509SecurityTokenProvider\n  - System.IdentityModel.Tokens.X509SecurityToken\n  - System.IO.BinaryReader\n  - System.IO.BinaryWriter\n  - System.IO.Stream\n  - System.IO.TextReader\n  - System.IO.TextWriter\n  - System.IO.UnmanagedMemoryAccessor\n  - System.IO.Compression.ZipArchive\n  - System.IO.IsolatedStorage.IsolatedStorageFile\n  - System.IO.Log.FileRecordSequence\n  - System.IO.Log.IRecordSequence\n  - System.IO.Log.LogRecord\n  - System.IO.Log.LogRecordSequence\n  - System.IO.Log.LogStore\n  - System.IO.MemoryMappedFiles.MemoryMappedFile\n  - System.IO.Packaging.EncryptedPackageEnvelope\n  - System.IO.Packaging.Package\n  - System.IO.Packaging.PackageProperties\n  - System.Management.ManagementObjectCollection.ManagementObjectEnumerator\n  - System.Management.ManagementObjectCollection\n  - System.Messaging.Cursor\n  - System.Messaging.MessageEnumerator\n  - System.Messaging.MessageQueueEnumerator\n  - System.Messaging.MessageQueueTransaction\n  - System.Messaging.SecurityContext\n  - System.Net.HttpListener\n  - System.Net.HttpListenerResponse\n  - System.Net.HttpWebResponse\n  - System.Net.WebResponse\n  - System.Net.Http.HttpContent\n  - System.Net.Http.HttpMessageHandler\n  - System.Net.Http.HttpMessageInvoker\n  - System.Net.Http.HttpRequestMessage\n  - System.Net.Http.HttpResponseMessage\n  - System.Net.Mail.AlternateViewCollection\n  - System.Net.Mail.AttachmentBase\n  - System.Net.Mail.AttachmentCollection\n  - System.Net.Mail.LinkedResourceCollection\n  - System.Net.Mail.MailMessage\n  - System.Net.Mail.SmtpClient\n  - System.Net.NetworkInformation.Ping\n  - System.Net.PeerToPeer.PeerNameRegistration\n  - System.Net.PeerToPeer.Collaboration.ContactManager\n  - System.Net.PeerToPeer.Collaboration.Peer\n  - System.Net.PeerToPeer.Collaboration.PeerApplication\n  - System.Net.PeerToPeer.Collaboration.PeerEndPoint\n  - System.Net.PeerToPeer.Collaboration.PeerObject\n  - System.Net.Sockets.Socket\n  - System.Net.Sockets.SocketAsyncEventArgs\n  - System.Net.Sockets.TcpClient\n  - System.Net.Sockets.UdpAnySourceMulticastClient\n  - System.Net.Sockets.UdpClient\n  - System.Net.Sockets.UdpSingleSourceMulticastClient\n  - System.Net.WebSockets.ClientWebSocket\n  - System.Net.WebSockets.WebSocket\n  - System.Printing.PrintJobInfoCollection\n  - System.Printing.PrintQueueCollection\n  - System.Printing.PrintSystemObject\n  - System.Printing.PrintSystemObjectPropertiesChangedEventArgs\n  - System.Printing.PrintSystemObjectPropertyChangedEventArgs\n  - System.Printing.PrintSystemObjects\n  - System.Printing.IndexedProperties.PrintProperty\n  - System.Printing.IndexedProperties.PrintPropertyDictionary\n  - System.Printing.Interop.PrintTicketConverter\n  - System.Reflection.Metadata.MetadataReaderProvider\n  - System.Reflection.PortableExecutable.PEReader\n  - System.Resources.IResourceReader\n  - System.Resources.IResourceWriter\n  - System.Resources.ResourceSet\n  - System.Runtime.MemoryFailPoint\n  - System.Runtime.Caching.ChangeMonitor\n  - System.Runtime.Caching.MemoryCache\n  - System.Runtime.InteropServices.CriticalHandle\n  - System.Runtime.InteropServices.SafeHandle\n  - System.Security.SecureString\n  - System.Security.SecurityContext\n  - System.Security.Cryptography.AsymmetricAlgorithm\n  - System.Security.Cryptography.CngKey\n  - System.Security.Cryptography.DeriveBytes\n  - System.Security.Cryptography.ECDiffieHellmanPublicKey\n  - System.Security.Cryptography.ICryptoTransform\n  - System.Security.Cryptography.IncrementalHash\n  - System.Security.Cryptography.RandomNumberGenerator\n  - System.Security.Cryptography.SymmetricAlgorithm\n  - System.Security.Cryptography.X509Certificates.X509Certificate\n  - System.Security.Cryptography.X509Certificates.X509Chain\n  - System.Security.Cryptography.X509Certificates.X509Store\n  - System.Security.Principal.WindowsIdentity\n  - System.Security.Principal.WindowsImpersonationContext\n  - System.Security.RightsManagement.CryptoProvider\n  - System.Security.RightsManagement.SecureEnvironment\n  - System.ServiceModel.ChannelFactory\n  - System.ServiceModel.ClientBase`1.ChannelBase`1\n  - System.ServiceModel.ClientBase`1\n  - System.ServiceModel.IClientChannel\n  - System.ServiceModel.OperationContextScope\n  - System.ServiceModel.ServiceHostBase\n  - System.ServiceModel.Activities.SendMessageChannelCache\n  - System.ServiceModel.Channels.Message\n  - System.ServiceModel.Channels.MessageBuffer\n  - System.ServiceModel.Channels.MessageProperties\n  - System.ServiceModel.Channels.RequestContext\n  - System.ServiceModel.Discovery.AnnouncementClient\n  - System.ServiceModel.Discovery.DiscoveryClient\n  - System.ServiceModel.Dispatcher.XPathResult\n  - System.ServiceModel.Routing.RoutingService\n  - System.ServiceModel.Security.SecurityMessageProperty\n  - System.Speech.Recognition.RecognizerInfo\n  - System.Speech.Recognition.SpeechRecognitionEngine\n  - System.Speech.Recognition.SpeechRecognizer\n  - System.Speech.Synthesis.SpeechSynthesizer\n  - System.Threading.AsyncFlowControl\n  - System.Threading.Barrier\n  - System.Threading.CancellationTokenRegistration\n  - System.Threading.CancellationTokenSource\n  - System.Threading.CountdownEvent\n  - System.Threading.ExecutionContext\n  - System.Threading.HostExecutionContext\n  - System.Threading.ManualResetEventSlim\n  - System.Threading.PreAllocatedOverlapped\n  - System.Threading.ReaderWriterLockSlim\n  - System.Threading.SemaphoreSlim\n  - System.Threading.ThreadLocal`1\n  - System.Threading.ThreadPoolBoundHandle\n  - System.Threading.Timer\n  - System.Threading.WaitHandle\n  - System.Threading.Tasks.Task\n  - System.Transactions.CommittableTransaction\n  - System.Transactions.Transaction\n  - System.Transactions.TransactionScope\n  - System.Web.HttpApplication\n  - System.Web.XmlSiteMapProvider\n  - System.Web.Caching.CacheDependency\n  - System.Web.Caching.CacheStoreProvider\n  - System.Web.ClientServices.ClientFormsIdentity\n  - System.Web.Compilation.ClientBuildManager\n  - System.Web.Compilation.IAssemblyPostProcessor\n  - System.Web.Hosting.AspNetMemoryMonitor\n  - System.Web.Hosting.IApplicationMonitor\n  - System.Web.Security.PassportIdentity\n  - System.Web.UI.Control\n  - System.Web.UI.DataVisualization.Charting.ChartElement\n  - System.Web.UI.DataVisualization.Charting.ChartElementCollection`1\n  - System.Web.UI.DataVisualization.Charting.ChartElementOutline\n  - System.Web.UI.DataVisualization.Charting.Title\n  - System.Web.UI.Design.ITemplateEditingFrame\n  - System.Web.UI.Design.TemplateEditingService\n  - System.Web.UI.Design.TemplateEditingVerb\n  - System.Web.UI.Design.WebFormsRootDesigner\n  - System.Web.UI.WebControls.WebParts.WebPartTracker\n  - System.Windows.Annotations.Storage.AnnotationStore\n  - System.Windows.Controls.SoundPlayerAction\n  - System.Windows.Controls.Primitives.DocumentPageView\n  - System.Windows.Documents.DocumentPage\n  - System.Windows.Forms.ApplicationContext\n  - System.Windows.Forms.Control\n  - System.Windows.Forms.Cursor\n  - System.Windows.Forms.DataGridViewBand\n  - System.Windows.Forms.DataGridViewCell\n  - System.Windows.Forms.DataGridViewColumn\n  - System.Windows.Forms.HtmlHistory\n  - System.Windows.Forms.IBindableComponent\n  - System.Windows.Forms.ImageListStreamer\n  - System.Windows.Forms.PaintEventArgs\n  - System.Windows.Forms.ScrollableControl\n  - System.Windows.Forms.ToolStrip\n  - System.Windows.Forms.ToolStripItem\n  - System.Windows.Forms.ToolStripOverflow\n  - System.Windows.Forms.ToolStripPanel\n  - System.Windows.Forms.ToolStripPanelRow\n  - System.Windows.Forms.WebBrowserSiteBase\n  - System.Windows.Forms.WindowsFormsSynchronizationContext\n  - System.Windows.Forms.DataVisualization.Charting.AxisScrollBar\n  - System.Windows.Forms.DataVisualization.Charting.Chart\n  - System.Windows.Forms.DataVisualization.Charting.ChartElement\n  - System.Windows.Forms.DataVisualization.Charting.ChartElementCollection`1\n  - System.Windows.Forms.DataVisualization.Charting.ChartElementOutline\n  - System.Windows.Forms.DataVisualization.Charting.Cursor\n  - System.Windows.Forms.DataVisualization.Charting.PrintingManager\n  - System.Windows.Forms.DataVisualization.Charting.Title\n  - System.Windows.Forms.Design.ComponentDocumentDesigner\n  - System.Windows.Forms.Design.DocumentDesigner\n  - System.Windows.Forms.Design.Behavior.BehaviorService\n  - System.Windows.Ink.GestureRecognizer\n  - System.Windows.Input.Cursor\n  - System.Windows.Interop.HwndHost\n  - System.Windows.Interop.HwndSource\n  - System.Windows.Markup.Primitives.MarkupWriter\n  - System.Windows.Media.CompositionTarget\n  - System.Windows.Media.DrawingContext\n  - System.Windows.Media.StreamGeometryContext\n  - System.Windows.Media.TextFormatting.TextFormatter\n  - System.Windows.Media.TextFormatting.TextLine\n  - System.Windows.Media.TextFormatting.TextLineBreak\n  - System.Windows.Threading.DispatcherProcessingDisabled\n  - System.Windows.Xps.Packaging.XpsDocument\n  - System.Windows.Xps.Packaging.XpsResource\n  - System.Windows.Xps.Serialization.BasePackagingPolicy\n  - System.Windows.Xps.Serialization.PackageSerializationManager\n  - System.Workflow.Activities.ActiveDirectoryRole\n  - System.Workflow.ComponentModel.ActivityExecutionContext\n  - System.Workflow.ComponentModel.DependencyObject\n  - System.Workflow.ComponentModel.Compiler.TypeProvider\n  - System.Workflow.ComponentModel.Design.ActivityDesigner\n  - System.Workflow.ComponentModel.Design.Connector\n  - System.Workflow.ComponentModel.Design.DesignerTheme\n  - System.Workflow.ComponentModel.Design.IWorkflowRootDesigner\n  - System.Workflow.ComponentModel.Design.WorkflowDesignerMessageFilter\n  - System.Workflow.ComponentModel.Design.WorkflowTheme\n  - System.Workflow.Runtime.WorkflowRuntime\n  - System.Xaml.XamlReader\n  - System.Xaml.XamlWriter\n  - System.Xml.XmlNodeList\n  - System.Xml.XmlReader\n  - System.Xml.XmlWriter\n  implements: []\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/IDisposable.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.IDisposable.Dispose\n  commentId: M:System.IDisposable.Dispose\n  id: Dispose\n  parent: System.IDisposable\n  langs:\n  - csharp\n  name: Dispose()\n  nameWithType: IDisposable.Dispose()\n  fullName: IDisposable.Dispose()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources.\n  remarks: \"Use this method to close or release unmanaged resources such as files, streams, and handles held by an instance of the class that implements this interface. By convention, this method is used for all tasks associated with freeing resources held by an object, or preparing an object for reuse.  \\n  \\n> [!WARNING]\\n>  If you are using a class that implements the <xref:System.IDisposable> interface, you should call its <xref:System.IDisposable.Dispose%2A> implementation when you are finished using the class. For more information, see the \\\"Using an object that implements IDisposable\\\" section in the <xref:System.IDisposable> topic.  \\n  \\n When implementing this method, ensure that all held resources are freed by propagating the call through the containment hierarchy. For example, if an object A allocates an object B, and object B allocates an object C, then A's <xref:System.IDisposable.Dispose%2A> implementation must call <xref:System.IDisposable.Dispose%2A> on B, which must in turn call <xref:System.IDisposable.Dispose%2A> on C.  \\n  \\n> [!IMPORTANT]\\n>  The C++ compiler supports deterministic disposal of resources and does not allow direct implementation of the <xref:System.IDisposable.Dispose%2A> method.  \\n  \\n An object must also call the <xref:System.IDisposable.Dispose%2A> method of its base class if the base class implements <xref:System.IDisposable>. For more information about implementing <xref:System.IDisposable> on a base class and its subclasses, see the \\\"IDisposable and the inheritance hierarchy\\\" section in the <xref:System.IDisposable> topic.  \\n  \\n If an object's <xref:System.IDisposable.Dispose%2A> method is called more than once, the object must ignore all calls after the first one. The object must not throw an exception if its <xref:System.IDisposable.Dispose%2A> method is called multiple times. Instance methods other than <xref:System.IDisposable.Dispose%2A> can throw an <xref:System.ObjectDisposedException> when resources are already disposed.  \\n  \\n Users might expect a resource type to use a particular convention to denote an allocated state versus a freed state. An example of this is stream classes, which are traditionally thought of as open or closed. The implementer of a class that has such a convention might choose to implement a public method with a customized name, such as `Close`, that calls the <xref:System.IDisposable.Dispose%2A> method.  \\n  \\n Because the <xref:System.IDisposable.Dispose%2A> method must be called explicitly, there is always a danger that the unmanaged resources will not be released, because the consumer of an object fails to call its <xref:System.IDisposable.Dispose%2A> method. There are two ways to avoid this:  \\n  \\n-   Wrap the managed resource in an object derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName>. Your <xref:System.IDisposable.Dispose%2A> implementation then calls the <xref:System.IDisposable.Dispose%2A> method of the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName> instances. For more information, see \\\"The SafeHandle alternative\\\" section in the <xref:System.Object.Finalize%2A?displayProperty=fullName> topic.  \\n  \\n-   Implement a finalizer to free resources when <xref:System.IDisposable.Dispose%2A> is not called. By default, the garbage collector automatically calls an object's finalizer before reclaiming its memory. However, if the <xref:System.IDisposable.Dispose%2A> method has been called, it is typically unnecessary for the garbage collector to call the disposed object's finalizer. To prevent automatic finalization, <xref:System.IDisposable.Dispose%2A> implementations can call the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method.  \\n  \\n When you use an object that accesses unmanaged resources, such as a <xref:System.IO.StreamWriter>, a good practice is to create the instance with a `using` statement. The `using` statement automatically closes the stream and calls <xref:System.IDisposable.Dispose%2A> on the object when the code that is using it has completed. For an example, see the <xref:System.IO.StreamWriter> class.\"\n  example:\n  - \"The following example shows how you can implement the <xref:System.IDisposable.Dispose%2A> method.  \\n  \\n [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]\\n [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]\\n [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]\"\n  syntax:\n    content: public void Dispose ();\n    parameters: []\n  overload: System.IDisposable.Dispose*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/IDisposable.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.IDisposable.Dispose\n  parent: System.IDisposable\n  isExternal: false\n  name: Dispose()\n  nameWithType: IDisposable.Dispose()\n  fullName: IDisposable.Dispose()\n- uid: System.IDisposable.Dispose*\n  parent: System.IDisposable\n  isExternal: false\n  name: Dispose\n  nameWithType: IDisposable.Dispose\n  fullName: IDisposable.Dispose\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/IDisposable.xml\n"}