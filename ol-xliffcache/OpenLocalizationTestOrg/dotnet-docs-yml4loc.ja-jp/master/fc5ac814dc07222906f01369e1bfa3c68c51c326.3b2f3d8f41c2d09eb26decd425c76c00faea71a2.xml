{"nodes":[{"content":"Notifies a waiting thread that an event has occurred. This class cannot be inherited.","nodes":[{"pos":[0,85],"content":"Notifies a waiting thread that an event has occurred. This class cannot be inherited.","nodes":[{"content":"Notifies a waiting thread that an event has occurred. This class cannot be inherited.","pos":[0,85],"nodes":[{"content":"Notifies a waiting thread that an event has occurred.","pos":[0,53]},{"content":"This class cannot be inherited.","pos":[54,85]}]}]}],"pos":[450,536],"yaml":true},{"content":"`AutoResetEvent` allows threads to communicate with each other by signaling. Typically, you use this class when threads need exclusive access to a resource.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.  \n  \n A thread waits for a signal by calling <xref:System.Threading.WaitHandle.WaitOne%2A> on the `AutoResetEvent`. If the `AutoResetEvent` is in the non-signaled state, the thread blocks, waiting for the thread that currently controls the resource to signal that the resource is available by calling <xref:System.Threading.EventWaitHandle.Set%2A>.  \n  \n Calling `Set` signals `AutoResetEvent` to release a waiting thread. `AutoResetEvent` remains signaled until a single waiting thread is released, and then automatically returns to the non-signaled state. If no threads are waiting, the state remains signaled indefinitely.  \n  \n If a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A> while the <xref:System.Threading.AutoResetEvent> is in the signaled state, the thread does not block. The <xref:System.Threading.AutoResetEvent> releases the thread immediately and returns to the non-signaled state.  \n  \n> [!IMPORTANT]\n>  There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread. If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released. It is as if the second call did not happen. Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.AutoResetEvent> is already signaled, the call has no effect.  \n  \n You can control the initial state of an `AutoResetEvent` by passing a Boolean value to the constructor: `true` if the initial state is signaled and `false` otherwise.  \n  \n `AutoResetEvent` can also be used with the `static`<xref:System.Threading.WaitHandle.WaitAll%2A> and <xref:System.Threading.WaitHandle.WaitAny%2A> methods.  \n  \n For more information about thread synchronization mechanisms, see [AutoResetEvent](~/docs/standard/threading/autoresetevent.md) in the conceptual documentation.  \n  \n Beginning with the .NET Framework version 2.0, <xref:System.Threading.AutoResetEvent> derives from the new <xref:System.Threading.EventWaitHandle> class. An <xref:System.Threading.AutoResetEvent> is functionally equivalent to an <xref:System.Threading.EventWaitHandle> created with <xref:System.Threading.EventResetMode?displayProperty=fullName>.  \n  \n> [!NOTE]\n>  Unlike the <xref:System.Threading.AutoResetEvent> class, the <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.","nodes":[{"pos":[0,156],"content":"`AutoResetEvent` allows threads to communicate with each other by signaling. Typically, you use this class when threads need exclusive access to a resource.","nodes":[{"content":"<ph id=\"ph1\">`AutoResetEvent`</ph> allows threads to communicate with each other by signaling.","pos":[0,76],"source":"`AutoResetEvent` allows threads to communicate with each other by signaling."},{"content":"Typically, you use this class when threads need exclusive access to a resource.","pos":[77,156]}]},{"pos":[164,690],"content":"[!IMPORTANT]\n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.","leadings":["","> "],"nodes":[{"content":" This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.","pos":[13,524],"nodes":[{"content":"This type implements the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface.","pos":[1,62],"source":" This type implements the <xref:System.IDisposable> interface."},{"content":"When you have finished using the type, you should dispose of it either directly or indirectly.","pos":[63,157]},{"content":"To dispose of the type directly, call its <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id=\"ph2\">`try`</ph><ph id=\"ph3\">/</ph><ph id=\"ph4\">`catch`</ph> block.","pos":[158,269],"source":" To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block."},{"content":"To dispose of it indirectly, use a language construct such as <ph id=\"ph1\">`using`</ph> (in C#) or <ph id=\"ph2\">`Using`</ph> (in Visual Basic).","pos":[270,377],"source":" To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic)."},{"content":"For more information, see the \"Using an Object that Implements IDisposable\" section in the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface topic.","pos":[378,511],"source":" For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic."}]}]},{"pos":[697,1039],"content":"A thread waits for a signal by calling <xref:System.Threading.WaitHandle.WaitOne%2A> on the `AutoResetEvent`. If the `AutoResetEvent` is in the non-signaled state, the thread blocks, waiting for the thread that currently controls the resource to signal that the resource is available by calling <xref:System.Threading.EventWaitHandle.Set%2A>.","nodes":[{"content":"A thread waits for a signal by calling <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> on the <ph id=\"ph2\">`AutoResetEvent`</ph>.","pos":[0,109],"source":"A thread waits for a signal by calling <xref:System.Threading.WaitHandle.WaitOne%2A> on the `AutoResetEvent`."},{"content":"If the <ph id=\"ph1\">`AutoResetEvent`</ph> is in the non-signaled state, the thread blocks, waiting for the thread that currently controls the resource to signal that the resource is available by calling <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph>.","pos":[110,342],"source":" If the `AutoResetEvent` is in the non-signaled state, the thread blocks, waiting for the thread that currently controls the resource to signal that the resource is available by calling <xref:System.Threading.EventWaitHandle.Set%2A>."}]},{"pos":[1046,1316],"content":"Calling `Set` signals `AutoResetEvent` to release a waiting thread. `AutoResetEvent` remains signaled until a single waiting thread is released, and then automatically returns to the non-signaled state. If no threads are waiting, the state remains signaled indefinitely.","nodes":[{"content":"Calling <ph id=\"ph1\">`Set`</ph> signals <ph id=\"ph2\">`AutoResetEvent`</ph> to release a waiting thread.","pos":[0,67],"source":"Calling `Set` signals `AutoResetEvent` to release a waiting thread."},{"content":"<ph id=\"ph1\">`AutoResetEvent`</ph> remains signaled until a single waiting thread is released, and then automatically returns to the non-signaled state.","pos":[68,202],"source":"`AutoResetEvent` remains signaled until a single waiting thread is released, and then automatically returns to the non-signaled state."},{"content":"If no threads are waiting, the state remains signaled indefinitely.","pos":[203,270]}]},{"pos":[1323,1602],"content":"If a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A> while the <xref:System.Threading.AutoResetEvent> is in the signaled state, the thread does not block. The <xref:System.Threading.AutoResetEvent> releases the thread immediately and returns to the non-signaled state.","nodes":[{"content":"If a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A> while the <xref:System.Threading.AutoResetEvent> is in the signaled state, the thread does not block. The <xref:System.Threading.AutoResetEvent> releases the thread immediately and returns to the non-signaled state.","pos":[0,279],"nodes":[{"content":"If a thread calls <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> while the <ph id=\"ph2\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> is in the signaled state, the thread does not block.","pos":[0,165],"source":"If a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A> while the <xref:System.Threading.AutoResetEvent> is in the signaled state, the thread does not block."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> releases the thread immediately and returns to the non-signaled state.","pos":[166,279],"source":" The <xref:System.Threading.AutoResetEvent> releases the thread immediately and returns to the non-signaled state."}]}]},{"pos":[1610,2115],"content":"[!IMPORTANT]\n There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread. If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released. It is as if the second call did not happen. Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.AutoResetEvent> is already signaled, the call has no effect.","leadings":["","> "],"nodes":[{"content":" There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread. If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released. It is as if the second call did not happen. Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.AutoResetEvent> is already signaled, the call has no effect.","pos":[13,503],"nodes":[{"content":"There is no guarantee that every call to the <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> method will release a thread.","pos":[1,122],"source":" There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread."},{"content":"If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released.","pos":[123,254]},{"content":"It is as if the second call did not happen.","pos":[255,298]},{"content":"Also, if <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle.Set%2A&gt;</ph> is called when there are no threads waiting and the <ph id=\"ph2\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> is already signaled, the call has no effect.","pos":[299,490],"source":" Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.AutoResetEvent> is already signaled, the call has no effect."}]}]},{"pos":[2122,2288],"content":"You can control the initial state of an <ph id=\"ph1\">`AutoResetEvent`</ph> by passing a Boolean value to the constructor: <ph id=\"ph2\">`true`</ph> if the initial state is signaled and <ph id=\"ph3\">`false`</ph> otherwise.","source":"You can control the initial state of an `AutoResetEvent` by passing a Boolean value to the constructor: `true` if the initial state is signaled and `false` otherwise."},{"pos":[2295,2450],"content":"<ph id=\"ph1\">`AutoResetEvent`</ph> can also be used with the <ph id=\"ph2\">`static`</ph><ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> methods.","source":"`AutoResetEvent` can also be used with the `static`<xref:System.Threading.WaitHandle.WaitAll%2A> and <xref:System.Threading.WaitHandle.WaitAny%2A> methods."},{"pos":[2457,2617],"content":"For more information about thread synchronization mechanisms, see <bpt id=\"p1\">[</bpt>AutoResetEvent<ept id=\"p1\">](~/docs/standard/threading/autoresetevent.md)</ept> in the conceptual documentation.","source":"For more information about thread synchronization mechanisms, see [AutoResetEvent](~/docs/standard/threading/autoresetevent.md) in the conceptual documentation."},{"pos":[2624,2970],"content":"Beginning with the .NET Framework version 2.0, <xref:System.Threading.AutoResetEvent> derives from the new <xref:System.Threading.EventWaitHandle> class. An <xref:System.Threading.AutoResetEvent> is functionally equivalent to an <xref:System.Threading.EventWaitHandle> created with <xref:System.Threading.EventResetMode?displayProperty=fullName>.","nodes":[{"content":"Beginning with the .NET Framework version 2.0, <xref:System.Threading.AutoResetEvent> derives from the new <xref:System.Threading.EventWaitHandle> class. An <xref:System.Threading.AutoResetEvent> is functionally equivalent to an <xref:System.Threading.EventWaitHandle> created with <xref:System.Threading.EventResetMode?displayProperty=fullName>.","pos":[0,346],"nodes":[{"content":"Beginning with the .NET Framework version 2.0, <ph id=\"ph1\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> derives from the new <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class.","pos":[0,153],"source":"Beginning with the .NET Framework version 2.0, <xref:System.Threading.AutoResetEvent> derives from the new <xref:System.Threading.EventWaitHandle> class."},{"content":"An <ph id=\"ph1\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> is functionally equivalent to an <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> created with <ph id=\"ph3\">&lt;xref:System.Threading.EventResetMode?displayProperty=fullName&gt;</ph>.","pos":[154,346],"source":" An <xref:System.Threading.AutoResetEvent> is functionally equivalent to an <xref:System.Threading.EventWaitHandle> created with <xref:System.Threading.EventResetMode?displayProperty=fullName>."}]}]},{"pos":[2978,3151],"content":"[!NOTE]\n Unlike the <xref:System.Threading.AutoResetEvent> class, the <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.","leadings":["","> "],"nodes":[{"content":"Unlike the <ph id=\"ph1\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> class, the <ph id=\"ph2\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class provides access to named system synchronization events.","pos":[9,171],"source":" Unlike the <xref:System.Threading.AutoResetEvent> class, the <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events."}]}],"pos":[547,3726],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Threading.AutoResetEvent\"></xref> class with a Boolean value indicating whether to set the initial state to signaled.","nodes":[{"pos":[0,170],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.AutoResetEvent\"&gt;&lt;/xref&gt;</ph> class with a Boolean value indicating whether to set the initial state to signaled.","source":"Initializes a new instance of the <xref href=\"System.Threading.AutoResetEvent\"></xref> class with a Boolean value indicating whether to set the initial state to signaled."}],"pos":[10472,10643],"yaml":true},{"content":"`true` to set the initial state to signaled; `false` to set the initial state to non-signaled.","nodes":[{"pos":[0,94],"content":"<ph id=\"ph1\">`true`</ph> to set the initial state to signaled; <ph id=\"ph2\">`false`</ph> to set the initial state to non-signaled.","source":"`true` to set the initial state to signaled; `false` to set the initial state to non-signaled."}],"pos":[12599,12696],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.AutoResetEvent\n  commentId: T:System.Threading.AutoResetEvent\n  id: AutoResetEvent\n  children:\n  - System.Threading.AutoResetEvent.#ctor(System.Boolean)\n  langs:\n  - csharp\n  name: AutoResetEvent\n  nameWithType: AutoResetEvent\n  fullName: System.Threading.AutoResetEvent\n  type: Class\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Notifies a waiting thread that an event has occurred. This class cannot be inherited.\n  remarks: \"`AutoResetEvent` allows threads to communicate with each other by signaling. Typically, you use this class when threads need exclusive access to a resource.  \\n  \\n> [!IMPORTANT]\\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \\\"Using an Object that Implements IDisposable\\\" section in the <xref:System.IDisposable> interface topic.  \\n  \\n A thread waits for a signal by calling <xref:System.Threading.WaitHandle.WaitOne%2A> on the `AutoResetEvent`. If the `AutoResetEvent` is in the non-signaled state, the thread blocks, waiting for the thread that currently controls the resource to signal that the resource is available by calling <xref:System.Threading.EventWaitHandle.Set%2A>.  \\n  \\n Calling `Set` signals `AutoResetEvent` to release a waiting thread. `AutoResetEvent` remains signaled until a single waiting thread is released, and then automatically returns to the non-signaled state. If no threads are waiting, the state remains signaled indefinitely.  \\n  \\n If a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A> while the <xref:System.Threading.AutoResetEvent> is in the signaled state, the thread does not block. The <xref:System.Threading.AutoResetEvent> releases the thread immediately and returns to the non-signaled state.  \\n  \\n> [!IMPORTANT]\\n>  There is no guarantee that every call to the <xref:System.Threading.EventWaitHandle.Set%2A> method will release a thread. If two calls are too close together, so that the second call occurs before a thread has been released, only one thread is released. It is as if the second call did not happen. Also, if <xref:System.Threading.EventWaitHandle.Set%2A> is called when there are no threads waiting and the <xref:System.Threading.AutoResetEvent> is already signaled, the call has no effect.  \\n  \\n You can control the initial state of an `AutoResetEvent` by passing a Boolean value to the constructor: `true` if the initial state is signaled and `false` otherwise.  \\n  \\n `AutoResetEvent` can also be used with the `static`<xref:System.Threading.WaitHandle.WaitAll%2A> and <xref:System.Threading.WaitHandle.WaitAny%2A> methods.  \\n  \\n For more information about thread synchronization mechanisms, see [AutoResetEvent](~/docs/standard/threading/autoresetevent.md) in the conceptual documentation.  \\n  \\n Beginning with the .NET Framework version 2.0, <xref:System.Threading.AutoResetEvent> derives from the new <xref:System.Threading.EventWaitHandle> class. An <xref:System.Threading.AutoResetEvent> is functionally equivalent to an <xref:System.Threading.EventWaitHandle> created with <xref:System.Threading.EventResetMode?displayProperty=fullName>.  \\n  \\n> [!NOTE]\\n>  Unlike the <xref:System.Threading.AutoResetEvent> class, the <xref:System.Threading.EventWaitHandle> class provides access to named system synchronization events.\"\n  example:\n  - \"The following example shows how to use <xref:System.Threading.AutoResetEvent> to release one thread at a time, by calling the <xref:System.Threading.EventWaitHandle.Set%2A> method (on the base class) each time the user presses the **Enter** key. The example starts three threads, which wait on an <xref:System.Threading.AutoResetEvent> that was created in the signaled state. The first thread is released immediately, because the <xref:System.Threading.AutoResetEvent> is already in the signaled state. This resets the <xref:System.Threading.AutoResetEvent> to the non-signaled state, so that subsequent threads block. The blocked threads are not released until the user releases them one at a time by pressing the **Enter** key.  \\n  \\n After the threads are released from the first <xref:System.Threading.AutoResetEvent>, they wait on another <xref:System.Threading.AutoResetEvent> that was created in the non-signaled state. All three threads block, so the <xref:System.Threading.EventWaitHandle.Set%2A> method must be called three times to release them all.  \\n  \\n [!code-cpp[System.Threading.AutoResetEvent#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CPP/simplerisbetter.cpp#3)]\\n [!code-csharp[System.Threading.AutoResetEvent#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CS/simplerisbetter.cs#3)]\\n [!code-vb[System.Threading.AutoResetEvent#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/VB/simplerisbetter.vb#3)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public sealed class AutoResetEvent : System.Threading.EventWaitHandle\n  inheritance:\n  - System.Object\n  - System.Threading.WaitHandle\n  - System.Threading.EventWaitHandle\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  - System.Threading.EventWaitHandle.GetAccessControl\n  - System.Threading.EventWaitHandle.OpenExisting(System.String)\n  - System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)\n  - System.Threading.EventWaitHandle.Reset\n  - System.Threading.EventWaitHandle.Set\n  - System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)\n  - System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)\n  - System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)\n  - System.Threading.WaitHandle.Close\n  - System.Threading.WaitHandle.Dispose\n  - System.Threading.WaitHandle.Dispose(System.Boolean)\n  - System.Threading.WaitHandle.Handle\n  - System.Threading.WaitHandle.InvalidHandle\n  - System.Threading.WaitHandle.SafeWaitHandle\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitOne\n  - System.Threading.WaitHandle.WaitOne(System.Int32)\n  - System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitOne(System.TimeSpan)\n  - System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitTimeout\n  extensionMethods:\n  - System.Threading.ThreadingAclExtensions.GetAccessControl(System.Threading.EventWaitHandle)\n  - System.Threading.ThreadingAclExtensions.SetAccessControl(System.Threading.EventWaitHandle,System.Security.AccessControl.EventWaitHandleSecurity)\n  - System.Threading.WaitHandleExtensions.GetSafeWaitHandle(System.Threading.WaitHandle)\n  - System.Threading.WaitHandleExtensions.SetSafeWaitHandle(System.Threading.WaitHandle,Microsoft.Win32.SafeHandles.SafeWaitHandle)\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/AutoResetEvent.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.AutoResetEvent.#ctor(System.Boolean)\n  commentId: M:System.Threading.AutoResetEvent.#ctor(System.Boolean)\n  id: '#ctor(System.Boolean)'\n  parent: System.Threading.AutoResetEvent\n  langs:\n  - csharp\n  name: AutoResetEvent(Boolean)\n  nameWithType: AutoResetEvent.AutoResetEvent(Boolean)\n  fullName: AutoResetEvent.AutoResetEvent(Boolean)\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.AutoResetEvent\"></xref> class with a Boolean value indicating whether to set the initial state to signaled.\n  remarks: ''\n  example:\n  - \"The following example uses an <xref:System.Threading.AutoResetEvent> to synchronize the activities of two threads. The first thread, which is the application thread, executes `Main`. It writes values to the protected resource, which is a `static` (`Shared` in Visual Basic) field named `number`. The second thread executes the static `ThreadProc` method, which reads the values written by `Main`.  \\n  \\n The `ThreadProc` method waits for the <xref:System.Threading.AutoResetEvent>. When `Main` calls the <xref:System.Threading.EventWaitHandle.Set%2A> method on the <xref:System.Threading.AutoResetEvent>, the `ThreadProc` method reads one value. The <xref:System.Threading.AutoResetEvent> immediately resets, so the `ThreadProc` method waits again.  \\n  \\n The program logic guarantees that the `ThreadProc` method will never read the same value two times. It does not guarantee that the `ThreadProc` method will read every value written by `Main`. That guarantee would require a second <xref:System.Threading.AutoResetEvent> lock.  \\n  \\n After each write operation, `Main` yields by calling the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method, to give the second thread a chance to execute. Otherwise, on a single-processor computer `Main` would write many values between any two read operations.  \\n  \\n [!code-cpp[System.Threading.AutoResetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CPP/class1.cpp#1)]\\n [!code-csharp[System.Threading.AutoResetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/CS/class1.cs#1)]\\n [!code-vb[System.Threading.AutoResetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.AutoResetEvent/VB/class1.vb#1)]\"\n  syntax:\n    content: public AutoResetEvent (bool initialState);\n    parameters:\n    - id: initialState\n      type: System.Boolean\n      description: '`true` to set the initial state to signaled; `false` to set the initial state to non-signaled.'\n  overload: System.Threading.AutoResetEvent.#ctor*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/AutoResetEvent.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Threading.EventWaitHandle\n  parent: System.Threading\n  isExternal: false\n  name: EventWaitHandle\n  nameWithType: EventWaitHandle\n  fullName: System.Threading.EventWaitHandle\n- uid: System.Threading.AutoResetEvent.#ctor(System.Boolean)\n  parent: System.Threading.AutoResetEvent\n  isExternal: false\n  name: AutoResetEvent(Boolean)\n  nameWithType: AutoResetEvent.AutoResetEvent(Boolean)\n  fullName: AutoResetEvent.AutoResetEvent(Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Threading.AutoResetEvent.#ctor*\n  parent: System.Threading.AutoResetEvent\n  isExternal: false\n  name: AutoResetEvent\n  nameWithType: AutoResetEvent.AutoResetEvent\n  fullName: AutoResetEvent.AutoResetEvent\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/AutoResetEvent.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.Threading.WaitHandle.Close\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Close()\n  nameWithType: WaitHandle.Close()\n  fullName: WaitHandle.Close()\n- uid: System.Threading.WaitHandle.Dispose\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Dispose()\n  nameWithType: WaitHandle.Dispose()\n  fullName: WaitHandle.Dispose()\n- uid: System.Threading.WaitHandle.Dispose(System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Dispose(Boolean)\n  nameWithType: WaitHandle.Dispose(Boolean)\n  fullName: WaitHandle.Dispose(Boolean)\n- uid: System.Threading.WaitHandle.Handle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Handle\n  nameWithType: WaitHandle.Handle\n  fullName: WaitHandle.Handle\n- uid: System.Threading.WaitHandle.InvalidHandle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: InvalidHandle\n  nameWithType: WaitHandle.InvalidHandle\n  fullName: WaitHandle.InvalidHandle\n- uid: System.Threading.WaitHandle.SafeWaitHandle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SafeWaitHandle\n  nameWithType: WaitHandle.SafeWaitHandle\n  fullName: WaitHandle.SafeWaitHandle\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle)\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], TimeSpan, Boolean)\n  fullName: WaitHandle.WaitAll(WaitHandle[], TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], Int32, Boolean)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], Int32, Boolean)\n  fullName: WaitHandle.WaitAll(WaitHandle[], Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], TimeSpan)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], TimeSpan)\n  fullName: WaitHandle.WaitAll(WaitHandle[], TimeSpan)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], Int32)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], Int32)\n  fullName: WaitHandle.WaitAll(WaitHandle[], Int32)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[])\n  nameWithType: WaitHandle.WaitAll(WaitHandle[])\n  fullName: WaitHandle.WaitAll(WaitHandle[])\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[])\n  nameWithType: WaitHandle.WaitAny(WaitHandle[])\n  fullName: WaitHandle.WaitAny(WaitHandle[])\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], Int32)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], Int32)\n  fullName: WaitHandle.WaitAny(WaitHandle[], Int32)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], TimeSpan)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], TimeSpan)\n  fullName: WaitHandle.WaitAny(WaitHandle[], TimeSpan)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], Int32, Boolean)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], Int32, Boolean)\n  fullName: WaitHandle.WaitAny(WaitHandle[], Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], TimeSpan, Boolean)\n  fullName: WaitHandle.WaitAny(WaitHandle[], TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitOne\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne()\n  nameWithType: WaitHandle.WaitOne()\n  fullName: WaitHandle.WaitOne()\n- uid: System.Threading.WaitHandle.WaitOne(System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(Int32)\n  nameWithType: WaitHandle.WaitOne(Int32)\n  fullName: WaitHandle.WaitOne(Int32)\n- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(TimeSpan)\n  nameWithType: WaitHandle.WaitOne(TimeSpan)\n  fullName: WaitHandle.WaitOne(TimeSpan)\n- uid: System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(Int32, Boolean)\n  nameWithType: WaitHandle.WaitOne(Int32, Boolean)\n  fullName: WaitHandle.WaitOne(Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitOne(TimeSpan, Boolean)\n  fullName: WaitHandle.WaitOne(TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitTimeout\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitTimeout\n  nameWithType: WaitHandle.WaitTimeout\n  fullName: WaitHandle.WaitTimeout\n- uid: System.Threading.EventWaitHandle.GetAccessControl\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: GetAccessControl()\n  nameWithType: EventWaitHandle.GetAccessControl()\n  fullName: EventWaitHandle.GetAccessControl()\n- uid: System.Threading.EventWaitHandle.OpenExisting(System.String)\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: OpenExisting(String)\n  nameWithType: EventWaitHandle.OpenExisting(String)\n  fullName: EventWaitHandle.OpenExisting(String)\n- uid: System.Threading.EventWaitHandle.OpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights)\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: OpenExisting(String, EventWaitHandleRights)\n  nameWithType: EventWaitHandle.OpenExisting(String, EventWaitHandleRights)\n  fullName: EventWaitHandle.OpenExisting(String, EventWaitHandleRights)\n- uid: System.Threading.EventWaitHandle.Reset\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: Reset()\n  nameWithType: EventWaitHandle.Reset()\n  fullName: EventWaitHandle.Reset()\n- uid: System.Threading.EventWaitHandle.Set\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: Set()\n  nameWithType: EventWaitHandle.Set()\n  fullName: EventWaitHandle.Set()\n- uid: System.Threading.EventWaitHandle.SetAccessControl(System.Security.AccessControl.EventWaitHandleSecurity)\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: SetAccessControl(EventWaitHandleSecurity)\n  nameWithType: EventWaitHandle.SetAccessControl(EventWaitHandleSecurity)\n  fullName: EventWaitHandle.SetAccessControl(EventWaitHandleSecurity)\n- uid: System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Threading.EventWaitHandle@)\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: TryOpenExisting(String, EventWaitHandle)\n  nameWithType: EventWaitHandle.TryOpenExisting(String, EventWaitHandle)\n  fullName: EventWaitHandle.TryOpenExisting(String, EventWaitHandle)\n- uid: System.Threading.EventWaitHandle.TryOpenExisting(System.String,System.Security.AccessControl.EventWaitHandleRights,System.Threading.EventWaitHandle@)\n  parent: System.Threading.EventWaitHandle\n  isExternal: false\n  name: TryOpenExisting(String, EventWaitHandleRights, EventWaitHandle)\n  nameWithType: EventWaitHandle.TryOpenExisting(String, EventWaitHandleRights, EventWaitHandle)\n  fullName: EventWaitHandle.TryOpenExisting(String, EventWaitHandleRights, EventWaitHandle)\n- uid: System.Threading.ThreadingAclExtensions.GetAccessControl(System.Threading.EventWaitHandle)\n  parent: System.Threading.ThreadingAclExtensions\n  isExternal: false\n  name: GetAccessControl(EventWaitHandle)\n  nameWithType: ThreadingAclExtensions.GetAccessControl(EventWaitHandle)\n  fullName: ThreadingAclExtensions.GetAccessControl(EventWaitHandle)\n- uid: System.Threading.ThreadingAclExtensions.SetAccessControl(System.Threading.EventWaitHandle,System.Security.AccessControl.EventWaitHandleSecurity)\n  parent: System.Threading.ThreadingAclExtensions\n  isExternal: false\n  name: SetAccessControl(EventWaitHandle, EventWaitHandleSecurity)\n  nameWithType: ThreadingAclExtensions.SetAccessControl(EventWaitHandle, EventWaitHandleSecurity)\n  fullName: ThreadingAclExtensions.SetAccessControl(EventWaitHandle, EventWaitHandleSecurity)\n- uid: System.Threading.WaitHandleExtensions.GetSafeWaitHandle(System.Threading.WaitHandle)\n  parent: System.Threading.WaitHandleExtensions\n  isExternal: false\n  name: GetSafeWaitHandle(WaitHandle)\n  nameWithType: WaitHandleExtensions.GetSafeWaitHandle(WaitHandle)\n  fullName: WaitHandleExtensions.GetSafeWaitHandle(WaitHandle)\n- uid: System.Threading.WaitHandleExtensions.SetSafeWaitHandle(System.Threading.WaitHandle,Microsoft.Win32.SafeHandles.SafeWaitHandle)\n  parent: System.Threading.WaitHandleExtensions\n  isExternal: false\n  name: SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n  nameWithType: WaitHandleExtensions.SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n  fullName: WaitHandleExtensions.SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n"}