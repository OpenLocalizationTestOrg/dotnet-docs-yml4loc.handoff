{"nodes":[{"content":"Provides a template for a method that is called whenever a dependency property value is being re-evaluated, or coercion is specifically requested.","nodes":[{"pos":[0,146],"content":"Provides a template for a method that is called whenever a dependency property value is being re-evaluated, or coercion is specifically requested.","nodes":[{"content":"Provides a template for a method that is called whenever a dependency property value is being re-evaluated, or coercion is specifically requested.","pos":[0,146]}]}],"pos":[371,518],"yaml":true},{"content":"Callbacks based on <xref:System.Windows.CoerceValueCallback> can be assigned to a dependency property through several different techniques. Each of these techniques requires that you first create a new property metadata object (<xref:System.Windows.PropertyMetadata>, or a derived class such as <xref:System.Windows.FrameworkPropertyMetadata>). Create the metadata object using a constructor signature that takes the `coerceValueCallback` parameter, and assign that parameter to your callback handler. Or construct the metadata by any signature and set the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> property prior to putting the metadata in use.  \n  \n When you have this metadata, you can:  \n  \n-   Define a new dependency property on a new class, using either signature of  <xref:System.Windows.DependencyProperty.Register%2A>, giving the metadata as the `typeMetadata` value.  \n  \n-   Override the metadata (call <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) for an existing dependency property, when you derive from the class that owns the dependency property.  \n  \n-   Add an existing dependency property to a new <xref:System.Windows.DependencyObject> class, using new metadata, by calling <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  \n  \n Implementations of this callback should check the value in `baseValue` and determine based on either the value or the type whether this is a value that needs to be further coerced.  \n  \n The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for a dependency property is invoked any time that the property system or any other caller calls <xref:System.Windows.DependencyObject.CoerceValue%2A> on a <xref:System.Windows.DependencyObject> instance, specifying that property's identifier as the `dp`.  \n  \n Changes to the property value may have come from any possible participant in the property system. This includes styles, generic invalidation, triggers, property value inheritance, and local value setting.  \n  \n Generally you should avoid specifying more than one <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>). Only one of the callbacks will be able to act. The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <xref:System.Windows.DependencyObject> caller. Other callbacks as assigned to metadata for the dependency property as it existed higher in the owner hierarchy are replaced when the metadata is overridden.","nodes":[{"pos":[0,665],"content":"Callbacks based on <xref:System.Windows.CoerceValueCallback> can be assigned to a dependency property through several different techniques. Each of these techniques requires that you first create a new property metadata object (<xref:System.Windows.PropertyMetadata>, or a derived class such as <xref:System.Windows.FrameworkPropertyMetadata>). Create the metadata object using a constructor signature that takes the `coerceValueCallback` parameter, and assign that parameter to your callback handler. Or construct the metadata by any signature and set the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> property prior to putting the metadata in use.","nodes":[{"content":"Callbacks based on <ph id=\"ph1\">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> can be assigned to a dependency property through several different techniques.","pos":[0,139],"source":"Callbacks based on <xref:System.Windows.CoerceValueCallback> can be assigned to a dependency property through several different techniques."},{"content":"Each of these techniques requires that you first create a new property metadata object (<ph id=\"ph1\">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>, or a derived class such as <ph id=\"ph2\">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>).","pos":[140,344],"source":" Each of these techniques requires that you first create a new property metadata object (<xref:System.Windows.PropertyMetadata>, or a derived class such as <xref:System.Windows.FrameworkPropertyMetadata>)."},{"content":"Create the metadata object using a constructor signature that takes the <ph id=\"ph1\">`coerceValueCallback`</ph> parameter, and assign that parameter to your callback handler.","pos":[345,501],"source":" Create the metadata object using a constructor signature that takes the `coerceValueCallback` parameter, and assign that parameter to your callback handler."},{"content":"Or construct the metadata by any signature and set the <ph id=\"ph1\">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> property prior to putting the metadata in use.","pos":[502,665],"source":" Or construct the metadata by any signature and set the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> property prior to putting the metadata in use."}]},{"pos":[672,709],"content":"When you have this metadata, you can:","nodes":[{"content":"When you have this metadata, you can:","pos":[0,37]}]},{"pos":[719,897],"content":"Define a new dependency property on a new class, using either signature of  <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, giving the metadata as the <ph id=\"ph2\">`typeMetadata`</ph> value.","source":"Define a new dependency property on a new class, using either signature of  <xref:System.Windows.DependencyProperty.Register%2A>, giving the metadata as the `typeMetadata` value."},{"pos":[907,1147],"content":"Override the metadata (call <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) for an existing dependency property, when you derive from the class that owns the dependency property.","nodes":[{"content":"Override the metadata (call <ph id=\"ph1\">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>) for an existing dependency property, when you derive from the class that owns the dependency property.","pos":[0,240],"source":"Override the metadata (call <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) for an existing dependency property, when you derive from the class that owns the dependency property."}]},{"pos":[1157,1380],"content":"Add an existing dependency property to a new <xref:System.Windows.DependencyObject> class, using new metadata, by calling <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>.","nodes":[{"content":"Add an existing dependency property to a new <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph> class, using new metadata, by calling <ph id=\"ph2\">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.","pos":[0,223],"source":"Add an existing dependency property to a new <xref:System.Windows.DependencyObject> class, using new metadata, by calling <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>."}]},{"pos":[1387,1567],"content":"Implementations of this callback should check the value in <ph id=\"ph1\">`baseValue`</ph> and determine based on either the value or the type whether this is a value that needs to be further coerced.","source":"Implementations of this callback should check the value in `baseValue` and determine based on either the value or the type whether this is a value that needs to be further coerced."},{"pos":[1574,1895],"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> for a dependency property is invoked any time that the property system or any other caller calls <ph id=\"ph2\">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph> on a <ph id=\"ph3\">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance, specifying that property's identifier as the <ph id=\"ph4\">`dp`</ph>.","source":"The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for a dependency property is invoked any time that the property system or any other caller calls <xref:System.Windows.DependencyObject.CoerceValue%2A> on a <xref:System.Windows.DependencyObject> instance, specifying that property's identifier as the `dp`."},{"pos":[1902,2106],"content":"Changes to the property value may have come from any possible participant in the property system. This includes styles, generic invalidation, triggers, property value inheritance, and local value setting.","nodes":[{"content":"Changes to the property value may have come from any possible participant in the property system. This includes styles, generic invalidation, triggers, property value inheritance, and local value setting.","pos":[0,204],"nodes":[{"content":"Changes to the property value may have come from any possible participant in the property system.","pos":[0,97]},{"content":"This includes styles, generic invalidation, triggers, property value inheritance, and local value setting.","pos":[98,204]}]}]},{"pos":[2113,2778],"content":"Generally you should avoid specifying more than one <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>). Only one of the callbacks will be able to act. The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <xref:System.Windows.DependencyObject> caller. Other callbacks as assigned to metadata for the dependency property as it existed higher in the owner hierarchy are replaced when the metadata is overridden.","nodes":[{"content":"Generally you should avoid specifying more than one <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>). Only one of the callbacks will be able to act. The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <xref:System.Windows.DependencyObject> caller. Other callbacks as assigned to metadata for the dependency property as it existed higher in the owner hierarchy are replaced when the metadata is overridden.","pos":[0,665],"nodes":[{"content":"Generally you should avoid specifying more than one <ph id=\"ph1\">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <ph id=\"ph2\">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>).","pos":[0,296],"source":"Generally you should avoid specifying more than one <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>)."},{"content":"Only one of the callbacks will be able to act.","pos":[297,343]},{"content":"The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <ph id=\"ph1\">&lt;xref:System.Windows.DependencyObject&gt;</ph> caller.","pos":[344,507],"source":" The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <xref:System.Windows.DependencyObject> caller."},{"content":"Other callbacks as assigned to metadata for the dependency property as it existed higher in the owner hierarchy are replaced when the metadata is overridden.","pos":[508,665]}]}]}],"pos":[529,3326],"yaml":true,"extradata":"MT"}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Windows.CoerceValueCallback\n  commentId: T:System.Windows.CoerceValueCallback\n  id: CoerceValueCallback\n  langs:\n  - csharp\n  name: CoerceValueCallback\n  nameWithType: CoerceValueCallback\n  fullName: System.Windows.CoerceValueCallback\n  type: Delegate\n  assemblies:\n  - WindowsBase\n  namespace: System.Windows\n  summary: Provides a template for a method that is called whenever a dependency property value is being re-evaluated, or coercion is specifically requested.\n  remarks: \"Callbacks based on <xref:System.Windows.CoerceValueCallback> can be assigned to a dependency property through several different techniques. Each of these techniques requires that you first create a new property metadata object (<xref:System.Windows.PropertyMetadata>, or a derived class such as <xref:System.Windows.FrameworkPropertyMetadata>). Create the metadata object using a constructor signature that takes the `coerceValueCallback` parameter, and assign that parameter to your callback handler. Or construct the metadata by any signature and set the <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> property prior to putting the metadata in use.  \\n  \\n When you have this metadata, you can:  \\n  \\n-   Define a new dependency property on a new class, using either signature of  <xref:System.Windows.DependencyProperty.Register%2A>, giving the metadata as the `typeMetadata` value.  \\n  \\n-   Override the metadata (call <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>) for an existing dependency property, when you derive from the class that owns the dependency property.  \\n  \\n-   Add an existing dependency property to a new <xref:System.Windows.DependencyObject> class, using new metadata, by calling <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  \\n  \\n Implementations of this callback should check the value in `baseValue` and determine based on either the value or the type whether this is a value that needs to be further coerced.  \\n  \\n The <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for a dependency property is invoked any time that the property system or any other caller calls <xref:System.Windows.DependencyObject.CoerceValue%2A> on a <xref:System.Windows.DependencyObject> instance, specifying that property's identifier as the `dp`.  \\n  \\n Changes to the property value may have come from any possible participant in the property system. This includes styles, generic invalidation, triggers, property value inheritance, and local value setting.  \\n  \\n Generally you should avoid specifying more than one <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>). Only one of the callbacks will be able to act. The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <xref:System.Windows.DependencyObject> caller. Other callbacks as assigned to metadata for the dependency property as it existed higher in the owner hierarchy are replaced when the metadata is overridden.\"\n  example:\n  - \"The following example includes an implementation of this callback to coerce the stored value of a dependency property based on other inputs, such as another property's value. In this case, the callback checks to see whether the `ShirtType` property corresponds to a type of shirt that has buttons; if so it establishes a starting default color for the `ButtonColor`, if the shirt type has no buttons, it coerces the `ButtonColor` value back to a starting value, which causes the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] (not shown) to remove that dropdown from the effective choices.  \\n  \\n [!code-csharp[DPCustom#CoerceValueCallback](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCustom/CSharp/default.xaml.cs#coercevaluecallback)]\\n [!code-vb[DPCustom#CoerceValueCallback](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCustom/visualbasic/default.xaml.vb#coercevaluecallback)]\"\n  syntax:\n    content: public delegate object CoerceValueCallback(DependencyObject d, object baseValue);\n  inheritance:\n  - System.Object\n  - System.Delegate\n  extensionMethods:\n  - System.Reflection.RuntimeReflectionExtensions.GetMethodInfo(System.Delegate)\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows/CoerceValueCallback.xml\n  ms.technology:\n  - dotnet-wpf\n  ms.author: kempb\n  manager: ghogen\nreferences:\n- uid: System.Delegate\n  parent: System\n  isExternal: false\n  name: Delegate\n  nameWithType: Delegate\n  fullName: System.Delegate\n- uid: System.Reflection.RuntimeReflectionExtensions.GetMethodInfo(System.Delegate)\n  parent: System.Reflection.RuntimeReflectionExtensions\n  isExternal: false\n  name: GetMethodInfo(Delegate)\n  nameWithType: RuntimeReflectionExtensions.GetMethodInfo(Delegate)\n  fullName: RuntimeReflectionExtensions.GetMethodInfo(Delegate)\n"}