<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">077eb53d2f7ab322fca3b6683a351e16f4871988</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Object.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">85b8c992743d785030922b1a0348797c4373c163</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0dc62929b93679b522ae2c837c28854e07a87c81</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>To view the .NET Framework source code for this type, see the <bpt id="p1">[</bpt>Reference Source<ept id="p1">](http://referencesource.microsoft.com/#mscorlib/system/object.cs#d9262ceecc1719ab)</ept>.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id="p1">[</bpt>instructions<ept id="p1">](http://referencesource.microsoft.com/)</ept>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>Languages typically do not require a class to declare inheritance from <ph id="ph1">&lt;xref:System.Object&gt;</ph> because the inheritance is implicit.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because all classes in the .NET Framework are derived from <ph id="ph1">&lt;xref:System.Object&gt;</ph>, every method defined in the <ph id="ph2">&lt;xref:System.Object&gt;</ph> class is available in all objects in the system.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>Derived classes can and do override some of these methods, including:</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> - Supports comparisons between objects.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> - Performs cleanup operations before an object is automatically reclaimed.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> - Generates a number corresponding to the value of the object to support the use of a hash table.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> - Manufactures a human-readable text string that describes an instance of the class.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>Performance Considerations</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the process of boxing and unboxing a type carries a performance cost.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>Create a general method that accepts an <ph id="ph1">&lt;xref:System.Object&gt;</ph> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>Design your type and its members to use generics.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>The generic method is type-specific and can be invoked without boxing the calling parameter.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although it is sometimes necessary to develop general purpose classes that accept and return <ph id="ph1">&lt;xref:System.Object&gt;</ph> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Determines whether the specified object is equal to the current object.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type of comparison between the current instance and the <ph id="ph1">`obj`</ph> parameter depends on whether the current instance is a reference type or a value type.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current instance is a reference type, the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method tests for reference equality, and a call to the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method is equivalent to a call to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reference equality means that the object variables that are compared refer to the same object.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates the result of such a comparison.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>It defines a <ph id="ph1">`Person`</ph> class, which is a reference type, and calls the <ph id="ph2">`Person`</ph> class constructor to instantiate two new <ph id="ph3">`Person`</ph> objects, <ph id="ph4">`person1a`</ph> and <ph id="ph5">`person2`</ph>, which have the same value.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>It also assigns <ph id="ph1">`person1a`</ph> to another object variable, <ph id="ph2">`person1b`</ph>.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the output from the example shows, <ph id="ph1">`person1a`</ph> and <ph id="ph2">`person1b`</ph> are equal because they reference the same object.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">`person1a`</ph> and <ph id="ph2">`person2`</ph> are not equal, although they have the same value.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.Equals#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.Equals#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current instance is a value type, the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method tests for value equality.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value equality means the following:</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>The two objects are of the same type.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the following example shows, a <ph id="ph1">&lt;xref:System.Byte&gt;</ph> object that has a value of 12 does not equal an <ph id="ph2">&lt;xref:System.Int32&gt;</ph> object that has a value of 12, because the two objects have different run-time types.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.Equals#3<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.Equals#3<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>The values of the public and private fields of the two objects are equal.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example tests for value equality.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>It defines a <ph id="ph1">`Person`</ph> structure, which is a value type, and calls the <ph id="ph2">`Person`</ph> class constructor to instantiate two new <ph id="ph3">`Person`</ph> objects, <ph id="ph4">`person1`</ph> and <ph id="ph5">`person2`</ph>, which have the same value.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>As the output from the example shows, although the two object variables refer to different objects, <ph id="ph1">`person1`</ph> and <ph id="ph2">`person2`</ph> are equal because they have the same value for the private <ph id="ph3">`personName`</ph> field.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.Equals#4<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.Equals#4<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the <ph id="ph1">&lt;xref:System.Object&gt;</ph> class is the base class for all types in the .NET Framework, the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method provides the default equality comparison for all other types.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, types often override the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method to implement value equality.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the Notes for Callers and Notes for Inheritors sections.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method overload on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and currently don’t implement an <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>method.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, they appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> [!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method overload.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>Notes for Callers</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>Derived classes frequently override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method to implement value equality.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, types also frequently provide an additional strongly typed overload to the <ph id="ph1">`Equals`</ph> method, typically by implementing the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you call the <ph id="ph1">`Equals`</ph> method to test for equality, you should know whether the current instance overrides <ph id="ph2">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph> and understand how a particular call to an <ph id="ph3">`Equals`</ph> method is resolved.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example provides an illustration.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>It instantiates three <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects with identical strings, and then makes four calls to <ph id="ph2">`Equals`</ph> methods.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT">
          <source>The first method call returns <ph id="ph1">`true`</ph>, and the remaining three return <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.Equals#5<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.Equals#5<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the first case, the strongly typed <ph id="ph1">&lt;xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=fullName&gt;</ph> method overload, which tests for value equality, is called.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the strings assigned to the two <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects are equal, the method returns <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> does not override <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because of this, when the <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> object is cast to an <ph id="ph2">&lt;xref:System.Object&gt;</ph>, when a <ph id="ph3">&lt;xref:System.Text.StringBuilder&gt;</ph> instance is assigned to a variable of type <ph id="ph4">&lt;xref:System.Object&gt;</ph>, and when the <ph id="ph5">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=fullName&gt;</ph> method is passed two <ph id="ph6">&lt;xref:System.Text.StringBuilder&gt;</ph> objects, the default <ph id="ph7">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method is called.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> is a reference type, this is equivalent to passing the two <ph id="ph2">&lt;xref:System.Text.StringBuilder&gt;</ph> objects to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although all three <ph id="ph1">&lt;xref:System.Text.StringBuilder&gt;</ph> objects contain identical strings, they refer to three distinct objects.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>As a result, these three method calls return <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can compare the current object to another object for reference equality by calling the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>In Visual Basic, you can also use the <ph id="ph1">`is`</ph> keyword (for example, <ph id="ph2">`If Me Is otherObject Then ...`</ph>).</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>Notes for Inheritors</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you define your own type, that type inherits the functionality defined by the <ph id="ph1">`Equals`</ph> method of its base type.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the default implementation of the <ph id="ph1">`Equals`</ph> method for the major categories of types in the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type category</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>Equality defined by</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>Comments</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>Class derived directly from <ph id="ph1">&lt;xref:System.Object&gt;</ph></source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reference equality; equivalent to calling <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>Structure</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumeration</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>Values must have the same enumeration type and the same underlying value.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delegate</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delegates must have the same type with identical invocation lists.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>Interface</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reference equality.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a value type, you should always override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, because tests for equality that rely on reflection offer poor performance.</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also override the default implementation of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>Such implementations of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> return <ph id="ph2">`true`</ph> if the two objects have the same value, even if they are not the same instance.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the value of a <ph id="ph1">&lt;xref:System.String&gt;</ph> object is based on the characters of the string; the <ph id="ph2">&lt;xref:System.String.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method overrides the <ph id="ph3">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method to return <ph id="ph4">`true`</ph> for any two string instances that contain the same characters in the same order.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example shows how to override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method to test for value equality.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method for the <ph id="ph2">`Person`</ph> class.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`Person`</ph> accepted its base class implementation of equality, two <ph id="ph2">`Person`</ph> objects would be equal only if they referenced a single object.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, in this case, two <ph id="ph1">`Person`</ph> objects are equal if they have the same value for the <ph id="ph2">`Person.Id`</ph> property.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.Equals#6<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.Equals#6<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition to overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>, you can implement the <ph id="ph2">&lt;xref:System.IEquatable%601&gt;</ph> interface to provide a strongly typed test for equality.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following statements must be true for all implementations of the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the list, <ph id="ph1">`x`</ph>, <ph id="ph2">`y`</ph>, and <ph id="ph3">`z`</ph> represent object references that are not <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`x.Equals(x)`</ph> returns <ph id="ph2">`true`</ph>, except in cases that involve floating-point types.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`x.Equals(y)`</ph> returns the same value as <ph id="ph2">`y.Equals(x)`</ph>.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`x.Equals(y)`</ph> returns <ph id="ph2">`true`</ph> if both <ph id="ph3">`x`</ph> and <ph id="ph4">`y`</ph> are <ph id="ph5">`NaN`</ph>.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`(x.Equals(y) &amp;&amp; y.Equals(z))`</ph> returns <ph id="ph2">`true`</ph>, then <ph id="ph3">`x.Equals(z)`</ph> returns <ph id="ph4">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT">
          <source>Successive calls to <ph id="ph1">`x.Equals(y)`</ph> return the same value as long as the objects referenced by <ph id="ph2">`x`</ph> and <ph id="ph3">`y`</ph> are not modified.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`x.Equals(null)`</ph> returns <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>Implementations of <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> must not throw exceptions; they should always return a value.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if <ph id="ph1">`obj`</ph> is <ph id="ph2">`null`</ph>, the <ph id="ph3">&lt;xref:System.Object.Equals%2A&gt;</ph> method should return <ph id="ph4">`false`</ph> instead of throwing an <ph id="ph5">&lt;xref:System.ArgumentNullException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>Follow these guidelines when overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>:</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>Types that implement <ph id="ph1">&lt;xref:System.IComparable&gt;</ph> must override <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>Types that override <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> must also override <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>; otherwise, hash tables  might not work correctly.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should consider implementing the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface to support strongly typed tests for equality.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT">
          <source>Your <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=fullName&gt;</ph> implementation should return results that are consistent with <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> method to return the same result as the equality operator.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT">
          <source>This  helps ensure that class library code that uses <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> (such as <ph id="ph2">&lt;xref:System.Collections.ArrayList&gt;</ph> and <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph>) behaves in a manner that is consistent with the way the equality operator is used by application code.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT">
          <source>Guidelines for Reference Types</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following guidelines apply to overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> for a reference type:</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>Consider overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> if the semantics of the type are based on the fact that the type represents some value(s).</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most reference types must not overload the equality operator, even if they override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should not override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> on a mutable reference type.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is because overriding <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> requires that you also override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, as discussed in the previous section.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT">
          <source>Guidelines for Value Types</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following guidelines apply to overriding <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> for a value type:</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are defining a value type that includes one or more fields whose values are reference types, you should override <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph> implementation provided by <ph id="ph2">&lt;xref:System.ValueType&gt;</ph> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you override <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> and your development language supports operator overloading, you must overload the equality operator.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should implement the <ph id="ph1">&lt;xref:System.IEquatable%601&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling the strongly typed <ph id="ph1">&lt;xref:System.IEquatable%601.Equals%2A?displayProperty=fullName&gt;</ph> method avoids boxing the <ph id="ph2">`obj`</ph> argument.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The object to compare with the current object.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the specified object  is equal to the current object; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Determines whether the specified object instances are considered equal.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>The static <ph id="ph1">&lt;xref:System.Object.Equals%28System.Object%2CSystem.Object%29&gt;</ph> method indicates whether two objects, <ph id="ph2">`objA`</ph> and  <ph id="ph3">`objB`</ph>, are equal.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>It also enables you to test objects whose value is <bpt id="p1">**</bpt>null<ept id="p1">**</ept> for equality.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>It compares <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> for equality as follows:</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>It determines whether the two objects represent the same object reference.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>If they do, the method returns <ph id="ph1">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>This test is equivalent to calling the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, if both <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, the method returns <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>It determines whether either <ph id="ph1">`objA`</ph> or <ph id="ph2">`objB`</ph> is <bpt id="p1">**</bpt>null<ept id="p1">**</ept>.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>If so, it returns <ph id="ph1">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the two objects do not represent the same object reference and neither is <bpt id="p1">**</bpt>null<ept id="p1">**</ept>, it calls <ph id="ph1">`objA`</ph>.<ph id="ph2">`Equals`</ph>(<ph id="ph3">`objB`</ph>) and returns the result.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that if <ph id="ph1">`objA`</ph> overrides the <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29?displayProperty=fullName&gt;</ph> method, this override is called.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The first object to compare.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>The second object to compare.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the objects are considered equal; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>If both <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">objA</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">objB</ph><ept id="p2">&lt;/code&gt;</ept> are <bpt id="p3">**</bpt>null<ept id="p3">**</ept>, the method returns <ph id="ph3">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT">
          <source>The method is protected and therefore is accessible only through this class or through a derived class.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this section:</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>How finalization works<ept id="p1">](#How)</ept></source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>Notes for implementers<ept id="p1">](#Notes)</ept></source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The SafeHandle alternative<ept id="p1">](#SafeHandle)</ept></source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT">
          <source>How finalization works</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Object&gt;</ph> class provides no implementation for the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, and the garbage collector does not mark types derived from <ph id="ph3">&lt;xref:System.Object&gt;</ph> for finalization unless they override the <ph id="ph4">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a type does override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT">
          <source>The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT">
          <source>The garbage collector then calls the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method automatically under the following conditions:</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT">
          <source>After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <ph id="ph1">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT">
          <source>During shutdown of an application domain, unless the object is exempt from finalization.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT">
          <source>During shutdown, even objects that are still accessible are finalized.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <ph id="ph2">&lt;xref:System.GC.ReRegisterForFinalize%2A?displayProperty=fullName&gt;</ph> and the <ph id="ph3">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=fullName&gt;</ph> method has not been subsequently called.</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> operations have the following limitations:</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT">
          <source>The exact time when the finalizer executes is undefined.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT">
          <source>To ensure deterministic release of resources for instances of your class, implement a <ph id="ph1">`Close`</ph> method or provide a <ph id="ph2">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT">
          <source>The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT">
          <source>The thread on which the finalizer runs is unspecified.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method might not run to completion or might not run at all under the following exceptional circumstances:</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT">
          <source>If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the process terminates without giving the runtime a chance to clean up.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> or an override of <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active <ph id="ph3">`try`</ph><ph id="ph4">/</ph><ph id="ph5">`finally`</ph> blocks or finalizers are executed.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>This behavior ensures process integrity if the finalizer cannot free or destroy resources.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>Notes for implementers</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should override <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> for a class that uses unmanaged resources such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see <bpt id="p1">[</bpt>The SafeHandle alternative<ept id="p1">](#SafeHandle)</ept> section.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method does nothing by default, but you should override <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> only if necessary, and only to release unmanaged resources.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition, you should override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method for reference types only.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime only finalizes reference types.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT">
          <source>It ignores finalizers on value types.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>Every implementation of <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> in a derived type must call its base type's implementation of <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is the only case in which application code is allowed to call <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT">
          <source>The C# compiler does not allow you to override the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, you provide a finalizer by implementing a <bpt id="p1">[</bpt>destructor<ept id="p1">](~/docs/csharp/programming-guide/classes-and-structs/destructors.md)</ept> for your class.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>A C# destructor automatically calls the destructor of its base class.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>Visual C++ also provides its own syntax for implementing the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the "Destructors and finalizers" section of <bpt id="p1">[</bpt>How to: Define and Consume Classes and Structs (C++/CLI)<ept id="p1">](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7)</ept>.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>To release resources immediately, you can also choose to implement the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> and the <ph id="ph1">&lt;xref:System.IDisposable&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method to free unmanaged resources in the event that the <ph id="ph3">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method is not called.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the object can only be resurrected once; <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> cannot be called on resurrected objects during garbage collection.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT">
          <source>There is one action that your implementation of <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> should never take: it should never throw an exception.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>The SafeHandle alternative</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <ph id="ph1">&lt;xref:System.OutOfMemoryException&gt;</ph> and <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> terminate the finalizer.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <ph id="ph1">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName&gt;</ph> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework provides the following classes in the <ph id="ph1">&lt;xref:Microsoft.Win32?displayProperty=fullName&gt;</ph> namespace that are derived from <ph id="ph2">&lt;xref:System.Runtime.InteropServices.SafeHandle?displayProperty=fullName&gt;</ph>:</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> is a wrapper class for a file handle.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> is a wrapper class for memory-mapped file handles.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> is a wrapper class for a pointer to a block of unmanaged memory.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph>, <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>, and <ph id="ph3">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph> are wrapper classes for cryptographic handles.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> is a wrapper class for pipe handles.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> is a wrapper class for a handle to a registry key.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> is a wrapper class for a wait handle.</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses the <bpt id="p1">[</bpt>dispose pattern<ept id="p1">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept> with safe handles instead of overriding the <ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT">
          <source>It defines a <ph id="ph1">`FileAssociation`</ph> class that wraps registry information about the application that handles files with a particular file extension.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT">
          <source>The two registry handles returned as <ph id="ph1">`out`</ph> parameters by Windows <bpt id="p1">[</bpt>RegOpenKeyEx<ept id="p1">](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx)</ept> function calls are passed to the <ph id="ph2">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> constructor.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source>The type's protected <ph id="ph1">`Dispose`</ph> method then calls the <ph id="ph2">`SafeRegistryHandle.Dispose`</ph> method  to free these two handles.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.Finalize#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.Finalize#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve">
          <source>Serves as the default hash function.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <ph id="ph1">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> class, the <ph id="ph2">&lt;xref:System.Collections.Hashtable&gt;</ph> class, or a type derived from the <ph id="ph3">&lt;xref:System.Collections.DictionaryBase&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method provides this hash code for algorithms that need quick checks of object equality.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the <bpt id="p1">[</bpt>Hash Function<ept id="p1">](http://en.wikipedia.org/wiki/Hash_function)</ept> entry in Wikipedia.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two objects that are equal return hash codes that are equal.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>Furthermore, the .NET Framework does not guarantee the default implementation of the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms.</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>Two consequences follow from this:</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should not assume that equal hash codes imply object equality.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>A hash code is not a permanent value.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>For this reason:</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not serialize hash code values or store them in databases.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use the hash code as the key to retrieve an object from a keyed collection.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not send hash codes across application domains or processes.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT">
          <source>In some cases, hash codes may be computed on a per-process or per-application domain basis.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>For cryptographic hashes, use a class derived from the <ph id="ph1">&lt;xref:System.Security.Cryptography.HashAlgorithm?displayProperty=fullName&gt;</ph> or <ph id="ph2">&lt;xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=fullName&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>Do not test for equality of hash codes to determine whether two objects are equal.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>(Unequal objects can have identical hash codes.) To test for equality, call the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method can be overridden by a derived type.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> is not overridden, hash codes for reference types are computed by calling the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> method of the base class, which computes a hash code based on an object's reference; for more information, see <ph id="ph3">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>In other words, two objects for which the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> have identical hash codes.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>If value types do not override <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.ValueType.GetHashCode%2A?displayProperty=fullName&gt;</ph> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT">
          <source>In other words, value types whose fields have equal values have equal hash codes.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about overriding <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, see the "Notes to Inheritors" section.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you override the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method, you should also override <ph id="ph2">&lt;xref:System.Object.Equals%2A&gt;</ph>, and vice versa.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>If your overridden <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method returns <ph id="ph2">`true`</ph> when two objects are tested for equality, your overridden <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method must return the same value for the two objects.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT">
          <source>If an object that is used as a key in a hash table does not provide a useful implementation of <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>, you can specify a hash code provider by supplying an <ph id="ph2">&lt;xref:System.Collections.IEqualityComparer&gt;</ph> implementation to one of the overloads of the <ph id="ph3">&lt;xref:System.Collections.Hashtable&gt;</ph> class constructor.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and currently don’t implement a <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, they appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> [!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source>A hash code for the current object.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Gets the <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> of the current instance.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because <ph id="ph1">&lt;xref:System.Object?displayProperty=fullName&gt;</ph> is the base class for all types in the .NET Framework type system, the <ph id="ph2">&lt;xref:System.Object.GetType%2A&gt;</ph> method can be used to return <ph id="ph3">&lt;xref:System.Type&gt;</ph> objects that represent all .NET Framework types.</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>The .NET Framework recognizes the following five categories of types:</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes, which are derived from <ph id="ph1">&lt;xref:System.Object?displayProperty=fullName&gt;</ph>,</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>Value types, which are derived from <ph id="ph1">&lt;xref:System.ValueType?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>Interfaces, which are derived from <ph id="ph1">&lt;xref:System.Object?displayProperty=fullName&gt;</ph> starting with the .NET Framework 2.0.</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumerations, which are derived from <ph id="ph1">&lt;xref:System.Enum?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delegates, which are derived from <ph id="ph1">&lt;xref:System.MulticastDelegate?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>For two objects <ph id="ph1">`x`</ph> and <ph id="ph2">`y`</ph> that have identical runtime types, <ph id="ph3">`Object.ReferenceEquals(x.GetType(),y.GetType())`</ph> returns <ph id="ph4">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method with the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method to determine whether one numeric value is the same type as two other numeric values.</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.GetType#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.GetType#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, you can use the <ph id="ph1">`TypeOf…Is`</ph> construct in Visual Basic or the <ph id="ph2">`is`</ph> keyword in C#.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method is inherited by all types that derive from <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that, in addition to using your own language's comparison keyword, you can use the <ph id="ph1">&lt;xref:System.Object.GetType%2A&gt;</ph> method to determine the type of a particular object, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.GetType#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.GetType#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type&gt;</ph> object exposes the metadata associated with the class of the current <ph id="ph2">&lt;xref:System.Object&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve">
          <source>The exact runtime type of the current instance.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve">
          <source>Creates a shallow copy of the current <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a field is a value type, a bit-by-bit copy of the field is performed.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method does not meet your needs.</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>These include the following:</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>This assumes that the values of an object are entirely defined by its class constructor.</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.Object.MemberwiseClone%2A&gt;</ph> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">`DeepCopy`</ph> method in the example illustrates this approach.</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use reflection with recursion to perform the deep copy operation.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve">
          <source>A shallow copy of the current <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve">
          <source>Determines whether the specified <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph> instances are the same instance.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>Unlike the <ph id="ph1">&lt;xref:System.Object.Equals%2A&gt;</ph> method and the equality operator, the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method cannot be overridden.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because of this, if you want to test two object references for equality and you are unsure about the implementation of the <ph id="ph1">`Equals`</ph> method, you can call the <ph id="ph2">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the return value of the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method may appear to be anomalous in these two scenarios:</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>When comparing value types.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are value types, they are boxed before they are passed to the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT">
          <source>This means that if both <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> represent the same instance of a value type, the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method nevertheless returns <ph id="ph4">`false`</ph>, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.ReferenceEquals#1<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.ReferenceEquals#1<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information on boxing value types, see <bpt id="p1">[</bpt>Boxing and Unboxing<ept id="p1">](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>When comparing strings.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`objA`</ph> and <ph id="ph2">`objB`</ph> are strings, the <ph id="ph3">&lt;xref:System.Object.ReferenceEquals%2A&gt;</ph> method returns <ph id="ph4">`true`</ph> if the string is interned.</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>It does not perform a test for value equality.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>In the following example, <ph id="ph1">`s1`</ph> and <ph id="ph2">`s2`</ph> are equal because they are two instances of a single interned string.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, <ph id="ph1">`s3`</ph> and <ph id="ph2">`s4`</ph> are not equal, because although they are have identical string values, that string is not interned.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.ReferenceEquals#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.ReferenceEquals#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about string interning, see <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve">
          <source>The first object to compare.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve">
          <source>The second object  to compare.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">objA</ph><ept id="p1">&lt;/code&gt;</ept> is the same instance as <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">objB</ph><ept id="p2">&lt;/code&gt;</ept> or if both are <bpt id="p3">**</bpt>null<ept id="p3">**</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve">
          <source>Returns a string that represents the current object.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> is the major formatting method in the .NET Framework.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT">
          <source>It converts an object to its string representation so that it is suitable for display.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>(For information about formatting support in the .NET Framework, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.) Default implementations of the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method return the fully qualified name of the object's type.</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT">
          <source>You may have reached this page by following the link from the member list of another type.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is because that type does not override <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, it inherits the functionality of the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT">
          <source>Types frequently override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method to provide a more suitable string representation of a particular type.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT">
          <source>Types also frequently overload the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method to provide support for format strings or culture-sensitive formatting.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>In this section:</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>The default Object.ToString() method<ept id="p1">](#Default)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Overriding the Object.ToString() method<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Overloading the ToString method<ept id="p1">](#Overloading)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Extending the Object.ToString method<ept id="p1">](#Extending)</ept><ph id="ph1"> </ph></source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1"> [</bpt>Notes for the Windows Runtime<ept id="p1">](#WinRT)</ept></source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default Object.ToString() method</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT">
          <source>The default implementation of the <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method returns the fully qualified name of the type of the <ph id="ph2">&lt;xref:System.Object&gt;</ph>, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Object.ToString#1<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.Object.ToString#1<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Object.ToString#1<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because <ph id="ph1">&lt;xref:System.Object&gt;</ph> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example illustrates this.</source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT">
          <source>It defines a class named <ph id="ph1">`Object1`</ph> that accepts the default implementation of all <ph id="ph2">&lt;xref:System.Object&gt;</ph> members.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT">
          <source>Its <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method returns the object's fully qualified type name.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Object.ToString#2<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.Object.ToString#2<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Object.ToString#2<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT">
          <source>Overriding the Object.ToString() method</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT">
          <source>Types commonly override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method to return a string that represents the object instance.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the base types such as <ph id="ph1">&lt;xref:System.Char&gt;</ph>, <ph id="ph2">&lt;xref:System.Int32&gt;</ph>, and <ph id="ph3">&lt;xref:System.String&gt;</ph> provide <ph id="ph4">&lt;xref:System.Object.ToString%2A&gt;</ph> implementations that return the string form of the value that the object represents.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example defines a class, <ph id="ph1">`Object2`</ph>, that overrides the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method to return the type name along with its value.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-cpp</bpt><bpt id="p2">[</bpt>System.Object.ToString#3<ept id="p2">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-csharp</bpt><bpt id="p4">[</bpt>System.Object.ToString#3<ept id="p4">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)</ept><ept id="p3">]</ept> <bpt id="p5">[!code-vb</bpt><bpt id="p6">[</bpt>System.Object.ToString#3<ept id="p6">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)</ept><ept id="p5">]</ept></source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following table lists the type categories in the .NET Framework and indicates whether or not they override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT">
          <source>Type category</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT">
          <source>Overrides Object.ToString()</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT">
          <source>Behavior</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT">
          <source>Class</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT">
          <source>n/a</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT">
          <source>n/a</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT">
          <source>Structure</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes (<ph id="ph1">&lt;xref:System.ValueType.ToString%2A?displayProperty=fullName&gt;</ph>)</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source>Same as Object.ToString()</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT">
          <source>Enumeration</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT">
          <source>Yes (<ph id="ph1">&lt;xref:System.Enum.ToString?displayProperty=fullName&gt;</ph>)</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT">
          <source>The member name</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT">
          <source>Interface</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT">
          <source>n/a</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT">
          <source>Delegate</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT">
          <source>No</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source>n/a</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the Notes to Inheritors section for additional information on overriding <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT">
          <source>Overloading the ToString method</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT">
          <source>In addition to overriding the parameterless <ph id="ph1">&lt;xref:System.Object.ToString?displayProperty=fullName&gt;</ph> method, many types overload the <ph id="ph2">`ToString`</ph> method to provide versions of the method that accept parameters.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example overloads the <ph id="ph1">`ToString`</ph> method to return a result string that includes the value of various fields of an <ph id="ph2">`Automobile`</ph> class.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT">
          <source>It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.ToString#4<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.ToString#4<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example calls the overloaded <ph id="ph1">&lt;xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=fullName&gt;</ph> method to display culture-sensitive formatting of a currency value.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.ToString#5<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.ToString#5<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information on format strings and culture-sensitive formatting, see <bpt id="p1">[</bpt>Formatting Types<ept id="p1">](~/docs/standard/base-types/formatting-types.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the format strings supported by numeric values, see <bpt id="p1">[</bpt>Standard Numeric Format Strings<ept id="p1">](~/docs/standard/base-types/standard-numeric-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Numeric Format Strings<ept id="p2">](~/docs/standard/base-types/custom-numeric-format-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT">
          <source>For the format strings supported by date and time values, see <bpt id="p1">[</bpt>Standard Date and Time Format Strings<ept id="p1">](~/docs/standard/base-types/standard-date-and-time-format-strings.md)</ept> and <bpt id="p2">[</bpt>Custom Date and Time Format Strings<ept id="p2">](~/docs/standard/base-types/custom-date-and-time-format-strings.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT">
          <source>Extending the Object.ToString method</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because a type inherits the default <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method, you may find its behavior undesirable and want to change it.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is particularly true of arrays and collection classes.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>While you may expect the <ph id="ph1">`ToString`</ph> method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.ToString#6<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.ToString#6<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT">
          <source>You have several options to produce the result string that you'd like.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the type is an array, a collection object, or an object that implements the <ph id="ph1">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id="ph2">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph> interfaces, you can enumerate its elements by using the <ph id="ph3">`foreach`</ph> statement in C# or the <ph id="ph4">`For Each...Next`</ph> construct in Visual Basic.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the class is not <ph id="ph1">`sealed`</ph> (in C#) or <ph id="ph2">`NotInheritable`</ph> (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method you want to customize.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT">
          <source>At a minimum, this requires that you do the following:</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT">
          <source>Implement any necessary constructors.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT">
          <source>Derived classes do not inherit their base class constructors.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT">
          <source>Override the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method to return the result string that you'd like.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example defines a wrapper class for the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method to display the value of each method of the collection rather than the fully qualified type name.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.ToString#7<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.ToString#7<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT">
          <source>Develop an <bpt id="p1">[</bpt>extension method<ept id="p1">](~/docs/standard/design-guidelines/extension-methods.md)</ept> that returns the result string that you want.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that you can't override the default <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named <ph id="ph2">`ToString`</ph> that is called in place of the original type's <ph id="ph3">`ToString`</ph> method.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>You'll have to provide some other name for your parameterless <ph id="ph1">`ToString`</ph> replacement.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example defines two methods that extend the <ph id="ph1">&lt;xref:System.Collections.Generic.List%601&gt;</ph> class: a parameterless <ph id="ph2">`ToString2`</ph> method, and a <ph id="ph3">`ToString`</ph> method with a <ph id="ph4">&lt;xref:System.String&gt;</ph> parameter that represents a format string.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>System.Object.ToString#8<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)</ept><ept id="p1">]</ept>  <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>System.Object.ToString#8<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT">
          <source>Notes for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph></source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT">
          <source>When you call the <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph> method on a class in the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, it provides the default behavior for classes that don’t override <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is part of the support that the .NET Framework provides for the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> (see <bpt id="p1">[</bpt>.NET Framework Support for Windows Store Apps and Windows Runtime<ept id="p1">](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)</ept>).</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT">
          <source>Classes in the <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> don’t inherit <ph id="ph2">&lt;xref:System.Object&gt;</ph>, and don’t always implement a <ph id="ph3">&lt;xref:System.Object.ToString%2A&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, they always appear to have <ph id="ph1">&lt;xref:System.Object.ToString%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Object.Equals%28System.Object%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A&gt;</ph> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, the common language runtime will use <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> on a <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> object before falling back to the default implementation of <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1"> [!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> classes that are written in C# or Visual Basic can override the <ph id="ph2">&lt;xref:System.Object.ToString%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> and the IStringable Interface</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with <ph id="ph1">[!INCLUDE[win81](~/includes/win81-md.md)]</ph>, the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> includes an <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interface whose single method, <bpt id="p2">[</bpt>IStringable.ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept>, provides basic formatting support comparable to that provided by <ph id="ph3">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>To prevent ambiguity, you should not implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> on managed types.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT">
          <source>When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime will automatically route calls from <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> to <ph id="ph1">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> in the event <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> is not implemented on the managed object.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because the common language runtime auto-implements <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> for all managed types in <ph id="ph1">[!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)]</ph> apps, we recommend that you do not provide your own <bpt id="p2">[</bpt>IStringable<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementation.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>Implementing <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> may result in unintended behavior when calling <ph id="ph1">`ToString`</ph> from the <ph id="ph2">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph>, C++/CX, or JavaScript.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you do choose to implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> in a public managed type that is exported in a <ph id="ph1">[!INCLUDE[wrt](~/includes/wrt-md.md)]</ph> component, the following restrictions apply:</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can define the <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> interface only in a "class implements" relationship, such as</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source>in C#, or</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>in Visual Basic.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot implement <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> on an interface.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot declare a parameter to be of type <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept>.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> cannot be the return type of a method, property, or field.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>You cannot hide your <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> implementation from base classes by using a method definition such as the following:</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, the <bpt id="p1">[</bpt>IStringable.ToString<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementation must always override the base class implementation.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can hide a <ph id="ph1">`ToString`</ph> implementation only by invoking it on a strongly typed class instance.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that under a variety of conditions, calls from native code to a managed type that implements <bpt id="p1">[</bpt>IStringable<ept id="p1">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx)</ept> or hides its <bpt id="p2">[</bpt>ToString<ept id="p2">](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx)</ept> implementation can produce unexpected behavior.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve">
          <source>A string that represents the current object.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>