{"nodes":[{"content":"Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.","nodes":[{"pos":[0,133],"content":"Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.","nodes":[{"content":"Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.","pos":[0,133]}]}],"pos":[2111,2245],"yaml":true},{"content":"Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time. <xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.  \n  \n> [!NOTE]\n>  <xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state. <xref:System.Threading.ReaderWriterLockSlim>avoids many cases of potential deadlock. In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>. <xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.  \n  \n By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> flag and do not allow recursion. This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks. To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.  \n  \n A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode. (In the rest of this topic, \"upgradeable read mode\" is referred to as \"upgradeable mode\", and the phrase \"enter `x` mode\" is used in preference to the longer phrase \"enter the lock in `x` mode\".)  \n  \n Regardless of recursion policy, only one thread can be in write mode at any time. When a thread is in write mode, no other thread can enter the lock in any mode. Only one thread can be in upgradeable mode at any time. Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.  \n  \n <xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes. No thread can change the mode of another thread.  \n  \n If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:  \n  \n-   A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.  \n  \n    > [!NOTE]\n    >  Blocking new readers when writers are queued is a lock fairness policy that favors writers. The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios. Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.  \n  \n-   A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.  \n  \n-   A thread that tries to enter write mode blocks if there is a thread in any of the three modes.  \n  \n## Upgrading and Downgrading Locks  \n Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met. A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods. Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.  \n  \n> [!IMPORTANT]\n>  Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks. For example, if two threads in read mode both try to enter write mode, they will deadlock. Upgradeable mode is designed to avoid such deadlocks.  \n  \n If there are other threads in read mode, the thread that is upgrading blocks. While the thread is blocked, other threads that try to enter read mode are blocked. When all threads have exited from read mode, the blocked upgradeable thread enters write mode. If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.  \n  \n When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode. The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.  \n  \n> [!IMPORTANT]\n>  If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode. Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.  \n  \n A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method. This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.  \n  \n After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.  \n  \n## Entering the Lock Recursively  \n You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName>.  \n  \n> [!NOTE]\n>  The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.  \n  \n For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:  \n  \n-   A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode. If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown. Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed. As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.  \n  \n-   A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively. However, an attempt to enter write mode blocks if there are other threads in read mode.  \n  \n-   A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.  \n  \n-   A thread that has not entered the lock can enter any mode. This attempt can block for the same reasons as an attempt to enter a non-recursive lock.  \n  \n A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode. If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.  \n  \n## Lock States  \n You may find it useful to think of the lock in terms of its states. A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.  \n  \n-   Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).  \n  \n-   Read: In this state, one or more threads have entered the lock for read access to the protected resource.  \n  \n    > [!NOTE]\n    >  A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.  \n  \n-   Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access. No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.  \n  \n-   Write: In this state, one thread has entered the lock for write access to the protected resource. That thread has exclusive possession of the lock. Any other thread that tries to enter the lock for any reason is blocked.  \n  \n The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column. At the time it takes the action, `t` has no mode. (The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock. The cells describe what happens to the thread, and show changes to the lock state in parentheses.  \n  \n||Not entered (N)|Read (R)|Upgrade (U)|Write (W)|  \n|-|-----------------------|----------------|-------------------|-----------------|  \n|`t` enters read mode|`t` enters (R).|`t` blocks if threads are waiting for write mode; otherwise, `t` enters.|`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup>|`t` blocks.|  \n|`t` enters upgradeable mode|`t` enters (U).|`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U).|`t` blocks.|`t` blocks.|  \n|`t` enters write mode|`t` enters (W).|`t` blocks.|`t` blocks.<sup>2</sup>|`t` blocks.|  \n  \n <sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode. This action never blocks. The lock state does not change. (The thread can then complete a downgrade to read mode by exiting upgradeable mode.)  \n  \n <sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode. Otherwise it upgrades to write mode. The lock state changes to Write (W). If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.  \n  \n When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:  \n  \n-   First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).  \n  \n-   Failing that, a thread that is waiting for write mode.  \n  \n-   Failing that, a thread that is waiting for upgradeable mode.  \n  \n-   Failing that, all threads that are waiting for read mode.  \n  \n The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change. In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.","nodes":[{"pos":[0,493],"content":"Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time. <xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.","nodes":[{"content":"Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time. <xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.","pos":[0,493],"nodes":[{"content":"Use <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> to protect a resource that is read by multiple threads and written to by one thread at a time.","pos":[0,143],"source":"Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.","pos":[144,493],"source":" <xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource."}]}]},{"pos":[501,1018],"content":"[!NOTE]\n <xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state. <xref:System.Threading.ReaderWriterLockSlim>avoids many cases of potential deadlock. In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>. <xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.","leadings":["","> "],"nodes":[{"content":" <xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state. <xref:System.Threading.ReaderWriterLockSlim>avoids many cases of potential deadlock. In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>. <xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.","pos":[8,515],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is similar to <ph id=\"ph2\">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, but it has simplified rules for recursion and for upgrading and downgrading lock state.","pos":[1,189],"source":" <xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>avoids many cases of potential deadlock.","pos":[190,274],"source":" <xref:System.Threading.ReaderWriterLockSlim>avoids many cases of potential deadlock."},{"content":"In addition, the performance of <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is significantly better than <ph id=\"ph2\">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>.","pos":[275,422],"source":" In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>."},{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> is recommended for all new development.","pos":[423,507],"source":" <xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development."}]}]},{"pos":[1025,1692],"content":"By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> flag and do not allow recursion. This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks. To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.","nodes":[{"content":"By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> flag and do not allow recursion. This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks. To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.","pos":[0,667],"nodes":[{"content":"By default, new instances of <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> are created with the <ph id=\"ph2\">&lt;xref:System.Threading.LockRecursionPolicy?displayProperty=fullName&gt;</ph> flag and do not allow recursion.","pos":[0,196],"source":"By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> flag and do not allow recursion."},{"content":"This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks.","pos":[197,356]},{"content":"To simplify migration from existing projects that use <ph id=\"ph1\">&lt;xref:System.Threading.Monitor&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.ReaderWriterLock&gt;</ph>, you can use the <ph id=\"ph3\">&lt;xref:System.Threading.LockRecursionPolicy?displayProperty=fullName&gt;</ph> flag to create instances of <ph id=\"ph4\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that allow recursion.","pos":[357,667],"source":" To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion."}]}]},{"pos":[1699,1988],"content":"A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode. (In the rest of this topic, \"upgradeable read mode\" is referred to as \"upgradeable mode\", and the phrase \"enter `x` mode\" is used in preference to the longer phrase \"enter the lock in `x` mode\".)","nodes":[{"content":"A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode.","pos":[0,93]},{"content":"(In the rest of this topic, \"upgradeable read mode\" is referred to as \"upgradeable mode\", and the phrase \"enter <ph id=\"ph1\">`x`</ph> mode\" is used in preference to the longer phrase \"enter the lock in <ph id=\"ph2\">`x`</ph> mode\".)","pos":[94,289],"source":" (In the rest of this topic, \"upgradeable read mode\" is referred to as \"upgradeable mode\", and the phrase \"enter `x` mode\" is used in preference to the longer phrase \"enter the lock in `x` mode\".)"}]},{"pos":[1995,2341],"content":"Regardless of recursion policy, only one thread can be in write mode at any time. When a thread is in write mode, no other thread can enter the lock in any mode. Only one thread can be in upgradeable mode at any time. Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.","nodes":[{"content":"Regardless of recursion policy, only one thread can be in write mode at any time. When a thread is in write mode, no other thread can enter the lock in any mode. Only one thread can be in upgradeable mode at any time. Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.","pos":[0,346],"nodes":[{"content":"Regardless of recursion policy, only one thread can be in write mode at any time.","pos":[0,81]},{"content":"When a thread is in write mode, no other thread can enter the lock in any mode.","pos":[82,161]},{"content":"Only one thread can be in upgradeable mode at any time.","pos":[162,217]},{"content":"Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.","pos":[218,346]}]}]},{"pos":[2349,2875],"content":"[!IMPORTANT]\n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.","leadings":["","> "],"nodes":[{"content":" This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.","pos":[13,524],"nodes":[{"content":"This type implements the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface.","pos":[1,62],"source":" This type implements the <xref:System.IDisposable> interface."},{"content":"When you have finished using the type, you should dispose of it either directly or indirectly.","pos":[63,157]},{"content":"To dispose of the type directly, call its <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id=\"ph2\">`try`</ph><ph id=\"ph3\">/</ph><ph id=\"ph4\">`catch`</ph> block.","pos":[158,269],"source":" To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block."},{"content":"To dispose of it indirectly, use a language construct such as <ph id=\"ph1\">`using`</ph> (in C#) or <ph id=\"ph2\">`Using`</ph> (in Visual Basic).","pos":[270,377],"source":" To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic)."},{"content":"For more information, see the \"Using an Object that Implements IDisposable\" section in the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface topic.","pos":[378,511],"source":" For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic."}]}]},{"pos":[2882,3117],"content":"<xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes. No thread can change the mode of another thread.","nodes":[{"content":"<xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes. No thread can change the mode of another thread.","pos":[0,235],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> has managed thread affinity; that is, each <ph id=\"ph2\">&lt;xref:System.Threading.Thread&gt;</ph> object must make its own method calls to enter and exit lock modes.","pos":[0,186],"source":"<xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes."},{"content":"No thread can change the mode of another thread.","pos":[187,235]}]}]},{"pos":[3124,3268],"content":"If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:","nodes":[{"content":"If a <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> does not allow recursion, a thread that tries to enter the lock can block for several reasons:","pos":[0,144],"source":"If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:"}]},{"pos":[3278,3418],"content":"A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.","nodes":[{"content":"A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.","pos":[0,140]}]},{"pos":[3430,3772],"content":"[!NOTE]\nBlocking new readers when writers are queued is a lock fairness policy that favors writers. The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios. Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.","leadings":["","    >  "],"nodes":[{"content":"Blocking new readers when writers are queued is a lock fairness policy that favors writers. The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios. Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.","pos":[8,335],"nodes":[{"content":"Blocking new readers when writers are queued is a lock fairness policy that favors writers.","pos":[0,91]},{"content":"The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios.","pos":[92,213]},{"content":"Future versions of the <ph id=\"ph1\">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]</ph> may introduce new fairness policies.","pos":[214,327],"source":" Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies."}]}]},{"pos":[3782,3980],"content":"A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.","nodes":[{"content":"A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.","pos":[0,198]}]},{"pos":[3990,4084],"content":"A thread that tries to enter write mode blocks if there is a thread in any of the three modes.","nodes":[{"content":"A thread that tries to enter write mode blocks if there is a thread in any of the three modes.","pos":[0,94]}]},{"pos":[4093,4124],"content":"Upgrading and Downgrading Locks","linkify":"Upgrading and Downgrading Locks","nodes":[{"content":"Upgrading and Downgrading Locks","pos":[0,31]}]},{"pos":[4128,4770],"content":"Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met. A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods. Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.","nodes":[{"content":"Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met. A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods. Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.","pos":[0,642],"nodes":[{"content":"Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met.","pos":[0,152]},{"content":"A thread that has entered a <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <ph id=\"ph2\">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> methods.","pos":[153,474],"source":" A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods."},{"content":"Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.","pos":[475,642]}]}]},{"pos":[4778,5137],"content":"[!IMPORTANT]\n Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks. For example, if two threads in read mode both try to enter write mode, they will deadlock. Upgradeable mode is designed to avoid such deadlocks.","leadings":["","> "],"nodes":[{"content":" Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks. For example, if two threads in read mode both try to enter write mode, they will deadlock. Upgradeable mode is designed to avoid such deadlocks.","pos":[13,357],"nodes":[{"content":"Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.","pos":[1,199]},{"content":"For example, if two threads in read mode both try to enter write mode, they will deadlock.","pos":[200,290]},{"content":"Upgradeable mode is designed to avoid such deadlocks.","pos":[291,344]}]}]},{"pos":[5144,5592],"content":"If there are other threads in read mode, the thread that is upgrading blocks. While the thread is blocked, other threads that try to enter read mode are blocked. When all threads have exited from read mode, the blocked upgradeable thread enters write mode. If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.","nodes":[{"content":"If there are other threads in read mode, the thread that is upgrading blocks. While the thread is blocked, other threads that try to enter read mode are blocked. When all threads have exited from read mode, the blocked upgradeable thread enters write mode. If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.","pos":[0,448],"nodes":[{"content":"If there are other threads in read mode, the thread that is upgrading blocks.","pos":[0,77]},{"content":"While the thread is blocked, other threads that try to enter read mode are blocked.","pos":[78,161]},{"content":"When all threads have exited from read mode, the blocked upgradeable thread enters write mode.","pos":[162,256]},{"content":"If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.","pos":[257,448]}]}]},{"pos":[5599,5910],"content":"When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode. The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.","nodes":[{"content":"When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode. The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.","pos":[0,311],"nodes":[{"content":"When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode.","pos":[0,168]},{"content":"The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.","pos":[169,311]}]}]},{"pos":[5918,6230],"content":"[!IMPORTANT]\n If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode. Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.","leadings":["","> "],"nodes":[{"content":" If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode. Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.","pos":[13,310],"nodes":[{"content":"If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode.","pos":[1,133]},{"content":"Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.","pos":[134,297]}]}]},{"pos":[6237,6612],"content":"A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method. This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.","nodes":[{"content":"A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method. This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.","pos":[0,375],"nodes":[{"content":"A thread in upgradeable mode can downgrade to read mode by first calling the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method and then calling the <ph id=\"ph2\">&lt;xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A&gt;</ph> method.","pos":[0,246],"source":"A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method."},{"content":"This downgrade pattern is allowed for all lock recursion policies, even <ph id=\"ph1\">&lt;xref:System.Threading.LockRecursionPolicy.NoRecursion&gt;</ph>.","pos":[247,375],"source":" This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>."}]}]},{"pos":[6619,6727],"content":"After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.","nodes":[{"content":"After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.","pos":[0,108]}]},{"pos":[6736,6765],"content":"Entering the Lock Recursively","linkify":"Entering the Lock Recursively","nodes":[{"content":"Entering the Lock Recursively","pos":[0,29]}]},{"pos":[6769,7098],"content":"You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName>.","nodes":[{"content":"You can create a <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that supports recursive lock entry by using the <ph id=\"ph2\">&lt;xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29&gt;</ph> constructor that specifies lock policy, and specifying <ph id=\"ph3\">&lt;xref:System.Threading.LockRecursionPolicy?displayProperty=fullName&gt;</ph>.","pos":[0,329],"source":"You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName>."}]},{"pos":[7106,7270],"content":"[!NOTE]\n The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.","leadings":["","> "],"nodes":[{"content":"The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.","pos":[9,162]}]},{"pos":[7277,7412],"content":"For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:","nodes":[{"content":"For a <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that allows recursion, the following can be said about the modes a thread can enter:","pos":[0,135],"source":"For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:"}]},{"pos":[7422,7854],"content":"A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode. If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown. Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed. As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.","nodes":[{"content":"A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode. If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown. Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed. As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.","pos":[0,432],"nodes":[{"content":"A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode.","pos":[0,103]},{"content":"If it tries to do this, a <ph id=\"ph1\">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown.","pos":[104,187],"source":" If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown."},{"content":"Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed.","pos":[188,330]},{"content":"As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.","pos":[331,432]}]}]},{"pos":[7864,8069],"content":"A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively. However, an attempt to enter write mode blocks if there are other threads in read mode.","nodes":[{"content":"A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively. However, an attempt to enter write mode blocks if there are other threads in read mode.","pos":[0,205],"nodes":[{"content":"A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively.","pos":[0,117]},{"content":"However, an attempt to enter write mode blocks if there are other threads in read mode.","pos":[118,205]}]}]},{"pos":[8079,8196],"content":"A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.","nodes":[{"content":"A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.","pos":[0,117]}]},{"pos":[8206,8353],"content":"A thread that has not entered the lock can enter any mode. This attempt can block for the same reasons as an attempt to enter a non-recursive lock.","nodes":[{"content":"A thread that has not entered the lock can enter any mode. This attempt can block for the same reasons as an attempt to enter a non-recursive lock.","pos":[0,147],"nodes":[{"content":"A thread that has not entered the lock can enter any mode.","pos":[0,58]},{"content":"This attempt can block for the same reasons as an attempt to enter a non-recursive lock.","pos":[59,147]}]}]},{"pos":[8360,8646],"content":"A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode. If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.","nodes":[{"content":"A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode. If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.","pos":[0,286],"nodes":[{"content":"A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode.","pos":[0,133]},{"content":"If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <ph id=\"ph1\">&lt;xref:System.Threading.SynchronizationLockException&gt;</ph> is thrown.","pos":[134,286],"source":" If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown."}]}]},{"pos":[8655,8666],"content":"Lock States","linkify":"Lock States","nodes":[{"content":"Lock States","pos":[0,11]}]},{"pos":[8670,8853],"content":"You may find it useful to think of the lock in terms of its states. A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.","nodes":[{"content":"You may find it useful to think of the lock in terms of its states. A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.","pos":[0,183],"nodes":[{"content":"You may find it useful to think of the lock in terms of its states.","pos":[0,67]},{"content":"A <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> can be in one of four states: not entered, read, upgrade, and write.","pos":[68,183],"source":" A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write."}]}]},{"pos":[8863,8962],"content":"Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).","nodes":[{"content":"Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).","pos":[0,99]}]},{"pos":[8972,9077],"content":"Read: In this state, one or more threads have entered the lock for read access to the protected resource.","nodes":[{"content":"Read: In this state, one or more threads have entered the lock for read access to the protected resource.","pos":[0,105]}]},{"pos":[9089,9337],"content":"[!NOTE]\nA thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.","leadings":["","    >  "],"nodes":[{"content":"A thread can enter the lock in read mode by using the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> methods, or by downgrading from upgradeable mode.","pos":[8,241],"source":"A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode."}]},{"pos":[9347,9705],"content":"Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access. No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.","nodes":[{"content":"Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access. No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.","pos":[0,358],"nodes":[{"content":"Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access.","pos":[0,210]},{"content":"No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.","pos":[211,358]}]}]},{"pos":[9715,9935],"content":"Write: In this state, one thread has entered the lock for write access to the protected resource. That thread has exclusive possession of the lock. Any other thread that tries to enter the lock for any reason is blocked.","nodes":[{"content":"Write: In this state, one thread has entered the lock for write access to the protected resource. That thread has exclusive possession of the lock. Any other thread that tries to enter the lock for any reason is blocked.","pos":[0,220],"nodes":[{"content":"Write: In this state, one thread has entered the lock for write access to the protected resource.","pos":[0,97]},{"content":"That thread has exclusive possession of the lock.","pos":[98,147]},{"content":"Any other thread that tries to enter the lock for any reason is blocked.","pos":[148,220]}]}]},{"pos":[9942,10407],"content":"The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column. At the time it takes the action, `t` has no mode. (The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock. The cells describe what happens to the thread, and show changes to the lock state in parentheses.","nodes":[{"content":"The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread <ph id=\"ph1\">`t`</ph> takes the action described in the leftmost column.","pos":[0,174],"source":"The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column."},{"content":"At the time it takes the action, <ph id=\"ph1\">`t`</ph> has no mode.","pos":[175,224],"source":" At the time it takes the action, `t` has no mode."},{"content":"(The special case where <ph id=\"ph1\">`t`</ph> is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock.","pos":[225,367],"source":" (The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock."},{"content":"The cells describe what happens to the thread, and show changes to the lock state in parentheses.","pos":[368,465]}]},{"pos":[10415,10430],"content":"Not entered (N)","nodes":[{"content":"Not entered (N)","pos":[0,15]}]},{"pos":[10431,10439],"content":"Read (R)","nodes":[{"content":"Read (R)","pos":[0,8]}]},{"pos":[10440,10451],"content":"Upgrade (U)","nodes":[{"content":"Upgrade (U)","pos":[0,11]}]},{"pos":[10452,10461],"content":"Write (W)","nodes":[{"content":"Write (W)","pos":[0,9]}]},{"pos":[10551,10571],"content":"<ph id=\"ph1\">`t`</ph> enters read mode","source":"`t` enters read mode"},{"pos":[10572,10587],"content":"<ph id=\"ph1\">`t`</ph> enters (R).","source":"`t` enters (R)."},{"pos":[10588,10660],"content":"<ph id=\"ph1\">`t`</ph> blocks if threads are waiting for write mode; otherwise, <ph id=\"ph2\">`t`</ph> enters.","source":"`t` blocks if threads are waiting for write mode; otherwise, `t` enters."},{"pos":[10661,10745],"content":"<ph id=\"ph1\">`t`</ph> blocks if threads are waiting for write mode; otherwise, <ph id=\"ph2\">`t`</ph> enters.<bpt id=\"p1\">&lt;sup&gt;</bpt>1<ept id=\"p1\">&lt;/sup&gt;</ept>","source":"`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup>"},{"pos":[10746,10757],"content":"<ph id=\"ph1\">`t`</ph> blocks.","source":"`t` blocks."},{"pos":[10762,10789],"content":"<ph id=\"ph1\">`t`</ph> enters upgradeable mode","source":"`t` enters upgradeable mode"},{"pos":[10790,10805],"content":"<ph id=\"ph1\">`t`</ph> enters (U).","source":"`t` enters (U)."},{"pos":[10806,10898],"content":"<ph id=\"ph1\">`t`</ph> blocks if threads are waiting for write mode or upgrade mode; otherwise, <ph id=\"ph2\">`t`</ph> enters (U).","source":"`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U)."},{"pos":[10899,10910],"content":"<ph id=\"ph1\">`t`</ph> blocks.","source":"`t` blocks."},{"pos":[10911,10922],"content":"<ph id=\"ph1\">`t`</ph> blocks.","source":"`t` blocks."},{"pos":[10927,10948],"content":"<ph id=\"ph1\">`t`</ph> enters write mode","source":"`t` enters write mode"},{"pos":[10949,10964],"content":"<ph id=\"ph1\">`t`</ph> enters (W).","source":"`t` enters (W)."},{"pos":[10965,10976],"content":"<ph id=\"ph1\">`t`</ph> blocks.","source":"`t` blocks."},{"pos":[10977,11000],"content":"<ph id=\"ph1\">`t`</ph> blocks.<bpt id=\"p1\">&lt;sup&gt;</bpt>2<ept id=\"p1\">&lt;/sup&gt;</ept>","source":"`t` blocks.<sup>2</sup>"},{"pos":[11001,11012],"content":"<ph id=\"ph1\">`t`</ph> blocks.","source":"`t` blocks."},{"pos":[11020,11235],"content":"<sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode. This action never blocks. The lock state does not change. (The thread can then complete a downgrade to read mode by exiting upgradeable mode.)","nodes":[{"content":"<bpt id=\"p1\">&lt;sup&gt;</bpt>1<ept id=\"p1\">&lt;/sup&gt;</ept> If <ph id=\"ph1\">`t`</ph> starts out in upgradeable mode, it enters read mode.","pos":[0,72],"source":"<sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode."},{"content":"This action never blocks.","pos":[73,98]},{"content":"The lock state does not change.","pos":[99,130]},{"content":"(The thread can then complete a downgrade to read mode by exiting upgradeable mode.)","pos":[131,215]}]},{"pos":[11242,11586],"content":"<sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode. Otherwise it upgrades to write mode. The lock state changes to Write (W). If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.","nodes":[{"content":"<bpt id=\"p1\">&lt;sup&gt;</bpt>2<ept id=\"p1\">&lt;/sup&gt;</ept> If <ph id=\"ph1\">`t`</ph> starts out in upgradeable mode, it blocks if there are threads in read mode.","pos":[0,96],"source":"<sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode."},{"content":"Otherwise it upgrades to write mode.","pos":[97,133]},{"content":"The lock state changes to Write (W).","pos":[134,170]},{"content":"If <ph id=\"ph1\">`t`</ph> blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.","pos":[171,344],"source":" If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode."}]},{"pos":[11593,11707],"content":"When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:","nodes":[{"content":"When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:","pos":[0,114]}]},{"pos":[11717,11838],"content":"First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).","nodes":[{"content":"First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).","pos":[0,121]}]},{"pos":[11848,11902],"content":"Failing that, a thread that is waiting for write mode.","nodes":[{"content":"Failing that, a thread that is waiting for write mode.","pos":[0,54]}]},{"pos":[11912,11972],"content":"Failing that, a thread that is waiting for upgradeable mode.","nodes":[{"content":"Failing that, a thread that is waiting for upgradeable mode.","pos":[0,60]}]},{"pos":[11982,12039],"content":"Failing that, all threads that are waiting for read mode.","nodes":[{"content":"Failing that, all threads that are waiting for read mode.","pos":[0,57]}]},{"pos":[12046,12419],"content":"The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change. In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.","nodes":[{"content":"The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change. In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.","pos":[0,373],"nodes":[{"content":"The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change.","pos":[0,198]},{"content":"In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.","pos":[199,373]}]}]}],"pos":[2256,14786],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> class with default property values.","nodes":[{"pos":[0,128],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim\"&gt;&lt;/xref&gt;</ph> class with default property values.","source":"Initializes a new instance of the <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> class with default property values."}],"pos":[20164,20293],"yaml":true},{"content":"A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion. That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName>.  \n  \n For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.","nodes":[{"pos":[0,278],"content":"A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion. That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName>.","nodes":[{"content":"A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion. That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName>.","pos":[0,278],"nodes":[{"content":"A <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> that is initialized with this constructor does not allow recursion.","pos":[0,114],"source":"A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion."},{"content":"That is, the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A&gt;</ph> property returns <ph id=\"ph2\">&lt;xref:System.Threading.LockRecursionPolicy?displayProperty=fullName&gt;</ph>.","pos":[115,278],"source":" That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName>."}]}]},{"pos":[285,469],"content":"For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.","nodes":[{"content":"For more information about recursion policy and its effects, see the <ph id=\"ph1\">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id=\"ph2\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.","pos":[0,184],"source":"For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class."}]}],"pos":[20304,20778],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> class, specifying the lock recursion policy.","nodes":[{"pos":[0,137],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim\"&gt;&lt;/xref&gt;</ph> class, specifying the lock recursion policy.","source":"Initializes a new instance of the <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> class, specifying the lock recursion policy."}],"pos":[26096,26234],"yaml":true},{"content":"Recursion policy determines the restrictions on threads that enter the lock more than once. For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode. Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.  \n  \n> [!NOTE]\n>  A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.  \n  \n Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.  \n  \n For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.","nodes":[{"pos":[0,528],"content":"Recursion policy determines the restrictions on threads that enter the lock more than once. For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode. Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.","nodes":[{"content":"Recursion policy determines the restrictions on threads that enter the lock more than once. For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode. Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.","pos":[0,528],"nodes":[{"content":"Recursion policy determines the restrictions on threads that enter the lock more than once.","pos":[0,91]},{"content":"For example, if a lock was created with <ph id=\"ph1\">&lt;xref:System.Threading.LockRecursionPolicy?displayProperty=fullName&gt;</ph> and a thread has entered the lock in read mode, <ph id=\"ph2\">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in read mode.","pos":[92,359],"source":" For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode."},{"content":"Similarly, if a thread has entered the lock in write mode, <ph id=\"ph1\">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in any mode.","pos":[360,528],"source":" Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode."}]}]},{"pos":[536,676],"content":"[!NOTE]\n A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.","leadings":["","> "],"nodes":[{"content":"A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.","pos":[9,138]}]},{"pos":[683,881],"content":"Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.","nodes":[{"content":"Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.","pos":[0,198]}]},{"pos":[888,1072],"content":"For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.","nodes":[{"content":"For more information about recursion policy and its effects, see the <ph id=\"ph1\">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id=\"ph2\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.","pos":[0,184],"source":"For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class."}]}],"pos":[26245,27327],"yaml":true,"extradata":"MT"},{"content":"One of the enumeration values that specifies the lock recursion policy.","nodes":[{"pos":[0,71],"content":"One of the enumeration values that specifies the lock recursion policy.","nodes":[{"content":"One of the enumeration values that specifies the lock recursion policy.","pos":[0,71]}]}],"pos":[30353,30425],"yaml":true},{"content":"Gets the total number of unique threads that have entered the lock in read mode.","nodes":[{"pos":[0,80],"content":"Gets the total number of unique threads that have entered the lock in read mode.","nodes":[{"content":"Gets the total number of unique threads that have entered the lock in read mode.","pos":[0,80]}]}],"pos":[32014,32095],"yaml":true},{"content":"A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.  \n  \n Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","nodes":[{"pos":[0,117],"content":"A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.","nodes":[{"content":"A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.","pos":[0,117]}]},{"pos":[124,372],"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","nodes":[{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","pos":[0,248],"nodes":[{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.","pos":[0,119]},{"content":"The results can change as soon as they have been calculated.","pos":[120,180]},{"content":"Therefore, it is not safe to make decisions based on this property.","pos":[181,248]}]}]}],"pos":[32106,32483],"yaml":true,"extradata":"MT"},{"content":"The number of unique threads that have entered the lock in read mode.","nodes":[{"pos":[0,69],"content":"The number of unique threads that have entered the lock in read mode.","nodes":[{"content":"The number of unique threads that have entered the lock in read mode.","pos":[0,69]}]}],"pos":[33850,33920],"yaml":true},{"content":"Releases all resources used by the current instance of the <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> class.","nodes":[{"pos":[0,124],"content":"Releases all resources used by the current instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim\"&gt;&lt;/xref&gt;</ph> class.","source":"Releases all resources used by the current instance of the <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> class."}],"pos":[35470,35595],"yaml":true},{"content":"Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>. The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state. After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying. For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  \n  \n> [!NOTE]\n>  Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.","nodes":[{"pos":[0,761],"content":"Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>. The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state. After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying. For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).","nodes":[{"content":"Call <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> when you are finished using the <ph id=\"ph2\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph>.","pos":[0,138],"source":"Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> method leaves the <ph id=\"ph2\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in an unusable state.","pos":[139,283],"source":" The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state."},{"content":"After calling <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph>, you must release all references to the <ph id=\"ph2\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> so the garbage collector can reclaim the memory that the <ph id=\"ph3\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> was occupying.","pos":[284,555],"source":" After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Cleaning Up Unmanaged Resources<ept id=\"p1\">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id=\"p2\">[</bpt>Implementing a Dispose Method<ept id=\"p2\">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.","pos":[556,761],"source":" For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md)."}]},{"pos":[769,946],"content":"[!NOTE]\n Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.","leadings":["","> "],"nodes":[{"content":"Always call <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.Dispose%2A&gt;</ph> before you release your last reference to the <ph id=\"ph2\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> object.","pos":[9,175],"source":" Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object."}]}],"pos":[35606,36558],"yaml":true,"extradata":"MT"},{"content":"<xref href=\"System.Threading.ReaderWriterLockSlim.WaitingReadCount\"></xref> is greater than zero.  \n  \n -or-  \n  \n <xref href=\"System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount\"></xref> is greater than zero.  \n  \n -or-  \n  \n <xref href=\"System.Threading.ReaderWriterLockSlim.WaitingWriteCount\"></xref> is greater than zero.","nodes":[{"pos":[0,97],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim.WaitingReadCount\"&gt;&lt;/xref&gt;</ph> is greater than zero.","source":"<xref href=\"System.Threading.ReaderWriterLockSlim.WaitingReadCount\"></xref> is greater than zero."},{"pos":[104,108],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[115,215],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount\"&gt;&lt;/xref&gt;</ph> is greater than zero.","source":"<xref href=\"System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount\"></xref> is greater than zero."},{"pos":[222,226],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[233,331],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim.WaitingWriteCount\"&gt;&lt;/xref&gt;</ph> is greater than zero.","source":"<xref href=\"System.Threading.ReaderWriterLockSlim.WaitingWriteCount\"></xref> is greater than zero."}],"pos":[36833,37181],"yaml":true},{"content":"Tries to enter the lock in read mode.","nodes":[{"pos":[0,37],"content":"Tries to enter the lock in read mode.","nodes":[{"content":"Tries to enter the lock in read mode.","pos":[0,37]}]}],"pos":[38682,38720],"yaml":true},{"content":"This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.  \n  \n Multiple threads can enter read mode at the same time.  \n  \n If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.  \n  \n> [!NOTE]\n>  If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.  \n  \n At most one thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.","nodes":[{"pos":[0,295],"content":"This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.","nodes":[{"content":"This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.","pos":[0,295],"nodes":[{"content":"This method blocks until the calling thread enters the lock, and therefore might never return.","pos":[0,94]},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.","pos":[95,295],"source":" Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval."}]}]},{"pos":[302,356],"content":"Multiple threads can enter read mode at the same time.","nodes":[{"content":"Multiple threads can enter read mode at the same time.","pos":[0,54]}]},{"pos":[363,607],"content":"If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.","nodes":[{"content":"If one or more threads are waiting to enter write mode, a thread that calls the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it.","pos":[0,244],"source":"If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it."}]},{"pos":[615,789],"content":"[!NOTE]\n If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.","leadings":["","> "],"nodes":[{"content":"If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.","pos":[9,172]}]},{"pos":[796,1131],"content":"At most one thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.","nodes":[{"content":"At most one thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.","pos":[0,335],"nodes":[{"content":"At most one thread can be in upgradeable mode while other threads are in read mode.","pos":[0,83]},{"content":"If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.","pos":[84,335],"source":" If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block."}]}]}],"pos":[38731,39874],"yaml":true,"extradata":"MT"},{"content":"The current thread cannot acquire the write lock when it holds the read lock.  \n  \n -or-  \n  \n The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref>, and the current thread has attempted to acquire the read lock when it already holds the read lock.  \n  \n -or-  \n  \n The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref>, and the current thread has attempted to acquire the read lock when it already holds the write lock.  \n  \n -or-  \n  \n The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception.","nodes":[{"pos":[0,77],"content":"The current thread cannot acquire the write lock when it holds the read lock.","nodes":[{"content":"The current thread cannot acquire the write lock when it holds the read lock.","pos":[0,77]}]},{"pos":[84,88],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[95,355],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"&gt;&lt;/xref&gt;</ph> property is <ph id=\"ph2\">&lt;xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"&gt;&lt;/xref&gt;</ph>, and the current thread has attempted to acquire the read lock when it already holds the read lock.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref>, and the current thread has attempted to acquire the read lock when it already holds the read lock."},{"pos":[362,366],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[373,634],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"&gt;&lt;/xref&gt;</ph> property is <ph id=\"ph2\">&lt;xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"&gt;&lt;/xref&gt;</ph>, and the current thread has attempted to acquire the read lock when it already holds the write lock.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref>, and the current thread has attempted to acquire the read lock when it already holds the write lock."},{"pos":[641,645],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[652,794],"content":"The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception.","nodes":[{"content":"The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception.","pos":[0,142],"nodes":[{"content":"The recursion number would exceed the capacity of the counter.","pos":[0,62]},{"content":"This limit is so large that applications should never encounter this exception.","pos":[63,142]}]}]}],"pos":[41504,42321],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.","nodes":[{"pos":[0,88],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim\"&gt;&lt;/xref&gt;</ph> object has been disposed.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed."}],"pos":[42427,42516],"yaml":true},{"content":"Tries to enter the lock in upgradeable mode.","nodes":[{"pos":[0,44],"content":"Tries to enter the lock in upgradeable mode.","nodes":[{"content":"Tries to enter the lock in upgradeable mode.","pos":[0,44]}]}],"pos":[44083,44128],"yaml":true},{"content":"This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.  \n  \n Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.  \n  \n Only one thread can enter upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.  \n  \n If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.  \n  \n> [!NOTE]\n>  If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.","nodes":[{"pos":[0,313],"content":"This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.","nodes":[{"content":"This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.","pos":[0,313],"nodes":[{"content":"This method blocks until the calling thread enters the lock, and therefore might never return.","pos":[0,94]},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.","pos":[95,313],"source":" Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval."}]}]},{"pos":[320,614],"content":"Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.","nodes":[{"content":"Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.","pos":[0,294],"nodes":[{"content":"Use upgradeable mode when a thread usually accesses the resource that is protected by the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.","pos":[0,212],"source":"Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met."},{"content":"A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.","pos":[213,294]}]}]},{"pos":[621,882],"content":"Only one thread can enter upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.","nodes":[{"content":"Only one thread can enter upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.","pos":[0,261],"nodes":[{"content":"Only one thread can enter upgradeable mode at any given time.","pos":[0,61]},{"content":"If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.","pos":[62,261]}]}]},{"pos":[889,1144],"content":"If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.","nodes":[{"content":"If one or more threads are waiting to enter write mode, a thread that calls the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it.","pos":[0,255],"source":"If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it."}]},{"pos":[1152,1340],"content":"[!NOTE]\n If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.","leadings":["","> "],"nodes":[{"content":"If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.","pos":[9,186]}]}],"pos":[44139,45491],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock in any mode.  \n  \n -or-  \n  \n The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.  \n  \n -or-  \n  \n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"pos":[0,225],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"&gt;&lt;/xref&gt;</ph> property is <ph id=\"ph2\">&lt;xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"&gt;&lt;/xref&gt;</ph> and the current thread has already entered the lock in any mode.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock in any mode."},{"pos":[232,236],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[243,364],"content":"The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.","nodes":[{"content":"The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.","pos":[0,121]}]},{"pos":[371,375],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[382,511],"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","pos":[0,129],"nodes":[{"content":"The recursion number would exceed the capacity of the counter.","pos":[0,62]},{"content":"The limit is so large that applications should never encounter it.","pos":[63,129]}]}]}],"pos":[47947,48473],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.","nodes":[{"pos":[0,88],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim\"&gt;&lt;/xref&gt;</ph> object has been disposed.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed."}],"pos":[48579,48668],"yaml":true},{"content":"Tries to enter the lock in write mode.","nodes":[{"pos":[0,38],"content":"Tries to enter the lock in write mode.","nodes":[{"content":"Tries to enter the lock in write mode.","pos":[0,38]}]}],"pos":[50175,50214],"yaml":true},{"content":"This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.  \n  \n If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode. When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.  \n  \n> [!NOTE]\n>  If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.","nodes":[{"pos":[0,297],"content":"This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.","nodes":[{"content":"This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.","pos":[0,297],"nodes":[{"content":"This method blocks until the calling thread enters the lock, and therefore might never return.","pos":[0,94]},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.","pos":[95,297],"source":" Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval."}]}]},{"pos":[304,744],"content":"If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode. When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.","nodes":[{"content":"If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode. When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.","pos":[0,440],"nodes":[{"content":"If other threads have entered the lock in read mode, a thread that calls the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode.","pos":[0,196],"source":"If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode."},{"content":"When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.","pos":[197,440]}]}]},{"pos":[752,928],"content":"[!NOTE]\n If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.","leadings":["","> "],"nodes":[{"content":"If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.","pos":[9,174]}]}],"pos":[50225,51161],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock in any mode.  \n  \n -or-  \n  \n The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.  \n  \n -or-  \n  \n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"pos":[0,225],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"&gt;&lt;/xref&gt;</ph> property is <ph id=\"ph2\">&lt;xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"&gt;&lt;/xref&gt;</ph> and the current thread has already entered the lock in any mode.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock in any mode."},{"pos":[232,236],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[243,370],"content":"The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.","nodes":[{"content":"The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.","pos":[0,127]}]},{"pos":[377,381],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[388,517],"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","pos":[0,129],"nodes":[{"content":"The recursion number would exceed the capacity of the counter.","pos":[0,62]},{"content":"The limit is so large that applications should never encounter it.","pos":[63,129]}]}]}],"pos":[52818,53350],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.","nodes":[{"pos":[0,88],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim\"&gt;&lt;/xref&gt;</ph> object has been disposed.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed."}],"pos":[53456,53545],"yaml":true},{"content":"Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).","nodes":[{"pos":[0,98],"content":"Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).","nodes":[{"content":"Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).","pos":[0,98]}]}],"pos":[55040,55139],"yaml":true},{"content":"This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.  \n  \n Exiting the lock might signal other waiting threads.","nodes":[{"pos":[0,405],"content":"This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.","nodes":[{"content":"This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.","pos":[0,405],"nodes":[{"content":"This method is not sensitive to recursion order.","pos":[0,48]},{"content":"For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter.","pos":[49,213]},{"content":"If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.","pos":[214,405]}]}]},{"pos":[412,464],"content":"Exiting the lock might signal other waiting threads.","nodes":[{"content":"Exiting the lock might signal other waiting threads.","pos":[0,52]}]}],"pos":[55150,55619],"yaml":true,"extradata":"MT"},{"content":"The current thread has not entered the lock in read mode.","nodes":[{"pos":[0,57],"content":"The current thread has not entered the lock in read mode.","nodes":[{"content":"The current thread has not entered the lock in read mode.","pos":[0,57]}]}],"pos":[57247,57305],"yaml":true},{"content":"Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).","nodes":[{"pos":[0,112],"content":"Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).","nodes":[{"content":"Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).","pos":[0,112]}]}],"pos":[58866,58979],"yaml":true},{"content":"This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.  \n  \n Exiting the lock might signal other waiting threads.","nodes":[{"pos":[0,420],"content":"This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.","nodes":[{"content":"This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.","pos":[0,420],"nodes":[{"content":"This method is not sensitive to recursion order.","pos":[0,48]},{"content":"For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.","pos":[49,214]},{"content":"If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.","pos":[215,420]}]}]},{"pos":[427,479],"content":"Exiting the lock might signal other waiting threads.","nodes":[{"content":"Exiting the lock might signal other waiting threads.","pos":[0,52]}]}],"pos":[58990,59474],"yaml":true,"extradata":"MT"},{"content":"The current thread has not entered the lock in upgradeable mode.","nodes":[{"pos":[0,64],"content":"The current thread has not entered the lock in upgradeable mode.","nodes":[{"content":"The current thread has not entered the lock in upgradeable mode.","pos":[0,64]}]}],"pos":[61809,61874],"yaml":true},{"content":"Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).","nodes":[{"pos":[0,100],"content":"Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).","nodes":[{"content":"Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).","pos":[0,100]}]}],"pos":[63375,63476],"yaml":true},{"content":"This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.  \n  \n Exiting the lock might signal other waiting threads.","nodes":[{"pos":[0,406],"content":"This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.","nodes":[{"content":"This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.","pos":[0,406],"nodes":[{"content":"This method is not sensitive to recursion order.","pos":[0,48]},{"content":"For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter.","pos":[49,214]},{"content":"If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.","pos":[215,406]}]}]},{"pos":[413,465],"content":"Exiting the lock might signal other waiting threads.","nodes":[{"content":"Exiting the lock might signal other waiting threads.","pos":[0,52]}]}],"pos":[63487,63957],"yaml":true,"extradata":"MT"},{"content":"The current thread has not entered the lock in write mode.","nodes":[{"pos":[0,58],"content":"The current thread has not entered the lock in write mode.","nodes":[{"content":"The current thread has not entered the lock in write mode.","pos":[0,58]}]}],"pos":[65624,65683],"yaml":true},{"content":"Gets a value that indicates whether the current thread has entered the lock in read mode.","nodes":[{"pos":[0,89],"content":"Gets a value that indicates whether the current thread has entered the lock in read mode.","nodes":[{"content":"Gets a value that indicates whether the current thread has entered the lock in read mode.","pos":[0,89]}]}],"pos":[67186,67276],"yaml":true},{"content":"This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.","nodes":[{"pos":[0,133],"content":"This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.","nodes":[{"content":"This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.","pos":[0,133],"nodes":[{"content":"This property is intended for use in asserts or for other debugging purposes.","pos":[0,77]},{"content":"Do not use it to control the flow of program execution.","pos":[78,133]}]}]}],"pos":[67287,67421],"yaml":true,"extradata":"MT"},{"content":"`true` if the current thread has entered read mode; otherwise, `false`.","nodes":[{"pos":[0,71],"content":"<ph id=\"ph1\">`true`</ph> if the current thread has entered read mode; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the current thread has entered read mode; otherwise, `false`."}],"pos":[68438,68512],"yaml":true},{"content":"Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.","nodes":[{"pos":[0,96],"content":"Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.","nodes":[{"content":"Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.","pos":[0,96]}]}],"pos":[70164,70261],"yaml":true},{"content":"This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.","nodes":[{"pos":[0,133],"content":"This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.","nodes":[{"content":"This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.","pos":[0,133],"nodes":[{"content":"This property is intended for use in asserts or for other debugging purposes.","pos":[0,77]},{"content":"Do not use it to control the flow of program execution.","pos":[78,133]}]}]}],"pos":[70272,70406],"yaml":true,"extradata":"MT"},{"content":"`true` if the current thread has entered upgradeable mode; otherwise, `false`.","nodes":[{"pos":[0,78],"content":"<ph id=\"ph1\">`true`</ph> if the current thread has entered upgradeable mode; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the current thread has entered upgradeable mode; otherwise, `false`."}],"pos":[71452,71533],"yaml":true},{"content":"Gets a value that indicates whether the current thread has entered the lock in write mode.","nodes":[{"pos":[0,90],"content":"Gets a value that indicates whether the current thread has entered the lock in write mode.","nodes":[{"content":"Gets a value that indicates whether the current thread has entered the lock in write mode.","pos":[0,90]}]}],"pos":[73136,73227],"yaml":true},{"content":"This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.","nodes":[{"pos":[0,133],"content":"This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.","nodes":[{"content":"This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.","pos":[0,133],"nodes":[{"content":"This property is intended for use in asserts or for other debugging purposes.","pos":[0,77]},{"content":"Do not use it to control the flow of program execution.","pos":[78,133]}]}]}],"pos":[73238,73372],"yaml":true,"extradata":"MT"},{"content":"`true` if the current thread has entered write mode; otherwise, `false`.","nodes":[{"pos":[0,72],"content":"<ph id=\"ph1\">`true`</ph> if the current thread has entered write mode; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the current thread has entered write mode; otherwise, `false`."}],"pos":[74392,74467],"yaml":true},{"content":"Gets a value that indicates the recursion policy for the current <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object.","nodes":[{"pos":[0,131],"content":"Gets a value that indicates the recursion policy for the current <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim\"&gt;&lt;/xref&gt;</ph> object.","source":"Gets a value that indicates the recursion policy for the current <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object."}],"pos":[76060,76192],"yaml":true},{"content":"Recursion policy determines the restrictions on threads that enter the lock more than once. For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.  \n  \n> [!NOTE]\n>  A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.  \n  \n Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.  \n  \n For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.","nodes":[{"pos":[0,359],"content":"Recursion policy determines the restrictions on threads that enter the lock more than once. For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.","nodes":[{"content":"Recursion policy determines the restrictions on threads that enter the lock more than once. For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.","pos":[0,359],"nodes":[{"content":"Recursion policy determines the restrictions on threads that enter the lock more than once.","pos":[0,91]},{"content":"For example, if a lock was created with <ph id=\"ph1\">&lt;xref:System.Threading.LockRecursionPolicy?displayProperty=fullName&gt;</ph> and a thread has entered the lock in read mode, <ph id=\"ph2\">&lt;xref:System.Threading.LockRecursionException&gt;</ph> is thrown if the thread tries to reenter the lock in read mode.","pos":[92,359],"source":" For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode."}]}]},{"pos":[367,507],"content":"[!NOTE]\n A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.","leadings":["","> "],"nodes":[{"content":"A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.","pos":[9,138]}]},{"pos":[514,712],"content":"Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.","nodes":[{"content":"Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.","pos":[0,198]}]},{"pos":[719,903],"content":"For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.","nodes":[{"content":"For more information about recursion policy and its effects, see the <ph id=\"ph1\">&lt;xref:System.Threading.LockRecursionPolicy&gt;</ph> enumeration and the <ph id=\"ph2\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> class.","pos":[0,184],"source":"For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class."}]}],"pos":[76203,77116],"yaml":true,"extradata":"MT"},{"content":"One of the enumeration values that specifies the lock recursion policy.","nodes":[{"pos":[0,71],"content":"One of the enumeration values that specifies the lock recursion policy.","nodes":[{"content":"One of the enumeration values that specifies the lock recursion policy.","pos":[0,71]}]}],"pos":[77288,77360],"yaml":true},{"content":"Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.","nodes":[{"pos":[0,109],"content":"Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.","nodes":[{"content":"Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.","pos":[0,109]}]}],"pos":[78971,79081],"yaml":true},{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","nodes":[{"pos":[0,248],"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","nodes":[{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","pos":[0,248],"nodes":[{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.","pos":[0,119]},{"content":"The results can change as soon as they have been calculated.","pos":[120,180]},{"content":"Therefore, it is not safe to make decisions based on this property.","pos":[181,248]}]}]}],"pos":[79092,79341],"yaml":true,"extradata":"MT"},{"content":"0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times.","nodes":[{"pos":[0,200],"content":"0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or <bpt id=\"p1\">*</bpt><ph id=\"ph1\">n</ph><ept id=\"p1\">*</ept> if the thread has entered the lock recursively <bpt id=\"p2\">*</bpt><ph id=\"ph2\">n</ph><ept id=\"p2\">*</ept> - 1 times.","source":"0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times."}],"pos":[79459,79660],"yaml":true},{"content":"Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.","nodes":[{"pos":[0,116],"content":"Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.","nodes":[{"content":"Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.","pos":[0,116]}]}],"pos":[81292,81409],"yaml":true},{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","nodes":[{"pos":[0,248],"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","nodes":[{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","pos":[0,248],"nodes":[{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.","pos":[0,119]},{"content":"The results can change as soon as they have been calculated.","pos":[120,180]},{"content":"Therefore, it is not safe to make decisions based on this property.","pos":[181,248]}]}]}],"pos":[81420,81669],"yaml":true,"extradata":"MT"},{"content":"0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times.","nodes":[{"pos":[0,215],"content":"0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or <bpt id=\"p1\">*</bpt><ph id=\"ph1\">n</ph><ept id=\"p1\">*</ept> if the thread has entered upgradeable mode recursively <bpt id=\"p2\">*</bpt><ph id=\"ph2\">n</ph><ept id=\"p2\">*</ept> - 1 times.","source":"0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times."}],"pos":[81790,82006],"yaml":true},{"content":"Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.","nodes":[{"pos":[0,110],"content":"Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.","nodes":[{"content":"Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.","pos":[0,110]}]}],"pos":[83629,83740],"yaml":true},{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","nodes":[{"pos":[0,248],"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","nodes":[{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","pos":[0,248],"nodes":[{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.","pos":[0,119]},{"content":"The results can change as soon as they have been calculated.","pos":[120,180]},{"content":"Therefore, it is not safe to make decisions based on this property.","pos":[181,248]}]}]}],"pos":[83751,84000],"yaml":true,"extradata":"MT"},{"content":"0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times.","nodes":[{"pos":[0,197],"content":"0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or <bpt id=\"p1\">*</bpt><ph id=\"ph1\">n</ph><ept id=\"p1\">*</ept> if the thread has entered write mode recursively <bpt id=\"p2\">*</bpt><ph id=\"ph2\">n</ph><ept id=\"p2\">*</ept> - 1 times.","source":"0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times."}],"pos":[84119,84317],"yaml":true},{"content":"Tries to enter the lock in read mode, with an optional integer time-out.","nodes":[{"pos":[0,72],"content":"Tries to enter the lock in read mode, with an optional integer time-out.","nodes":[{"content":"Tries to enter the lock in read mode, with an optional integer time-out.","pos":[0,72]}]}],"pos":[85981,86054],"yaml":true},{"content":"If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.  \n  \n Multiple threads can enter read mode at the same time.  \n  \n If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.  \n  \n> [!NOTE]\n>  If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.  \n  \n One thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.","nodes":[{"pos":[0,140],"content":"If <ph id=\"ph1\">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id=\"ph2\">`false`</ph> immediately if the desired state is unavailable.","source":"If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable."},{"pos":[147,201],"content":"Multiple threads can enter read mode at the same time.","nodes":[{"content":"Multiple threads can enter read mode at the same time.","pos":[0,54]}]},{"pos":[208,516],"content":"If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.","nodes":[{"content":"If one or more threads are waiting to enter write mode, a thread that calls the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.","pos":[0,308],"source":"If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires."}]},{"pos":[524,698],"content":"[!NOTE]\n If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.","leadings":["","> "],"nodes":[{"content":"If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.","pos":[9,172]}]},{"pos":[705,1035],"content":"One thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.","nodes":[{"content":"One thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.","pos":[0,330],"nodes":[{"content":"One thread can be in upgradeable mode while other threads are in read mode.","pos":[0,75]},{"content":"If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.","pos":[76,330],"source":" If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block."}]}]}],"pos":[86065,87112],"yaml":true,"extradata":"MT"},{"content":"The number of milliseconds to wait, or -1 (<xref href=\"System.Threading.Timeout.Infinite\"></xref>) to wait indefinitely.","nodes":[{"pos":[0,120],"content":"The number of milliseconds to wait, or -1 (<ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph>) to wait indefinitely.","source":"The number of milliseconds to wait, or -1 (<xref href=\"System.Threading.Timeout.Infinite\"></xref>) to wait indefinitely."}],"pos":[87281,87402],"yaml":true},{"content":"`true` if the calling thread entered read mode, otherwise, `false`.","nodes":[{"pos":[0,67],"content":"<ph id=\"ph1\">`true`</ph> if the calling thread entered read mode, otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the calling thread entered read mode, otherwise, `false`."}],"pos":[87460,87530],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock.  \n  \n -or-  \n  \n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"pos":[0,213],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"&gt;&lt;/xref&gt;</ph> property is <ph id=\"ph2\">&lt;xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"&gt;&lt;/xref&gt;</ph> and the current thread has already entered the lock.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock."},{"pos":[220,224],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[231,360],"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","pos":[0,129],"nodes":[{"content":"The recursion number would exceed the capacity of the counter.","pos":[0,62]},{"content":"The limit is so large that applications should never encounter it.","pos":[63,129]}]}]}],"pos":[87736,88107],"yaml":true},{"content":"The value of <code>millisecondsTimeout</code> is negative, but it is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1), which is the only negative value allowed.","nodes":[{"pos":[0,184],"content":"The value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">millisecondsTimeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is negative, but it is not equal to <ph id=\"ph2\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (-1), which is the only negative value allowed.","source":"The value of <code>millisecondsTimeout</code> is negative, but it is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1), which is the only negative value allowed."}],"pos":[88221,88406],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.","nodes":[{"pos":[0,88],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim\"&gt;&lt;/xref&gt;</ph> object has been disposed.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed."}],"pos":[88512,88601],"yaml":true},{"content":"Tries to enter the lock in read mode, with an optional time-out.","nodes":[{"pos":[0,64],"content":"Tries to enter the lock in read mode, with an optional time-out.","nodes":[{"content":"Tries to enter the lock in read mode, with an optional time-out.","pos":[0,64]}]}],"pos":[90195,90260],"yaml":true},{"content":"If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.  \n  \n Multiple threads can enter the lock in read mode at the same time.  \n  \n If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.  \n  \n> [!NOTE]\n>  If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.  \n  \n One thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.","nodes":[{"pos":[0,128],"content":"If <ph id=\"ph1\">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id=\"ph2\">`false`</ph> immediately if the desired state is unavailable.","source":"If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable."},{"pos":[135,201],"content":"Multiple threads can enter the lock in read mode at the same time.","nodes":[{"content":"Multiple threads can enter the lock in read mode at the same time.","pos":[0,66]}]},{"pos":[208,515],"content":"If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.","nodes":[{"content":"If one or more threads are queued to enter write mode, a thread that calls the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.","pos":[0,307],"source":"If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires."}]},{"pos":[523,697],"content":"[!NOTE]\n If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.","leadings":["","> "],"nodes":[{"content":"If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.","pos":[9,172]}]},{"pos":[704,1034],"content":"One thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.","nodes":[{"content":"One thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.","pos":[0,330],"nodes":[{"content":"One thread can be in upgradeable mode while other threads are in read mode.","pos":[0,75]},{"content":"If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A&gt;</ph> method enter read mode immediately and do not block.","pos":[76,330],"source":" If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block."}]}]}],"pos":[90271,91317],"yaml":true,"extradata":"MT"},{"content":"The interval to wait, or -1 milliseconds to wait indefinitely.","nodes":[{"pos":[0,62],"content":"The interval to wait, or -1 milliseconds to wait indefinitely.","nodes":[{"content":"The interval to wait, or -1 milliseconds to wait indefinitely.","pos":[0,62]}]}],"pos":[91470,91533],"yaml":true},{"content":"`true` if the calling thread entered read mode, otherwise, `false`.","nodes":[{"pos":[0,67],"content":"<ph id=\"ph1\">`true`</ph> if the calling thread entered read mode, otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the calling thread entered read mode, otherwise, `false`."}],"pos":[91591,91661],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock.  \n  \n -or-  \n  \n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"pos":[0,213],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"&gt;&lt;/xref&gt;</ph> property is <ph id=\"ph2\">&lt;xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"&gt;&lt;/xref&gt;</ph> and the current thread has already entered the lock.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock."},{"pos":[220,224],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[231,360],"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","pos":[0,129],"nodes":[{"content":"The recursion number would exceed the capacity of the counter.","pos":[0,62]},{"content":"The limit is so large that applications should never encounter it.","pos":[63,129]}]}]}],"pos":[91867,92238],"yaml":true},{"content":"The value of <code>timeout</code> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  \n  \n -or-  \n  \n The value of <code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref> milliseconds.","nodes":[{"pos":[0,128],"content":"The value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.","source":"The value of <code>timeout</code> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,252],"content":"The value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph> milliseconds.","source":"The value of <code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref> milliseconds."}],"pos":[92352,92613],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.","nodes":[{"pos":[0,88],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim\"&gt;&lt;/xref&gt;</ph> object has been disposed.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed."}],"pos":[92719,92808],"yaml":true},{"content":"Tries to enter the lock in upgradeable mode, with an optional time-out.","nodes":[{"pos":[0,71],"content":"Tries to enter the lock in upgradeable mode, with an optional time-out.","nodes":[{"content":"Tries to enter the lock in upgradeable mode, with an optional time-out.","pos":[0,71]}]}],"pos":[94450,94522],"yaml":true},{"content":"If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.  \n  \n Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.  \n  \n Only one thread can enter a lock in upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.  \n  \n If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.  \n  \n> [!NOTE]\n>  If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.","nodes":[{"pos":[0,140],"content":"If <ph id=\"ph1\">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id=\"ph2\">`false`</ph> immediately if the desired state is unavailable.","source":"If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable."},{"pos":[147,441],"content":"Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.","nodes":[{"content":"Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.","pos":[0,294],"nodes":[{"content":"Use upgradeable mode when a thread usually accesses the resource that is protected by the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.","pos":[0,212],"source":"Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met."},{"content":"A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.","pos":[213,294]}]}]},{"pos":[448,719],"content":"Only one thread can enter a lock in upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.","nodes":[{"content":"Only one thread can enter a lock in upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.","pos":[0,271],"nodes":[{"content":"Only one thread can enter a lock in upgradeable mode at any given time.","pos":[0,71]},{"content":"If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.","pos":[72,271]}]}]},{"pos":[726,1045],"content":"If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.","nodes":[{"content":"If one or more threads are waiting to enter write mode, a thread that calls the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.","pos":[0,319],"source":"If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires."}]},{"pos":[1053,1241],"content":"[!NOTE]\n If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.","leadings":["","> "],"nodes":[{"content":"If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.","pos":[9,186]}]}],"pos":[94533,95786],"yaml":true,"extradata":"MT"},{"content":"The number of milliseconds to wait, or -1 (<xref href=\"System.Threading.Timeout.Infinite\"></xref>) to wait indefinitely.","nodes":[{"pos":[0,120],"content":"The number of milliseconds to wait, or -1 (<ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph>) to wait indefinitely.","source":"The number of milliseconds to wait, or -1 (<xref href=\"System.Threading.Timeout.Infinite\"></xref>) to wait indefinitely."}],"pos":[95966,96087],"yaml":true},{"content":"`true` if the calling thread entered upgradeable mode, otherwise, `false`.","nodes":[{"pos":[0,74],"content":"<ph id=\"ph1\">`true`</ph> if the calling thread entered upgradeable mode, otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the calling thread entered upgradeable mode, otherwise, `false`."}],"pos":[96145,96222],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock.  \n  \n -or-  \n  \n The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  \n  \n -or-  \n  \n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"pos":[0,213],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"&gt;&lt;/xref&gt;</ph> property is <ph id=\"ph2\">&lt;xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"&gt;&lt;/xref&gt;</ph> and the current thread has already entered the lock.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock."},{"pos":[220,224],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[231,381],"content":"The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.","nodes":[{"content":"The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.","pos":[0,150]}]},{"pos":[388,392],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[399,528],"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","pos":[0,129],"nodes":[{"content":"The recursion number would exceed the capacity of the counter.","pos":[0,62]},{"content":"The limit is so large that applications should never encounter it.","pos":[63,129]}]}]}],"pos":[96439,96982],"yaml":true},{"content":"The value of <code>millisecondsTimeout</code> is negative, but it is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1), which is the only negative value allowed.","nodes":[{"pos":[0,184],"content":"The value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">millisecondsTimeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is negative, but it is not equal to <ph id=\"ph2\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (-1), which is the only negative value allowed.","source":"The value of <code>millisecondsTimeout</code> is negative, but it is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1), which is the only negative value allowed."}],"pos":[97096,97281],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.","nodes":[{"pos":[0,88],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim\"&gt;&lt;/xref&gt;</ph> object has been disposed.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed."}],"pos":[97387,97476],"yaml":true},{"content":"Tries to enter the lock in upgradeable mode, with an optional time-out.","nodes":[{"pos":[0,71],"content":"Tries to enter the lock in upgradeable mode, with an optional time-out.","nodes":[{"content":"Tries to enter the lock in upgradeable mode, with an optional time-out.","pos":[0,71]}]}],"pos":[99136,99208],"yaml":true},{"content":"If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.  \n  \n Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.  \n  \n Only one thread can enter a lock in upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.  \n  \n If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.  \n  \n> [!NOTE]\n>  If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.","nodes":[{"pos":[0,128],"content":"If <ph id=\"ph1\">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id=\"ph2\">`false`</ph> immediately if the desired state is unavailable.","source":"If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable."},{"pos":[135,421],"content":"Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.","nodes":[{"content":"Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.","pos":[0,286],"nodes":[{"content":"Use upgradeable mode when a thread usually accesses the resource protected by the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim&gt;</ph> in read mode, but may need to enter write mode if certain conditions are met.","pos":[0,204],"source":"Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met."},{"content":"A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.","pos":[205,286]}]}]},{"pos":[428,699],"content":"Only one thread can enter a lock in upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.","nodes":[{"content":"Only one thread can enter a lock in upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.","pos":[0,271],"nodes":[{"content":"Only one thread can enter a lock in upgradeable mode at any given time.","pos":[0,71]},{"content":"If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.","pos":[72,271]}]}]},{"pos":[706,1025],"content":"If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.","nodes":[{"content":"If one or more threads are waiting to enter write mode, a thread that calls the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A&gt;</ph> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.","pos":[0,319],"source":"If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires."}]},{"pos":[1033,1221],"content":"[!NOTE]\n If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.","leadings":["","> "],"nodes":[{"content":"If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.","pos":[9,186]}]}],"pos":[99219,100452],"yaml":true,"extradata":"MT"},{"content":"The interval to wait, or -1 milliseconds to wait indefinitely.","nodes":[{"pos":[0,62],"content":"The interval to wait, or -1 milliseconds to wait indefinitely.","nodes":[{"content":"The interval to wait, or -1 milliseconds to wait indefinitely.","pos":[0,62]}]}],"pos":[100616,100679],"yaml":true},{"content":"`true` if the calling thread entered upgradeable mode, otherwise, `false`.","nodes":[{"pos":[0,74],"content":"<ph id=\"ph1\">`true`</ph> if the calling thread entered upgradeable mode, otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the calling thread entered upgradeable mode, otherwise, `false`."}],"pos":[100737,100814],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock.  \n  \n -or-  \n  \n The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  \n  \n -or-  \n  \n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"pos":[0,213],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"&gt;&lt;/xref&gt;</ph> property is <ph id=\"ph2\">&lt;xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"&gt;&lt;/xref&gt;</ph> and the current thread has already entered the lock.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock."},{"pos":[220,224],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[231,381],"content":"The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.","nodes":[{"content":"The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.","pos":[0,150]}]},{"pos":[388,392],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[399,528],"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","pos":[0,129],"nodes":[{"content":"The recursion number would exceed the capacity of the counter.","pos":[0,62]},{"content":"The limit is so large that applications should never encounter it.","pos":[63,129]}]}]}],"pos":[101031,101574],"yaml":true},{"content":"The value of <code>timeout</code> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  \n  \n -or-  \n  \n The value of <code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref> milliseconds.","nodes":[{"pos":[0,128],"content":"The value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.","source":"The value of <code>timeout</code> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,252],"content":"The value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph> milliseconds.","source":"The value of <code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref> milliseconds."}],"pos":[101688,101949],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.","nodes":[{"pos":[0,88],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim\"&gt;&lt;/xref&gt;</ph> object has been disposed.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed."}],"pos":[102055,102144],"yaml":true},{"content":"Tries to enter the lock in write mode, with an optional time-out.","nodes":[{"pos":[0,65],"content":"Tries to enter the lock in write mode, with an optional time-out.","nodes":[{"content":"Tries to enter the lock in write mode, with an optional time-out.","pos":[0,65]}]}],"pos":[103726,103792],"yaml":true},{"content":"If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.  \n  \n If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed. While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.  \n  \n> [!NOTE]\n>  If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.","nodes":[{"pos":[0,140],"content":"If <ph id=\"ph1\">`millisecondsTimeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id=\"ph2\">`false`</ph> immediately if the desired state is unavailable.","source":"If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable."},{"pos":[147,636],"content":"If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed. While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.","nodes":[{"content":"If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed. While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.","pos":[0,489],"nodes":[{"content":"If other threads have entered the lock in read mode, a thread that calls the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode or until the time-out interval has elapsed.","pos":[0,242],"source":"If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed."},{"content":"While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.","pos":[243,489]}]}]},{"pos":[644,820],"content":"[!NOTE]\n If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.","leadings":["","> "],"nodes":[{"content":"If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.","pos":[9,174]}]}],"pos":[103803,104631],"yaml":true,"extradata":"MT"},{"content":"The number of milliseconds to wait, or -1 (<xref href=\"System.Threading.Timeout.Infinite\"></xref>) to wait indefinitely.","nodes":[{"pos":[0,120],"content":"The number of milliseconds to wait, or -1 (<ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph>) to wait indefinitely.","source":"The number of milliseconds to wait, or -1 (<xref href=\"System.Threading.Timeout.Infinite\"></xref>) to wait indefinitely."}],"pos":[106371,106492],"yaml":true},{"content":"`true` if the calling thread entered write mode, otherwise, `false`.","nodes":[{"pos":[0,68],"content":"<ph id=\"ph1\">`true`</ph> if the calling thread entered write mode, otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the calling thread entered write mode, otherwise, `false`."}],"pos":[106550,106621],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock.  \n  \n -or-  \n  \n The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  \n  \n -or-  \n  \n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"pos":[0,213],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"&gt;&lt;/xref&gt;</ph> property is <ph id=\"ph2\">&lt;xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"&gt;&lt;/xref&gt;</ph> and the current thread has already entered the lock.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock."},{"pos":[220,224],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[231,375],"content":"The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.","nodes":[{"content":"The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.","pos":[0,144]}]},{"pos":[382,386],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[393,522],"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","pos":[0,129],"nodes":[{"content":"The recursion number would exceed the capacity of the counter.","pos":[0,62]},{"content":"The limit is so large that applications should never encounter it.","pos":[63,129]}]}]}],"pos":[106828,107365],"yaml":true},{"content":"The value of <code>millisecondsTimeout</code> is negative, but it is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1), which is the only negative value allowed.","nodes":[{"pos":[0,184],"content":"The value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">millisecondsTimeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is negative, but it is not equal to <ph id=\"ph2\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (-1), which is the only negative value allowed.","source":"The value of <code>millisecondsTimeout</code> is negative, but it is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1), which is the only negative value allowed."}],"pos":[107479,107664],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.","nodes":[{"pos":[0,88],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim\"&gt;&lt;/xref&gt;</ph> object has been disposed.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed."}],"pos":[107770,107859],"yaml":true},{"content":"Tries to enter the lock in write mode, with an optional time-out.","nodes":[{"pos":[0,65],"content":"Tries to enter the lock in write mode, with an optional time-out.","nodes":[{"content":"Tries to enter the lock in write mode, with an optional time-out.","pos":[0,65]}]}],"pos":[109459,109525],"yaml":true},{"content":"If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.  \n  \n If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed. While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.  \n  \n> [!NOTE]\n>  If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.","nodes":[{"pos":[0,128],"content":"If <ph id=\"ph1\">`timeout`</ph> is 0 (zero), this method checks the lock state and returns <ph id=\"ph2\">`false`</ph> immediately if the desired state is unavailable.","source":"If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable."},{"pos":[135,624],"content":"If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed. While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.","nodes":[{"content":"If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed. While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.","pos":[0,489],"nodes":[{"content":"If other threads have entered the lock in read mode, a thread that calls the <ph id=\"ph1\">&lt;xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A&gt;</ph> method blocks until those threads have exited read mode or until the time-out interval has elapsed.","pos":[0,242],"source":"If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed."},{"content":"While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.","pos":[243,489]}]}]},{"pos":[632,808],"content":"[!NOTE]\n If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.","leadings":["","> "],"nodes":[{"content":"If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.","pos":[9,174]}]}],"pos":[109536,110352],"yaml":true,"extradata":"MT"},{"content":"The interval to wait, or -1 milliseconds to wait indefinitely.","nodes":[{"pos":[0,62],"content":"The interval to wait, or -1 milliseconds to wait indefinitely.","nodes":[{"content":"The interval to wait, or -1 milliseconds to wait indefinitely.","pos":[0,62]}]}],"pos":[110506,110569],"yaml":true},{"content":"`true` if the calling thread entered write mode, otherwise, `false`.","nodes":[{"pos":[0,68],"content":"<ph id=\"ph1\">`true`</ph> if the calling thread entered write mode, otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the calling thread entered write mode, otherwise, `false`."}],"pos":[110627,110698],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock.  \n  \n -or-  \n  \n The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  \n  \n -or-  \n  \n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"pos":[0,213],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"&gt;&lt;/xref&gt;</ph> property is <ph id=\"ph2\">&lt;xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"&gt;&lt;/xref&gt;</ph> and the current thread has already entered the lock.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\"></xref> property is <xref href=\"System.Threading.LockRecursionPolicy.NoRecursion\"></xref> and the current thread has already entered the lock."},{"pos":[220,224],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[231,375],"content":"The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.","nodes":[{"content":"The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.","pos":[0,144]}]},{"pos":[382,386],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[393,522],"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","nodes":[{"content":"The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.","pos":[0,129],"nodes":[{"content":"The recursion number would exceed the capacity of the counter.","pos":[0,62]},{"content":"The limit is so large that applications should never encounter it.","pos":[63,129]}]}]}],"pos":[110905,111442],"yaml":true},{"content":"The value of <code>timeout</code> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  \n  \n -or-  \n  \n The value of <code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref> milliseconds.","nodes":[{"pos":[0,128],"content":"The value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.","source":"The value of <code>timeout</code> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,252],"content":"The value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph> milliseconds.","source":"The value of <code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref> milliseconds."}],"pos":[111556,111817],"yaml":true},{"content":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.","nodes":[{"pos":[0,88],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.ReaderWriterLockSlim\"&gt;&lt;/xref&gt;</ph> object has been disposed.","source":"The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed."}],"pos":[111923,112012],"yaml":true},{"content":"Gets the total number of threads that are waiting to enter the lock in read mode.","nodes":[{"pos":[0,81],"content":"Gets the total number of threads that are waiting to enter the lock in read mode.","nodes":[{"content":"Gets the total number of threads that are waiting to enter the lock in read mode.","pos":[0,81]}]}],"pos":[113527,113609],"yaml":true},{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","nodes":[{"pos":[0,248],"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","nodes":[{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","pos":[0,248],"nodes":[{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.","pos":[0,119]},{"content":"The results can change as soon as they have been calculated.","pos":[120,180]},{"content":"Therefore, it is not safe to make decisions based on this property.","pos":[181,248]}]}]}],"pos":[113620,113869],"yaml":true,"extradata":"MT"},{"content":"The total number of threads that are waiting to enter read mode.","nodes":[{"pos":[0,64],"content":"The total number of threads that are waiting to enter read mode.","nodes":[{"content":"The total number of threads that are waiting to enter read mode.","pos":[0,64]}]}],"pos":[114930,114995],"yaml":true},{"content":"Gets the total number of threads that are waiting to enter the lock in upgradeable mode.","nodes":[{"pos":[0,88],"content":"Gets the total number of threads that are waiting to enter the lock in upgradeable mode.","nodes":[{"content":"Gets the total number of threads that are waiting to enter the lock in upgradeable mode.","pos":[0,88]}]}],"pos":[116613,116702],"yaml":true},{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","nodes":[{"pos":[0,248],"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","nodes":[{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","pos":[0,248],"nodes":[{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.","pos":[0,119]},{"content":"The results can change as soon as they have been calculated.","pos":[120,180]},{"content":"Therefore, it is not safe to make decisions based on this property.","pos":[181,248]}]}]}],"pos":[116713,116962],"yaml":true,"extradata":"MT"},{"content":"The total number of threads that are waiting to enter upgradeable mode.","nodes":[{"pos":[0,71],"content":"The total number of threads that are waiting to enter upgradeable mode.","nodes":[{"content":"The total number of threads that are waiting to enter upgradeable mode.","pos":[0,71]}]}],"pos":[118036,118108],"yaml":true},{"content":"Gets the total number of threads that are waiting to enter the lock in write mode.","nodes":[{"pos":[0,82],"content":"Gets the total number of threads that are waiting to enter the lock in write mode.","nodes":[{"content":"Gets the total number of threads that are waiting to enter the lock in write mode.","pos":[0,82]}]}],"pos":[119717,119800],"yaml":true},{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","nodes":[{"pos":[0,248],"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","nodes":[{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.","pos":[0,248],"nodes":[{"content":"Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm.","pos":[0,119]},{"content":"The results can change as soon as they have been calculated.","pos":[120,180]},{"content":"Therefore, it is not safe to make decisions based on this property.","pos":[181,248]}]}]}],"pos":[119811,120060],"yaml":true,"extradata":"MT"},{"content":"The total number of threads that are waiting to enter write mode.","nodes":[{"pos":[0,65],"content":"The total number of threads that are waiting to enter write mode.","nodes":[{"content":"The total number of threads that are waiting to enter write mode.","pos":[0,65]}]}],"pos":[121124,121190],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.ReaderWriterLockSlim\n  commentId: T:System.Threading.ReaderWriterLockSlim\n  id: ReaderWriterLockSlim\n  children:\n  - System.Threading.ReaderWriterLockSlim.#ctor\n  - System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)\n  - System.Threading.ReaderWriterLockSlim.CurrentReadCount\n  - System.Threading.ReaderWriterLockSlim.Dispose\n  - System.Threading.ReaderWriterLockSlim.EnterReadLock\n  - System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock\n  - System.Threading.ReaderWriterLockSlim.EnterWriteLock\n  - System.Threading.ReaderWriterLockSlim.ExitReadLock\n  - System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock\n  - System.Threading.ReaderWriterLockSlim.ExitWriteLock\n  - System.Threading.ReaderWriterLockSlim.IsReadLockHeld\n  - System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n  - System.Threading.ReaderWriterLockSlim.IsWriteLockHeld\n  - System.Threading.ReaderWriterLockSlim.RecursionPolicy\n  - System.Threading.ReaderWriterLockSlim.RecursiveReadCount\n  - System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount\n  - System.Threading.ReaderWriterLockSlim.RecursiveWriteCount\n  - System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)\n  - System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)\n  - System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)\n  - System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)\n  - System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)\n  - System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)\n  - System.Threading.ReaderWriterLockSlim.WaitingReadCount\n  - System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount\n  - System.Threading.ReaderWriterLockSlim.WaitingWriteCount\n  langs:\n  - csharp\n  name: ReaderWriterLockSlim\n  nameWithType: ReaderWriterLockSlim\n  fullName: System.Threading.ReaderWriterLockSlim\n  type: Class\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Represents a lock that is used to manage access to a resource, allowing multiple threads for reading or exclusive access for writing.\n  remarks: \"Use <xref:System.Threading.ReaderWriterLockSlim> to protect a resource that is read by multiple threads and written to by one thread at a time. <xref:System.Threading.ReaderWriterLockSlim> allows multiple threads to be in read mode, allows one thread to be in write mode with exclusive ownership of the lock, and allows one thread that has read access to be in upgradeable read mode, from which the thread can upgrade to write mode without having to relinquish its read access to the resource.  \\n  \\n> [!NOTE]\\n>  <xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state. <xref:System.Threading.ReaderWriterLockSlim>avoids many cases of potential deadlock. In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>. <xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.  \\n  \\n By default, new instances of <xref:System.Threading.ReaderWriterLockSlim> are created with the <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> flag and do not allow recursion. This default policy is recommended for all new development, because recursion introduces unnecessary complications and makes your code more prone to deadlocks. To simplify migration from existing projects that use <xref:System.Threading.Monitor> or <xref:System.Threading.ReaderWriterLock>, you can use the <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> flag to create instances of <xref:System.Threading.ReaderWriterLockSlim> that allow recursion.  \\n  \\n A thread can enter the lock in three modes: read mode, write mode, and upgradeable read mode. (In the rest of this topic, \\\"upgradeable read mode\\\" is referred to as \\\"upgradeable mode\\\", and the phrase \\\"enter `x` mode\\\" is used in preference to the longer phrase \\\"enter the lock in `x` mode\\\".)  \\n  \\n Regardless of recursion policy, only one thread can be in write mode at any time. When a thread is in write mode, no other thread can enter the lock in any mode. Only one thread can be in upgradeable mode at any time. Any number of threads can be in read mode, and there can be one thread in upgradeable mode while other threads are in read mode.  \\n  \\n> [!IMPORTANT]\\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \\\"Using an Object that Implements IDisposable\\\" section in the <xref:System.IDisposable> interface topic.  \\n  \\n <xref:System.Threading.ReaderWriterLockSlim> has managed thread affinity; that is, each <xref:System.Threading.Thread> object must make its own method calls to enter and exit lock modes. No thread can change the mode of another thread.  \\n  \\n If a <xref:System.Threading.ReaderWriterLockSlim> does not allow recursion, a thread that tries to enter the lock can block for several reasons:  \\n  \\n-   A thread that tries to enter read mode blocks if there are threads waiting to enter write mode or if there is a single thread in write mode.  \\n  \\n    > [!NOTE]\\n    >  Blocking new readers when writers are queued is a lock fairness policy that favors writers. The current fairness policy balances fairness to readers and writers, to promote throughput in the most common scenarios. Future versions of the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] may introduce new fairness policies.  \\n  \\n-   A thread that tries to enter upgradeable mode blocks if there is already a thread in upgradeable mode, if there are threads waiting to enter write mode, or if there is a single thread in write mode.  \\n  \\n-   A thread that tries to enter write mode blocks if there is a thread in any of the three modes.  \\n  \\n## Upgrading and Downgrading Locks  \\n Upgradeable mode is intended for cases where a thread usually reads from the protected resource, but might need to write to it if some condition is met. A thread that has entered a <xref:System.Threading.ReaderWriterLockSlim> in upgradeable mode has read access to the protected resource, and can upgrade to write mode by calling the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> methods. Because there can be only one thread in upgradeable mode at a time, upgrading to write mode cannot deadlock when recursion is not allowed, which is the default policy.  \\n  \\n> [!IMPORTANT]\\n>  Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks. For example, if two threads in read mode both try to enter write mode, they will deadlock. Upgradeable mode is designed to avoid such deadlocks.  \\n  \\n If there are other threads in read mode, the thread that is upgrading blocks. While the thread is blocked, other threads that try to enter read mode are blocked. When all threads have exited from read mode, the blocked upgradeable thread enters write mode. If there are other threads waiting to enter write mode, they remain blocked, because the single thread that is in upgradeable mode prevents them from gaining exclusive access to the resource.  \\n  \\n When the thread in upgradeable mode exits write mode, other threads that are waiting to enter read mode can do so, unless there are threads waiting to enter write mode. The thread in upgradeable mode can upgrade and downgrade indefinitely, as long as it is the only thread that writes to the protected resource.  \\n  \\n> [!IMPORTANT]\\n>  If you allow multiple threads to enter write mode or upgradeable mode, you must not allow one thread to monopolize upgradeable mode. Otherwise, threads that try to enter write mode directly will be blocked indefinitely, and while they are blocked, other threads will be unable to enter read mode.  \\n  \\n A thread in upgradeable mode can downgrade to read mode by first calling the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method and then calling the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method. This downgrade pattern is allowed for all lock recursion policies, even <xref:System.Threading.LockRecursionPolicy.NoRecursion>.  \\n  \\n After downgrading to read mode, a thread cannot reenter upgradeable mode until it has exited from read mode.  \\n  \\n## Entering the Lock Recursively  \\n You can create a <xref:System.Threading.ReaderWriterLockSlim> that supports recursive lock entry by using the <xref:System.Threading.ReaderWriterLockSlim.%23ctor%28System.Threading.LockRecursionPolicy%29> constructor that specifies lock policy, and specifying <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName>.  \\n  \\n> [!NOTE]\\n>  The use of recursion is not recommended for new development, because it introduces unnecessary complications and makes your code more prone to deadlocks.  \\n  \\n For a <xref:System.Threading.ReaderWriterLockSlim> that allows recursion, the following can be said about the modes a thread can enter:  \\n  \\n-   A thread in read mode can enter read mode recursively, but cannot enter write mode or upgradeable mode. If it tries to do this, a <xref:System.Threading.LockRecursionException> is thrown. Entering read mode and then entering write mode or upgradeable mode is a pattern with a strong probability of deadlocks, so it is not allowed. As discussed earlier, upgradeable mode is provided for cases where it is necessary to upgrade a lock.  \\n  \\n-   A thread in upgradeable mode can enter write mode and/or read mode, and can enter any of the three modes recursively. However, an attempt to enter write mode blocks if there are other threads in read mode.  \\n  \\n-   A thread in write mode can enter read mode and/or upgradeable mode, and can enter any of the three modes recursively.  \\n  \\n-   A thread that has not entered the lock can enter any mode. This attempt can block for the same reasons as an attempt to enter a non-recursive lock.  \\n  \\n A thread can exit the modes it has entered in any order, as long as it exits each mode exactly as many times as it entered that mode. If a thread tries to exit a mode too many times, or to exit a mode it has not entered, a <xref:System.Threading.SynchronizationLockException> is thrown.  \\n  \\n## Lock States  \\n You may find it useful to think of the lock in terms of its states. A <xref:System.Threading.ReaderWriterLockSlim> can be in one of four states: not entered, read, upgrade, and write.  \\n  \\n-   Not entered: In this state, no threads have entered the lock (or all threads have exited the lock).  \\n  \\n-   Read: In this state, one or more threads have entered the lock for read access to the protected resource.  \\n  \\n    > [!NOTE]\\n    >  A thread can enter the lock in read mode by using the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> or <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> methods, or by downgrading from upgradeable mode.  \\n  \\n-   Upgrade: In this state, one thread has entered the lock for read access with the option to upgrade to write access (that is, in upgradeable mode), and zero or more threads have entered the lock for read access. No more than one thread at a time can enter the lock with the option to upgrade; additional threads that try to enter upgradeable mode are blocked.  \\n  \\n-   Write: In this state, one thread has entered the lock for write access to the protected resource. That thread has exclusive possession of the lock. Any other thread that tries to enter the lock for any reason is blocked.  \\n  \\n The following table describes the transitions between lock states, for locks that do not allow recursion, when a thread `t` takes the action described in the leftmost column. At the time it takes the action, `t` has no mode. (The special case where `t` is in upgradeable mode is described in the table footnotes.) The top row describes the starting state of the lock. The cells describe what happens to the thread, and show changes to the lock state in parentheses.  \\n  \\n||Not entered (N)|Read (R)|Upgrade (U)|Write (W)|  \\n|-|-----------------------|----------------|-------------------|-----------------|  \\n|`t` enters read mode|`t` enters (R).|`t` blocks if threads are waiting for write mode; otherwise, `t` enters.|`t` blocks if threads are waiting for write mode; otherwise, `t` enters.<sup>1</sup>|`t` blocks.|  \\n|`t` enters upgradeable mode|`t` enters (U).|`t` blocks if threads are waiting for write mode or upgrade mode; otherwise, `t` enters (U).|`t` blocks.|`t` blocks.|  \\n|`t` enters write mode|`t` enters (W).|`t` blocks.|`t` blocks.<sup>2</sup>|`t` blocks.|  \\n  \\n <sup>1</sup> If `t` starts out in upgradeable mode, it enters read mode. This action never blocks. The lock state does not change. (The thread can then complete a downgrade to read mode by exiting upgradeable mode.)  \\n  \\n <sup>2</sup> If `t` starts out in upgradeable mode, it blocks if there are threads in read mode. Otherwise it upgrades to write mode. The lock state changes to Write (W). If `t` blocks because there are threads in read mode, it enters write mode as soon as the last thread exits read mode, even if there are threads waiting to enter write mode.  \\n  \\n When a state change occurs because a thread exits the lock, the next thread to be awakened is selected as follows:  \\n  \\n-   First, a thread that is waiting for write mode and is already in upgradeable mode (there can be at most one such thread).  \\n  \\n-   Failing that, a thread that is waiting for write mode.  \\n  \\n-   Failing that, a thread that is waiting for upgradeable mode.  \\n  \\n-   Failing that, all threads that are waiting for read mode.  \\n  \\n The subsequent state of the lock is always Write (W) in the first two cases and Upgrade (U) in the third case, regardless of the state of the lock when the exiting thread triggered the state change. In the last case, the state of the lock is Upgrade (U) if there is a thread in upgradeable mode after the state change, and Read (R) otherwise, regardless of the prior state.\"\n  example:\n  - \"The following example shows a simple synchronized cache that holds strings with integer keys. An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache.  \\n  \\n The example includes simple methods to add to the cache, delete from the cache, and read from the cache. To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.  \\n  \\n To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.  \\n  \\n The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.  \\n  \\n The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  \\n  \\n The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string \\\"cucumber\\\" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string \\\"green bean\\\".  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]\"\n  syntax:\n    content: 'public class ReaderWriterLockSlim : IDisposable'\n  inheritance:\n  - System.Object\n  implements:\n  - System.IDisposable\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.#ctor\n  commentId: M:System.Threading.ReaderWriterLockSlim.#ctor\n  id: '#ctor'\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: ReaderWriterLockSlim()\n  nameWithType: ReaderWriterLockSlim.ReaderWriterLockSlim()\n  fullName: ReaderWriterLockSlim.ReaderWriterLockSlim()\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> class with default property values.\n  remarks: \"A <xref:System.Threading.ReaderWriterLockSlim> that is initialized with this constructor does not allow recursion. That is, the <xref:System.Threading.ReaderWriterLockSlim.RecursionPolicy%2A> property returns <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName>.  \\n  \\n For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.\"\n  example:\n  - \"The following example shows a simple synchronized cache that holds strings with integer keys. An instance of <xref:System.Threading.ReaderWriterLockSlim> is used to synchronize access to the <xref:System.Collections.Generic.Dictionary%602> that serves as the inner cache. The parameterless constructor is used to create the lock.  \\n  \\n The example includes simple methods to add to the cache, delete from the cache, and read from the cache. To demonstrate time-outs, the example includes a method that adds to the cache only if it can do so within a specified time-out.  \\n  \\n To demonstrate upgradeable mode, the example includes a method that retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade from read access to write access as needed, without the risk of deadlocks.  \\n  \\n The example includes a nested enumeration that specifies the return values for the method that demonstrates upgradeable mode.  \\n  \\n The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#12)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#12)]  \\n  \\n The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string \\\"cucumber\\\" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string \\\"green bean\\\".  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#11)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#11)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/classexample1.cs#13)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/classexample1.vb#13)]\"\n  syntax:\n    content: public ReaderWriterLockSlim ();\n    parameters: []\n  overload: System.Threading.ReaderWriterLockSlim.#ctor*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)\n  commentId: M:System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)\n  id: '#ctor(System.Threading.LockRecursionPolicy)'\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: ReaderWriterLockSlim(LockRecursionPolicy)\n  nameWithType: ReaderWriterLockSlim.ReaderWriterLockSlim(LockRecursionPolicy)\n  fullName: ReaderWriterLockSlim.ReaderWriterLockSlim(LockRecursionPolicy)\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> class, specifying the lock recursion policy.\n  remarks: \"Recursion policy determines the restrictions on threads that enter the lock more than once. For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode. Similarly, if a thread has entered the lock in write mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in any mode.  \\n  \\n> [!NOTE]\\n>  A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.  \\n  \\n Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.  \\n  \\n For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.\"\n  example:\n  - \"The following example shows two exception scenarios, one that depends on the <xref:System.Threading.LockRecursionPolicy> setting and one that does not.  \\n  \\n In the first scenario, the thread enters read mode and then tries to enter read mode recursively. If the <xref:System.Threading.ReaderWriterLockSlim> is created by using the default constructor, which sets recursion policy to <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName>, an exception is thrown. If <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> is used to create the <xref:System.Threading.ReaderWriterLockSlim>, no exception is thrown.  \\n  \\n In the second scenario, the thread enters read mode and then tries to enter write mode. <xref:System.Threading.LockRecursionException> is thrown regardless of the lock recursion policy.  \\n  \\n[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] \\n[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   \\n[!code-csharp[System.Threading.LockRecursionPolicy#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#12)] \\n[!code-vb[System.Threading.LockRecursionPolicy#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#12)]  \\n  \\n The following code then uses the `SynchronizedCache` object to store a dictionary of vegetable names. It creates three tasks. The first writes the names of vegetables stored in an array to a `SynchronizedCache` instance. The second and third task display the names of the vegetables, the first in ascending order (from low index to high index), the second in descending order. The final task searches for the string \\\"cucumber\\\" and, when it finds it, calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method  to substitute the string \\\"green bean\\\".  \\n  \\n[!code-csharp[System.Threading.LockRecursionPolicy#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#11)] \\n[!code-vb[System.Threading.LockRecursionPolicy#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#11)]   \\n[!code-csharp[System.Threading.LockRecursionPolicy#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/cs/ClassExample1.cs#13)] \\n[!code-vb[System.Threading.LockRecursionPolicy#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.LockRecursionPolicy/vb/ClassExample1.vb#13)]\"\n  syntax:\n    content: public ReaderWriterLockSlim (System.Threading.LockRecursionPolicy recursionPolicy);\n    parameters:\n    - id: recursionPolicy\n      type: System.Threading.LockRecursionPolicy\n      description: One of the enumeration values that specifies the lock recursion policy.\n  overload: System.Threading.ReaderWriterLockSlim.#ctor*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.CurrentReadCount\n  commentId: P:System.Threading.ReaderWriterLockSlim.CurrentReadCount\n  id: CurrentReadCount\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: CurrentReadCount\n  nameWithType: ReaderWriterLockSlim.CurrentReadCount\n  fullName: ReaderWriterLockSlim.CurrentReadCount\n  type: Property\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Gets the total number of unique threads that have entered the lock in read mode.\n  remarks: \"A thread is counted only once, even if the lock allows recursion and the thread has entered read mode multiple times.  \\n  \\n Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.\"\n  example:\n  - \"The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.CurrentReadCount%2A> property to generate an event log entry if the number of threads in read mode exceeds a threshold.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#2)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#2)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#11)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#11)]\"\n  syntax:\n    content: public int CurrentReadCount { get; }\n    return:\n      type: System.Int32\n      description: The number of unique threads that have entered the lock in read mode.\n  overload: System.Threading.ReaderWriterLockSlim.CurrentReadCount*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.Dispose\n  commentId: M:System.Threading.ReaderWriterLockSlim.Dispose\n  id: Dispose\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: Dispose()\n  nameWithType: ReaderWriterLockSlim.Dispose()\n  fullName: ReaderWriterLockSlim.Dispose()\n  type: Method\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Releases all resources used by the current instance of the <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> class.\n  remarks: \"Call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> when you are finished using the <xref:System.Threading.ReaderWriterLockSlim>. The <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> method leaves the <xref:System.Threading.ReaderWriterLockSlim> in an unusable state. After calling <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A>, you must release all references to the <xref:System.Threading.ReaderWriterLockSlim> so the garbage collector can reclaim the memory that the <xref:System.Threading.ReaderWriterLockSlim> was occupying. For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  \\n  \\n> [!NOTE]\\n>  Always call <xref:System.Threading.ReaderWriterLockSlim.Dispose%2A> before you release your last reference to the <xref:System.Threading.ReaderWriterLockSlim> object.\"\n  syntax:\n    content: public void Dispose ();\n    parameters: []\n  overload: System.Threading.ReaderWriterLockSlim.Dispose*\n  exceptions:\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: \"<xref href=\\\"System.Threading.ReaderWriterLockSlim.WaitingReadCount\\\"></xref> is greater than zero.  \\n  \\n -or-  \\n  \\n <xref href=\\\"System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount\\\"></xref> is greater than zero.  \\n  \\n -or-  \\n  \\n <xref href=\\\"System.Threading.ReaderWriterLockSlim.WaitingWriteCount\\\"></xref> is greater than zero.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.EnterReadLock\n  commentId: M:System.Threading.ReaderWriterLockSlim.EnterReadLock\n  id: EnterReadLock\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: EnterReadLock()\n  nameWithType: ReaderWriterLockSlim.EnterReadLock()\n  fullName: ReaderWriterLockSlim.EnterReadLock()\n  type: Method\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Tries to enter the lock in read mode.\n  remarks: \"This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered read mode during that interval.  \\n  \\n Multiple threads can enter read mode at the same time.  \\n  \\n If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.  \\n  \\n> [!NOTE]\\n>  If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.  \\n  \\n At most one thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method enter read mode immediately and do not block.\"\n  example:\n  - \"The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method to enter the lock in read mode. The method shown in the example retrieves the value associated with a key. If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method. A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]\"\n  syntax:\n    content: public void EnterReadLock ();\n    parameters: []\n  overload: System.Threading.ReaderWriterLockSlim.EnterReadLock*\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"The current thread cannot acquire the write lock when it holds the read lock.  \\n  \\n -or-  \\n  \\n The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\"></xref>, and the current thread has attempted to acquire the read lock when it already holds the read lock.  \\n  \\n -or-  \\n  \\n The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\"></xref>, and the current thread has attempted to acquire the read lock when it already holds the write lock.  \\n  \\n -or-  \\n  \\n The recursion number would exceed the capacity of the counter. This limit is so large that applications should never encounter this exception.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock\n  commentId: M:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock\n  id: EnterUpgradeableReadLock\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: EnterUpgradeableReadLock()\n  nameWithType: ReaderWriterLockSlim.EnterUpgradeableReadLock()\n  fullName: ReaderWriterLockSlim.EnterUpgradeableReadLock()\n  type: Method\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Tries to enter the lock in upgradeable mode.\n  remarks: \"This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method to block for a specified interval, and then return if the calling thread has not entered upgradeable mode during that interval.  \\n  \\n Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can downgrade to read mode or upgrade to write mode.  \\n  \\n Only one thread can enter upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.  \\n  \\n If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it.  \\n  \\n> [!NOTE]\\n>  If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.\"\n  example:\n  - \"The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock%2A> method to enter the lock in upgradeable mode. A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.  \\n  \\n The method shown in the example retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.  \\n  \\n The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]\"\n  syntax:\n    content: public void EnterUpgradeableReadLock ();\n    parameters: []\n  overload: System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock*\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\"></xref> and the current thread has already entered the lock in any mode.  \\n  \\n -or-  \\n  \\n The current thread has entered read mode, so trying to enter upgradeable mode would create the possibility of a deadlock.  \\n  \\n -or-  \\n  \\n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.EnterWriteLock\n  commentId: M:System.Threading.ReaderWriterLockSlim.EnterWriteLock\n  id: EnterWriteLock\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: EnterWriteLock()\n  nameWithType: ReaderWriterLockSlim.EnterWriteLock()\n  fullName: ReaderWriterLockSlim.EnterWriteLock()\n  type: Method\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Tries to enter the lock in write mode.\n  remarks: \"This method blocks until the calling thread enters the lock, and therefore might never return. Use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to block for a specified interval, and then return if the calling thread has not entered write mode during that interval.  \\n  \\n If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method blocks until those threads have exited read mode. When there are threads waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.  \\n  \\n> [!NOTE]\\n>  If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.\"\n  example:\n  - \"The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method to enter the lock in write mode. The method shown in the example adds a new key/value pair to the synchronized cache. If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method. A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]\"\n  syntax:\n    content: public void EnterWriteLock ();\n    parameters: []\n  overload: System.Threading.ReaderWriterLockSlim.EnterWriteLock*\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\"></xref> and the current thread has already entered the lock in any mode.  \\n  \\n -or-  \\n  \\n The current thread has entered read mode, so trying to enter the lock in write mode would create the possibility of a deadlock.  \\n  \\n -or-  \\n  \\n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.ExitReadLock\n  commentId: M:System.Threading.ReaderWriterLockSlim.ExitReadLock\n  id: ExitReadLock\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: ExitReadLock()\n  nameWithType: ReaderWriterLockSlim.ExitReadLock()\n  fullName: ReaderWriterLockSlim.ExitReadLock()\n  type: Method\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Reduces the recursion count for read mode, and exits read mode if the resulting count is 0 (zero).\n  remarks: \"This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in read mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.  \\n  \\n Exiting the lock might signal other waiting threads.\"\n  example:\n  - \"The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitReadLock%2A> method, ensuring that the caller exits read mode. The method shown in the example retrieves the value associated with a key. If the key is not found, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method. The <xref:System.Threading.ReaderWriterLockSlim.EnterReadLock%2A> method is used to enter read mode.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#3)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#3)]\"\n  syntax:\n    content: public void ExitReadLock ();\n    parameters: []\n  overload: System.Threading.ReaderWriterLockSlim.ExitReadLock*\n  exceptions:\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: The current thread has not entered the lock in read mode.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock\n  commentId: M:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock\n  id: ExitUpgradeableReadLock\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: ExitUpgradeableReadLock()\n  nameWithType: ReaderWriterLockSlim.ExitUpgradeableReadLock()\n  fullName: ReaderWriterLockSlim.ExitUpgradeableReadLock()\n  type: Method\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Reduces the recursion count for upgradeable mode, and exits upgradeable mode if the resulting count is 0 (zero).\n  remarks: \"This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in upgradeable mode; the order in which the thread exits upgradeable mode and write mode does not matter.  \\n  \\n Exiting the lock might signal other waiting threads.\"\n  example:\n  - \"The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock%2A> method, ensuring that the caller exits upgradeable mode.  \\n  \\n The method shown in the example retrieves the value associated with a key and compares it with a new value. If the value is unchanged, the method returns a status indicating no change. It no value is found for the key, the key/value pair is inserted. If the value has changed, it is updated. Upgradeable mode allows the thread to upgrade the read lock as needed, without risk of deadlocks.  \\n  \\n The example uses the default constructor to create the lock, so recursion is not allowed. Programming the <xref:System.Threading.ReaderWriterLockSlim> is simpler and less prone to error when the lock does not allow recursion.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#6)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#6)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#10)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#10)]\"\n  syntax:\n    content: public void ExitUpgradeableReadLock ();\n    parameters: []\n  overload: System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock*\n  exceptions:\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: The current thread has not entered the lock in upgradeable mode.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.ExitWriteLock\n  commentId: M:System.Threading.ReaderWriterLockSlim.ExitWriteLock\n  id: ExitWriteLock\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: ExitWriteLock()\n  nameWithType: ReaderWriterLockSlim.ExitWriteLock()\n  fullName: ReaderWriterLockSlim.ExitWriteLock()\n  type: Method\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Reduces the recursion count for write mode, and exits write mode if the resulting count is 0 (zero).\n  remarks: \"This method is not sensitive to recursion order. For example, if a thread enters a lock in upgradeable mode and then enters the lock in write mode, the order in which the thread exits the two modes does not matter. If a lock allows recursion, a thread can enter the lock in write mode and then enter it recursively in read mode; the order in which the thread exits read mode and write mode does not matter.  \\n  \\n Exiting the lock might signal other waiting threads.\"\n  example:\n  - \"The following example shows how to use a `finally` block to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits write mode. The method shown in the example adds a new key/value pair to the synchronized cache. If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method. The <xref:System.Threading.ReaderWriterLockSlim.EnterWriteLock%2A> method is used to enter the lock in write mode.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#4)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#4)]\"\n  syntax:\n    content: public void ExitWriteLock ();\n    parameters: []\n  overload: System.Threading.ReaderWriterLockSlim.ExitWriteLock*\n  exceptions:\n  - type: System.Threading.SynchronizationLockException\n    commentId: T:System.Threading.SynchronizationLockException\n    description: The current thread has not entered the lock in write mode.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.IsReadLockHeld\n  commentId: P:System.Threading.ReaderWriterLockSlim.IsReadLockHeld\n  id: IsReadLockHeld\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: IsReadLockHeld\n  nameWithType: ReaderWriterLockSlim.IsReadLockHeld\n  fullName: ReaderWriterLockSlim.IsReadLockHeld\n  type: Property\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Gets a value that indicates whether the current thread has entered the lock in read mode.\n  remarks: This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.\n  example:\n  - \"The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsReadLockHeld%2A> property to generate an assert if the current thread has entered read mode unexpectedly.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#21)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#21)]\"\n  syntax:\n    content: public bool IsReadLockHeld { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current thread has entered read mode; otherwise, `false`.'\n  overload: System.Threading.ReaderWriterLockSlim.IsReadLockHeld*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n  commentId: P:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n  id: IsUpgradeableReadLockHeld\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: IsUpgradeableReadLockHeld\n  nameWithType: ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n  fullName: ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n  type: Property\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Gets a value that indicates whether the current thread has entered the lock in upgradeable mode.\n  remarks: This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.\n  example:\n  - \"The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld%2A> property to generate an assert if the current thread has entered upgradeable mode unexpectedly.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#22)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#22)]\"\n  syntax:\n    content: public bool IsUpgradeableReadLockHeld { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current thread has entered upgradeable mode; otherwise, `false`.'\n  overload: System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.IsWriteLockHeld\n  commentId: P:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld\n  id: IsWriteLockHeld\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: IsWriteLockHeld\n  nameWithType: ReaderWriterLockSlim.IsWriteLockHeld\n  fullName: ReaderWriterLockSlim.IsWriteLockHeld\n  type: Property\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Gets a value that indicates whether the current thread has entered the lock in write mode.\n  remarks: This property is intended for use in asserts or for other debugging purposes. Do not use it to control the flow of program execution.\n  example:\n  - \"The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.IsWriteLockHeld%2A> property to generate an assert if the current thread has entered write mode unexpectedly.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#23)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#23)]\"\n  syntax:\n    content: public bool IsWriteLockHeld { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current thread has entered write mode; otherwise, `false`.'\n  overload: System.Threading.ReaderWriterLockSlim.IsWriteLockHeld*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.RecursionPolicy\n  commentId: P:System.Threading.ReaderWriterLockSlim.RecursionPolicy\n  id: RecursionPolicy\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: RecursionPolicy\n  nameWithType: ReaderWriterLockSlim.RecursionPolicy\n  fullName: ReaderWriterLockSlim.RecursionPolicy\n  type: Property\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Gets a value that indicates the recursion policy for the current <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object.\n  remarks: \"Recursion policy determines the restrictions on threads that enter the lock more than once. For example, if a lock was created with <xref:System.Threading.LockRecursionPolicy?displayProperty=fullName> and a thread has entered the lock in read mode, <xref:System.Threading.LockRecursionException> is thrown if the thread tries to reenter the lock in read mode.  \\n  \\n> [!NOTE]\\n>  A thread in upgradeable mode can upgrade to write mode or downgrade to read mode regardless of the lock recursion policy setting.  \\n  \\n Regardless of recursion policy, a thread that initially entered read mode is not allowed to upgrade to upgradeable mode or write mode, because that pattern creates a strong probability of deadlocks.  \\n  \\n For more information about recursion policy and its effects, see the <xref:System.Threading.LockRecursionPolicy> enumeration and the <xref:System.Threading.ReaderWriterLockSlim> class.\"\n  syntax:\n    content: public System.Threading.LockRecursionPolicy RecursionPolicy { get; }\n    return:\n      type: System.Threading.LockRecursionPolicy\n      description: One of the enumeration values that specifies the lock recursion policy.\n  overload: System.Threading.ReaderWriterLockSlim.RecursionPolicy*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.RecursiveReadCount\n  commentId: P:System.Threading.ReaderWriterLockSlim.RecursiveReadCount\n  id: RecursiveReadCount\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: RecursiveReadCount\n  nameWithType: ReaderWriterLockSlim.RecursiveReadCount\n  fullName: ReaderWriterLockSlim.RecursiveReadCount\n  type: Property\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Gets the number of times the current thread has entered the lock in read mode, as an indication of recursion.\n  remarks: Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.\n  syntax:\n    content: public int RecursiveReadCount { get; }\n    return:\n      type: System.Int32\n      description: 0 (zero) if the current thread has not entered read mode, 1 if the thread has entered read mode but has not entered it recursively, or *n* if the thread has entered the lock recursively *n* - 1 times.\n  overload: System.Threading.ReaderWriterLockSlim.RecursiveReadCount*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount\n  commentId: P:System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount\n  id: RecursiveUpgradeCount\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: RecursiveUpgradeCount\n  nameWithType: ReaderWriterLockSlim.RecursiveUpgradeCount\n  fullName: ReaderWriterLockSlim.RecursiveUpgradeCount\n  type: Property\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Gets the number of times the current thread has entered the lock in upgradeable mode, as an indication of recursion.\n  remarks: Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.\n  syntax:\n    content: public int RecursiveUpgradeCount { get; }\n    return:\n      type: System.Int32\n      description: 0 if the current thread has not entered upgradeable mode, 1 if the thread has entered upgradeable mode but has not entered it recursively, or *n* if the thread has entered upgradeable mode recursively *n* - 1 times.\n  overload: System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.RecursiveWriteCount\n  commentId: P:System.Threading.ReaderWriterLockSlim.RecursiveWriteCount\n  id: RecursiveWriteCount\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: RecursiveWriteCount\n  nameWithType: ReaderWriterLockSlim.RecursiveWriteCount\n  fullName: ReaderWriterLockSlim.RecursiveWriteCount\n  type: Property\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Gets the number of times the current thread has entered the lock in write mode, as an indication of recursion.\n  remarks: Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.\n  syntax:\n    content: public int RecursiveWriteCount { get; }\n    return:\n      type: System.Int32\n      description: 0 if the current thread has not entered write mode, 1 if the thread has entered write mode but has not entered it recursively, or *n* if the thread has entered write mode recursively *n* - 1 times.\n  overload: System.Threading.ReaderWriterLockSlim.RecursiveWriteCount*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)\n  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)\n  id: TryEnterReadLock(System.Int32)\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: TryEnterReadLock(Int32)\n  nameWithType: ReaderWriterLockSlim.TryEnterReadLock(Int32)\n  fullName: ReaderWriterLockSlim.TryEnterReadLock(Int32)\n  type: Method\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Tries to enter the lock in read mode, with an optional integer time-out.\n  remarks: \"If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.  \\n  \\n Multiple threads can enter read mode at the same time.  \\n  \\n If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.  \\n  \\n> [!NOTE]\\n>  If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.  \\n  \\n One thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.\"\n  syntax:\n    content: public bool TryEnterReadLock (int millisecondsTimeout);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait, or -1 (<xref href=\"System.Threading.Timeout.Infinite\"></xref>) to wait indefinitely.\n    return:\n      type: System.Boolean\n      description: '`true` if the calling thread entered read mode, otherwise, `false`.'\n  overload: System.Threading.ReaderWriterLockSlim.TryEnterReadLock*\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\"></xref> and the current thread has already entered the lock.  \\n  \\n -or-  \\n  \\n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The value of <code>millisecondsTimeout</code> is negative, but it is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1), which is the only negative value allowed.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)\n  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)\n  id: TryEnterReadLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: TryEnterReadLock(TimeSpan)\n  nameWithType: ReaderWriterLockSlim.TryEnterReadLock(TimeSpan)\n  fullName: ReaderWriterLockSlim.TryEnterReadLock(TimeSpan)\n  type: Method\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Tries to enter the lock in read mode, with an optional time-out.\n  remarks: \"If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.  \\n  \\n Multiple threads can enter the lock in read mode at the same time.  \\n  \\n If one or more threads are queued to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.  \\n  \\n> [!NOTE]\\n>  If a lock allows recursion, a thread that has entered the lock in read mode can enter read mode recursively, even if other threads are waiting to enter write mode.  \\n  \\n One thread can be in upgradeable mode while other threads are in read mode. If additional threads are waiting to enter upgradeable mode, and there are no threads waiting to enter write mode, threads that call the <xref:System.Threading.ReaderWriterLockSlim.TryEnterReadLock%2A> method enter read mode immediately and do not block.\"\n  syntax:\n    content: public bool TryEnterReadLock (TimeSpan timeout);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The interval to wait, or -1 milliseconds to wait indefinitely.\n    return:\n      type: System.Boolean\n      description: '`true` if the calling thread entered read mode, otherwise, `false`.'\n  overload: System.Threading.ReaderWriterLockSlim.TryEnterReadLock*\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\"></xref> and the current thread has already entered the lock.  \\n  \\n -or-  \\n  \\n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"The value of <code>timeout</code> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  \\n  \\n -or-  \\n  \\n The value of <code>timeout</code> is greater than <xref href=\\\"System.Int32.MaxValue\\\"></xref> milliseconds.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)\n  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)\n  id: TryEnterUpgradeableReadLock(System.Int32)\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: TryEnterUpgradeableReadLock(Int32)\n  nameWithType: ReaderWriterLockSlim.TryEnterUpgradeableReadLock(Int32)\n  fullName: ReaderWriterLockSlim.TryEnterUpgradeableReadLock(Int32)\n  type: Method\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Tries to enter the lock in upgradeable mode, with an optional time-out.\n  remarks: \"If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.  \\n  \\n Use upgradeable mode when a thread usually accesses the resource that is protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.  \\n  \\n Only one thread can enter a lock in upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.  \\n  \\n If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.  \\n  \\n> [!NOTE]\\n>  If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.\"\n  syntax:\n    content: public bool TryEnterUpgradeableReadLock (int millisecondsTimeout);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait, or -1 (<xref href=\"System.Threading.Timeout.Infinite\"></xref>) to wait indefinitely.\n    return:\n      type: System.Boolean\n      description: '`true` if the calling thread entered upgradeable mode, otherwise, `false`.'\n  overload: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock*\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\"></xref> and the current thread has already entered the lock.  \\n  \\n -or-  \\n  \\n The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  \\n  \\n -or-  \\n  \\n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The value of <code>millisecondsTimeout</code> is negative, but it is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1), which is the only negative value allowed.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)\n  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)\n  id: TryEnterUpgradeableReadLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: TryEnterUpgradeableReadLock(TimeSpan)\n  nameWithType: ReaderWriterLockSlim.TryEnterUpgradeableReadLock(TimeSpan)\n  fullName: ReaderWriterLockSlim.TryEnterUpgradeableReadLock(TimeSpan)\n  type: Method\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Tries to enter the lock in upgradeable mode, with an optional time-out.\n  remarks: \"If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.  \\n  \\n Use upgradeable mode when a thread usually accesses the resource protected by the <xref:System.Threading.ReaderWriterLockSlim> in read mode, but may need to enter write mode if certain conditions are met. A thread in upgradeable mode can upgrade to write mode or downgrade to read mode.  \\n  \\n Only one thread can enter a lock in upgradeable mode at any given time. If a thread is in upgradeable mode, and there are no threads waiting to enter write mode, any number of other threads can enter read mode, even if there are threads waiting to enter upgradeable mode.  \\n  \\n If one or more threads are waiting to enter write mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock%2A> method blocks until those threads have either timed out or entered write mode and then exited from it, or until the calling thread's own time-out interval expires.  \\n  \\n> [!NOTE]\\n>  If a lock allows recursion, a thread that has entered the lock in upgradeable mode can enter upgradeable mode recursively, even if other threads are waiting to enter write mode.\"\n  syntax:\n    content: public bool TryEnterUpgradeableReadLock (TimeSpan timeout);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The interval to wait, or -1 milliseconds to wait indefinitely.\n    return:\n      type: System.Boolean\n      description: '`true` if the calling thread entered upgradeable mode, otherwise, `false`.'\n  overload: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock*\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\"></xref> and the current thread has already entered the lock.  \\n  \\n -or-  \\n  \\n The current thread initially entered the lock in read mode, and therefore trying to enter upgradeable mode would create the possibility of a deadlock.  \\n  \\n -or-  \\n  \\n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"The value of <code>timeout</code> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  \\n  \\n -or-  \\n  \\n The value of <code>timeout</code> is greater than <xref href=\\\"System.Int32.MaxValue\\\"></xref> milliseconds.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)\n  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)\n  id: TryEnterWriteLock(System.Int32)\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: TryEnterWriteLock(Int32)\n  nameWithType: ReaderWriterLockSlim.TryEnterWriteLock(Int32)\n  fullName: ReaderWriterLockSlim.TryEnterWriteLock(Int32)\n  type: Method\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Tries to enter the lock in write mode, with an optional time-out.\n  remarks: \"If `millisecondsTimeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.  \\n  \\n If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed. While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.  \\n  \\n> [!NOTE]\\n>  If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.\"\n  example:\n  - \"The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method to enter the lock in write mode, with a time-out. The method shown in the example adds a new key/value pair to the synchronized cache. If the specified time-out interval elapses before the thread enters the lock, the method returns `false`. The method returns `true` if the key/value pair is added.  \\n  \\n If the key is already in the cache, the exception thrown by the inner <xref:System.Collections.Generic.Dictionary%602> is allowed to terminate the method. A `finally` block is used to execute the <xref:System.Threading.ReaderWriterLockSlim.ExitWriteLock%2A> method, ensuring that the caller exits the lock.  \\n  \\n This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLockSlim> class.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#2)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#2)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/cs/source.cs#5)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Shadow#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Shadow/vb/source.vb#5)]\"\n  syntax:\n    content: public bool TryEnterWriteLock (int millisecondsTimeout);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait, or -1 (<xref href=\"System.Threading.Timeout.Infinite\"></xref>) to wait indefinitely.\n    return:\n      type: System.Boolean\n      description: '`true` if the calling thread entered write mode, otherwise, `false`.'\n  overload: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock*\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\"></xref> and the current thread has already entered the lock.  \\n  \\n -or-  \\n  \\n The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  \\n  \\n -or-  \\n  \\n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The value of <code>millisecondsTimeout</code> is negative, but it is not equal to <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1), which is the only negative value allowed.\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)\n  commentId: M:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)\n  id: TryEnterWriteLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: TryEnterWriteLock(TimeSpan)\n  nameWithType: ReaderWriterLockSlim.TryEnterWriteLock(TimeSpan)\n  fullName: ReaderWriterLockSlim.TryEnterWriteLock(TimeSpan)\n  type: Method\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Tries to enter the lock in write mode, with an optional time-out.\n  remarks: \"If `timeout` is 0 (zero), this method checks the lock state and returns `false` immediately if the desired state is unavailable.  \\n  \\n If other threads have entered the lock in read mode, a thread that calls the <xref:System.Threading.ReaderWriterLockSlim.TryEnterWriteLock%2A> method blocks until those threads have exited read mode or until the time-out interval has elapsed. While threads are blocked waiting to enter write mode, additional threads that try to enter read mode or upgradeable mode block until all the threads waiting to enter write mode have either timed out or entered write mode and then exited from it.  \\n  \\n> [!NOTE]\\n>  If a lock allows recursion, a thread that has entered the lock in write mode can enter write mode recursively, even if other threads are waiting to enter write mode.\"\n  syntax:\n    content: public bool TryEnterWriteLock (TimeSpan timeout);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: The interval to wait, or -1 milliseconds to wait indefinitely.\n    return:\n      type: System.Boolean\n      description: '`true` if the calling thread entered write mode, otherwise, `false`.'\n  overload: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock*\n  exceptions:\n  - type: System.Threading.LockRecursionException\n    commentId: T:System.Threading.LockRecursionException\n    description: \"The <xref href=\\\"System.Threading.ReaderWriterLockSlim.RecursionPolicy\\\"></xref> property is <xref href=\\\"System.Threading.LockRecursionPolicy.NoRecursion\\\"></xref> and the current thread has already entered the lock.  \\n  \\n -or-  \\n  \\n The current thread initially entered the lock in read mode, and therefore trying to enter write mode would create the possibility of a deadlock.  \\n  \\n -or-  \\n  \\n The recursion number would exceed the capacity of the counter. The limit is so large that applications should never encounter it.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"The value of <code>timeout</code> is negative, but it is not equal to -1 milliseconds, which is the only negative value allowed.  \\n  \\n -or-  \\n  \\n The value of <code>timeout</code> is greater than <xref href=\\\"System.Int32.MaxValue\\\"></xref> milliseconds.\"\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The <xref href=\"System.Threading.ReaderWriterLockSlim\"></xref> object has been disposed.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.WaitingReadCount\n  commentId: P:System.Threading.ReaderWriterLockSlim.WaitingReadCount\n  id: WaitingReadCount\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: WaitingReadCount\n  nameWithType: ReaderWriterLockSlim.WaitingReadCount\n  fullName: ReaderWriterLockSlim.WaitingReadCount\n  type: Property\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Gets the total number of threads that are waiting to enter the lock in read mode.\n  remarks: Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.\n  example:\n  - \"The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingReadCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter read mode, exceeds a threshold.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#31)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#31)]\"\n  syntax:\n    content: public int WaitingReadCount { get; }\n    return:\n      type: System.Int32\n      description: The total number of threads that are waiting to enter read mode.\n  overload: System.Threading.ReaderWriterLockSlim.WaitingReadCount*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount\n  commentId: P:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount\n  id: WaitingUpgradeCount\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: WaitingUpgradeCount\n  nameWithType: ReaderWriterLockSlim.WaitingUpgradeCount\n  fullName: ReaderWriterLockSlim.WaitingUpgradeCount\n  type: Property\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Gets the total number of threads that are waiting to enter the lock in upgradeable mode.\n  remarks: Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.\n  example:\n  - \"The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter upgradeable mode, exceeds a threshold.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#33)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#33)]\"\n  syntax:\n    content: public int WaitingUpgradeCount { get; }\n    return:\n      type: System.Int32\n      description: The total number of threads that are waiting to enter upgradeable mode.\n  overload: System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.ReaderWriterLockSlim.WaitingWriteCount\n  commentId: P:System.Threading.ReaderWriterLockSlim.WaitingWriteCount\n  id: WaitingWriteCount\n  parent: System.Threading.ReaderWriterLockSlim\n  langs:\n  - csharp\n  name: WaitingWriteCount\n  nameWithType: ReaderWriterLockSlim.WaitingWriteCount\n  fullName: ReaderWriterLockSlim.WaitingWriteCount\n  type: Property\n  assemblies:\n  - System.Threading\n  - System.Core\n  - netstandard\n  namespace: System.Threading\n  summary: Gets the total number of threads that are waiting to enter the lock in write mode.\n  remarks: Use this property only for debugging, profiling, and logging purposes, and not to control the behavior of an algorithm. The results can change as soon as they have been calculated. Therefore, it is not safe to make decisions based on this property.\n  example:\n  - \"The following example shows how to use the <xref:System.Threading.ReaderWriterLockSlim.WaitingWriteCount%2A> property to generate an event log entry if the number of threads that are blocked, waiting to enter write mode, exceeds a threshold.  \\n  \\n [!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#1)]\\n [!code-vb[System.Threading.ReaderWriterLockSlim_Aux#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#1)]  \\n[!code-csharp[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/cs/source.cs#32)]\\n[!code-vb[System.Threading.ReaderWriterLockSlim_Aux#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLockSlim_Aux/vb/source.vb#32)]\"\n  syntax:\n    content: public int WaitingWriteCount { get; }\n    return:\n      type: System.Int32\n      description: The total number of threads that are waiting to enter write mode.\n  overload: System.Threading.ReaderWriterLockSlim.WaitingWriteCount*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.Threading.SynchronizationLockException\n  parent: System.Threading\n  isExternal: false\n  name: SynchronizationLockException\n  nameWithType: SynchronizationLockException\n  fullName: System.Threading.SynchronizationLockException\n- uid: System.Threading.LockRecursionException\n  parent: System.Threading\n  isExternal: false\n  name: LockRecursionException\n  nameWithType: LockRecursionException\n  fullName: System.Threading.LockRecursionException\n- uid: System.ObjectDisposedException\n  parent: System\n  isExternal: false\n  name: ObjectDisposedException\n  nameWithType: ObjectDisposedException\n  fullName: System.ObjectDisposedException\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.Threading.ReaderWriterLockSlim.#ctor\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: ReaderWriterLockSlim()\n  nameWithType: ReaderWriterLockSlim.ReaderWriterLockSlim()\n  fullName: ReaderWriterLockSlim.ReaderWriterLockSlim()\n- uid: System.Threading.ReaderWriterLockSlim.#ctor(System.Threading.LockRecursionPolicy)\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: ReaderWriterLockSlim(LockRecursionPolicy)\n  nameWithType: ReaderWriterLockSlim.ReaderWriterLockSlim(LockRecursionPolicy)\n  fullName: ReaderWriterLockSlim.ReaderWriterLockSlim(LockRecursionPolicy)\n- uid: System.Threading.LockRecursionPolicy\n  parent: System.Threading\n  isExternal: false\n  name: LockRecursionPolicy\n  nameWithType: LockRecursionPolicy\n  fullName: System.Threading.LockRecursionPolicy\n- uid: System.Threading.ReaderWriterLockSlim.CurrentReadCount\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: CurrentReadCount\n  nameWithType: ReaderWriterLockSlim.CurrentReadCount\n  fullName: ReaderWriterLockSlim.CurrentReadCount\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Threading.ReaderWriterLockSlim.Dispose\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: Dispose()\n  nameWithType: ReaderWriterLockSlim.Dispose()\n  fullName: ReaderWriterLockSlim.Dispose()\n- uid: System.Threading.ReaderWriterLockSlim.EnterReadLock\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: EnterReadLock()\n  nameWithType: ReaderWriterLockSlim.EnterReadLock()\n  fullName: ReaderWriterLockSlim.EnterReadLock()\n- uid: System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: EnterUpgradeableReadLock()\n  nameWithType: ReaderWriterLockSlim.EnterUpgradeableReadLock()\n  fullName: ReaderWriterLockSlim.EnterUpgradeableReadLock()\n- uid: System.Threading.ReaderWriterLockSlim.EnterWriteLock\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: EnterWriteLock()\n  nameWithType: ReaderWriterLockSlim.EnterWriteLock()\n  fullName: ReaderWriterLockSlim.EnterWriteLock()\n- uid: System.Threading.ReaderWriterLockSlim.ExitReadLock\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: ExitReadLock()\n  nameWithType: ReaderWriterLockSlim.ExitReadLock()\n  fullName: ReaderWriterLockSlim.ExitReadLock()\n- uid: System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: ExitUpgradeableReadLock()\n  nameWithType: ReaderWriterLockSlim.ExitUpgradeableReadLock()\n  fullName: ReaderWriterLockSlim.ExitUpgradeableReadLock()\n- uid: System.Threading.ReaderWriterLockSlim.ExitWriteLock\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: ExitWriteLock()\n  nameWithType: ReaderWriterLockSlim.ExitWriteLock()\n  fullName: ReaderWriterLockSlim.ExitWriteLock()\n- uid: System.Threading.ReaderWriterLockSlim.IsReadLockHeld\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: IsReadLockHeld\n  nameWithType: ReaderWriterLockSlim.IsReadLockHeld\n  fullName: ReaderWriterLockSlim.IsReadLockHeld\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: IsUpgradeableReadLockHeld\n  nameWithType: ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n  fullName: ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n- uid: System.Threading.ReaderWriterLockSlim.IsWriteLockHeld\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: IsWriteLockHeld\n  nameWithType: ReaderWriterLockSlim.IsWriteLockHeld\n  fullName: ReaderWriterLockSlim.IsWriteLockHeld\n- uid: System.Threading.ReaderWriterLockSlim.RecursionPolicy\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: RecursionPolicy\n  nameWithType: ReaderWriterLockSlim.RecursionPolicy\n  fullName: ReaderWriterLockSlim.RecursionPolicy\n- uid: System.Threading.ReaderWriterLockSlim.RecursiveReadCount\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: RecursiveReadCount\n  nameWithType: ReaderWriterLockSlim.RecursiveReadCount\n  fullName: ReaderWriterLockSlim.RecursiveReadCount\n- uid: System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: RecursiveUpgradeCount\n  nameWithType: ReaderWriterLockSlim.RecursiveUpgradeCount\n  fullName: ReaderWriterLockSlim.RecursiveUpgradeCount\n- uid: System.Threading.ReaderWriterLockSlim.RecursiveWriteCount\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: RecursiveWriteCount\n  nameWithType: ReaderWriterLockSlim.RecursiveWriteCount\n  fullName: ReaderWriterLockSlim.RecursiveWriteCount\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.Int32)\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: TryEnterReadLock(Int32)\n  nameWithType: ReaderWriterLockSlim.TryEnterReadLock(Int32)\n  fullName: ReaderWriterLockSlim.TryEnterReadLock(Int32)\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterReadLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: TryEnterReadLock(TimeSpan)\n  nameWithType: ReaderWriterLockSlim.TryEnterReadLock(TimeSpan)\n  fullName: ReaderWriterLockSlim.TryEnterReadLock(TimeSpan)\n- uid: System.TimeSpan\n  parent: System\n  isExternal: false\n  name: TimeSpan\n  nameWithType: TimeSpan\n  fullName: System.TimeSpan\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.Int32)\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: TryEnterUpgradeableReadLock(Int32)\n  nameWithType: ReaderWriterLockSlim.TryEnterUpgradeableReadLock(Int32)\n  fullName: ReaderWriterLockSlim.TryEnterUpgradeableReadLock(Int32)\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: TryEnterUpgradeableReadLock(TimeSpan)\n  nameWithType: ReaderWriterLockSlim.TryEnterUpgradeableReadLock(TimeSpan)\n  fullName: ReaderWriterLockSlim.TryEnterUpgradeableReadLock(TimeSpan)\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.Int32)\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: TryEnterWriteLock(Int32)\n  nameWithType: ReaderWriterLockSlim.TryEnterWriteLock(Int32)\n  fullName: ReaderWriterLockSlim.TryEnterWriteLock(Int32)\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock(System.TimeSpan)\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: TryEnterWriteLock(TimeSpan)\n  nameWithType: ReaderWriterLockSlim.TryEnterWriteLock(TimeSpan)\n  fullName: ReaderWriterLockSlim.TryEnterWriteLock(TimeSpan)\n- uid: System.Threading.ReaderWriterLockSlim.WaitingReadCount\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: WaitingReadCount\n  nameWithType: ReaderWriterLockSlim.WaitingReadCount\n  fullName: ReaderWriterLockSlim.WaitingReadCount\n- uid: System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: WaitingUpgradeCount\n  nameWithType: ReaderWriterLockSlim.WaitingUpgradeCount\n  fullName: ReaderWriterLockSlim.WaitingUpgradeCount\n- uid: System.Threading.ReaderWriterLockSlim.WaitingWriteCount\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: WaitingWriteCount\n  nameWithType: ReaderWriterLockSlim.WaitingWriteCount\n  fullName: ReaderWriterLockSlim.WaitingWriteCount\n- uid: System.Threading.ReaderWriterLockSlim.#ctor*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: ReaderWriterLockSlim\n  nameWithType: ReaderWriterLockSlim.ReaderWriterLockSlim\n  fullName: ReaderWriterLockSlim.ReaderWriterLockSlim\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.CurrentReadCount*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: CurrentReadCount\n  nameWithType: ReaderWriterLockSlim.CurrentReadCount\n  fullName: ReaderWriterLockSlim.CurrentReadCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.Dispose*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: Dispose\n  nameWithType: ReaderWriterLockSlim.Dispose\n  fullName: ReaderWriterLockSlim.Dispose\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.EnterReadLock*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: EnterReadLock\n  nameWithType: ReaderWriterLockSlim.EnterReadLock\n  fullName: ReaderWriterLockSlim.EnterReadLock\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.EnterUpgradeableReadLock*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: EnterUpgradeableReadLock\n  nameWithType: ReaderWriterLockSlim.EnterUpgradeableReadLock\n  fullName: ReaderWriterLockSlim.EnterUpgradeableReadLock\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.EnterWriteLock*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: EnterWriteLock\n  nameWithType: ReaderWriterLockSlim.EnterWriteLock\n  fullName: ReaderWriterLockSlim.EnterWriteLock\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.ExitReadLock*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: ExitReadLock\n  nameWithType: ReaderWriterLockSlim.ExitReadLock\n  fullName: ReaderWriterLockSlim.ExitReadLock\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.ExitUpgradeableReadLock*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: ExitUpgradeableReadLock\n  nameWithType: ReaderWriterLockSlim.ExitUpgradeableReadLock\n  fullName: ReaderWriterLockSlim.ExitUpgradeableReadLock\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.ExitWriteLock*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: ExitWriteLock\n  nameWithType: ReaderWriterLockSlim.ExitWriteLock\n  fullName: ReaderWriterLockSlim.ExitWriteLock\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.IsReadLockHeld*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: IsReadLockHeld\n  nameWithType: ReaderWriterLockSlim.IsReadLockHeld\n  fullName: ReaderWriterLockSlim.IsReadLockHeld\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.IsUpgradeableReadLockHeld*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: IsUpgradeableReadLockHeld\n  nameWithType: ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n  fullName: ReaderWriterLockSlim.IsUpgradeableReadLockHeld\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.IsWriteLockHeld*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: IsWriteLockHeld\n  nameWithType: ReaderWriterLockSlim.IsWriteLockHeld\n  fullName: ReaderWriterLockSlim.IsWriteLockHeld\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.RecursionPolicy*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: RecursionPolicy\n  nameWithType: ReaderWriterLockSlim.RecursionPolicy\n  fullName: ReaderWriterLockSlim.RecursionPolicy\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.RecursiveReadCount*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: RecursiveReadCount\n  nameWithType: ReaderWriterLockSlim.RecursiveReadCount\n  fullName: ReaderWriterLockSlim.RecursiveReadCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.RecursiveUpgradeCount*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: RecursiveUpgradeCount\n  nameWithType: ReaderWriterLockSlim.RecursiveUpgradeCount\n  fullName: ReaderWriterLockSlim.RecursiveUpgradeCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.RecursiveWriteCount*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: RecursiveWriteCount\n  nameWithType: ReaderWriterLockSlim.RecursiveWriteCount\n  fullName: ReaderWriterLockSlim.RecursiveWriteCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterReadLock*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: TryEnterReadLock\n  nameWithType: ReaderWriterLockSlim.TryEnterReadLock\n  fullName: ReaderWriterLockSlim.TryEnterReadLock\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterUpgradeableReadLock*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: TryEnterUpgradeableReadLock\n  nameWithType: ReaderWriterLockSlim.TryEnterUpgradeableReadLock\n  fullName: ReaderWriterLockSlim.TryEnterUpgradeableReadLock\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.TryEnterWriteLock*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: TryEnterWriteLock\n  nameWithType: ReaderWriterLockSlim.TryEnterWriteLock\n  fullName: ReaderWriterLockSlim.TryEnterWriteLock\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.WaitingReadCount*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: WaitingReadCount\n  nameWithType: ReaderWriterLockSlim.WaitingReadCount\n  fullName: ReaderWriterLockSlim.WaitingReadCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.WaitingUpgradeCount*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: WaitingUpgradeCount\n  nameWithType: ReaderWriterLockSlim.WaitingUpgradeCount\n  fullName: ReaderWriterLockSlim.WaitingUpgradeCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Threading.ReaderWriterLockSlim.WaitingWriteCount*\n  parent: System.Threading.ReaderWriterLockSlim\n  isExternal: false\n  name: WaitingWriteCount\n  nameWithType: ReaderWriterLockSlim.WaitingWriteCount\n  fullName: ReaderWriterLockSlim.WaitingWriteCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/ReaderWriterLockSlim.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.IDisposable\n  parent: System\n  isExternal: false\n  name: IDisposable\n  nameWithType: IDisposable\n  fullName: System.IDisposable\n"}