{"nodes":[{"content":"Specifies a method's behavior when called within a constrained execution region.","nodes":[{"pos":[0,80],"content":"Specifies a method's behavior when called within a constrained execution region.","nodes":[{"content":"Specifies a method's behavior when called within a constrained execution region.","pos":[0,80]}]}],"pos":[552,633],"yaml":true},{"content":"The <xref:System.Runtime.ConstrainedExecution.Cer> enumeration specifies the behavior of a method, type, or assembly within a constrained execution region (CER). Use one of the three available values to indicate that the entity will succeed, has no knowledge of a CER, or might (deterministically) be able to report success or failure.  \n  \n A CER provides guarantees that the region of code will execute uninterrupted even if an asynchronous exception such as an aborted thread out-of-memory exception, or stack overflow is raised.","nodes":[{"pos":[0,335],"content":"The <xref:System.Runtime.ConstrainedExecution.Cer> enumeration specifies the behavior of a method, type, or assembly within a constrained execution region (CER). Use one of the three available values to indicate that the entity will succeed, has no knowledge of a CER, or might (deterministically) be able to report success or failure.","nodes":[{"content":"The <xref:System.Runtime.ConstrainedExecution.Cer> enumeration specifies the behavior of a method, type, or assembly within a constrained execution region (CER). Use one of the three available values to indicate that the entity will succeed, has no knowledge of a CER, or might (deterministically) be able to report success or failure.","pos":[0,335],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.Cer&gt;</ph> enumeration specifies the behavior of a method, type, or assembly within a constrained execution region (CER).","pos":[0,161],"source":"The <xref:System.Runtime.ConstrainedExecution.Cer> enumeration specifies the behavior of a method, type, or assembly within a constrained execution region (CER)."},{"content":"Use one of the three available values to indicate that the entity will succeed, has no knowledge of a CER, or might (deterministically) be able to report success or failure.","pos":[162,335]}]}]},{"pos":[342,532],"content":"A CER provides guarantees that the region of code will execute uninterrupted even if an asynchronous exception such as an aborted thread out-of-memory exception, or stack overflow is raised.","nodes":[{"content":"A CER provides guarantees that the region of code will execute uninterrupted even if an asynchronous exception such as an aborted thread out-of-memory exception, or stack overflow is raised.","pos":[0,190]}]}],"pos":[644,1181],"yaml":true,"extradata":"MT"},{"content":"In the face of exceptional conditions, the method might fail. In this case, the method will report back to the calling method whether it succeeded or failed. The method must have a CER around the method body to ensure that it can report the return value.","nodes":[{"pos":[0,254],"content":"In the face of exceptional conditions, the method might fail. In this case, the method will report back to the calling method whether it succeeded or failed. The method must have a CER around the method body to ensure that it can report the return value.","nodes":[{"content":"In the face of exceptional conditions, the method might fail. In this case, the method will report back to the calling method whether it succeeded or failed. The method must have a CER around the method body to ensure that it can report the return value.","pos":[0,254],"nodes":[{"content":"In the face of exceptional conditions, the method might fail.","pos":[0,61]},{"content":"In this case, the method will report back to the calling method whether it succeeded or failed.","pos":[62,157]},{"content":"The method must have a CER around the method body to ensure that it can report the return value.","pos":[158,254]}]}]}],"pos":[3106,3361],"yaml":true},{"content":"The method, type, or assembly has no concept of a CER. It does not take advantage of CER guarantees. This implies the following:","nodes":[{"pos":[0,128],"content":"The method, type, or assembly has no concept of a CER. It does not take advantage of CER guarantees. This implies the following:","nodes":[{"content":"The method, type, or assembly has no concept of a CER. It does not take advantage of CER guarantees. This implies the following:","pos":[0,128],"nodes":[{"content":"The method, type, or assembly has no concept of a CER.","pos":[0,54]},{"content":"It does not take advantage of CER guarantees.","pos":[55,100]},{"content":"This implies the following:","pos":[101,128]}]}]}],"pos":[4522,4653],"yaml":true},{"content":"-   In the face of exceptional conditions the method might fail.  \n  \n-   The method might or might not report that it failed (it is non-deterministic).  \n  \n-   The method is not written with CERs in mind (which is the most likely scenario).  \n  \n If a method, type, or assembly is not explicitly marked to succeed, it is implicitly marked as `Cer.None`.","nodes":[{"pos":[4,64],"content":"In the face of exceptional conditions the method might fail.","nodes":[{"content":"In the face of exceptional conditions the method might fail.","pos":[0,60]}]},{"pos":[74,152],"content":"The method might or might not report that it failed (it is non-deterministic).","nodes":[{"content":"The method might or might not report that it failed (it is non-deterministic).","pos":[0,78]}]},{"pos":[162,242],"content":"The method is not written with CERs in mind (which is the most likely scenario).","nodes":[{"content":"The method is not written with CERs in mind (which is the most likely scenario).","pos":[0,80]}]},{"pos":[249,355],"content":"If a method, type, or assembly is not explicitly marked to succeed, it is implicitly marked as <ph id=\"ph1\">`Cer.None`</ph>.","source":"If a method, type, or assembly is not explicitly marked to succeed, it is implicitly marked as `Cer.None`."}],"pos":[4664,5028],"yaml":true,"extradata":"MT"},{"content":"In the face of exceptional conditions, the method is guaranteed to succeed. You should always construct a CER around the method that is called, even when it is called from within a non-CER region. A method is successful if it accomplishes what is intended. For example, marking <xref href=\"System.Collections.ArrayList.Count\"></xref> with <code>ReliabilityContractAttribute(Cer.Success)</code> implies that when it is run under a CER, it always returns a count of the number of elements in the <xref href=\"System.Collections.ArrayList\"></xref> and it can never leave the internal fields in an undetermined state.","nodes":[{"pos":[0,612],"content":"In the face of exceptional conditions, the method is guaranteed to succeed. You should always construct a CER around the method that is called, even when it is called from within a non-CER region. A method is successful if it accomplishes what is intended. For example, marking <xref href=\"System.Collections.ArrayList.Count\"></xref> with <code>ReliabilityContractAttribute(Cer.Success)</code> implies that when it is run under a CER, it always returns a count of the number of elements in the <xref href=\"System.Collections.ArrayList\"></xref> and it can never leave the internal fields in an undetermined state.","nodes":[{"content":"In the face of exceptional conditions, the method is guaranteed to succeed.","pos":[0,75]},{"content":"You should always construct a CER around the method that is called, even when it is called from within a non-CER region.","pos":[76,196]},{"content":"A method is successful if it accomplishes what is intended.","pos":[197,256]},{"content":"For example, marking <ph id=\"ph1\">&lt;xref href=\"System.Collections.ArrayList.Count\"&gt;&lt;/xref&gt;</ph> with <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">ReliabilityContractAttribute(Cer.Success)</ph><ept id=\"p1\">&lt;/code&gt;</ept> implies that when it is run under a CER, it always returns a count of the number of elements in the <ph id=\"ph3\">&lt;xref href=\"System.Collections.ArrayList\"&gt;&lt;/xref&gt;</ph> and it can never leave the internal fields in an undetermined state.","pos":[257,612],"source":" For example, marking <xref href=\"System.Collections.ArrayList.Count\"></xref> with <code>ReliabilityContractAttribute(Cer.Success)</code> implies that when it is run under a CER, it always returns a count of the number of elements in the <xref href=\"System.Collections.ArrayList\"></xref> and it can never leave the internal fields in an undetermined state."}]}],"pos":[6204,6817],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Runtime.ConstrainedExecution.Cer\n  commentId: T:System.Runtime.ConstrainedExecution.Cer\n  id: Cer\n  children:\n  - System.Runtime.ConstrainedExecution.Cer.MayFail\n  - System.Runtime.ConstrainedExecution.Cer.None\n  - System.Runtime.ConstrainedExecution.Cer.Success\n  langs:\n  - csharp\n  name: Cer\n  nameWithType: Cer\n  fullName: System.Runtime.ConstrainedExecution.Cer\n  type: Enum\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.ConstrainedExecution\n  summary: Specifies a method's behavior when called within a constrained execution region.\n  remarks: \"The <xref:System.Runtime.ConstrainedExecution.Cer> enumeration specifies the behavior of a method, type, or assembly within a constrained execution region (CER). Use one of the three available values to indicate that the entity will succeed, has no knowledge of a CER, or might (deterministically) be able to report success or failure.  \\n  \\n A CER provides guarantees that the region of code will execute uninterrupted even if an asynchronous exception such as an aborted thread out-of-memory exception, or stack overflow is raised.\"\n  example:\n  - \"The following code example demonstrates the use of the <xref:System.Runtime.ConstrainedExecution.Cer> enumeration when specifying a constrained execution region for a method. This code example is part of a larger example provided for the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute.%23ctor%2A> constructor.  \\n  \\n [!code-csharp[System.Runtime.ConstrainedExecution#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.ConstrainedExecution/cs/program.cs#3)]\\n [!code-vb[System.Runtime.ConstrainedExecution#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.ConstrainedExecution/vb/program.vb#3)]\"\n  syntax:\n    content: public enum Cer\n  inheritance:\n  - System.Object\n  - System.ValueType\n  - System.Enum\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.ConstrainedExecution/Cer.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.ConstrainedExecution.Cer.MayFail\n  commentId: F:System.Runtime.ConstrainedExecution.Cer.MayFail\n  id: MayFail\n  parent: System.Runtime.ConstrainedExecution.Cer\n  langs:\n  - csharp\n  name: MayFail\n  nameWithType: Cer.MayFail\n  fullName: Cer.MayFail\n  type: Field\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.ConstrainedExecution\n  summary: In the face of exceptional conditions, the method might fail. In this case, the method will report back to the calling method whether it succeeded or failed. The method must have a CER around the method body to ensure that it can report the return value.\n  syntax:\n    content: MayFail\n    return:\n      type: System.Runtime.ConstrainedExecution.Cer\n      description: ''\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.ConstrainedExecution/Cer.xml\n- uid: System.Runtime.ConstrainedExecution.Cer.None\n  commentId: F:System.Runtime.ConstrainedExecution.Cer.None\n  id: None\n  parent: System.Runtime.ConstrainedExecution.Cer\n  langs:\n  - csharp\n  name: None\n  nameWithType: Cer.None\n  fullName: Cer.None\n  type: Field\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.ConstrainedExecution\n  summary: 'The method, type, or assembly has no concept of a CER. It does not take advantage of CER guarantees. This implies the following:'\n  remarks: \"-   In the face of exceptional conditions the method might fail.  \\n  \\n-   The method might or might not report that it failed (it is non-deterministic).  \\n  \\n-   The method is not written with CERs in mind (which is the most likely scenario).  \\n  \\n If a method, type, or assembly is not explicitly marked to succeed, it is implicitly marked as `Cer.None`.\"\n  syntax:\n    content: None\n    return:\n      type: System.Runtime.ConstrainedExecution.Cer\n      description: ''\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.ConstrainedExecution/Cer.xml\n- uid: System.Runtime.ConstrainedExecution.Cer.Success\n  commentId: F:System.Runtime.ConstrainedExecution.Cer.Success\n  id: Success\n  parent: System.Runtime.ConstrainedExecution.Cer\n  langs:\n  - csharp\n  name: Success\n  nameWithType: Cer.Success\n  fullName: Cer.Success\n  type: Field\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.ConstrainedExecution\n  summary: In the face of exceptional conditions, the method is guaranteed to succeed. You should always construct a CER around the method that is called, even when it is called from within a non-CER region. A method is successful if it accomplishes what is intended. For example, marking <xref href=\"System.Collections.ArrayList.Count\"></xref> with <code>ReliabilityContractAttribute(Cer.Success)</code> implies that when it is run under a CER, it always returns a count of the number of elements in the <xref href=\"System.Collections.ArrayList\"></xref> and it can never leave the internal fields in an undetermined state.\n  syntax:\n    content: Success\n    return:\n      type: System.Runtime.ConstrainedExecution.Cer\n      description: ''\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.ConstrainedExecution/Cer.xml\nreferences:\n- uid: System.Enum\n  parent: System\n  isExternal: false\n  name: Enum\n  nameWithType: Enum\n  fullName: System.Enum\n- uid: System.Runtime.ConstrainedExecution.Cer.MayFail\n  parent: System.Runtime.ConstrainedExecution.Cer\n  isExternal: false\n  name: MayFail\n  nameWithType: Cer.MayFail\n  fullName: Cer.MayFail\n- uid: System.Runtime.ConstrainedExecution.Cer\n  parent: System.Runtime.ConstrainedExecution\n  isExternal: false\n  name: Cer\n  nameWithType: Cer\n  fullName: System.Runtime.ConstrainedExecution.Cer\n- uid: System.Runtime.ConstrainedExecution.Cer.None\n  parent: System.Runtime.ConstrainedExecution.Cer\n  isExternal: false\n  name: None\n  nameWithType: Cer.None\n  fullName: Cer.None\n- uid: System.Runtime.ConstrainedExecution.Cer.Success\n  parent: System.Runtime.ConstrainedExecution.Cer\n  isExternal: false\n  name: Success\n  nameWithType: Cer.Success\n  fullName: Cer.Success\n"}