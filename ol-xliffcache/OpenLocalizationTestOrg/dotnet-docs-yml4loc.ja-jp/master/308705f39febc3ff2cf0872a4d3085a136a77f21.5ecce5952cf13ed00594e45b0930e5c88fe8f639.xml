{"nodes":[{"content":"Encapsulates operating system–specific objects that wait for exclusive access to shared resources.","nodes":[{"pos":[0,98],"content":"Encapsulates operating system–specific objects that wait for exclusive access to shared resources.","nodes":[{"content":"Encapsulates operating system–specific objects that wait for exclusive access to shared resources.","pos":[0,98]}]}],"pos":[2260,2359],"yaml":true},{"content":"The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations. For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).  \n  \n The <xref:System.Threading.WaitHandle> class itself is abstract. Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources. The classes derived from <xref:System.Threading.WaitHandle> include:  \n  \n-   The <xref:System.Threading.Mutex> class. See [Mutexes](~/docs/standard/threading/mutexes.md).  \n  \n-   The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>. See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  \n  \n-   The <xref:System.Threading.Semaphore> class. See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  \n  \n Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.  \n  \n The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity. Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore. Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.  \n  \n Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.  \n  \n In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.. These include:  \n  \n-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.  \n  \n-   <xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.  \n  \n-   <xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .  \n  \n The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.  \n  \n <xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern. See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md). When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle. You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.","nodes":[{"pos":[0,377],"content":"The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations. For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations.","pos":[0,193],"source":"The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations."},{"content":"For a comparison of wait handles with other synchronization objects, see <bpt id=\"p1\">[</bpt>Overview of Synchronization Primitives<ept id=\"p1\">](~/docs/standard/threading/overview-of-synchronization-primitives.md)</ept>.","pos":[194,377],"source":" For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md)."}]},{"pos":[384,788],"content":"The <xref:System.Threading.WaitHandle> class itself is abstract. Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources. The classes derived from <xref:System.Threading.WaitHandle> include:","nodes":[{"content":"The <xref:System.Threading.WaitHandle> class itself is abstract. Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources. The classes derived from <xref:System.Threading.WaitHandle> include:","pos":[0,404],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> class itself is abstract.","pos":[0,64],"source":"The <xref:System.Threading.WaitHandle> class itself is abstract."},{"content":"Classes derived from <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle&gt;</ph> methods to block while waiting for access to shared resources.","pos":[65,335],"source":" Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources."},{"content":"The classes derived from <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> include:","pos":[336,404],"source":" The classes derived from <xref:System.Threading.WaitHandle> include:"}]}]},{"pos":[798,891],"content":"The <xref:System.Threading.Mutex> class. See [Mutexes](~/docs/standard/threading/mutexes.md).","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph> class.","pos":[0,40],"source":"The <xref:System.Threading.Mutex> class."},{"content":"See <bpt id=\"p1\">[</bpt>Mutexes<ept id=\"p1\">](~/docs/standard/threading/mutexes.md)</ept>.","pos":[41,93],"source":" See [Mutexes](~/docs/standard/threading/mutexes.md)."}]},{"pos":[901,1226],"content":"The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>. See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph> class and its derived classes, <ph id=\"ph2\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>.","pos":[0,159],"source":"The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>."},{"content":"See <bpt id=\"p1\">[</bpt>EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent<ept id=\"p1\">](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)</ept>.","pos":[160,325],"source":" See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md)."}]},{"pos":[1236,1373],"content":"The <xref:System.Threading.Semaphore> class. See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> class.","pos":[0,44],"source":"The <xref:System.Threading.Semaphore> class."},{"content":"See <bpt id=\"p1\">[</bpt>Semaphore and SemaphoreSlim<ept id=\"p1\">](~/docs/standard/threading/semaphore-and-semaphoreslim.md)</ept>.","pos":[45,137],"source":" See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md)."}]},{"pos":[1380,1583],"content":"Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.","nodes":[{"content":"Threads can block on an individual wait handle by calling the instance method <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>, which is inherited by classes derived from <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle&gt;</ph>.","pos":[0,203],"source":"Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>."}]},{"pos":[1590,2162],"content":"The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity. Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore. Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.","nodes":[{"content":"The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity. Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore. Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.","pos":[0,572],"nodes":[{"content":"The derived classes of <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> differ in their thread affinity.","pos":[0,90],"source":"The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity."},{"content":"Event wait handles (<ph id=\"ph1\">&lt;xref:System.Threading.EventWaitHandle&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Threading.AutoResetEvent&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Threading.ManualResetEvent&gt;</ph>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore.","pos":[91,338],"source":" Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore."},{"content":"Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <ph id=\"ph1\">&lt;xref:System.Threading.Mutex.ReleaseMutex%2A&gt;</ph> method on a mutex that it does not own.","pos":[339,572],"source":" Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own."}]}]},{"pos":[2169,2373],"content":"Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.","nodes":[{"content":"Because the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> class derives from <ph id=\"ph2\">&lt;xref:System.MarshalByRefObject&gt;</ph>, these classes can be used to synchronize the activities of threads across application domain boundaries.","pos":[0,204],"source":"Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries."}]},{"pos":[2380,2587],"content":"In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.. These include:","nodes":[{"content":"In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.. These include:","pos":[0,207],"nodes":[{"content":"In addition to its derived classes, the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> class has a number of static methods that block a thread until one or more synchronization objects receive a signal..","pos":[0,192],"source":"In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.."},{"content":"These include:","pos":[193,207]}]}]},{"pos":[2597,2730],"content":"<xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph>, which allows a thread to signal one wait handle and immediately wait on another.","pos":[0,133],"source":"<xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another."}]},{"pos":[2740,2873],"content":"<xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph>, which allows a thread to wait until all the wait handles in an array receive a signal.","pos":[0,133],"source":"<xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal."}]},{"pos":[2883,3028],"content":"<xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .","pos":[0,145],"source":"<xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled ."}]},{"pos":[3035,3255],"content":"The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.","nodes":[{"content":"The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.","pos":[0,220]}]},{"pos":[3263,3822],"content":"[!IMPORTANT]\n This type implements the <xref:System.IDisposable> interface. When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.","leadings":["","> "],"nodes":[{"content":" This type implements the <xref:System.IDisposable> interface. When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.","pos":[13,557],"nodes":[{"content":"This type implements the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface.","pos":[1,62],"source":" This type implements the <xref:System.IDisposable> interface."},{"content":"When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly.","pos":[63,183]},{"content":"To dispose of the type directly, call its <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> method in a <ph id=\"ph2\">`try`</ph><ph id=\"ph3\">/</ph><ph id=\"ph4\">`catch`</ph> block.","pos":[184,302],"source":" To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block."},{"content":"To dispose of it indirectly, use a language construct such as <ph id=\"ph1\">`using`</ph> (in C#) or <ph id=\"ph2\">`Using`</ph> (in Visual Basic).","pos":[303,410],"source":" To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic)."},{"content":"For more information, see the \"Using an Object that Implements IDisposable\" section in the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface topic.","pos":[411,544],"source":" For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic."}]}]},{"pos":[3829,4323],"content":"<xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern. See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md). When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle. You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> implements the <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> pattern.","pos":[0,95],"source":"<xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern."},{"content":"See <bpt id=\"p1\">[</bpt>Dispose Pattern<ept id=\"p1\">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>.","pos":[96,172],"source":" See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md)."},{"content":"When you derive from <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> property to store your native handle operating system handle.","pos":[173,352],"source":" When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle."},{"content":"You do not need to override the protected <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.Dispose%2A&gt;</ph> method unless you use additional unmanaged resources.","pos":[353,494],"source":" You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources."}]}],"pos":[2370,6727],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Threading.WaitHandle\"></xref> class.","nodes":[{"pos":[0,89],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> class.","source":"Initializes a new instance of the <xref href=\"System.Threading.WaitHandle\"></xref> class."}],"pos":[9755,9845],"yaml":true},{"content":"Releases all resources held by the current <xref href=\"System.Threading.WaitHandle\"></xref>.","nodes":[{"pos":[0,92],"content":"Releases all resources held by the current <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph>.","source":"Releases all resources held by the current <xref href=\"System.Threading.WaitHandle\"></xref>."}],"pos":[11404,11497],"yaml":true},{"content":"This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method for the <xref:System.Threading.WaitHandle> class and its derived classes. It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method. Call this method to release all resources held by an instance of `WaitHandle` or a derived class.  \n  \n Once this method is called, references to the current instance cause undefined behavior.  \n  \n> [!NOTE]\n>  Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>. Otherwise, the resources it is using will not be freed.","nodes":[{"pos":[0,481],"content":"This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method for the <xref:System.Threading.WaitHandle> class and its derived classes. It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method. Call this method to release all resources held by an instance of `WaitHandle` or a derived class.","nodes":[{"content":"This method is the public implementation of the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> method for the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle&gt;</ph> class and its derived classes.","pos":[0,190],"source":"This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method for the <xref:System.Threading.WaitHandle> class and its derived classes."},{"content":"It provides a standard implementation that calls the <ph id=\"ph1\">`Dispose(Boolean)`</ph> overload with a <ph id=\"ph2\">`true`</ph> argument and then calls the <ph id=\"ph3\">&lt;xref:System.GC.SuppressFinalize%2A?displayProperty=fullName&gt;</ph> method.","pos":[191,383],"source":" It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method."},{"content":"Call this method to release all resources held by an instance of <ph id=\"ph1\">`WaitHandle`</ph> or a derived class.","pos":[384,481],"source":" Call this method to release all resources held by an instance of `WaitHandle` or a derived class."}]},{"pos":[488,576],"content":"Once this method is called, references to the current instance cause undefined behavior.","nodes":[{"content":"Once this method is called, references to the current instance cause undefined behavior.","pos":[0,88]}]},{"pos":[584,834],"content":"[!NOTE]\n Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>. Otherwise, the resources it is using will not be freed.","leadings":["","> "],"nodes":[{"content":" Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>. Otherwise, the resources it is using will not be freed.","pos":[8,248],"nodes":[{"content":"Always call <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.Dispose&gt;</ph> before you release your last reference to the <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle&gt;</ph>.","pos":[1,184],"source":" Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>."},{"content":"Otherwise, the resources it is using will not be freed.","pos":[185,240]}]}]}],"pos":[11508,12350],"yaml":true,"extradata":"MT"},{"content":"Releases all resources used by the current instance of the <xref href=\"System.Threading.WaitHandle\"></xref> class.","nodes":[{"pos":[0,114],"content":"Releases all resources used by the current instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> class.","source":"Releases all resources used by the current instance of the <xref href=\"System.Threading.WaitHandle\"></xref> class."}],"pos":[13582,13697],"yaml":true},{"content":"This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.  \n  \n> [!NOTE]\n>  Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>. Otherwise, the resources it is using will not be freed.","nodes":[{"pos":[0,84],"content":"This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.","nodes":[{"content":"This method is equivalent to the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> method.","pos":[0,84],"source":"This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method."}]},{"pos":[92,342],"content":"[!NOTE]\n Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>. Otherwise, the resources it is using will not be freed.","leadings":["","> "],"nodes":[{"content":" Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>. Otherwise, the resources it is using will not be freed.","pos":[8,248],"nodes":[{"content":"Always call <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.Dispose&gt;</ph> before you release your last reference to the <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle&gt;</ph>.","pos":[1,184],"source":" Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>."},{"content":"Otherwise, the resources it is using will not be freed.","pos":[185,240]}]}]}],"pos":[13708,14056],"yaml":true,"extradata":"MT"},{"content":"When overridden in a derived class, releases the unmanaged resources used by the <xref href=\"System.Threading.WaitHandle\"></xref>, and optionally releases the managed resources.","nodes":[{"pos":[0,177],"content":"When overridden in a derived class, releases the unmanaged resources used by the <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph>, and optionally releases the managed resources.","source":"When overridden in a derived class, releases the unmanaged resources used by the <xref href=\"System.Threading.WaitHandle\"></xref>, and optionally releases the managed resources."}],"pos":[15697,15875],"yaml":true},{"content":"This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.  When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.","nodes":[{"pos":[0,363],"content":"This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.  When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.","nodes":[{"content":"This method is called by the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.Close%2A&gt;</ph> and the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.Dispose&gt;</ph> methods with the <ph id=\"ph3\">`explicitDisposing`</ph> parameter set to <ph id=\"ph4\">`true`</ph>.","pos":[0,185],"source":"This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`."},{"content":"When the <ph id=\"ph1\">`explicitDisposing`</ph> parameter is <ph id=\"ph2\">`true`</ph>, this method releases all resources held by any managed objects that this <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle&gt;</ph> object references.","pos":[187,363],"source":"  When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references."}]}],"pos":[15886,16250],"yaml":true,"extradata":"MT"},{"content":"`true` to release both managed and unmanaged resources; `false` to release only unmanaged resources.","nodes":[{"pos":[0,100],"content":"<ph id=\"ph1\">`true`</ph> to release both managed and unmanaged resources; <ph id=\"ph2\">`false`</ph> to release only unmanaged resources.","source":"`true` to release both managed and unmanaged resources; `false` to release only unmanaged resources."}],"pos":[16420,16523],"yaml":true},{"content":"Gets or sets the native operating system handle.","nodes":[{"pos":[0,48],"content":"Gets or sets the native operating system handle.","nodes":[{"content":"Gets or sets the native operating system handle.","pos":[0,48]}]}],"pos":[18036,18085],"yaml":true},{"content":"Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle. This can result in a leaked handle.  \n  \n Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead. Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.","nodes":[{"pos":[0,154],"content":"Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle. This can result in a leaked handle.","nodes":[{"content":"Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle. This can result in a leaked handle.","pos":[0,154],"nodes":[{"content":"Assigning a new value to the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.Handle%2A&gt;</ph> property does not close the previous handle.","pos":[0,118],"source":"Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle."},{"content":"This can result in a leaked handle.","pos":[119,154]}]}]},{"pos":[161,523],"content":"Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead. Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.","nodes":[{"content":"Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead. Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.","pos":[0,362],"nodes":[{"content":"Do not use this property in the .NET Framework version 2.0 or later; use the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> property instead.","pos":[0,147],"source":"Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead."},{"content":"Setting this property to a valid handle also sets the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> property, but setting it to <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.InvalidHandle&gt;</ph> can result in a leaked handle.","pos":[148,362],"source":" Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle."}]}]}],"pos":[18096,18624],"yaml":true,"extradata":"MT"},{"content":"An `IntPtr` representing the native operating system handle. The default is the value of the <xref href=\"System.Threading.WaitHandle.InvalidHandle\"></xref> field.","nodes":[{"pos":[0,162],"content":"An `IntPtr` representing the native operating system handle. The default is the value of the <xref href=\"System.Threading.WaitHandle.InvalidHandle\"></xref> field.","nodes":[{"content":"An <ph id=\"ph1\">`IntPtr`</ph> representing the native operating system handle.","pos":[0,60],"source":"An `IntPtr` representing the native operating system handle."},{"content":"The default is the value of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle.InvalidHandle\"&gt;&lt;/xref&gt;</ph> field.","pos":[61,162],"source":" The default is the value of the <xref href=\"System.Threading.WaitHandle.InvalidHandle\"></xref> field."}]}],"pos":[18923,19086],"yaml":true},{"content":"Represents an invalid native operating system handle. This field is read-only.","nodes":[{"pos":[0,78],"content":"Represents an invalid native operating system handle. This field is read-only.","nodes":[{"content":"Represents an invalid native operating system handle. This field is read-only.","pos":[0,78],"nodes":[{"content":"Represents an invalid native operating system handle.","pos":[0,53]},{"content":"This field is read-only.","pos":[54,78]}]}]}],"pos":[20429,20508],"yaml":true},{"content":"Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.","nodes":[{"pos":[0,88],"content":"Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.","nodes":[{"content":"Used internally to initialize the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.Handle%2A&gt;</ph> property.","pos":[0,88],"source":"Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property."}]}],"pos":[20519,20608],"yaml":true,"extradata":"MT"},{"content":"Gets or sets the native operating system handle.","nodes":[{"pos":[0,48],"content":"Gets or sets the native operating system handle.","nodes":[{"content":"Gets or sets the native operating system handle.","pos":[0,48]}]}],"pos":[22234,22283],"yaml":true},{"content":"When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected. Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.  \n  \n <xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern. See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md). When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle. You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.","nodes":[{"pos":[0,409],"content":"When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected. Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.","nodes":[{"content":"When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected. Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.","pos":[0,409],"nodes":[{"content":"When you assign a new value to the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> property, the previous handle will be closed when the previous <ph id=\"ph2\">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> object is collected.","pos":[0,221],"source":"When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected."},{"content":"Do not manually close the handle, because this results in an <ph id=\"ph1\">&lt;xref:System.ObjectDisposedException&gt;</ph> when the <ph id=\"ph2\">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> attempts to close the handle.","pos":[222,409],"source":" Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle."}]}]},{"pos":[416,910],"content":"<xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern. See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md). When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle. You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> implements the <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> pattern.","pos":[0,95],"source":"<xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern."},{"content":"See <bpt id=\"p1\">[</bpt>Dispose Pattern<ept id=\"p1\">](~/docs/standard/design-guidelines/dispose-pattern.md)</ept>.","pos":[96,172],"source":" See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md)."},{"content":"When you derive from <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph>, use the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.SafeWaitHandle%2A&gt;</ph> property to store your native handle operating system handle.","pos":[173,352],"source":" When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle."},{"content":"You do not need to override the protected <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.Dispose%2A&gt;</ph> method unless you use additional unmanaged resources.","pos":[353,494],"source":" You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources."}]}],"pos":[22294,23209],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"Microsoft.Win32.SafeHandles.SafeWaitHandle\"></xref> representing the native operating system handle.","nodes":[{"pos":[0,114],"content":"A <ph id=\"ph1\">&lt;xref href=\"Microsoft.Win32.SafeHandles.SafeWaitHandle\"&gt;&lt;/xref&gt;</ph> representing the native operating system handle.","source":"A <xref href=\"Microsoft.Win32.SafeHandles.SafeWaitHandle\"></xref> representing the native operating system handle."}],"pos":[23876,23991],"yaml":true},{"content":"Signals one <xref href=\"System.Threading.WaitHandle\"></xref> and waits on another.","nodes":[{"pos":[0,82],"content":"Signals one <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> and waits on another.","source":"Signals one <xref href=\"System.Threading.WaitHandle\"></xref> and waits on another."}],"pos":[25693,25776],"yaml":true},{"content":"This operation is not guaranteed to be atomic. After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.","nodes":[{"pos":[0,210],"content":"This operation is not guaranteed to be atomic. After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.","nodes":[{"content":"This operation is not guaranteed to be atomic.","pos":[0,46]},{"content":"After the current thread signals <ph id=\"ph1\">`toSignal`</ph> but before it waits on <ph id=\"ph2\">`toWaitOn`</ph>, a thread that is running on another processor might signal <ph id=\"ph3\">`toWaitOn`</ph> or wait on it.","pos":[47,210],"source":" After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it."}]}],"pos":[25787,25998],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Threading.WaitHandle\"></xref> to signal.","nodes":[{"pos":[0,63],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> to signal.","source":"The <xref href=\"System.Threading.WaitHandle\"></xref> to signal."}],"pos":[27486,27550],"yaml":true},{"content":"The <xref href=\"System.Threading.WaitHandle\"></xref> to wait on.","nodes":[{"pos":[0,64],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> to wait on.","source":"The <xref href=\"System.Threading.WaitHandle\"></xref> to wait on."}],"pos":[27628,27693],"yaml":true},{"content":"`true` if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.","nodes":[{"pos":[0,120],"content":"<ph id=\"ph1\">`true`</ph> if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.","source":"`true` if both the signal and the wait complete successfully; if the wait does not complete, the method does not return."}],"pos":[27751,27874],"yaml":true},{"content":"<code>toSignal</code> is `null`.  \n  \n -or-  \n  \n <code>toWaitOn</code> is `null`.","nodes":[{"pos":[0,32],"content":"<ph id=\"ph1\">&lt;code&gt;toSignal&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>toSignal</code> is `null`."},{"pos":[39,43],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[50,82],"content":"<ph id=\"ph1\">&lt;code&gt;toWaitOn&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>toWaitOn</code> is `null`."}],"pos":[28045,28134],"yaml":true},{"content":"The method was called on a thread that has <xref href=\"System.STAThreadAttribute\"></xref>.","nodes":[{"pos":[0,90],"content":"The method was called on a thread that has <ph id=\"ph1\">&lt;xref href=\"System.STAThreadAttribute\"&gt;&lt;/xref&gt;</ph>.","source":"The method was called on a thread that has <xref href=\"System.STAThreadAttribute\"></xref>."}],"pos":[28236,28327],"yaml":true},{"content":"This method is not supported on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,73],"content":"This method is not supported on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"This method is not supported on Windows 98 or Windows Millennium Edition.","pos":[0,73]}]}],"pos":[28445,28519],"yaml":true},{"content":"<code>toSignal</code> is a semaphore, and it already has a full count.","nodes":[{"pos":[0,70],"content":"<ph id=\"ph1\">&lt;code&gt;toSignal&lt;/code&gt;</ph> is a semaphore, and it already has a full count.","source":"<code>toSignal</code> is a semaphore, and it already has a full count."}],"pos":[28629,28700],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[28826,28970],"yaml":true},{"content":"Signals one <xref href=\"System.Threading.WaitHandle\"></xref> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.","nodes":[{"pos":[0,240],"content":"Signals one <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.","source":"Signals one <xref href=\"System.Threading.WaitHandle\"></xref> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait."}],"pos":[30471,30712],"yaml":true},{"content":"This operation is not guaranteed to be atomic. After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.  \n  \n If `millisecondsTimeout` is zero, the method does not block. It tests the state of the `toWaitOn` and returns immediately.  \n  \n## Notes on Exiting the Context  \n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.  \n  \n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"pos":[0,210],"content":"This operation is not guaranteed to be atomic. After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.","nodes":[{"content":"This operation is not guaranteed to be atomic.","pos":[0,46]},{"content":"After the current thread signals <ph id=\"ph1\">`toSignal`</ph> but before it waits on <ph id=\"ph2\">`toWaitOn`</ph>, a thread that is running on another processor might signal <ph id=\"ph3\">`toWaitOn`</ph> or wait on it.","pos":[47,210],"source":" After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it."}]},{"pos":[217,339],"content":"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the `toWaitOn` and returns immediately.","nodes":[{"content":"If <ph id=\"ph1\">`millisecondsTimeout`</ph> is zero, the method does not block.","pos":[0,60],"source":"If `millisecondsTimeout` is zero, the method does not block."},{"content":"It tests the state of the <ph id=\"ph1\">`toWaitOn`</ph> and returns immediately.","pos":[61,122],"source":" It tests the state of the `toWaitOn` and returns immediately."}]},{"pos":[348,376],"content":"Notes on Exiting the Context","linkify":"Notes on Exiting the Context","nodes":[{"content":"Notes on Exiting the Context","pos":[0,28]}]},{"pos":[380,932],"content":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.","nodes":[{"content":"The <ph id=\"ph1\">`exitContext`</ph> parameter has no effect unless the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method is called from inside a nondefault managed context.","pos":[0,163],"source":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context."},{"content":"This can happen if your thread is inside a call to an instance of a class derived from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>.","pos":[164,284],"source":" This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>."},{"content":"Even if you are currently executing a method on a class that does not derive from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id=\"ph3\">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.","pos":[285,552],"source":" Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain."}]},{"pos":[939,1359],"content":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.","nodes":[{"content":"When your code is executing in a nondefault context, specifying <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method.","pos":[0,274],"source":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method."},{"content":"The thread returns to the original nondefault context after the call to the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method completes.","pos":[275,420],"source":" The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes."}]},{"pos":[1366,2068],"content":"This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"content":"This can be useful when the context-bound class has <ph id=\"ph1\">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.","pos":[0,117],"source":"This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>."},{"content":"In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.","pos":[118,270]},{"content":"If code in the call stack of a member calls the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method and specifies <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.","pos":[271,546],"source":" If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.","pos":[547,702],"source":" When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain."}]}],"pos":[30723,32803],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Threading.WaitHandle\"></xref> to signal.","nodes":[{"pos":[0,63],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> to signal.","source":"The <xref href=\"System.Threading.WaitHandle\"></xref> to signal."}],"pos":[33074,33138],"yaml":true},{"content":"The <xref href=\"System.Threading.WaitHandle\"></xref> to wait on.","nodes":[{"pos":[0,64],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> to wait on.","source":"The <xref href=\"System.Threading.WaitHandle\"></xref> to wait on."}],"pos":[33216,33281],"yaml":true},{"content":"An integer that represents the interval to wait. If the value is <xref href=\"System.Threading.Timeout.Infinite\"></xref>, that is, -1, the wait is infinite.","nodes":[{"pos":[0,155],"content":"An integer that represents the interval to wait. If the value is <xref href=\"System.Threading.Timeout.Infinite\"></xref>, that is, -1, the wait is infinite.","nodes":[{"content":"An integer that represents the interval to wait.","pos":[0,48]},{"content":"If the value is <ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph>, that is, -1, the wait is infinite.","pos":[49,155],"source":" If the value is <xref href=\"System.Threading.Timeout.Infinite\"></xref>, that is, -1, the wait is infinite."}]}],"pos":[33355,33511],"yaml":true},{"content":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.","nodes":[{"pos":[0,153],"content":"<ph id=\"ph1\">`true`</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`."}],"pos":[33579,33735],"yaml":true},{"content":"`true` if both the signal and the wait completed successfully, or `false` if the signal completed but the wait timed out.","nodes":[{"pos":[0,121],"content":"<ph id=\"ph1\">`true`</ph> if both the signal and the wait completed successfully, or <ph id=\"ph2\">`false`</ph> if the signal completed but the wait timed out.","source":"`true` if both the signal and the wait completed successfully, or `false` if the signal completed but the wait timed out."}],"pos":[33793,33917],"yaml":true},{"content":"<code>toSignal</code> is `null`.  \n  \n -or-  \n  \n <code>toWaitOn</code> is `null`.","nodes":[{"pos":[0,32],"content":"<ph id=\"ph1\">&lt;code&gt;toSignal&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>toSignal</code> is `null`."},{"pos":[39,43],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[50,82],"content":"<ph id=\"ph1\">&lt;code&gt;toWaitOn&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>toWaitOn</code> is `null`."}],"pos":[34088,34177],"yaml":true},{"content":"The method is called on a thread that has <xref href=\"System.STAThreadAttribute\"></xref>.","nodes":[{"pos":[0,89],"content":"The method is called on a thread that has <ph id=\"ph1\">&lt;xref href=\"System.STAThreadAttribute\"&gt;&lt;/xref&gt;</ph>.","source":"The method is called on a thread that has <xref href=\"System.STAThreadAttribute\"></xref>."}],"pos":[34279,34369],"yaml":true},{"content":"This method is not supported on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,73],"content":"This method is not supported on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"This method is not supported on Windows 98 or Windows Millennium Edition.","pos":[0,73]}]}],"pos":[34487,34561],"yaml":true},{"content":"The <xref href=\"System.Threading.WaitHandle\"></xref> cannot be signaled because it would exceed its maximum count.","nodes":[{"pos":[0,114],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> cannot be signaled because it would exceed its maximum count.","source":"The <xref href=\"System.Threading.WaitHandle\"></xref> cannot be signaled because it would exceed its maximum count."}],"pos":[34671,34786],"yaml":true},{"content":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.","nodes":[{"pos":[0,107],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite time-out.","source":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out."}],"pos":[34900,35008],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[35134,35278],"yaml":true},{"content":"Signals one <xref href=\"System.Threading.WaitHandle\"></xref> and waits on another, specifying the time-out interval as a <xref href=\"System.TimeSpan\"></xref> and specifying whether to exit the synchronization domain for the context before entering the wait.","nodes":[{"pos":[0,257],"content":"Signals one <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> and waits on another, specifying the time-out interval as a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> and specifying whether to exit the synchronization domain for the context before entering the wait.","source":"Signals one <xref href=\"System.Threading.WaitHandle\"></xref> and waits on another, specifying the time-out interval as a <xref href=\"System.TimeSpan\"></xref> and specifying whether to exit the synchronization domain for the context before entering the wait."}],"pos":[36814,37072],"yaml":true},{"content":"This operation is not guaranteed to be atomic. After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.  \n  \n The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \n  \n If `timeout` is zero, the method does not block. It tests the state of the `toWaitOn` and returns immediately.  \n  \n## Notes on Exiting the Context  \n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.  \n  \n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"pos":[0,210],"content":"This operation is not guaranteed to be atomic. After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.","nodes":[{"content":"This operation is not guaranteed to be atomic.","pos":[0,46]},{"content":"After the current thread signals <ph id=\"ph1\">`toSignal`</ph> but before it waits on <ph id=\"ph2\">`toWaitOn`</ph>, a thread that is running on another processor might signal <ph id=\"ph3\">`toWaitOn`</ph> or wait on it.","pos":[47,210],"source":" After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it."}]},{"pos":[217,306],"content":"The maximum value for <ph id=\"ph1\">`timeout`</ph> is <ph id=\"ph2\">&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;</ph>.","source":"The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>."},{"pos":[313,423],"content":"If `timeout` is zero, the method does not block. It tests the state of the `toWaitOn` and returns immediately.","nodes":[{"content":"If <ph id=\"ph1\">`timeout`</ph> is zero, the method does not block.","pos":[0,48],"source":"If `timeout` is zero, the method does not block."},{"content":"It tests the state of the <ph id=\"ph1\">`toWaitOn`</ph> and returns immediately.","pos":[49,110],"source":" It tests the state of the `toWaitOn` and returns immediately."}]},{"pos":[432,460],"content":"Notes on Exiting the Context","linkify":"Notes on Exiting the Context","nodes":[{"content":"Notes on Exiting the Context","pos":[0,28]}]},{"pos":[464,1016],"content":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.","nodes":[{"content":"The <ph id=\"ph1\">`exitContext`</ph> parameter has no effect unless the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method is called from inside a nondefault managed context.","pos":[0,163],"source":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context."},{"content":"This can happen if your thread is inside a call to an instance of a class derived from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>.","pos":[164,284],"source":" This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>."},{"content":"Even if you are currently executing a method on a class that does not derive from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id=\"ph3\">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.","pos":[285,552],"source":" Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain."}]},{"pos":[1023,1443],"content":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.","nodes":[{"content":"When your code is executing in a nondefault context, specifying <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method.","pos":[0,274],"source":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method."},{"content":"The thread returns to the original nondefault context after the call to the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method completes.","pos":[275,420],"source":" The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes."}]},{"pos":[1450,2152],"content":"This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"content":"This can be useful when the context-bound class has <ph id=\"ph1\">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.","pos":[0,117],"source":"This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>."},{"content":"In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.","pos":[118,270]},{"content":"If code in the call stack of a member calls the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method and specifies <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.","pos":[271,546],"source":" If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.SignalAndWait%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.","pos":[547,702],"source":" When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain."}]}],"pos":[37083,39249],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Threading.WaitHandle\"></xref> to signal.","nodes":[{"pos":[0,63],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> to signal.","source":"The <xref href=\"System.Threading.WaitHandle\"></xref> to signal."}],"pos":[39513,39577],"yaml":true},{"content":"The <xref href=\"System.Threading.WaitHandle\"></xref> to wait on.","nodes":[{"pos":[0,64],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> to wait on.","source":"The <xref href=\"System.Threading.WaitHandle\"></xref> to wait on."}],"pos":[39655,39720],"yaml":true},{"content":"A <xref href=\"System.TimeSpan\"></xref> that represents the interval to wait. If the value is -1, the wait is infinite.","nodes":[{"pos":[0,118],"content":"A <xref href=\"System.TimeSpan\"></xref> that represents the interval to wait. If the value is -1, the wait is infinite.","nodes":[{"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents the interval to wait.","pos":[0,76],"source":"A <xref href=\"System.TimeSpan\"></xref> that represents the interval to wait."},{"content":"If the value is -1, the wait is infinite.","pos":[77,118]}]}],"pos":[39785,39904],"yaml":true},{"content":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.","nodes":[{"pos":[0,153],"content":"<ph id=\"ph1\">`true`</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`."}],"pos":[39972,40128],"yaml":true},{"content":"`true` if both the signal and the wait completed successfully, or `false` if the signal completed but the wait timed out.","nodes":[{"pos":[0,121],"content":"<ph id=\"ph1\">`true`</ph> if both the signal and the wait completed successfully, or <ph id=\"ph2\">`false`</ph> if the signal completed but the wait timed out.","source":"`true` if both the signal and the wait completed successfully, or `false` if the signal completed but the wait timed out."}],"pos":[40186,40310],"yaml":true},{"content":"<code>toSignal</code> is `null`.  \n  \n -or-  \n  \n <code>toWaitOn</code> is `null`.","nodes":[{"pos":[0,32],"content":"<ph id=\"ph1\">&lt;code&gt;toSignal&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>toSignal</code> is `null`."},{"pos":[39,43],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[50,82],"content":"<ph id=\"ph1\">&lt;code&gt;toWaitOn&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>toWaitOn</code> is `null`."}],"pos":[40481,40570],"yaml":true},{"content":"The method was called on a thread that has <xref href=\"System.STAThreadAttribute\"></xref>.","nodes":[{"pos":[0,90],"content":"The method was called on a thread that has <ph id=\"ph1\">&lt;xref href=\"System.STAThreadAttribute\"&gt;&lt;/xref&gt;</ph>.","source":"The method was called on a thread that has <xref href=\"System.STAThreadAttribute\"></xref>."}],"pos":[40672,40763],"yaml":true},{"content":"This method is not supported on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,73],"content":"This method is not supported on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"This method is not supported on Windows 98 or Windows Millennium Edition.","pos":[0,73]}]}],"pos":[40881,40955],"yaml":true},{"content":"<code>toSignal</code> is a semaphore, and it already has a full count.","nodes":[{"pos":[0,70],"content":"<ph id=\"ph1\">&lt;code&gt;toSignal&lt;/code&gt;</ph> is a semaphore, and it already has a full count.","source":"<code>toSignal</code> is a semaphore, and it already has a full count."}],"pos":[41065,41136],"yaml":true},{"content":"<code>timeout</code> evaluates to a negative number of milliseconds other than -1.  \n  \n -or-  \n  \n <code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,82],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> evaluates to a negative number of milliseconds other than -1.","source":"<code>timeout</code> evaluates to a negative number of milliseconds other than -1."},{"pos":[89,93],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[100,180],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[41250,41439],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[41565,41709],"yaml":true},{"content":"Waits for all the elements in the specified array to receive a signal, using a <xref href=\"System.TimeSpan\"></xref> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.","nodes":[{"pos":[0,226],"content":"Waits for all the elements in the specified array to receive a signal, using a <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.","source":"Waits for all the elements in the specified array to receive a signal, using a <xref href=\"System.TimeSpan\"></xref> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait."}],"pos":[43084,43311],"yaml":true},{"content":"If `timeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call will fail.  \n  \n> [!NOTE]\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \n  \n The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \n  \n## Notes on Exiting the Context  \n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method. It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.  \n  \n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"pos":[0,112],"content":"If `timeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.","nodes":[{"content":"If <ph id=\"ph1\">`timeout`</ph> is zero, the method does not block.","pos":[0,48],"source":"If `timeout` is zero, the method does not block."},{"content":"It tests the state of the wait handles and returns immediately.","pos":[49,112]}]},{"pos":[119,594],"content":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.","pos":[0,89],"source":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0."},{"content":"In previous versions, the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns <ph id=\"ph2\">`true`</ph> when a mutex is abandoned.","pos":[90,210],"source":" In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned."},{"content":"An abandoned mutex often indicates a serious coding error.","pos":[211,269]},{"content":"In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).","pos":[270,418]},{"content":"The exception contains information useful for debugging.","pos":[419,475]}]},{"pos":[601,925],"content":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call will fail.","nodes":[{"content":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call will fail.","pos":[0,324],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.","pos":[0,160],"source":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs."},{"content":"On some implementations, if more than 64 handles are passed, a <ph id=\"ph1\">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.","pos":[161,270],"source":" On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown."},{"content":"If the array contains duplicates, the call will fail.","pos":[271,324]}]}]},{"pos":[933,1072],"content":"[!NOTE]\n The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method is not supported on threads that have <ph id=\"ph2\">&lt;xref:System.STAThreadAttribute&gt;</ph>.","pos":[9,137],"source":" The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>."}]},{"pos":[1079,1168],"content":"The maximum value for <ph id=\"ph1\">`timeout`</ph> is <ph id=\"ph2\">&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;</ph>.","source":"The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>."},{"pos":[1177,1205],"content":"Notes on Exiting the Context","linkify":"Notes on Exiting the Context","nodes":[{"content":"Notes on Exiting the Context","pos":[0,28]}]},{"pos":[1209,1754],"content":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.","nodes":[{"content":"The <ph id=\"ph1\">`exitContext`</ph> parameter has no effect unless the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method is called from inside a nondefault managed context.","pos":[0,157],"source":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context."},{"content":"This can happen if your thread is inside a call to an instance of a class derived from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>.","pos":[158,278],"source":" This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>."},{"content":"Even if you are currently executing a method on a class that is not derived from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id=\"ph3\">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.","pos":[279,545],"source":" Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain."}]},{"pos":[1761,2161],"content":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method. It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.","nodes":[{"content":"When your code is executing in a nondefault context, specifying <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method.","pos":[0,268],"source":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method."},{"content":"It returns to the original nondefault context after the call to the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method completes.","pos":[269,400],"source":" It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes."}]},{"pos":[2168,2858],"content":"This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"content":"This can be useful when the context-bound class has <ph id=\"ph1\">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.","pos":[0,117],"source":"This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>."},{"content":"In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.","pos":[118,270]},{"content":"If code in the call stack of a member calls the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method and specifies <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.","pos":[271,540],"source":" If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.","pos":[541,690],"source":" When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain."}]}],"pos":[43322,46199],"yaml":true,"extradata":"MT"},{"content":"A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.","nodes":[{"pos":[0,151],"content":"A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.","nodes":[{"content":"A <ph id=\"ph1\">`WaitHandle`</ph> array containing the objects for which the current instance will wait.","pos":[0,85],"source":"A `WaitHandle` array containing the objects for which the current instance will wait."},{"content":"This array cannot contain multiple references to the same object.","pos":[86,151]}]}],"pos":[47190,47342],"yaml":true},{"content":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds, to wait indefinitely.","nodes":[{"pos":[0,187],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents the number of milliseconds to wait, or a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents -1 milliseconds, to wait indefinitely.","source":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds, to wait indefinitely."}],"pos":[47407,47595],"yaml":true},{"content":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.","nodes":[{"pos":[0,153],"content":"<ph id=\"ph1\">`true`</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`."}],"pos":[47663,47819],"yaml":true},{"content":"`true` when every element in <code>waitHandles</code> has received a signal; otherwise `false`.","nodes":[{"pos":[0,95],"content":"<ph id=\"ph1\">`true`</ph> when every element in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> has received a signal; otherwise <ph id=\"ph3\">`false`</ph>.","source":"`true` when every element in <code>waitHandles</code> has received a signal; otherwise `false`."}],"pos":[47877,47975],"yaml":true},{"content":"The <code>waitHandles</code> parameter is `null`.  \n  \n -or-  \n  \n One or more of the objects in the <code>waitHandles</code> array is `null`.  \n  \n -or-  \n  \n <code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later.","nodes":[{"pos":[0,49],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>waitHandles</code> parameter is `null`."},{"pos":[56,60],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[67,142],"content":"One or more of the objects in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array is <ph id=\"ph2\">`null`</ph>.","source":"One or more of the objects in the <code>waitHandles</code> array is `null`."},{"pos":[149,153],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[160,261],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements and the .NET Framework version is 2.0 or later.","source":"<code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later."}],"pos":[48140,48412],"yaml":true},{"content":"The <code>waitHandles</code> array contains elements that are duplicates.","nodes":[{"pos":[0,73],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains elements that are duplicates.","source":"The <code>waitHandles</code> array contains elements that are duplicates."}],"pos":[48528,48602],"yaml":true},{"content":"The number of objects in <code>waitHandles</code> is greater than the system permits.  \n  \n -or-  \n  \n The <xref href=\"System.STAThreadAttribute\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.","nodes":[{"pos":[0,85],"content":"The number of objects in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> is greater than the system permits.","source":"The number of objects in <code>waitHandles</code> is greater than the system permits."},{"pos":[92,96],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[103,283],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.STAThreadAttribute\"&gt;&lt;/xref&gt;</ph> attribute is applied to the thread procedure for the current thread, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains more than one element.","source":"The <xref href=\"System.STAThreadAttribute\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element."}],"pos":[48704,48996],"yaml":true},{"content":"<code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1.","nodes":[{"pos":[0,99],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements and the .NET Framework version is 1.0 or 1.1.","source":"<code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1."}],"pos":[49096,49196],"yaml":true},{"content":"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  \n  \n -or-  \n  \n <code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,108],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.","source":"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out."},{"pos":[115,119],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[126,206],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[49310,49525],"yaml":true},{"content":"The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,144],"content":"The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,144],"nodes":[{"content":"The wait terminated because a thread exited without releasing a mutex.","pos":[0,70]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[71,144]}]}]}],"pos":[49651,49796],"yaml":true},{"content":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,149],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains a transparent proxy for a <ph id=\"ph2\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[49906,50056],"yaml":true},{"content":"Waits for all the elements in the specified array to receive a signal, using an <xref href=\"System.Int32\"></xref> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.","nodes":[{"pos":[0,223],"content":"Waits for all the elements in the specified array to receive a signal, using an <ph id=\"ph1\">&lt;xref href=\"System.Int32\"&gt;&lt;/xref&gt;</ph> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.","source":"Waits for all the elements in the specified array to receive a signal, using an <xref href=\"System.Int32\"></xref> value to specify the time interval and specifying whether to exit the synchronization domain before the wait."}],"pos":[51413,51637],"yaml":true},{"content":"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.  \n  \n> [!NOTE]\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \n  \n## Notes on Exiting the Context  \n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.  \n  \n This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"pos":[0,124],"content":"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.","nodes":[{"content":"If <ph id=\"ph1\">`millisecondsTimeout`</ph> is zero, the method does not block.","pos":[0,60],"source":"If `millisecondsTimeout` is zero, the method does not block."},{"content":"It tests the state of the wait handles and returns immediately.","pos":[61,124]}]},{"pos":[131,606],"content":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.","pos":[0,89],"source":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0."},{"content":"In previous versions, the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns <ph id=\"ph2\">`true`</ph> when a mutex is abandoned.","pos":[90,210],"source":" In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned."},{"content":"An abandoned mutex often indicates a serious coding error.","pos":[211,269]},{"content":"In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).","pos":[270,418]},{"content":"The exception contains information useful for debugging.","pos":[419,475]}]},{"pos":[613,995],"content":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.","nodes":[{"content":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.","pos":[0,382],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.","pos":[0,168],"source":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs."},{"content":"On some implementations, if more than 64 handles are passed, a <ph id=\"ph1\">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.","pos":[169,278],"source":" On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown."},{"content":"If there are duplicates in the array, the call fails with a <ph id=\"ph1\">&lt;xref:System.DuplicateWaitObjectException&gt;</ph>.","pos":[279,382],"source":" If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>."}]}]},{"pos":[1003,1142],"content":"[!NOTE]\n The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method is not supported on threads that have <ph id=\"ph2\">&lt;xref:System.STAThreadAttribute&gt;</ph>.","pos":[9,137],"source":" The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>."}]},{"pos":[1151,1179],"content":"Notes on Exiting the Context","linkify":"Notes on Exiting the Context","nodes":[{"content":"Notes on Exiting the Context","pos":[0,28]}]},{"pos":[1183,1728],"content":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.","nodes":[{"content":"The <ph id=\"ph1\">`exitContext`</ph> parameter has no effect unless the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method is called from inside a nondefault managed context.","pos":[0,157],"source":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context."},{"content":"This can happen if your thread is inside a call to an instance of a class derived from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>.","pos":[158,278],"source":" This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>."},{"content":"Even if you are currently executing a method on a class that is not derived from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id=\"ph3\">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.","pos":[279,545],"source":" Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain."}]},{"pos":[1735,2143],"content":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.","nodes":[{"content":"When your code is executing in a nondefault context, specifying <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method.","pos":[0,268],"source":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method."},{"content":"The thread returns to the original nondefault context after the call to the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method completes.","pos":[269,408],"source":" The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes."}]},{"pos":[2150,2854],"content":"This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"content":"This can be useful when the context-bound class has the <ph id=\"ph1\">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph> attribute.","pos":[0,131],"source":"This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute."},{"content":"In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.","pos":[132,284]},{"content":"If code in the call stack of a member calls the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method and specifies <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.","pos":[285,554],"source":" If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.","pos":[555,704],"source":" When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain."}]}],"pos":[51648,54519],"yaml":true,"extradata":"MT"},{"content":"A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).","nodes":[{"pos":[0,164],"content":"A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).","nodes":[{"content":"A <ph id=\"ph1\">`WaitHandle`</ph> array containing the objects for which the current instance will wait.","pos":[0,85],"source":"A `WaitHandle` array containing the objects for which the current instance will wait."},{"content":"This array cannot contain multiple references to the same object (duplicates).","pos":[86,164]}]}],"pos":[55517,55682],"yaml":true},{"content":"The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely.","nodes":[{"pos":[0,120],"content":"The number of milliseconds to wait, or <ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (-1) to wait indefinitely.","source":"The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely."}],"pos":[55756,55877],"yaml":true},{"content":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.","nodes":[{"pos":[0,153],"content":"<ph id=\"ph1\">`true`</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`."}],"pos":[55945,56101],"yaml":true},{"content":"`true` when every element in <code>waitHandles</code> has received a signal; otherwise, `false`.","nodes":[{"pos":[0,96],"content":"<ph id=\"ph1\">`true`</ph> when every element in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> has received a signal; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` when every element in <code>waitHandles</code> has received a signal; otherwise, `false`."}],"pos":[56159,56258],"yaml":true},{"content":"The <code>waitHandles</code> parameter is `null`.  \n  \n -or-  \n  \n One or more of the objects in the <code>waitHandles</code> array is `null`.  \n  \n -or-  \n  \n <code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later.","nodes":[{"pos":[0,49],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>waitHandles</code> parameter is `null`."},{"pos":[56,60],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[67,142],"content":"One or more of the objects in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array is <ph id=\"ph2\">`null`</ph>.","source":"One or more of the objects in the <code>waitHandles</code> array is `null`."},{"pos":[149,153],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[160,261],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements and the .NET Framework version is 2.0 or later.","source":"<code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later."}],"pos":[56423,56695],"yaml":true},{"content":"The <code>waitHandles</code> array contains elements that are duplicates.","nodes":[{"pos":[0,73],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains elements that are duplicates.","source":"The <code>waitHandles</code> array contains elements that are duplicates."}],"pos":[56811,56885],"yaml":true},{"content":"The number of objects in <code>waitHandles</code> is greater than the system permits.  \n  \n -or-  \n  \n The <xref href=\"System.STAThreadAttribute\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.","nodes":[{"pos":[0,85],"content":"The number of objects in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> is greater than the system permits.","source":"The number of objects in <code>waitHandles</code> is greater than the system permits."},{"pos":[92,96],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[103,283],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.STAThreadAttribute\"&gt;&lt;/xref&gt;</ph> attribute is applied to the thread procedure for the current thread, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains more than one element.","source":"The <xref href=\"System.STAThreadAttribute\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element."}],"pos":[56987,57279],"yaml":true},{"content":"<code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1.","nodes":[{"pos":[0,99],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements and the .NET Framework version is 1.0 or 1.1.","source":"<code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1."}],"pos":[57379,57479],"yaml":true},{"content":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.","nodes":[{"pos":[0,107],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite time-out.","source":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out."}],"pos":[57593,57701],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[57827,57971],"yaml":true},{"content":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,149],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains a transparent proxy for a <ph id=\"ph2\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[58081,58231],"yaml":true},{"content":"Waits for all the elements in the specified array to receive a signal, using a <xref href=\"System.TimeSpan\"></xref> value to specify the time interval.","nodes":[{"pos":[0,151],"content":"Waits for all the elements in the specified array to receive a signal, using a <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> value to specify the time interval.","source":"Waits for all the elements in the specified array to receive a signal, using a <xref href=\"System.TimeSpan\"></xref> value to specify the time interval."}],"pos":[59551,59703],"yaml":true},{"content":"If `timeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call will fail.  \n  \n> [!NOTE]\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \n  \n The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \n  \n Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.","nodes":[{"pos":[0,112],"content":"If `timeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.","nodes":[{"content":"If <ph id=\"ph1\">`timeout`</ph> is zero, the method does not block.","pos":[0,48],"source":"If `timeout` is zero, the method does not block."},{"content":"It tests the state of the wait handles and returns immediately.","pos":[49,112]}]},{"pos":[119,443],"content":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call will fail.","nodes":[{"content":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call will fail.","pos":[0,324],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs.","pos":[0,160],"source":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs."},{"content":"On some implementations, if more than 64 handles are passed, a <ph id=\"ph1\">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.","pos":[161,270],"source":" On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown."},{"content":"If the array contains duplicates, the call will fail.","pos":[271,324]}]}]},{"pos":[451,590],"content":"[!NOTE]\n The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method is not supported on threads that have <ph id=\"ph2\">&lt;xref:System.STAThreadAttribute&gt;</ph>.","pos":[9,137],"source":" The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>."}]},{"pos":[597,686],"content":"The maximum value for <ph id=\"ph1\">`timeout`</ph> is <ph id=\"ph2\">&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;</ph>.","source":"The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>."},{"pos":[693,916],"content":"Calling this method overload is the same as calling the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29&gt;</ph> overload and specifying <ph id=\"ph2\">`false`</ph> for <ph id=\"ph3\">`exitContext`</ph>.","source":"Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`."}],"pos":[59714,60642],"yaml":true,"extradata":"MT"},{"content":"A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.","nodes":[{"pos":[0,151],"content":"A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.","nodes":[{"content":"A <ph id=\"ph1\">`WaitHandle`</ph> array containing the objects for which the current instance will wait.","pos":[0,85],"source":"A `WaitHandle` array containing the objects for which the current instance will wait."},{"content":"This array cannot contain multiple references to the same object.","pos":[86,151]}]}],"pos":[60854,61006],"yaml":true},{"content":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds, to wait indefinitely.","nodes":[{"pos":[0,187],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents the number of milliseconds to wait, or a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents -1 milliseconds, to wait indefinitely.","source":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds, to wait indefinitely."}],"pos":[61071,61259],"yaml":true},{"content":"`true` when every element in <code>waitHandles</code> has received a signal; otherwise, `false`.","nodes":[{"pos":[0,96],"content":"<ph id=\"ph1\">`true`</ph> when every element in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> has received a signal; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` when every element in <code>waitHandles</code> has received a signal; otherwise, `false`."}],"pos":[61317,61416],"yaml":true},{"content":"The <code>waitHandles</code> parameter is `null`.  \n  \n -or-  \n  \n One or more of the objects in the <code>waitHandles</code> array is `null`.  \n  \n -or-  \n  \n <code>waitHandles</code> is an array with no elements.","nodes":[{"pos":[0,49],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>waitHandles</code> parameter is `null`."},{"pos":[56,60],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[67,142],"content":"One or more of the objects in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array is <ph id=\"ph2\">`null`</ph>.","source":"One or more of the objects in the <code>waitHandles</code> array is `null`."},{"pos":[149,153],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[160,214],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements.","source":"<code>waitHandles</code> is an array with no elements."}],"pos":[61581,61806],"yaml":true},{"content":"<block subset=\"none\" type=\"note\">\n      <p>  \n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.ArgumentException\"></xref>, instead.  \n  \n</p>\n    </block>  \n  \n The <code>waitHandles</code> array contains elements that are duplicates.","nodes":[{"pos":[0,345],"content":"<block subset=\"none\" type=\"note\">\n      <p>  \n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.ArgumentException\"></xref>, instead.","nodes":[{"content":"In the <bpt id=\"p1\">[</bpt>.NET for Windows Store apps<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id=\"p2\">[</bpt>Portable Class Library<ept id=\"p2\">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id=\"ph1\">&lt;xref href=\"System.ArgumentException\"&gt;&lt;/xref&gt;</ph>, instead.","pos":[47,345],"source":" In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.ArgumentException\"></xref>, instead."}]},{"pos":[351,368],"content":"</p>\n    </block>","nodes":[]},{"pos":[375,448],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains elements that are duplicates.","source":"The <code>waitHandles</code> array contains elements that are duplicates."}],"pos":[61922,62386],"yaml":true},{"content":"The number of objects in <code>waitHandles</code> is greater than the system permits.  \n  \n -or-  \n  \n The <xref href=\"System.STAThreadAttribute\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.","nodes":[{"pos":[0,85],"content":"The number of objects in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> is greater than the system permits.","source":"The number of objects in <code>waitHandles</code> is greater than the system permits."},{"pos":[92,96],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[103,283],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.STAThreadAttribute\"&gt;&lt;/xref&gt;</ph> attribute is applied to the thread procedure for the current thread, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains more than one element.","source":"The <xref href=\"System.STAThreadAttribute\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element."}],"pos":[62488,62780],"yaml":true},{"content":"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  \n  \n -or-  \n  \n <code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,108],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.","source":"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out."},{"pos":[115,119],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[126,206],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[62894,63109],"yaml":true},{"content":"The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,144],"content":"The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,144],"nodes":[{"content":"The wait terminated because a thread exited without releasing a mutex.","pos":[0,70]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[71,144]}]}]}],"pos":[63235,63380],"yaml":true},{"content":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,149],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains a transparent proxy for a <ph id=\"ph2\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[63490,63640],"yaml":true},{"content":"Waits for all the elements in the specified array to receive a signal, using an <xref href=\"System.Int32\"></xref> value to specify the time interval.","nodes":[{"pos":[0,149],"content":"Waits for all the elements in the specified array to receive a signal, using an <ph id=\"ph1\">&lt;xref href=\"System.Int32\"&gt;&lt;/xref&gt;</ph> value to specify the time interval.","source":"Waits for all the elements in the specified array to receive a signal, using an <xref href=\"System.Int32\"></xref> value to specify the time interval."}],"pos":[65269,65419],"yaml":true},{"content":"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.  \n  \n> [!NOTE]\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \n  \n Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.","nodes":[{"pos":[0,124],"content":"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.","nodes":[{"content":"If <ph id=\"ph1\">`millisecondsTimeout`</ph> is zero, the method does not block.","pos":[0,60],"source":"If `millisecondsTimeout` is zero, the method does not block."},{"content":"It tests the state of the wait handles and returns immediately.","pos":[61,124]}]},{"pos":[131,513],"content":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.","nodes":[{"content":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.","pos":[0,382],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs.","pos":[0,168],"source":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs."},{"content":"On some implementations, if more than 64 handles are passed, a <ph id=\"ph1\">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.","pos":[169,278],"source":" On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown."},{"content":"If there are duplicates in the array, the call fails with a <ph id=\"ph1\">&lt;xref:System.DuplicateWaitObjectException&gt;</ph>.","pos":[279,382],"source":" If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>."}]}]},{"pos":[521,660],"content":"[!NOTE]\n The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method is not supported on threads that have <ph id=\"ph2\">&lt;xref:System.STAThreadAttribute&gt;</ph>.","pos":[9,137],"source":" The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>."}]},{"pos":[667,887],"content":"Calling this method overload is the same as calling the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> overload and specifying <ph id=\"ph2\">`false`</ph> for <ph id=\"ph3\">`exitContext`</ph>.","source":"Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`."}],"pos":[65430,66327],"yaml":true,"extradata":"MT"},{"content":"A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).","nodes":[{"pos":[0,164],"content":"A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).","nodes":[{"content":"A <ph id=\"ph1\">`WaitHandle`</ph> array containing the objects for which the current instance will wait.","pos":[0,85],"source":"A `WaitHandle` array containing the objects for which the current instance will wait."},{"content":"This array cannot contain multiple references to the same object (duplicates).","pos":[86,164]}]}],"pos":[66546,66711],"yaml":true},{"content":"The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely.","nodes":[{"pos":[0,120],"content":"The number of milliseconds to wait, or <ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (-1) to wait indefinitely.","source":"The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely."}],"pos":[66785,66906],"yaml":true},{"content":"`true` when every element in <code>waitHandles</code> has received a signal; otherwise, `false`.","nodes":[{"pos":[0,96],"content":"<ph id=\"ph1\">`true`</ph> when every element in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> has received a signal; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` when every element in <code>waitHandles</code> has received a signal; otherwise, `false`."}],"pos":[66964,67063],"yaml":true},{"content":"The <code>waitHandles</code> parameter is `null`.  \n  \n -or-  \n  \n One or more of the objects in the <code>waitHandles</code> array is `null`.  \n  \n -or-  \n  \n <code>waitHandles</code> is an array with no elements.","nodes":[{"pos":[0,49],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>waitHandles</code> parameter is `null`."},{"pos":[56,60],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[67,142],"content":"One or more of the objects in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array is <ph id=\"ph2\">`null`</ph>.","source":"One or more of the objects in the <code>waitHandles</code> array is `null`."},{"pos":[149,153],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[160,214],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements.","source":"<code>waitHandles</code> is an array with no elements."}],"pos":[67228,67453],"yaml":true},{"content":"<block subset=\"none\" type=\"note\">\n      <p>  \n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.ArgumentException\"></xref>, instead.  \n  \n</p>\n    </block>  \n  \n The <code>waitHandles</code> array contains elements that are duplicates.","nodes":[{"pos":[0,345],"content":"<block subset=\"none\" type=\"note\">\n      <p>  \n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.ArgumentException\"></xref>, instead.","nodes":[{"content":"In the <bpt id=\"p1\">[</bpt>.NET for Windows Store apps<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id=\"p2\">[</bpt>Portable Class Library<ept id=\"p2\">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id=\"ph1\">&lt;xref href=\"System.ArgumentException\"&gt;&lt;/xref&gt;</ph>, instead.","pos":[47,345],"source":" In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.ArgumentException\"></xref>, instead."}]},{"pos":[351,368],"content":"</p>\n    </block>","nodes":[]},{"pos":[375,448],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains elements that are duplicates.","source":"The <code>waitHandles</code> array contains elements that are duplicates."}],"pos":[67569,68033],"yaml":true},{"content":"The number of objects in <code>waitHandles</code> is greater than the system permits.  \n  \n -or-  \n  \n The <xref href=\"System.STAThreadAttribute\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.","nodes":[{"pos":[0,85],"content":"The number of objects in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> is greater than the system permits.","source":"The number of objects in <code>waitHandles</code> is greater than the system permits."},{"pos":[92,96],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[103,283],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.STAThreadAttribute\"&gt;&lt;/xref&gt;</ph> attribute is applied to the thread procedure for the current thread, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains more than one element.","source":"The <xref href=\"System.STAThreadAttribute\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element."}],"pos":[68135,68427],"yaml":true},{"content":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.","nodes":[{"pos":[0,107],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite time-out.","source":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out."}],"pos":[68541,68649],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[68775,68919],"yaml":true},{"content":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,149],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains a transparent proxy for a <ph id=\"ph2\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[69029,69179],"yaml":true},{"content":"Waits for all the elements in the specified array to receive a signal.","nodes":[{"pos":[0,70],"content":"Waits for all the elements in the specified array to receive a signal.","nodes":[{"content":"Waits for all the elements in the specified array to receive a signal.","pos":[0,70]}]}],"pos":[70748,70819],"yaml":true},{"content":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.  \n  \n> [!NOTE]\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \n  \n Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>) for `millisecondsTimeout` and `true` for `exitContext`.","nodes":[{"pos":[0,475],"content":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.","pos":[0,89],"source":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0."},{"content":"In previous versions, the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns <ph id=\"ph2\">`true`</ph> when a mutex is abandoned.","pos":[90,210],"source":" In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned."},{"content":"An abandoned mutex often indicates a serious coding error.","pos":[211,269]},{"content":"In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).","pos":[270,418]},{"content":"The exception contains information useful for debugging.","pos":[419,475]}]},{"pos":[482,791],"content":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.","nodes":[{"content":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.","pos":[0,309],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method returns when all the handles are signaled.","pos":[0,99],"source":"The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled."},{"content":"On some implementations, if more than 64 handles are passed, a <ph id=\"ph1\">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.","pos":[100,209],"source":" On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown."},{"content":"If the array contains duplicates, the call fails with a <ph id=\"ph1\">&lt;xref:System.DuplicateWaitObjectException&gt;</ph>.","pos":[210,309],"source":" If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>."}]}]},{"pos":[799,938],"content":"[!NOTE]\n The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%2A&gt;</ph> method is not supported on threads that have <ph id=\"ph2\">&lt;xref:System.STAThreadAttribute&gt;</ph>.","pos":[9,137],"source":" The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>."}]},{"pos":[945,1277],"content":"Calling this method overload is equivalent to calling the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> method overload and specifying -1 (or <ph id=\"ph2\">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;</ph>) for <ph id=\"ph3\">`millisecondsTimeout`</ph> and <ph id=\"ph4\">`true`</ph> for <ph id=\"ph5\">`exitContext`</ph>.","source":"Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>) for `millisecondsTimeout` and `true` for `exitContext`."}],"pos":[70830,72117],"yaml":true,"extradata":"MT"},{"content":"A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.","nodes":[{"pos":[0,151],"content":"A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.","nodes":[{"content":"A <ph id=\"ph1\">`WaitHandle`</ph> array containing the objects for which the current instance will wait.","pos":[0,85],"source":"A `WaitHandle` array containing the objects for which the current instance will wait."},{"content":"This array cannot contain multiple references to the same object.","pos":[86,151]}]}],"pos":[73072,73224],"yaml":true},{"content":"`true` when every element in <code>waitHandles</code> has received a signal; otherwise the method never returns.","nodes":[{"pos":[0,112],"content":"<ph id=\"ph1\">`true`</ph> when every element in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> has received a signal; otherwise the method never returns.","source":"`true` when every element in <code>waitHandles</code> has received a signal; otherwise the method never returns."}],"pos":[73282,73397],"yaml":true},{"content":"The <code>waitHandles</code> parameter is `null`. -or-  \n  \n One or more of the objects in the <code>waitHandles</code> array are `null`.  \n  \n -or-  \n  \n <code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later.","nodes":[{"pos":[0,54],"content":"The <code>waitHandles</code> parameter is `null`. -or-","nodes":[{"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","pos":[0,49],"source":"The <code>waitHandles</code> parameter is `null`."},{"content":"-or-","pos":[50,54]}]},{"pos":[61,137],"content":"One or more of the objects in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array are <ph id=\"ph2\">`null`</ph>.","source":"One or more of the objects in the <code>waitHandles</code> array are `null`."},{"pos":[144,148],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[155,256],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements and the .NET Framework version is 2.0 or later.","source":"<code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later."}],"pos":[73562,73827],"yaml":true},{"content":"<block subset=\"none\" type=\"note\">\n      <p>  \n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.ArgumentException\"></xref>, instead.  \n  \n</p>\n    </block>  \n  \n The <code>waitHandles</code> array contains elements that are duplicates.","nodes":[{"pos":[0,345],"content":"<block subset=\"none\" type=\"note\">\n      <p>  \n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.ArgumentException\"></xref>, instead.","nodes":[{"content":"In the <bpt id=\"p1\">[</bpt>.NET for Windows Store apps<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id=\"p2\">[</bpt>Portable Class Library<ept id=\"p2\">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id=\"ph1\">&lt;xref href=\"System.ArgumentException\"&gt;&lt;/xref&gt;</ph>, instead.","pos":[47,345],"source":" In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.ArgumentException\"></xref>, instead."}]},{"pos":[351,368],"content":"</p>\n    </block>","nodes":[]},{"pos":[375,448],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains elements that are duplicates.","source":"The <code>waitHandles</code> array contains elements that are duplicates."}],"pos":[73943,74407],"yaml":true},{"content":"The number of objects in <code>waitHandles</code> is greater than the system permits.  \n  \n -or-  \n  \n The <xref href=\"System.STAThreadAttribute\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.","nodes":[{"pos":[0,85],"content":"The number of objects in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> is greater than the system permits.","source":"The number of objects in <code>waitHandles</code> is greater than the system permits."},{"pos":[92,96],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[103,283],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.STAThreadAttribute\"&gt;&lt;/xref&gt;</ph> attribute is applied to the thread procedure for the current thread, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains more than one element.","source":"The <xref href=\"System.STAThreadAttribute\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element."}],"pos":[74509,74801],"yaml":true},{"content":"<code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1.","nodes":[{"pos":[0,99],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements and the .NET Framework version is 1.0 or 1.1.","source":"<code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1."}],"pos":[74901,75001],"yaml":true},{"content":"The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,144],"content":"The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,144],"nodes":[{"content":"The wait terminated because a thread exited without releasing a mutex.","pos":[0,70]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[71,144]}]}]}],"pos":[75127,75272],"yaml":true},{"content":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,149],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains a transparent proxy for a <ph id=\"ph2\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[75382,75532],"yaml":true},{"content":"Waits for any of the elements in the specified array to receive a signal.","nodes":[{"pos":[0,73],"content":"Waits for any of the elements in the specified array to receive a signal.","nodes":[{"content":"Waits for any of the elements in the specified array to receive a signal.","pos":[0,73]}]}],"pos":[77101,77175],"yaml":true},{"content":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \n  \n> [!NOTE]\n>  In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.  \n  \n This method returns when any handle is signaled. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \n  \n Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>) for `millisecondsTimeout` and `true` for `exitContext`.","nodes":[{"pos":[0,500],"content":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.","pos":[0,89],"source":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0."},{"content":"In previous versions, the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method returns <ph id=\"ph2\">`true`</ph> if the wait completes because a mutex is abandoned.","pos":[90,235],"source":" In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned."},{"content":"An abandoned mutex often indicates a serious coding error.","pos":[236,294]},{"content":"In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).","pos":[295,443]},{"content":"The exception contains information useful for debugging.","pos":[444,500]}]},{"pos":[507,885],"content":"The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method throws an <ph id=\"ph2\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> only when the wait completes because of an abandoned mutex.","pos":[0,174],"source":"The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex."},{"content":"If <ph id=\"ph1\">`waitHandles`</ph> contains a released mutex with a lower index number than the abandoned mutex, the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method completes normally and the exception is not thrown.","pos":[175,378],"source":" If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown."}]},{"pos":[893,1184],"content":"[!NOTE]\n In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.","leadings":["","> "],"nodes":[{"content":"In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph>, and that <ph id=\"ph2\">`Mutex`</ph> is at index 0 (zero) in a <ph id=\"ph3\">`WaitAny`</ph> array on another thread, the index returned by <ph id=\"ph4\">`WaitAny`</ph> is 128 instead of 0.","pos":[9,289],"source":" In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0."}]},{"pos":[1191,1525],"content":"This method returns when any handle is signaled. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.","nodes":[{"content":"This method returns when any handle is signaled. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.","pos":[0,334],"nodes":[{"content":"This method returns when any handle is signaled.","pos":[0,48]},{"content":"If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.","pos":[49,224]},{"content":"On some implementations, if more that 64 handles are passed, a <ph id=\"ph1\">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.","pos":[225,334],"source":" On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown."}]}]},{"pos":[1532,1864],"content":"Calling this method overload is equivalent to calling the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> method overload and specifying -1 (or <ph id=\"ph2\">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;</ph>) for <ph id=\"ph3\">`millisecondsTimeout`</ph> and <ph id=\"ph4\">`true`</ph> for <ph id=\"ph5\">`exitContext`</ph>.","source":"Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>) for `millisecondsTimeout` and `true` for `exitContext`."}],"pos":[77186,79062],"yaml":true,"extradata":"MT"},{"content":"A `WaitHandle` array containing the objects for which the current instance will wait.","nodes":[{"pos":[0,85],"content":"A <ph id=\"ph1\">`WaitHandle`</ph> array containing the objects for which the current instance will wait.","source":"A `WaitHandle` array containing the objects for which the current instance will wait."}],"pos":[79692,79778],"yaml":true},{"content":"The array index of the object that satisfied the wait.","nodes":[{"pos":[0,54],"content":"The array index of the object that satisfied the wait.","nodes":[{"content":"The array index of the object that satisfied the wait.","pos":[0,54]}]}],"pos":[79834,79889],"yaml":true},{"content":"The <code>waitHandles</code> parameter is `null`.  \n  \n -or-  \n  \n One or more of the objects in the <code>waitHandles</code> array is `null`.","nodes":[{"pos":[0,49],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>waitHandles</code> parameter is `null`."},{"pos":[56,60],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[67,142],"content":"One or more of the objects in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array is <ph id=\"ph2\">`null`</ph>.","source":"One or more of the objects in the <code>waitHandles</code> array is `null`."}],"pos":[80054,80203],"yaml":true},{"content":"The number of objects in <code>waitHandles</code> is greater than the system permits.","nodes":[{"pos":[0,85],"content":"The number of objects in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> is greater than the system permits.","source":"The number of objects in <code>waitHandles</code> is greater than the system permits."}],"pos":[80305,80391],"yaml":true},{"content":"<code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.","nodes":[{"pos":[0,100],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.","source":"<code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1."}],"pos":[80491,80592],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[80718,80862],"yaml":true},{"content":"<code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later.","nodes":[{"pos":[0,102],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements, and the .NET Framework version is 2.0 or later.","source":"<code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later."}],"pos":[80956,81059],"yaml":true},{"content":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,149],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains a transparent proxy for a <ph id=\"ph2\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[81169,81319],"yaml":true},{"content":"Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.","nodes":[{"pos":[0,133],"content":"Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.","nodes":[{"content":"Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.","pos":[0,133]}]}],"pos":[82965,83099],"yaml":true},{"content":"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \n  \n This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \n  \n Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.","nodes":[{"pos":[0,124],"content":"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.","nodes":[{"content":"If <ph id=\"ph1\">`millisecondsTimeout`</ph> is zero, the method does not block.","pos":[0,60],"source":"If `millisecondsTimeout` is zero, the method does not block."},{"content":"It tests the state of the wait handles and returns immediately.","pos":[61,124]}]},{"pos":[131,509],"content":"The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method throws an <ph id=\"ph2\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> only when the wait completes because of an abandoned mutex.","pos":[0,174],"source":"The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex."},{"content":"If <ph id=\"ph1\">`waitHandles`</ph> contains a released mutex with a lower index number than the abandoned mutex, the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method completes normally and the exception is not thrown.","pos":[175,378],"source":" If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown."}]},{"pos":[516,917],"content":"This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.","nodes":[{"content":"This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.","pos":[0,401],"nodes":[{"content":"This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.","pos":[0,115]},{"content":"If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.","pos":[116,291]},{"content":"On some implementations, if more that 64 handles are passed, a <ph id=\"ph1\">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.","pos":[292,401],"source":" On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown."}]}]},{"pos":[924,1144],"content":"Calling this method overload is the same as calling the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29&gt;</ph> overload and specifying <ph id=\"ph2\">`false`</ph> for <ph id=\"ph3\">`exitContext`</ph>.","source":"Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`."}],"pos":[83110,84263],"yaml":true,"extradata":"MT"},{"content":"A `WaitHandle` array containing the objects for which the current instance will wait.","nodes":[{"pos":[0,85],"content":"A <ph id=\"ph1\">`WaitHandle`</ph> array containing the objects for which the current instance will wait.","source":"A `WaitHandle` array containing the objects for which the current instance will wait."}],"pos":[84481,84567],"yaml":true},{"content":"The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely.","nodes":[{"pos":[0,120],"content":"The number of milliseconds to wait, or <ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (-1) to wait indefinitely.","source":"The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely."}],"pos":[84641,84762],"yaml":true},{"content":"The array index of the object that satisfied the wait, or <xref href=\"System.Threading.WaitHandle.WaitTimeout\"></xref> if no object satisfied the wait and a time interval equivalent to <code>millisecondsTimeout</code> has passed.","nodes":[{"pos":[0,229],"content":"The array index of the object that satisfied the wait, or <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle.WaitTimeout\"&gt;&lt;/xref&gt;</ph> if no object satisfied the wait and a time interval equivalent to <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">millisecondsTimeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> has passed.","source":"The array index of the object that satisfied the wait, or <xref href=\"System.Threading.WaitHandle.WaitTimeout\"></xref> if no object satisfied the wait and a time interval equivalent to <code>millisecondsTimeout</code> has passed."}],"pos":[84818,85048],"yaml":true},{"content":"The <code>waitHandles</code> parameter is `null`.  \n  \n -or-  \n  \n One or more of the objects in the <code>waitHandles</code> array is `null`.","nodes":[{"pos":[0,49],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>waitHandles</code> parameter is `null`."},{"pos":[56,60],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[67,142],"content":"One or more of the objects in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array is <ph id=\"ph2\">`null`</ph>.","source":"One or more of the objects in the <code>waitHandles</code> array is `null`."}],"pos":[85213,85362],"yaml":true},{"content":"The number of objects in <code>waitHandles</code> is greater than the system permits.","nodes":[{"pos":[0,85],"content":"The number of objects in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> is greater than the system permits.","source":"The number of objects in <code>waitHandles</code> is greater than the system permits."}],"pos":[85464,85550],"yaml":true},{"content":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.","nodes":[{"pos":[0,107],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite time-out.","source":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out."}],"pos":[85664,85772],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[85898,86042],"yaml":true},{"content":"<code>waitHandles</code> is an array with no elements.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements.","source":"<code>waitHandles</code> is an array with no elements."}],"pos":[86136,86191],"yaml":true},{"content":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,149],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains a transparent proxy for a <ph id=\"ph2\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[86301,86451],"yaml":true},{"content":"Waits for any of the elements in the specified array to receive a signal, using a <xref href=\"System.TimeSpan\"></xref> to specify the time interval.","nodes":[{"pos":[0,148],"content":"Waits for any of the elements in the specified array to receive a signal, using a <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> to specify the time interval.","source":"Waits for any of the elements in the specified array to receive a signal, using a <xref href=\"System.TimeSpan\"></xref> to specify the time interval."}],"pos":[88115,88264],"yaml":true},{"content":"If `timeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \n  \n This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \n  \n The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \n  \n Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.","nodes":[{"pos":[0,112],"content":"If `timeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.","nodes":[{"content":"If <ph id=\"ph1\">`timeout`</ph> is zero, the method does not block.","pos":[0,48],"source":"If `timeout` is zero, the method does not block."},{"content":"It tests the state of the wait handles and returns immediately.","pos":[49,112]}]},{"pos":[119,497],"content":"The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method throws an <ph id=\"ph2\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> only when the wait completes because of an abandoned mutex.","pos":[0,174],"source":"The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex."},{"content":"If <ph id=\"ph1\">`waitHandles`</ph> contains a released mutex with a lower index number than the abandoned mutex, the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method completes normally and the exception is not thrown.","pos":[175,378],"source":" If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown."}]},{"pos":[504,906],"content":"This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.","nodes":[{"content":"This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.","pos":[0,402],"nodes":[{"content":"This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.","pos":[0,116]},{"content":"If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.","pos":[117,292]},{"content":"On some implementations, if more that 64 handles are passed, a <ph id=\"ph1\">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.","pos":[293,402],"source":" On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown."}]}]},{"pos":[913,1002],"content":"The maximum value for <ph id=\"ph1\">`timeout`</ph> is <ph id=\"ph2\">&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;</ph>.","source":"The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>."},{"pos":[1009,1232],"content":"Calling this method overload is the same as calling the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29&gt;</ph> overload and specifying <ph id=\"ph2\">`false`</ph> for <ph id=\"ph3\">`exitContext`</ph>.","source":"Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`."}],"pos":[88275,89518],"yaml":true,"extradata":"MT"},{"content":"A `WaitHandle` array containing the objects for which the current instance will wait.","nodes":[{"pos":[0,85],"content":"A <ph id=\"ph1\">`WaitHandle`</ph> array containing the objects for which the current instance will wait.","source":"A `WaitHandle` array containing the objects for which the current instance will wait."}],"pos":[89729,89815],"yaml":true},{"content":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely.","nodes":[{"pos":[0,186],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents the number of milliseconds to wait, or a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents -1 milliseconds to wait indefinitely.","source":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely."}],"pos":[89880,90067],"yaml":true},{"content":"The array index of the object that satisfied the wait, or <xref href=\"System.Threading.WaitHandle.WaitTimeout\"></xref> if no object satisfied the wait and a time interval equivalent to <code>timeout</code> has passed.","nodes":[{"pos":[0,217],"content":"The array index of the object that satisfied the wait, or <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle.WaitTimeout\"&gt;&lt;/xref&gt;</ph> if no object satisfied the wait and a time interval equivalent to <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> has passed.","source":"The array index of the object that satisfied the wait, or <xref href=\"System.Threading.WaitHandle.WaitTimeout\"></xref> if no object satisfied the wait and a time interval equivalent to <code>timeout</code> has passed."}],"pos":[90123,90341],"yaml":true},{"content":"The <code>waitHandles</code> parameter is `null`.  \n  \n -or-  \n  \n One or more of the objects in the <code>waitHandles</code> array is `null`.","nodes":[{"pos":[0,49],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>waitHandles</code> parameter is `null`."},{"pos":[56,60],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[67,142],"content":"One or more of the objects in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array is <ph id=\"ph2\">`null`</ph>.","source":"One or more of the objects in the <code>waitHandles</code> array is `null`."}],"pos":[90506,90655],"yaml":true},{"content":"The number of objects in <code>waitHandles</code> is greater than the system permits.","nodes":[{"pos":[0,85],"content":"The number of objects in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> is greater than the system permits.","source":"The number of objects in <code>waitHandles</code> is greater than the system permits."}],"pos":[90757,90843],"yaml":true},{"content":"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  \n  \n -or-  \n  \n <code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,108],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.","source":"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out."},{"pos":[115,119],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[126,206],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[90957,91172],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[91298,91442],"yaml":true},{"content":"<code>waitHandles</code> is an array with no elements.","nodes":[{"pos":[0,54],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements.","source":"<code>waitHandles</code> is an array with no elements."}],"pos":[91536,91591],"yaml":true},{"content":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,149],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains a transparent proxy for a <ph id=\"ph2\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[91701,91851],"yaml":true},{"content":"Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.","nodes":[{"pos":[0,208],"content":"Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.","nodes":[{"content":"Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.","pos":[0,208]}]}],"pos":[93569,93778],"yaml":true},{"content":"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \n  \n> [!NOTE]\n>  In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.  \n  \n This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \n  \n## Notes on Exiting the Context  \n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.  \n  \n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"pos":[0,124],"content":"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.","nodes":[{"content":"If <ph id=\"ph1\">`millisecondsTimeout`</ph> is zero, the method does not block.","pos":[0,60],"source":"If `millisecondsTimeout` is zero, the method does not block."},{"content":"It tests the state of the wait handles and returns immediately.","pos":[61,124]}]},{"pos":[131,631],"content":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.","pos":[0,89],"source":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0."},{"content":"In previous versions, the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method returns <ph id=\"ph2\">`true`</ph> if the wait completes because a mutex is abandoned.","pos":[90,235],"source":" In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned."},{"content":"An abandoned mutex often indicates a serious coding error.","pos":[236,294]},{"content":"In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).","pos":[295,443]},{"content":"The exception contains information useful for debugging.","pos":[444,500]}]},{"pos":[638,1016],"content":"The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method throws an <ph id=\"ph2\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> only when the wait completes because of an abandoned mutex.","pos":[0,174],"source":"The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex."},{"content":"If <ph id=\"ph1\">`waitHandles`</ph> contains a released mutex with a lower index number than the abandoned mutex, the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method completes normally and the exception is not thrown.","pos":[175,378],"source":" If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown."}]},{"pos":[1024,1315],"content":"[!NOTE]\n In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.","leadings":["","> "],"nodes":[{"content":"In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph>, and that <ph id=\"ph2\">`Mutex`</ph> is at index 0 (zero) in a <ph id=\"ph3\">`WaitAny`</ph> array on another thread, the index returned by <ph id=\"ph4\">`WaitAny`</ph> is 128 instead of 0.","pos":[9,289],"source":" In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0."}]},{"pos":[1322,1723],"content":"This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.","nodes":[{"content":"This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.","pos":[0,401],"nodes":[{"content":"This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs.","pos":[0,115]},{"content":"If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.","pos":[116,291]},{"content":"On some implementations, if more that 64 handles are passed, a <ph id=\"ph1\">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.","pos":[292,401],"source":" On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown."}]}]},{"pos":[1732,1760],"content":"Notes on Exiting the Context","linkify":"Notes on Exiting the Context","nodes":[{"content":"Notes on Exiting the Context","pos":[0,28]}]},{"pos":[1764,2310],"content":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.","nodes":[{"content":"The <ph id=\"ph1\">`exitContext`</ph> parameter has no effect unless the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method is called from inside a nondefault managed context.","pos":[0,157],"source":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context."},{"content":"This can happen if your thread is inside a call to an instance of a class derived from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>.","pos":[158,278],"source":" This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>."},{"content":"Even if you are currently executing a method on a class that does not derive from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id=\"ph3\">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.","pos":[279,546],"source":" Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain."}]},{"pos":[2317,2725],"content":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.","nodes":[{"content":"When your code is executing in a nondefault context, specifying <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method.","pos":[0,268],"source":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method."},{"content":"The thread returns to the original nondefault context after the call to the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method completes.","pos":[269,408],"source":" The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes."}]},{"pos":[2732,3422],"content":"This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"content":"This can be useful when the context-bound class has <ph id=\"ph1\">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.","pos":[0,117],"source":"This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>."},{"content":"In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.","pos":[118,270]},{"content":"If code in the call stack of a member calls the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method and specifies <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.","pos":[271,540],"source":" If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.","pos":[541,690],"source":" When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain."}]}],"pos":[93789,97230],"yaml":true,"extradata":"MT"},{"content":"A `WaitHandle` array containing the objects for which the current instance will wait.","nodes":[{"pos":[0,85],"content":"A <ph id=\"ph1\">`WaitHandle`</ph> array containing the objects for which the current instance will wait.","source":"A `WaitHandle` array containing the objects for which the current instance will wait."}],"pos":[98164,98250],"yaml":true},{"content":"The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely.","nodes":[{"pos":[0,120],"content":"The number of milliseconds to wait, or <ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (-1) to wait indefinitely.","source":"The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely."}],"pos":[98324,98445],"yaml":true},{"content":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.","nodes":[{"pos":[0,153],"content":"<ph id=\"ph1\">`true`</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`."}],"pos":[98513,98669],"yaml":true},{"content":"The array index of the object that satisfied the wait, or <xref href=\"System.Threading.WaitHandle.WaitTimeout\"></xref> if no object satisfied the wait and a time interval equivalent to <code>millisecondsTimeout</code> has passed.","nodes":[{"pos":[0,229],"content":"The array index of the object that satisfied the wait, or <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle.WaitTimeout\"&gt;&lt;/xref&gt;</ph> if no object satisfied the wait and a time interval equivalent to <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">millisecondsTimeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> has passed.","source":"The array index of the object that satisfied the wait, or <xref href=\"System.Threading.WaitHandle.WaitTimeout\"></xref> if no object satisfied the wait and a time interval equivalent to <code>millisecondsTimeout</code> has passed."}],"pos":[98725,98955],"yaml":true},{"content":"The <code>waitHandles</code> parameter is `null`.  \n  \n -or-  \n  \n One or more of the objects in the <code>waitHandles</code> array is `null`.","nodes":[{"pos":[0,49],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>waitHandles</code> parameter is `null`."},{"pos":[56,60],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[67,142],"content":"One or more of the objects in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array is <ph id=\"ph2\">`null`</ph>.","source":"One or more of the objects in the <code>waitHandles</code> array is `null`."}],"pos":[99120,99269],"yaml":true},{"content":"The number of objects in <code>waitHandles</code> is greater than the system permits.","nodes":[{"pos":[0,85],"content":"The number of objects in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> is greater than the system permits.","source":"The number of objects in <code>waitHandles</code> is greater than the system permits."}],"pos":[99371,99457],"yaml":true},{"content":"<code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.","nodes":[{"pos":[0,100],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.","source":"<code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1."}],"pos":[99557,99658],"yaml":true},{"content":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.","nodes":[{"pos":[0,107],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite time-out.","source":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out."}],"pos":[99772,99880],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[100006,100150],"yaml":true},{"content":"<code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later.","nodes":[{"pos":[0,102],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements, and the .NET Framework version is 2.0 or later.","source":"<code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later."}],"pos":[100244,100347],"yaml":true},{"content":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,149],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains a transparent proxy for a <ph id=\"ph2\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[100457,100607],"yaml":true},{"content":"Waits for any of the elements in the specified array to receive a signal, using a <xref href=\"System.TimeSpan\"></xref> to specify the time interval and specifying whether to exit the synchronization domain before the wait.","nodes":[{"pos":[0,222],"content":"Waits for any of the elements in the specified array to receive a signal, using a <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> to specify the time interval and specifying whether to exit the synchronization domain before the wait.","source":"Waits for any of the elements in the specified array to receive a signal, using a <xref href=\"System.TimeSpan\"></xref> to specify the time interval and specifying whether to exit the synchronization domain before the wait."}],"pos":[101999,102222],"yaml":true},{"content":"If `timeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \n  \n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \n  \n> [!NOTE]\n>  In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.  \n  \n This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \n  \n The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \n  \n## Notes on Exiting the Context  \n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.  \n  \n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"pos":[0,112],"content":"If `timeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.","nodes":[{"content":"If <ph id=\"ph1\">`timeout`</ph> is zero, the method does not block.","pos":[0,48],"source":"If `timeout` is zero, the method does not block."},{"content":"It tests the state of the wait handles and returns immediately.","pos":[49,112]}]},{"pos":[119,619],"content":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.","pos":[0,89],"source":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0."},{"content":"In previous versions, the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method returns <ph id=\"ph2\">`true`</ph> if the wait completes because a mutex is abandoned.","pos":[90,235],"source":" In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned."},{"content":"An abandoned mutex often indicates a serious coding error.","pos":[236,294]},{"content":"In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).","pos":[295,443]},{"content":"The exception contains information useful for debugging.","pos":[444,500]}]},{"pos":[626,1004],"content":"The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method throws an <ph id=\"ph2\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> only when the wait completes because of an abandoned mutex.","pos":[0,174],"source":"The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex."},{"content":"If <ph id=\"ph1\">`waitHandles`</ph> contains a released mutex with a lower index number than the abandoned mutex, the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method completes normally and the exception is not thrown.","pos":[175,378],"source":" If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown."}]},{"pos":[1012,1303],"content":"[!NOTE]\n In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.","leadings":["","> "],"nodes":[{"content":"In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <ph id=\"ph1\">&lt;xref:System.Threading.Mutex&gt;</ph>, and that <ph id=\"ph2\">`Mutex`</ph> is at index 0 (zero) in a <ph id=\"ph3\">`WaitAny`</ph> array on another thread, the index returned by <ph id=\"ph4\">`WaitAny`</ph> is 128 instead of 0.","pos":[9,289],"source":" In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0."}]},{"pos":[1310,1712],"content":"This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.","nodes":[{"content":"This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.","pos":[0,402],"nodes":[{"content":"This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs.","pos":[0,116]},{"content":"If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects.","pos":[117,292]},{"content":"On some implementations, if more that 64 handles are passed, a <ph id=\"ph1\">&lt;xref:System.NotSupportedException&gt;</ph> is thrown.","pos":[293,402],"source":" On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown."}]}]},{"pos":[1719,1808],"content":"The maximum value for <ph id=\"ph1\">`timeout`</ph> is <ph id=\"ph2\">&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;</ph>.","source":"The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>."},{"pos":[1817,1845],"content":"Notes on Exiting the Context","linkify":"Notes on Exiting the Context","nodes":[{"content":"Notes on Exiting the Context","pos":[0,28]}]},{"pos":[1849,2395],"content":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.","nodes":[{"content":"The <ph id=\"ph1\">`exitContext`</ph> parameter has no effect unless the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method is called from inside a nondefault managed context.","pos":[0,157],"source":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context."},{"content":"This can happen if your thread is inside a call to an instance of a class derived from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>.","pos":[158,278],"source":" This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>."},{"content":"Even if you are currently executing a method on a class that does not derive from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id=\"ph3\">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.","pos":[279,546],"source":" Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain."}]},{"pos":[2402,2810],"content":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.","nodes":[{"content":"When your code is executing in a nondefault context, specifying <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method.","pos":[0,268],"source":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method."},{"content":"The thread returns to the original nondefault context after the call to the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method completes.","pos":[269,408],"source":" The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes."}]},{"pos":[2817,3507],"content":"This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"content":"This can be useful when the context-bound class has <ph id=\"ph1\">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.","pos":[0,117],"source":"This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>."},{"content":"In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.","pos":[118,270]},{"content":"If code in the call stack of a member calls the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method and specifies <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.","pos":[271,540],"source":" If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitAny%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.","pos":[541,690],"source":" When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain."}]}],"pos":[102233,105761],"yaml":true,"extradata":"MT"},{"content":"A `WaitHandle` array containing the objects for which the current instance will wait.","nodes":[{"pos":[0,85],"content":"A <ph id=\"ph1\">`WaitHandle`</ph> array containing the objects for which the current instance will wait.","source":"A `WaitHandle` array containing the objects for which the current instance will wait."}],"pos":[106688,106774],"yaml":true},{"content":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely.","nodes":[{"pos":[0,186],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents the number of milliseconds to wait, or a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents -1 milliseconds to wait indefinitely.","source":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely."}],"pos":[106839,107026],"yaml":true},{"content":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.","nodes":[{"pos":[0,153],"content":"<ph id=\"ph1\">`true`</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`."}],"pos":[107094,107250],"yaml":true},{"content":"The array index of the object that satisfied the wait, or <xref href=\"System.Threading.WaitHandle.WaitTimeout\"></xref> if no object satisfied the wait and a time interval equivalent to <code>timeout</code> has passed.","nodes":[{"pos":[0,217],"content":"The array index of the object that satisfied the wait, or <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle.WaitTimeout\"&gt;&lt;/xref&gt;</ph> if no object satisfied the wait and a time interval equivalent to <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">timeout</ph><ept id=\"p1\">&lt;/code&gt;</ept> has passed.","source":"The array index of the object that satisfied the wait, or <xref href=\"System.Threading.WaitHandle.WaitTimeout\"></xref> if no object satisfied the wait and a time interval equivalent to <code>timeout</code> has passed."}],"pos":[107306,107524],"yaml":true},{"content":"The <code>waitHandles</code> parameter is `null`.  \n  \n -or-  \n  \n One or more of the objects in the <code>waitHandles</code> array is `null`.","nodes":[{"pos":[0,49],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is <ph id=\"ph2\">`null`</ph>.","source":"The <code>waitHandles</code> parameter is `null`."},{"pos":[56,60],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[67,142],"content":"One or more of the objects in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array is <ph id=\"ph2\">`null`</ph>.","source":"One or more of the objects in the <code>waitHandles</code> array is `null`."}],"pos":[107689,107838],"yaml":true},{"content":"The number of objects in <code>waitHandles</code> is greater than the system permits.","nodes":[{"pos":[0,85],"content":"The number of objects in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> is greater than the system permits.","source":"The number of objects in <code>waitHandles</code> is greater than the system permits."}],"pos":[107940,108026],"yaml":true},{"content":"<code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.","nodes":[{"pos":[0,100],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.","source":"<code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1."}],"pos":[108126,108227],"yaml":true},{"content":"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  \n  \n -or-  \n  \n <code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,108],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.","source":"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out."},{"pos":[115,119],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[126,206],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[108341,108556],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[108682,108826],"yaml":true},{"content":"<code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later.","nodes":[{"pos":[0,102],"content":"<ph id=\"ph1\">&lt;code&gt;waitHandles&lt;/code&gt;</ph> is an array with no elements, and the .NET Framework version is 2.0 or later.","source":"<code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later."}],"pos":[108920,109023],"yaml":true},{"content":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,149],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">waitHandles</ph><ept id=\"p1\">&lt;/code&gt;</ept> array contains a transparent proxy for a <ph id=\"ph2\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[109133,109283],"yaml":true},{"content":"Blocks the current thread until the current <xref href=\"System.Threading.WaitHandle\"></xref> receives a signal.","nodes":[{"pos":[0,111],"content":"Blocks the current thread until the current <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> receives a signal.","source":"Blocks the current thread until the current <xref href=\"System.Threading.WaitHandle\"></xref> receives a signal."}],"pos":[110396,110508],"yaml":true},{"content":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The caller of this method blocks indefinitely until the current instance receives a signal. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \n  \n Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName> for the first parameter and `false` for the second parameter.  \n  \n Override this method to customize the behavior of derived classes.","nodes":[{"pos":[0,475],"content":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.","pos":[0,89],"source":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0."},{"content":"In previous versions, the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id=\"ph2\">`true`</ph> when a mutex is abandoned.","pos":[90,210],"source":" In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned."},{"content":"An abandoned mutex often indicates a serious coding error.","pos":[211,269]},{"content":"In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).","pos":[270,418]},{"content":"The exception contains information useful for debugging.","pos":[419,475]}]},{"pos":[482,811],"content":"The caller of this method blocks indefinitely until the current instance receives a signal. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.","nodes":[{"content":"The caller of this method blocks indefinitely until the current instance receives a signal. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.","pos":[0,329],"nodes":[{"content":"The caller of this method blocks indefinitely until the current instance receives a signal.","pos":[0,91]},{"content":"Use this method to block until a <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> receives a signal from another thread, such as is generated when an asynchronous operation completes.","pos":[92,261],"source":" Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes."},{"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> interface.","pos":[262,329],"source":" For more information, see the <xref:System.IAsyncResult> interface."}]}]},{"pos":[818,1118],"content":"Calling this method overload is equivalent to calling the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29&gt;</ph> method overload and specifying -1 or <ph id=\"ph2\">&lt;xref:System.Threading.Timeout.Infinite?displayProperty=fullName&gt;</ph> for the first parameter and <ph id=\"ph3\">`false`</ph> for the second parameter.","source":"Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName> for the first parameter and `false` for the second parameter."},{"pos":[1125,1191],"content":"Override this method to customize the behavior of derived classes.","nodes":[{"content":"Override this method to customize the behavior of derived classes.","pos":[0,66]}]}],"pos":[110519,111719],"yaml":true,"extradata":"MT"},{"content":"`true` if the current instance receives a signal. If the current instance is never signaled, <xref href=\"System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\"></xref> never returns.","nodes":[{"pos":[0,193],"content":"`true` if the current instance receives a signal. If the current instance is never signaled, <xref href=\"System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\"></xref> never returns.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the current instance receives a signal.","pos":[0,49],"source":"`true` if the current instance receives a signal."},{"content":"If the current instance is never signaled, <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\"&gt;&lt;/xref&gt;</ph> never returns.","pos":[50,193],"source":" If the current instance is never signaled, <xref href=\"System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\"></xref> never returns."}]}],"pos":[112504,112700],"yaml":true},{"content":"The current instance has already been disposed.","nodes":[{"pos":[0,47],"content":"The current instance has already been disposed.","nodes":[{"content":"The current instance has already been disposed.","pos":[0,47]}]}],"pos":[112869,112917],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[113043,113187],"yaml":true},{"content":"The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,129],"content":"The current instance is a transparent proxy for a <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[113297,113427],"yaml":true},{"content":"Blocks the current thread until the current <xref href=\"System.Threading.WaitHandle\"></xref> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.","nodes":[{"pos":[0,187],"content":"Blocks the current thread until the current <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.","source":"Blocks the current thread until the current <xref href=\"System.Threading.WaitHandle\"></xref> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds."}],"pos":[114924,115112],"yaml":true},{"content":"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handle and returns immediately.  \n  \n The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \n  \n Override this method to customize the behavior of derived classes.  \n  \n Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.","nodes":[{"pos":[0,123],"content":"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handle and returns immediately.","nodes":[{"content":"If <ph id=\"ph1\">`millisecondsTimeout`</ph> is zero, the method does not block.","pos":[0,60],"source":"If `millisecondsTimeout` is zero, the method does not block."},{"content":"It tests the state of the wait handle and returns immediately.","pos":[61,123]}]},{"pos":[130,467],"content":"The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.","nodes":[{"content":"The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.","pos":[0,337],"nodes":[{"content":"The caller of this method blocks until the current instance receives a signal or a time-out occurs.","pos":[0,99]},{"content":"Use this method to block until a <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> receives a signal from another thread, such as is generated when an asynchronous operation completes.","pos":[100,269],"source":" Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes."},{"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> interface.","pos":[270,337],"source":" For more information, see the <xref:System.IAsyncResult> interface."}]}]},{"pos":[474,540],"content":"Override this method to customize the behavior of derived classes.","nodes":[{"content":"Override this method to customize the behavior of derived classes.","pos":[0,66]}]},{"pos":[547,731],"content":"Calling this method overload is the same as calling the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29&gt;</ph> overload and specifying <ph id=\"ph2\">`false`</ph> for <ph id=\"ph3\">`exitContext`</ph>.","source":"Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`."}],"pos":[115123,115863],"yaml":true,"extradata":"MT"},{"content":"The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely.","nodes":[{"pos":[0,120],"content":"The number of milliseconds to wait, or <ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (-1) to wait indefinitely.","source":"The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely."}],"pos":[116684,116805],"yaml":true},{"content":"`true` if the current instance receives a signal; otherwise, `false`.","nodes":[{"pos":[0,69],"content":"<ph id=\"ph1\">`true`</ph> if the current instance receives a signal; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the current instance receives a signal; otherwise, `false`."}],"pos":[116863,116935],"yaml":true},{"content":"The current instance has already been disposed.","nodes":[{"pos":[0,47],"content":"The current instance has already been disposed.","nodes":[{"content":"The current instance has already been disposed.","pos":[0,47]}]}],"pos":[117104,117152],"yaml":true},{"content":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.","nodes":[{"pos":[0,107],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite time-out.","source":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out."}],"pos":[117266,117374],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[117500,117644],"yaml":true},{"content":"The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,129],"content":"The current instance is a transparent proxy for a <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[117754,117884],"yaml":true},{"content":"Blocks the current thread until the current instance receives a signal, using a <xref href=\"System.TimeSpan\"></xref> to specify the time interval.","nodes":[{"pos":[0,146],"content":"Blocks the current thread until the current instance receives a signal, using a <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> to specify the time interval.","source":"Blocks the current thread until the current instance receives a signal, using a <xref href=\"System.TimeSpan\"></xref> to specify the time interval."}],"pos":[119399,119546],"yaml":true},{"content":"If `timeout` is zero, the method does not block. It tests the state of the wait handle and returns immediately.  \n  \n The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \n  \n Override this method to customize the behavior of derived classes.  \n  \n The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \n  \n Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.","nodes":[{"pos":[0,111],"content":"If `timeout` is zero, the method does not block. It tests the state of the wait handle and returns immediately.","nodes":[{"content":"If <ph id=\"ph1\">`timeout`</ph> is zero, the method does not block.","pos":[0,48],"source":"If `timeout` is zero, the method does not block."},{"content":"It tests the state of the wait handle and returns immediately.","pos":[49,111]}]},{"pos":[118,455],"content":"The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.","nodes":[{"content":"The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.","pos":[0,337],"nodes":[{"content":"The caller of this method blocks until the current instance receives a signal or a time-out occurs.","pos":[0,99]},{"content":"Use this method to block until a <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> receives a signal from another thread, such as is generated when an asynchronous operation completes.","pos":[100,269],"source":" Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes."},{"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> interface.","pos":[270,337],"source":" For more information, see the <xref:System.IAsyncResult> interface."}]}]},{"pos":[462,528],"content":"Override this method to customize the behavior of derived classes.","nodes":[{"content":"Override this method to customize the behavior of derived classes.","pos":[0,66]}]},{"pos":[535,624],"content":"The maximum value for <ph id=\"ph1\">`timeout`</ph> is <ph id=\"ph2\">&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;</ph>.","source":"The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>."},{"pos":[631,818],"content":"Calling this method overload is the same as calling the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29&gt;</ph> overload and specifying <ph id=\"ph2\">`false`</ph> for <ph id=\"ph3\">`exitContext`</ph>.","source":"Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`."}],"pos":[119557,120386],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely.","nodes":[{"pos":[0,186],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents the number of milliseconds to wait, or a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents -1 milliseconds to wait indefinitely.","source":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely."}],"pos":[120538,120725],"yaml":true},{"content":"`true` if the current instance receives a signal; otherwise, `false`.","nodes":[{"pos":[0,69],"content":"<ph id=\"ph1\">`true`</ph> if the current instance receives a signal; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the current instance receives a signal; otherwise, `false`."}],"pos":[120783,120855],"yaml":true},{"content":"The current instance has already been disposed.","nodes":[{"pos":[0,47],"content":"The current instance has already been disposed.","nodes":[{"content":"The current instance has already been disposed.","pos":[0,47]}]}],"pos":[121024,121072],"yaml":true},{"content":"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  \n  \n -or-  \n  \n <code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,108],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.","source":"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out."},{"pos":[115,119],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[126,206],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[121186,121401],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[121527,121671],"yaml":true},{"content":"The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,129],"content":"The current instance is a transparent proxy for a <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[121781,121911],"yaml":true},{"content":"Blocks the current thread until the current <xref href=\"System.Threading.WaitHandle\"></xref> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.","nodes":[{"pos":[0,245],"content":"Blocks the current thread until the current <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.","source":"Blocks the current thread until the current <xref href=\"System.Threading.WaitHandle\"></xref> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait."}],"pos":[123480,123726],"yaml":true},{"content":"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handle and returns immediately.  \n  \n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \n  \n Override this method to customize the behavior of derived classes.  \n  \n## Notes on Exiting the Context  \n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.  \n  \n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"pos":[0,123],"content":"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handle and returns immediately.","nodes":[{"content":"If <ph id=\"ph1\">`millisecondsTimeout`</ph> is zero, the method does not block.","pos":[0,60],"source":"If `millisecondsTimeout` is zero, the method does not block."},{"content":"It tests the state of the wait handle and returns immediately.","pos":[61,123]}]},{"pos":[130,605],"content":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.","pos":[0,89],"source":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0."},{"content":"In previous versions, the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id=\"ph2\">`true`</ph> when a mutex is abandoned.","pos":[90,210],"source":" In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned."},{"content":"An abandoned mutex often indicates a serious coding error.","pos":[211,269]},{"content":"In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).","pos":[270,418]},{"content":"The exception contains information useful for debugging.","pos":[419,475]}]},{"pos":[612,949],"content":"The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.","nodes":[{"content":"The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.","pos":[0,337],"nodes":[{"content":"The caller of this method blocks until the current instance receives a signal or a time-out occurs.","pos":[0,99]},{"content":"Use this method to block until a <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> receives a signal from another thread, such as is generated when an asynchronous operation completes.","pos":[100,269],"source":" Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes."},{"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> interface.","pos":[270,337],"source":" For more information, see the <xref:System.IAsyncResult> interface."}]}]},{"pos":[956,1022],"content":"Override this method to customize the behavior of derived classes.","nodes":[{"content":"Override this method to customize the behavior of derived classes.","pos":[0,66]}]},{"pos":[1031,1059],"content":"Notes on Exiting the Context","linkify":"Notes on Exiting the Context","nodes":[{"content":"Notes on Exiting the Context","pos":[0,28]}]},{"pos":[1063,1609],"content":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.","nodes":[{"content":"The <ph id=\"ph1\">`exitContext`</ph> parameter has no effect unless the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method is called from inside a nondefault managed context.","pos":[0,157],"source":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context."},{"content":"This can happen if your thread is inside a call to an instance of a class derived from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>.","pos":[158,278],"source":" This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>."},{"content":"Even if you are currently executing a method on a class that does not derive from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id=\"ph3\">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.","pos":[279,546],"source":" Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain."}]},{"pos":[1616,2024],"content":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.","nodes":[{"content":"When your code is executing in a nondefault context, specifying <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.","pos":[0,268],"source":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method."},{"content":"The thread returns to the original nondefault context after the call to the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method completes.","pos":[269,408],"source":" The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes."}]},{"pos":[2031,2721],"content":"This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"content":"This can be useful when the context-bound class has <ph id=\"ph1\">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.","pos":[0,117],"source":"This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>."},{"content":"In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.","pos":[118,270]},{"content":"If code in the call stack of a member calls the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method and specifies <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.","pos":[271,540],"source":" If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.","pos":[541,690],"source":" When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain."}]}],"pos":[123737,126474],"yaml":true,"extradata":"MT"},{"content":"The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely.","nodes":[{"pos":[0,120],"content":"The number of milliseconds to wait, or <ph id=\"ph1\">&lt;xref href=\"System.Threading.Timeout.Infinite\"&gt;&lt;/xref&gt;</ph> (-1) to wait indefinitely.","source":"The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely."}],"pos":[127672,127793],"yaml":true},{"content":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.","nodes":[{"pos":[0,153],"content":"<ph id=\"ph1\">`true`</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`."}],"pos":[127861,128017],"yaml":true},{"content":"`true` if the current instance receives a signal; otherwise, `false`.","nodes":[{"pos":[0,69],"content":"<ph id=\"ph1\">`true`</ph> if the current instance receives a signal; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the current instance receives a signal; otherwise, `false`."}],"pos":[128075,128147],"yaml":true},{"content":"The current instance has already been disposed.","nodes":[{"pos":[0,47],"content":"The current instance has already been disposed.","nodes":[{"content":"The current instance has already been disposed.","pos":[0,47]}]}],"pos":[128316,128364],"yaml":true},{"content":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.","nodes":[{"pos":[0,107],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> is a negative number other than -1, which represents an infinite time-out.","source":"<code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out."}],"pos":[128478,128586],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[128712,128856],"yaml":true},{"content":"The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,129],"content":"The current instance is a transparent proxy for a <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[128966,129096],"yaml":true},{"content":"Blocks the current thread until the current instance receives a signal, using a <xref href=\"System.TimeSpan\"></xref> to specify the time interval and specifying whether to exit the synchronization domain before the wait.","nodes":[{"pos":[0,220],"content":"Blocks the current thread until the current instance receives a signal, using a <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> to specify the time interval and specifying whether to exit the synchronization domain before the wait.","source":"Blocks the current thread until the current instance receives a signal, using a <xref href=\"System.TimeSpan\"></xref> to specify the time interval and specifying whether to exit the synchronization domain before the wait."}],"pos":[130339,130560],"yaml":true},{"content":"If `timeout` is zero, the method does not block. It tests the state of the wait handle and returns immediately.  \n  \n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \n  \n The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \n  \n Override this method to customize the behavior of derived classes.  \n  \n The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \n  \n## Notes on Exiting the Context  \n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \n  \n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.  \n  \n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"pos":[0,111],"content":"If `timeout` is zero, the method does not block. It tests the state of the wait handle and returns immediately.","nodes":[{"content":"If <ph id=\"ph1\">`timeout`</ph> is zero, the method does not block.","pos":[0,48],"source":"If `timeout` is zero, the method does not block."},{"content":"It tests the state of the wait handle and returns immediately.","pos":[49,111]}]},{"pos":[118,593],"content":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Threading.AbandonedMutexException&gt;</ph> is new in the .NET Framework version 2.0.","pos":[0,89],"source":"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0."},{"content":"In previous versions, the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns <ph id=\"ph2\">`true`</ph> when a mutex is abandoned.","pos":[90,210],"source":" In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned."},{"content":"An abandoned mutex often indicates a serious coding error.","pos":[211,269]},{"content":"In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).","pos":[270,418]},{"content":"The exception contains information useful for debugging.","pos":[419,475]}]},{"pos":[600,937],"content":"The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.","nodes":[{"content":"The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.","pos":[0,337],"nodes":[{"content":"The caller of this method blocks until the current instance receives a signal or a time-out occurs.","pos":[0,99]},{"content":"Use this method to block until a <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle&gt;</ph> receives a signal from another thread, such as is generated when an asynchronous operation completes.","pos":[100,269],"source":" Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes."},{"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.IAsyncResult&gt;</ph> interface.","pos":[270,337],"source":" For more information, see the <xref:System.IAsyncResult> interface."}]}]},{"pos":[944,1010],"content":"Override this method to customize the behavior of derived classes.","nodes":[{"content":"Override this method to customize the behavior of derived classes.","pos":[0,66]}]},{"pos":[1017,1106],"content":"The maximum value for <ph id=\"ph1\">`timeout`</ph> is <ph id=\"ph2\">&lt;xref:System.Int32.MaxValue?displayProperty=fullName&gt;</ph>.","source":"The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>."},{"pos":[1115,1143],"content":"Notes on Exiting the Context","linkify":"Notes on Exiting the Context","nodes":[{"content":"Notes on Exiting the Context","pos":[0,28]}]},{"pos":[1147,1693],"content":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.","nodes":[{"content":"The <ph id=\"ph1\">`exitContext`</ph> parameter has no effect unless the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method is called from inside a nondefault managed context.","pos":[0,157],"source":"The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context."},{"content":"This can happen if your thread is inside a call to an instance of a class derived from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>.","pos":[158,278],"source":" This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>."},{"content":"Even if you are currently executing a method on a class that does not derive from <ph id=\"ph1\">&lt;xref:System.ContextBoundObject&gt;</ph>, like <ph id=\"ph2\">&lt;xref:System.String&gt;</ph>, you can be in a nondefault context if a <ph id=\"ph3\">&lt;xref:System.ContextBoundObject&gt;</ph> is on your stack in the current application domain.","pos":[279,546],"source":" Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain."}]},{"pos":[1700,2108],"content":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.","nodes":[{"content":"When your code is executing in a nondefault context, specifying <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`exitContext`</ph> causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method.","pos":[0,268],"source":"When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method."},{"content":"The thread returns to the original nondefault context after the call to the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method completes.","pos":[269,408],"source":" The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes."}]},{"pos":[2115,2805],"content":"This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.","nodes":[{"content":"This can be useful when the context-bound class has <ph id=\"ph1\">&lt;xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute&gt;</ph>.","pos":[0,117],"source":"This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>."},{"content":"In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.","pos":[118,270]},{"content":"If code in the call stack of a member calls the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method and specifies <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`exitContext`</ph>, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.","pos":[271,540],"source":" If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed."},{"content":"When the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method returns, the thread that made the call must wait to reenter the synchronization domain.","pos":[541,690],"source":" When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain."}]}],"pos":[130571,133394],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely.","nodes":[{"pos":[0,186],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents the number of milliseconds to wait, or a <ph id=\"ph2\">&lt;xref href=\"System.TimeSpan\"&gt;&lt;/xref&gt;</ph> that represents -1 milliseconds to wait indefinitely.","source":"A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely."}],"pos":[134217,134404],"yaml":true},{"content":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.","nodes":[{"pos":[0,153],"content":"<ph id=\"ph1\">`true`</ph> to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`."}],"pos":[134472,134628],"yaml":true},{"content":"`true` if the current instance receives a signal; otherwise, `false`.","nodes":[{"pos":[0,69],"content":"<ph id=\"ph1\">`true`</ph> if the current instance receives a signal; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the current instance receives a signal; otherwise, `false`."}],"pos":[134686,134758],"yaml":true},{"content":"The current instance has already been disposed.","nodes":[{"pos":[0,47],"content":"The current instance has already been disposed.","nodes":[{"content":"The current instance has already been disposed.","pos":[0,47]}]}],"pos":[134927,134975],"yaml":true},{"content":"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  \n  \n -or-  \n  \n <code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,108],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is a negative number other than -1 milliseconds, which represents an infinite time-out.","source":"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out."},{"pos":[115,119],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[126,206],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is greater than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"<code>timeout</code> is greater than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[135089,135304],"yaml":true},{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,143],"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","nodes":[{"content":"The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[0,143],"nodes":[{"content":"The wait completed because a thread exited without releasing a mutex.","pos":[0,69]},{"content":"This exception is not thrown on Windows 98 or Windows Millennium Edition.","pos":[70,143]}]}]}],"pos":[135430,135574],"yaml":true},{"content":"The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.","nodes":[{"pos":[0,129],"content":"The current instance is a transparent proxy for a <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle\"&gt;&lt;/xref&gt;</ph> in another application domain.","source":"The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain."}],"pos":[135684,135814],"yaml":true},{"content":"Indicates that a <xref href=\"System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\"></xref> operation timed out before any of the wait handles were signaled. This field is constant.","nodes":[{"pos":[0,222],"content":"Indicates that a <xref href=\"System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\"></xref> operation timed out before any of the wait handles were signaled. This field is constant.","nodes":[{"content":"Indicates that a <ph id=\"ph1\">&lt;xref href=\"System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\"&gt;&lt;/xref&gt;</ph> operation timed out before any of the wait handles were signaled.","pos":[0,198],"source":"Indicates that a <xref href=\"System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\"></xref> operation timed out before any of the wait handles were signaled."},{"content":"This field is constant.","pos":[199,222]}]}],"pos":[136927,137150],"yaml":true},{"content":"This field is one of the possible return values of `WaitAny`.","nodes":[{"pos":[0,61],"content":"This field is one of the possible return values of <ph id=\"ph1\">`WaitAny`</ph>.","source":"This field is one of the possible return values of `WaitAny`."}],"pos":[137161,137223],"yaml":true,"extradata":"MT"}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.WaitHandle\n  commentId: T:System.Threading.WaitHandle\n  id: WaitHandle\n  children:\n  - System.Threading.WaitHandle.#ctor\n  - System.Threading.WaitHandle.Close\n  - System.Threading.WaitHandle.Dispose\n  - System.Threading.WaitHandle.Dispose(System.Boolean)\n  - System.Threading.WaitHandle.Handle\n  - System.Threading.WaitHandle.InvalidHandle\n  - System.Threading.WaitHandle.SafeWaitHandle\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitOne\n  - System.Threading.WaitHandle.WaitOne(System.Int32)\n  - System.Threading.WaitHandle.WaitOne(System.TimeSpan)\n  - System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitTimeout\n  langs:\n  - csharp\n  name: WaitHandle\n  nameWithType: WaitHandle\n  fullName: System.Threading.WaitHandle\n  type: Class\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Encapsulates operating system–specific objects that wait for exclusive access to shared resources.\n  remarks: \"The <xref:System.Threading.WaitHandle> class encapsulates Win32 synchronization handles, and is used to represent all synchronization objects in the runtime that allow multiple wait operations. For a comparison of wait handles with other synchronization objects, see [Overview of Synchronization Primitives](~/docs/standard/threading/overview-of-synchronization-primitives.md).  \\n  \\n The <xref:System.Threading.WaitHandle> class itself is abstract. Classes derived from <xref:System.Threading.WaitHandle> define a signaling mechanism to indicate taking or releasing access to a shared resource, but they use the inherited <xref:System.Threading.WaitHandle> methods to block while waiting for access to shared resources. The classes derived from <xref:System.Threading.WaitHandle> include:  \\n  \\n-   The <xref:System.Threading.Mutex> class. See [Mutexes](~/docs/standard/threading/mutexes.md).  \\n  \\n-   The <xref:System.Threading.EventWaitHandle> class and its derived classes, <xref:System.Threading.AutoResetEvent> and <xref:System.Threading.ManualResetEvent>. See [EventWaitHandle, AutoResetEvent, CountdownEvent, ManualResetEvent](~/docs/standard/threading/eventwaithandle-autoresetevent-countdownevent-manualresetevent.md).  \\n  \\n-   The <xref:System.Threading.Semaphore> class. See [Semaphore and SemaphoreSlim](~/docs/standard/threading/semaphore-and-semaphoreslim.md).  \\n  \\n Threads can block on an individual wait handle by calling the instance method <xref:System.Threading.WaitHandle.WaitOne%2A>, which is inherited by classes derived from <xref:System.Threading.WaitHandle>.  \\n  \\n The derived classes of <xref:System.Threading.WaitHandle> differ in their thread affinity. Event wait handles (<xref:System.Threading.EventWaitHandle>, <xref:System.Threading.AutoResetEvent>, and <xref:System.Threading.ManualResetEvent>) and semaphores do not have thread affinity; any thread can signal an event wait handle or semaphore. Mutexes, on the other hand, do have thread affinity; the thread that owns a mutex must release it, and an exception is thrown if a thread calls the <xref:System.Threading.Mutex.ReleaseMutex%2A> method on a mutex that it does not own.  \\n  \\n Because the <xref:System.Threading.WaitHandle> class derives from <xref:System.MarshalByRefObject>, these classes can be used to synchronize the activities of threads across application domain boundaries.  \\n  \\n In addition to its derived classes, the <xref:System.Threading.WaitHandle> class has a number of static methods that block a thread until one or more synchronization objects receive a signal.. These include:  \\n  \\n-   <xref:System.Threading.WaitHandle.SignalAndWait%2A>, which allows a thread to signal one wait handle and immediately wait on another.  \\n  \\n-   <xref:System.Threading.WaitHandle.WaitAll%2A>, which allows a thread to wait until all the wait handles in an array receive a signal.  \\n  \\n-   <xref:System.Threading.WaitHandle.WaitAny%2A>, which allows a thread to wait until any one of a specified set of wait handles has been signaled .  \\n  \\n The overloads of these methods provide timeout intervals for abandoning the wait, and the opportunity to exit a synchronization context before entering the wait, allowing other threads to use the synchronization context.  \\n  \\n> [!IMPORTANT]\\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type or a type derived from it, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.Threading.WaitHandle.Close%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \\\"Using an Object that Implements IDisposable\\\" section in the <xref:System.IDisposable> interface topic.  \\n  \\n <xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern. See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md). When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle. You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.\"\n  example:\n  - \"The following code example shows how two threads can do background tasks while the Main thread waits for the tasks to complete using the static <xref:System.Threading.WaitHandle.WaitAny%2A> and <xref:System.Threading.WaitHandle.WaitAll%2A> methods of the <xref:System.Threading.WaitHandle> class.  \\n  \\n [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]\\n [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]\\n [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public abstract class WaitHandle : MarshalByRefObject, IDisposable\n  inheritance:\n  - System.Object\n  derivedClasses:\n  - System.Threading.EventWaitHandle\n  - System.Threading.Mutex\n  - System.Threading.Semaphore\n  implements:\n  - System.IDisposable\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  extensionMethods:\n  - System.Threading.WaitHandleExtensions.GetSafeWaitHandle(System.Threading.WaitHandle)\n  - System.Threading.WaitHandleExtensions.SetSafeWaitHandle(System.Threading.WaitHandle,Microsoft.Win32.SafeHandles.SafeWaitHandle)\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.#ctor\n  commentId: M:System.Threading.WaitHandle.#ctor\n  id: '#ctor'\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitHandle()\n  nameWithType: WaitHandle.WaitHandle()\n  fullName: WaitHandle.WaitHandle()\n  type: Constructor\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.WaitHandle\"></xref> class.\n  syntax:\n    content: protected WaitHandle ();\n    parameters: []\n  overload: System.Threading.WaitHandle.#ctor*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.Close\n  commentId: M:System.Threading.WaitHandle.Close\n  id: Close\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: Close()\n  nameWithType: WaitHandle.Close()\n  fullName: WaitHandle.Close()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading\n  summary: Releases all resources held by the current <xref href=\"System.Threading.WaitHandle\"></xref>.\n  remarks: \"This method is the public implementation of the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method for the <xref:System.Threading.WaitHandle> class and its derived classes. It provides a standard implementation that calls the `Dispose(Boolean)` overload with a `true` argument and then calls the <xref:System.GC.SuppressFinalize%2A?displayProperty=fullName> method. Call this method to release all resources held by an instance of `WaitHandle` or a derived class.  \\n  \\n Once this method is called, references to the current instance cause undefined behavior.  \\n  \\n> [!NOTE]\\n>  Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>. Otherwise, the resources it is using will not be freed.\"\n  syntax:\n    content: public virtual void Close ();\n    parameters: []\n  overload: System.Threading.WaitHandle.Close*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.Dispose\n  commentId: M:System.Threading.WaitHandle.Dispose\n  id: Dispose\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: Dispose()\n  nameWithType: WaitHandle.Dispose()\n  fullName: WaitHandle.Dispose()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Releases all resources used by the current instance of the <xref href=\"System.Threading.WaitHandle\"></xref> class.\n  remarks: \"This method is equivalent to the <xref:System.Threading.WaitHandle.Close%2A> method.  \\n  \\n> [!NOTE]\\n>  Always call <xref:System.Threading.WaitHandle.Close%2A> or <xref:System.Threading.WaitHandle.Dispose> before you release your last reference to the <xref:System.Threading.WaitHandle>. Otherwise, the resources it is using will not be freed.\"\n  syntax:\n    content: public void Dispose ();\n    parameters: []\n  overload: System.Threading.WaitHandle.Dispose*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.Dispose(System.Boolean)\n  commentId: M:System.Threading.WaitHandle.Dispose(System.Boolean)\n  id: Dispose(System.Boolean)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: Dispose(Boolean)\n  nameWithType: WaitHandle.Dispose(Boolean)\n  fullName: WaitHandle.Dispose(Boolean)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: When overridden in a derived class, releases the unmanaged resources used by the <xref href=\"System.Threading.WaitHandle\"></xref>, and optionally releases the managed resources.\n  remarks: This method is called by the <xref:System.Threading.WaitHandle.Close%2A> and the <xref:System.Threading.WaitHandle.Dispose> methods with the `explicitDisposing` parameter set to `true`.  When the `explicitDisposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Threading.WaitHandle> object references.\n  syntax:\n    content: protected virtual void Dispose (bool explicitDisposing);\n    parameters:\n    - id: explicitDisposing\n      type: System.Boolean\n      description: '`true` to release both managed and unmanaged resources; `false` to release only unmanaged resources.'\n  overload: System.Threading.WaitHandle.Dispose*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.Handle\n  commentId: P:System.Threading.WaitHandle.Handle\n  id: Handle\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: Handle\n  nameWithType: WaitHandle.Handle\n  fullName: WaitHandle.Handle\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading\n  summary: Gets or sets the native operating system handle.\n  remarks: \"Assigning a new value to the <xref:System.Threading.WaitHandle.Handle%2A> property does not close the previous handle. This can result in a leaked handle.  \\n  \\n Do not use this property in the .NET Framework version 2.0 or later; use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property instead. Setting this property to a valid handle also sets the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, but setting it to <xref:System.Threading.WaitHandle.InvalidHandle> can result in a leaked handle.\"\n  syntax:\n    content: >-\n      [System.Obsolete(\"Use the SafeWaitHandle property instead.\")]\n\n      [get: System.Security.SecuritySafeCritical]\n\n      [set: System.Security.SecurityCritical]\n\n      public virtual IntPtr Handle { get; set; }\n    return:\n      type: System.IntPtr\n      description: An `IntPtr` representing the native operating system handle. The default is the value of the <xref href=\"System.Threading.WaitHandle.InvalidHandle\"></xref> field.\n  overload: System.Threading.WaitHandle.Handle*\n  exceptions: []\n  attributes:\n  - type: System.ObsoleteAttribute\n  - type: 'get: System.Security.SecuritySafeCritical'\n  - type: 'set: System.Security.SecurityCritical'\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.InvalidHandle\n  commentId: F:System.Threading.WaitHandle.InvalidHandle\n  id: InvalidHandle\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: InvalidHandle\n  nameWithType: WaitHandle.InvalidHandle\n  fullName: WaitHandle.InvalidHandle\n  type: Field\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Represents an invalid native operating system handle. This field is read-only.\n  remarks: Used internally to initialize the <xref:System.Threading.WaitHandle.Handle%2A> property.\n  syntax:\n    content: protected static readonly IntPtr InvalidHandle;\n    return:\n      type: System.IntPtr\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.SafeWaitHandle\n  commentId: P:System.Threading.WaitHandle.SafeWaitHandle\n  id: SafeWaitHandle\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: SafeWaitHandle\n  nameWithType: WaitHandle.SafeWaitHandle\n  fullName: WaitHandle.SafeWaitHandle\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading\n  summary: Gets or sets the native operating system handle.\n  remarks: \"When you assign a new value to the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property, the previous handle will be closed when the previous <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> object is collected. Do not manually close the handle, because this results in an <xref:System.ObjectDisposedException> when the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> attempts to close the handle.  \\n  \\n <xref:System.Threading.WaitHandle> implements the <xref:System.IDisposable.Dispose%2A> pattern. See [Dispose Pattern](~/docs/standard/design-guidelines/dispose-pattern.md). When you derive from <xref:System.Threading.WaitHandle>, use the <xref:System.Threading.WaitHandle.SafeWaitHandle%2A> property to store your native handle operating system handle. You do not need to override the protected <xref:System.Threading.WaitHandle.Dispose%2A> method unless you use additional unmanaged resources.\"\n  syntax:\n    content: >-\n      [get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)]\n\n      [get: System.Security.SecurityCritical]\n\n      [set: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]\n\n      [set: System.Security.SecurityCritical]\n\n      public Microsoft.Win32.SafeHandles.SafeWaitHandle SafeWaitHandle { get; set; }\n    return:\n      type: Microsoft.Win32.SafeHandles.SafeWaitHandle\n      description: A <xref href=\"Microsoft.Win32.SafeHandles.SafeWaitHandle\"></xref> representing the native operating system handle.\n  overload: System.Threading.WaitHandle.SafeWaitHandle*\n  exceptions: []\n  attributes:\n  - type: 'get: System.Runtime.ConstrainedExecution.ReliabilityContract'\n  - type: 'get: System.Security.SecurityCritical'\n  - type: 'set: System.Runtime.ConstrainedExecution.ReliabilityContract'\n  - type: 'set: System.Security.SecurityCritical'\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\n  commentId: M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\n  id: SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: SignalAndWait(WaitHandle, WaitHandle)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading\n  summary: Signals one <xref href=\"System.Threading.WaitHandle\"></xref> and waits on another.\n  remarks: This operation is not guaranteed to be atomic. After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.\n  example:\n  - \"The following code example uses the <xref:System.Threading.WaitHandle.SignalAndWait%28System.Threading.WaitHandle%2CSystem.Threading.WaitHandle%29> method overload to allow the main thread to signal a blocked thread and then wait until the thread finishes a task.  \\n  \\n The example starts five threads, allows them to block on an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode?displayProperty=fullName> flag, and then releases one thread each time the user presses the ENTER key. The example then queues another five threads and releases them all using an <xref:System.Threading.EventWaitHandle> created with the <xref:System.Threading.EventResetMode?displayProperty=fullName> flag.  \\n  \\n [!code-cpp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/CS/source.cs#1)]\\n [!code-vb[System.Threading.WaitHandle.SignalAndWait#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.SignalAndWait/VB/source.vb#1)]\"\n  syntax:\n    content: public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn);\n    parameters:\n    - id: toSignal\n      type: System.Threading.WaitHandle\n      description: The <xref href=\"System.Threading.WaitHandle\"></xref> to signal.\n    - id: toWaitOn\n      type: System.Threading.WaitHandle\n      description: The <xref href=\"System.Threading.WaitHandle\"></xref> to wait on.\n    return:\n      type: System.Boolean\n      description: '`true` if both the signal and the wait complete successfully; if the wait does not complete, the method does not return.'\n  overload: System.Threading.WaitHandle.SignalAndWait*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>toSignal</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>toWaitOn</code> is `null`.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The method was called on a thread that has <xref href=\"System.STAThreadAttribute\"></xref>.\n  - type: System.PlatformNotSupportedException\n    commentId: T:System.PlatformNotSupportedException\n    description: This method is not supported on Windows 98 or Windows Millennium Edition.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <code>toSignal</code> is a semaphore, and it already has a full count.\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)\n  commentId: M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)\n  id: SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading\n  summary: Signals one <xref href=\"System.Threading.WaitHandle\"></xref> and waits on another, specifying a time-out interval as a 32-bit signed integer and specifying whether to exit the synchronization domain for the context before entering the wait.\n  remarks: \"This operation is not guaranteed to be atomic. After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.  \\n  \\n If `millisecondsTimeout` is zero, the method does not block. It tests the state of the `toWaitOn` and returns immediately.  \\n  \\n## Notes on Exiting the Context  \\n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \\n  \\n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.  \\n  \\n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.\"\n  syntax:\n    content: public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);\n    parameters:\n    - id: toSignal\n      type: System.Threading.WaitHandle\n      description: The <xref href=\"System.Threading.WaitHandle\"></xref> to signal.\n    - id: toWaitOn\n      type: System.Threading.WaitHandle\n      description: The <xref href=\"System.Threading.WaitHandle\"></xref> to wait on.\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: An integer that represents the interval to wait. If the value is <xref href=\"System.Threading.Timeout.Infinite\"></xref>, that is, -1, the wait is infinite.\n    - id: exitContext\n      type: System.Boolean\n      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'\n    return:\n      type: System.Boolean\n      description: '`true` if both the signal and the wait completed successfully, or `false` if the signal completed but the wait timed out.'\n  overload: System.Threading.WaitHandle.SignalAndWait*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>toSignal</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>toWaitOn</code> is `null`.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The method is called on a thread that has <xref href=\"System.STAThreadAttribute\"></xref>.\n  - type: System.PlatformNotSupportedException\n    commentId: T:System.PlatformNotSupportedException\n    description: This method is not supported on Windows 98 or Windows Millennium Edition.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <xref href=\"System.Threading.WaitHandle\"></xref> cannot be signaled because it would exceed its maximum count.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)\n  commentId: M:System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)\n  id: SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading\n  summary: Signals one <xref href=\"System.Threading.WaitHandle\"></xref> and waits on another, specifying the time-out interval as a <xref href=\"System.TimeSpan\"></xref> and specifying whether to exit the synchronization domain for the context before entering the wait.\n  remarks: \"This operation is not guaranteed to be atomic. After the current thread signals `toSignal` but before it waits on `toWaitOn`, a thread that is running on another processor might signal `toWaitOn` or wait on it.  \\n  \\n The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \\n  \\n If `timeout` is zero, the method does not block. It tests the state of the `toWaitOn` and returns immediately.  \\n  \\n## Notes on Exiting the Context  \\n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \\n  \\n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method completes.  \\n  \\n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.SignalAndWait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.\"\n  syntax:\n    content: public static bool SignalAndWait (System.Threading.WaitHandle toSignal, System.Threading.WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);\n    parameters:\n    - id: toSignal\n      type: System.Threading.WaitHandle\n      description: The <xref href=\"System.Threading.WaitHandle\"></xref> to signal.\n    - id: toWaitOn\n      type: System.Threading.WaitHandle\n      description: The <xref href=\"System.Threading.WaitHandle\"></xref> to wait on.\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> that represents the interval to wait. If the value is -1, the wait is infinite.\n    - id: exitContext\n      type: System.Boolean\n      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'\n    return:\n      type: System.Boolean\n      description: '`true` if both the signal and the wait completed successfully, or `false` if the signal completed but the wait timed out.'\n  overload: System.Threading.WaitHandle.SignalAndWait*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>toSignal</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>toWaitOn</code> is `null`.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The method was called on a thread that has <xref href=\"System.STAThreadAttribute\"></xref>.\n  - type: System.PlatformNotSupportedException\n    commentId: T:System.PlatformNotSupportedException\n    description: This method is not supported on Windows 98 or Windows Millennium Edition.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <code>toSignal</code> is a semaphore, and it already has a full count.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>timeout</code> evaluates to a negative number of milliseconds other than -1.  \\n  \\n -or-  \\n  \\n <code>timeout</code> is greater than <xref href=\\\"System.Int32.MaxValue\\\"></xref>.\"\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  commentId: M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  id: WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitAll(WaitHandle[], TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], TimeSpan, Boolean)\n  fullName: WaitHandle.WaitAll(WaitHandle[], TimeSpan, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading\n  summary: Waits for all the elements in the specified array to receive a signal, using a <xref href=\"System.TimeSpan\"></xref> value to specify the time interval, and specifying whether to exit the synchronization domain before the wait.\n  remarks: \"If `timeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \\n  \\n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \\n  \\n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call will fail.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \\n  \\n The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \\n  \\n## Notes on Exiting the Context  \\n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \\n  \\n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method. It returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.  \\n  \\n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.\"\n  example:\n  - \"The following code example shows how to use the thread pool to asynchronously create and write to a group of files. Each write operation is queued as a work item and signals when it is finished. The main thread waits for all the items to signal and then exits.  \\n  \\n [!code-cpp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CPP/source3.cpp#1)]\\n [!code-csharp[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/CS/source3.cs#1)]\\n [!code-vb[System.Threading.WaitHandle.WaitAll3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll3/VB/source3.vb#1)]\"\n  syntax:\n    content: public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);\n    parameters:\n    - id: waitHandles\n      type: System.Threading.WaitHandle[]\n      description: A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds, to wait indefinitely.\n    - id: exitContext\n      type: System.Boolean\n      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'\n    return:\n      type: System.Boolean\n      description: '`true` when every element in <code>waitHandles</code> has received a signal; otherwise `false`.'\n  overload: System.Threading.WaitHandle.WaitAll*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"The <code>waitHandles</code> parameter is `null`.  \\n  \\n -or-  \\n  \\n One or more of the objects in the <code>waitHandles</code> array is `null`.  \\n  \\n -or-  \\n  \\n <code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later.\"\n  - type: System.DuplicateWaitObjectException\n    commentId: T:System.DuplicateWaitObjectException\n    description: The <code>waitHandles</code> array contains elements that are duplicates.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: \"The number of objects in <code>waitHandles</code> is greater than the system permits.  \\n  \\n -or-  \\n  \\n The <xref href=\\\"System.STAThreadAttribute\\\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.\"\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: <code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  \\n  \\n -or-  \\n  \\n <code>timeout</code> is greater than <xref href=\\\"System.Int32.MaxValue\\\"></xref>.\"\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  commentId: M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  id: WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitAll(WaitHandle[], Int32, Boolean)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], Int32, Boolean)\n  fullName: WaitHandle.WaitAll(WaitHandle[], Int32, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading\n  summary: Waits for all the elements in the specified array to receive a signal, using an <xref href=\"System.Int32\"></xref> value to specify the time interval and specifying whether to exit the synchronization domain before the wait.\n  remarks: \"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \\n  \\n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \\n  \\n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \\n  \\n## Notes on Exiting the Context  \\n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAll%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \\n  \\n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAll%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAll%2A> method completes.  \\n  \\n This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAll%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.\"\n  example:\n  - \"The following code example shows how to use the thread pool to asynchronously create and write to a group of files. Each write operation is queued as a work item and signals when it is finished. The main thread waits for all the items to signal and then exits.  \\n  \\n [!code-cpp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CPP/source2.cpp#1)]\\n [!code-csharp[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/CS/source2.cs#1)]\\n [!code-vb[System.Threading.WaitHandle.WaitAll2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll2/VB/source2.vb#1)]\"\n  syntax:\n    content: public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);\n    parameters:\n    - id: waitHandles\n      type: System.Threading.WaitHandle[]\n      description: A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely.\n    - id: exitContext\n      type: System.Boolean\n      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'\n    return:\n      type: System.Boolean\n      description: '`true` when every element in <code>waitHandles</code> has received a signal; otherwise, `false`.'\n  overload: System.Threading.WaitHandle.WaitAll*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"The <code>waitHandles</code> parameter is `null`.  \\n  \\n -or-  \\n  \\n One or more of the objects in the <code>waitHandles</code> array is `null`.  \\n  \\n -or-  \\n  \\n <code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later.\"\n  - type: System.DuplicateWaitObjectException\n    commentId: T:System.DuplicateWaitObjectException\n    description: The <code>waitHandles</code> array contains elements that are duplicates.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: \"The number of objects in <code>waitHandles</code> is greater than the system permits.  \\n  \\n -or-  \\n  \\n The <xref href=\\\"System.STAThreadAttribute\\\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.\"\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: <code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)\n  commentId: M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)\n  id: WaitAll(System.Threading.WaitHandle[],System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitAll(WaitHandle[], TimeSpan)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], TimeSpan)\n  fullName: WaitHandle.WaitAll(WaitHandle[], TimeSpan)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Waits for all the elements in the specified array to receive a signal, using a <xref href=\"System.TimeSpan\"></xref> value to specify the time interval.\n  remarks: \"If `timeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \\n  \\n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either all the handles are signaled or a time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call will fail.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \\n  \\n The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \\n  \\n Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.\"\n  syntax:\n    content: public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);\n    parameters:\n    - id: waitHandles\n      type: System.Threading.WaitHandle[]\n      description: A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds, to wait indefinitely.\n    return:\n      type: System.Boolean\n      description: '`true` when every element in <code>waitHandles</code> has received a signal; otherwise, `false`.'\n  overload: System.Threading.WaitHandle.WaitAll*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"The <code>waitHandles</code> parameter is `null`.  \\n  \\n -or-  \\n  \\n One or more of the objects in the <code>waitHandles</code> array is `null`.  \\n  \\n -or-  \\n  \\n <code>waitHandles</code> is an array with no elements.\"\n  - type: System.DuplicateWaitObjectException\n    commentId: T:System.DuplicateWaitObjectException\n    description: \"<block subset=\\\"none\\\" type=\\\"note\\\">\\n      <p>  \\n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\\\"System.ArgumentException\\\"></xref>, instead.  \\n  \\n</p>\\n    </block>  \\n  \\n The <code>waitHandles</code> array contains elements that are duplicates.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: \"The number of objects in <code>waitHandles</code> is greater than the system permits.  \\n  \\n -or-  \\n  \\n The <xref href=\\\"System.STAThreadAttribute\\\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  \\n  \\n -or-  \\n  \\n <code>timeout</code> is greater than <xref href=\\\"System.Int32.MaxValue\\\"></xref>.\"\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)\n  commentId: M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)\n  id: WaitAll(System.Threading.WaitHandle[],System.Int32)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitAll(WaitHandle[], Int32)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], Int32)\n  fullName: WaitHandle.WaitAll(WaitHandle[], Int32)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Waits for all the elements in the specified array to receive a signal, using an <xref href=\"System.Int32\"></xref> value to specify the time interval.\n  remarks: \"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \\n  \\n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when the wait terminates, which means either when all the handles are signaled or when time-out occurs. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If there are duplicates in the array, the call fails with a <xref:System.DuplicateWaitObjectException>.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \\n  \\n Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.\"\n  syntax:\n    content: public static bool WaitAll (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);\n    parameters:\n    - id: waitHandles\n      type: System.Threading.WaitHandle[]\n      description: A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object (duplicates).\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely.\n    return:\n      type: System.Boolean\n      description: '`true` when every element in <code>waitHandles</code> has received a signal; otherwise, `false`.'\n  overload: System.Threading.WaitHandle.WaitAll*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"The <code>waitHandles</code> parameter is `null`.  \\n  \\n -or-  \\n  \\n One or more of the objects in the <code>waitHandles</code> array is `null`.  \\n  \\n -or-  \\n  \\n <code>waitHandles</code> is an array with no elements.\"\n  - type: System.DuplicateWaitObjectException\n    commentId: T:System.DuplicateWaitObjectException\n    description: \"<block subset=\\\"none\\\" type=\\\"note\\\">\\n      <p>  \\n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\\\"System.ArgumentException\\\"></xref>, instead.  \\n  \\n</p>\\n    </block>  \\n  \\n The <code>waitHandles</code> array contains elements that are duplicates.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: \"The number of objects in <code>waitHandles</code> is greater than the system permits.  \\n  \\n -or-  \\n  \\n The <xref href=\\\"System.STAThreadAttribute\\\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])\n  commentId: M:System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])\n  id: WaitAll(System.Threading.WaitHandle[])\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitAll(WaitHandle[])\n  nameWithType: WaitHandle.WaitAll(WaitHandle[])\n  fullName: WaitHandle.WaitAll(WaitHandle[])\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Waits for all the elements in the specified array to receive a signal.\n  remarks: \"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAll%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \\n  \\n The <xref:System.Threading.WaitHandle.WaitAll%2A> method returns when all the handles are signaled. On some implementations, if more than 64 handles are passed, a <xref:System.NotSupportedException> is thrown. If the array contains duplicates, the call fails with a <xref:System.DuplicateWaitObjectException>.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Threading.WaitHandle.WaitAll%2A> method is not supported on threads that have <xref:System.STAThreadAttribute>.  \\n  \\n Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAll%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>) for `millisecondsTimeout` and `true` for `exitContext`.\"\n  example:\n  - \"The following code example shows how to use the thread pool to asynchronously create and write to a group of files. Each write operation is queued as a work item and signals when it is finished. The main thread waits for all the items to signal and then exits.  \\n  \\n [!code-cpp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CPP/source1.cpp#1)]\\n [!code-csharp[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/CS/source1.cs#1)]\\n [!code-vb[System.Threading.WaitHandle.WaitAll1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAll1/VB/source1.vb#1)]\"\n  syntax:\n    content: public static bool WaitAll (System.Threading.WaitHandle[] waitHandles);\n    parameters:\n    - id: waitHandles\n      type: System.Threading.WaitHandle[]\n      description: A `WaitHandle` array containing the objects for which the current instance will wait. This array cannot contain multiple references to the same object.\n    return:\n      type: System.Boolean\n      description: '`true` when every element in <code>waitHandles</code> has received a signal; otherwise the method never returns.'\n  overload: System.Threading.WaitHandle.WaitAll*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"The <code>waitHandles</code> parameter is `null`. -or-  \\n  \\n One or more of the objects in the <code>waitHandles</code> array are `null`.  \\n  \\n -or-  \\n  \\n <code>waitHandles</code> is an array with no elements and the .NET Framework version is 2.0 or later.\"\n  - type: System.DuplicateWaitObjectException\n    commentId: T:System.DuplicateWaitObjectException\n    description: \"<block subset=\\\"none\\\" type=\\\"note\\\">\\n      <p>  \\n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\\\"System.ArgumentException\\\"></xref>, instead.  \\n  \\n</p>\\n    </block>  \\n  \\n The <code>waitHandles</code> array contains elements that are duplicates.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: \"The number of objects in <code>waitHandles</code> is greater than the system permits.  \\n  \\n -or-  \\n  \\n The <xref href=\\\"System.STAThreadAttribute\\\"></xref> attribute is applied to the thread procedure for the current thread, and <code>waitHandles</code> contains more than one element.\"\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: <code>waitHandles</code> is an array with no elements and the .NET Framework version is 1.0 or 1.1.\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait terminated because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\n  commentId: M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\n  id: WaitAny(System.Threading.WaitHandle[])\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitAny(WaitHandle[])\n  nameWithType: WaitHandle.WaitAny(WaitHandle[])\n  fullName: WaitHandle.WaitAny(WaitHandle[])\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Waits for any of the elements in the specified array to receive a signal.\n  remarks: \"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \\n  \\n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \\n  \\n> [!NOTE]\\n>  In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.  \\n  \\n This method returns when any handle is signaled. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \\n  \\n Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> method overload and specifying -1 (or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName>) for `millisecondsTimeout` and `true` for `exitContext`.\"\n  example:\n  - \"The following code example demonstrates calling the <xref:System.Threading.WaitHandle.WaitAny%2A>method.  \\n  \\n [!code-cpp[WaitHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/WaitHandle/cpp/WaitHandle.cpp#1)]\\n [!code-csharp[WaitHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/WaitHandle/CS/WaitHandle.cs#1)]\\n [!code-vb[WaitHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/WaitHandle/VB/WaitHandle.vb#1)]\"\n  syntax:\n    content: public static int WaitAny (System.Threading.WaitHandle[] waitHandles);\n    parameters:\n    - id: waitHandles\n      type: System.Threading.WaitHandle[]\n      description: A `WaitHandle` array containing the objects for which the current instance will wait.\n    return:\n      type: System.Int32\n      description: The array index of the object that satisfied the wait.\n  overload: System.Threading.WaitHandle.WaitAny*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"The <code>waitHandles</code> parameter is `null`.  \\n  \\n -or-  \\n  \\n One or more of the objects in the <code>waitHandles</code> array is `null`.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The number of objects in <code>waitHandles</code> is greater than the system permits.\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: <code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)\n  commentId: M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)\n  id: WaitAny(System.Threading.WaitHandle[],System.Int32)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitAny(WaitHandle[], Int32)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], Int32)\n  fullName: WaitHandle.WaitAny(WaitHandle[], Int32)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval.\n  remarks: \"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \\n  \\n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \\n  \\n This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \\n  \\n Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.\"\n  syntax:\n    content: public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout);\n    parameters:\n    - id: waitHandles\n      type: System.Threading.WaitHandle[]\n      description: A `WaitHandle` array containing the objects for which the current instance will wait.\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely.\n    return:\n      type: System.Int32\n      description: The array index of the object that satisfied the wait, or <xref href=\"System.Threading.WaitHandle.WaitTimeout\"></xref> if no object satisfied the wait and a time interval equivalent to <code>millisecondsTimeout</code> has passed.\n  overload: System.Threading.WaitHandle.WaitAny*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"The <code>waitHandles</code> parameter is `null`.  \\n  \\n -or-  \\n  \\n One or more of the objects in the <code>waitHandles</code> array is `null`.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The number of objects in <code>waitHandles</code> is greater than the system permits.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>waitHandles</code> is an array with no elements.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)\n  commentId: M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)\n  id: WaitAny(System.Threading.WaitHandle[],System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitAny(WaitHandle[], TimeSpan)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], TimeSpan)\n  fullName: WaitHandle.WaitAny(WaitHandle[], TimeSpan)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Waits for any of the elements in the specified array to receive a signal, using a <xref href=\"System.TimeSpan\"></xref> to specify the time interval.\n  remarks: \"If `timeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \\n  \\n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \\n  \\n This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \\n  \\n The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \\n  \\n Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitAny%28System.Threading.WaitHandle%5B%5D%2CSystem.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.\"\n  syntax:\n    content: public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout);\n    parameters:\n    - id: waitHandles\n      type: System.Threading.WaitHandle[]\n      description: A `WaitHandle` array containing the objects for which the current instance will wait.\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely.\n    return:\n      type: System.Int32\n      description: The array index of the object that satisfied the wait, or <xref href=\"System.Threading.WaitHandle.WaitTimeout\"></xref> if no object satisfied the wait and a time interval equivalent to <code>timeout</code> has passed.\n  overload: System.Threading.WaitHandle.WaitAny*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"The <code>waitHandles</code> parameter is `null`.  \\n  \\n -or-  \\n  \\n One or more of the objects in the <code>waitHandles</code> array is `null`.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The number of objects in <code>waitHandles</code> is greater than the system permits.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  \\n  \\n -or-  \\n  \\n <code>timeout</code> is greater than <xref href=\\\"System.Int32.MaxValue\\\"></xref>.\"\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>waitHandles</code> is an array with no elements.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  commentId: M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  id: WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitAny(WaitHandle[], Int32, Boolean)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], Int32, Boolean)\n  fullName: WaitHandle.WaitAny(WaitHandle[], Int32, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading\n  summary: Waits for any of the elements in the specified array to receive a signal, using a 32-bit signed integer to specify the time interval, and specifying whether to exit the synchronization domain before the wait.\n  remarks: \"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \\n  \\n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \\n  \\n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \\n  \\n> [!NOTE]\\n>  In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.  \\n  \\n This method returns when the wait terminates, either when any of the handles are signaled or when a timeout occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \\n  \\n## Notes on Exiting the Context  \\n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \\n  \\n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.  \\n  \\n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.\"\n  example:\n  - \"The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks. For space considerations, only the root directory of each disk is searched.  \\n  \\n [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]\\n [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]\\n [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]\"\n  syntax:\n    content: public static int WaitAny (System.Threading.WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);\n    parameters:\n    - id: waitHandles\n      type: System.Threading.WaitHandle[]\n      description: A `WaitHandle` array containing the objects for which the current instance will wait.\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely.\n    - id: exitContext\n      type: System.Boolean\n      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'\n    return:\n      type: System.Int32\n      description: The array index of the object that satisfied the wait, or <xref href=\"System.Threading.WaitHandle.WaitTimeout\"></xref> if no object satisfied the wait and a time interval equivalent to <code>millisecondsTimeout</code> has passed.\n  overload: System.Threading.WaitHandle.WaitAny*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"The <code>waitHandles</code> parameter is `null`.  \\n  \\n -or-  \\n  \\n One or more of the objects in the <code>waitHandles</code> array is `null`.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The number of objects in <code>waitHandles</code> is greater than the system permits.\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: <code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  commentId: M:System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  id: WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitAny(WaitHandle[], TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], TimeSpan, Boolean)\n  fullName: WaitHandle.WaitAny(WaitHandle[], TimeSpan, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading\n  summary: Waits for any of the elements in the specified array to receive a signal, using a <xref href=\"System.TimeSpan\"></xref> to specify the time interval and specifying whether to exit the synchronization domain before the wait.\n  remarks: \"If `timeout` is zero, the method does not block. It tests the state of the wait handles and returns immediately.  \\n  \\n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns `true` if the wait completes because a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \\n  \\n The <xref:System.Threading.WaitHandle.WaitAny%2A> method throws an <xref:System.Threading.AbandonedMutexException> only when the wait completes because of an abandoned mutex. If `waitHandles` contains a released mutex with a lower index number than the abandoned mutex, the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes normally and the exception is not thrown.  \\n  \\n> [!NOTE]\\n>  In versions of the .NET Framework earlier than version 2.0, if a thread exits or aborts without explicitly releasing a <xref:System.Threading.Mutex>, and that `Mutex` is at index 0 (zero) in a `WaitAny` array on another thread, the index returned by `WaitAny` is 128 instead of 0.  \\n  \\n This method returns when the wait terminates, either when any of the handles are signaled or when a time-out occurs. If more than one object becomes signaled during the call, the return value is the array index of the signaled object with the smallest index value of all the signaled objects. On some implementations, if more that 64 handles are passed, a <xref:System.NotSupportedException> is thrown.  \\n  \\n The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \\n  \\n## Notes on Exiting the Context  \\n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitAny%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \\n  \\n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitAny%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitAny%2A> method completes.  \\n  \\n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitAny%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitAny%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.\"\n  example:\n  - \"The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks. For space considerations, only the root directory of each disk is searched.  \\n  \\n [!code-cpp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CPP/source3.cpp#1)]\\n [!code-csharp[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/CS/source3.cs#1)]\\n [!code-vb[System.Threading.WaitHandle.WaitAny3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny3/VB/source3.vb#1)]\"\n  syntax:\n    content: public static int WaitAny (System.Threading.WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);\n    parameters:\n    - id: waitHandles\n      type: System.Threading.WaitHandle[]\n      description: A `WaitHandle` array containing the objects for which the current instance will wait.\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely.\n    - id: exitContext\n      type: System.Boolean\n      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'\n    return:\n      type: System.Int32\n      description: The array index of the object that satisfied the wait, or <xref href=\"System.Threading.WaitHandle.WaitTimeout\"></xref> if no object satisfied the wait and a time interval equivalent to <code>timeout</code> has passed.\n  overload: System.Threading.WaitHandle.WaitAny*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"The <code>waitHandles</code> parameter is `null`.  \\n  \\n -or-  \\n  \\n One or more of the objects in the <code>waitHandles</code> array is `null`.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The number of objects in <code>waitHandles</code> is greater than the system permits.\n  - type: System.ApplicationException\n    commentId: T:System.ApplicationException\n    description: <code>waitHandles</code> is an array with no elements, and the .NET Framework version is 1.0 or 1.1.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  \\n  \\n -or-  \\n  \\n <code>timeout</code> is greater than <xref href=\\\"System.Int32.MaxValue\\\"></xref>.\"\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>waitHandles</code> is an array with no elements, and the .NET Framework version is 2.0 or later.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The <code>waitHandles</code> array contains a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitOne\n  commentId: M:System.Threading.WaitHandle.WaitOne\n  id: WaitOne\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitOne()\n  nameWithType: WaitHandle.WaitOne()\n  fullName: WaitHandle.WaitOne()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Blocks the current thread until the current <xref href=\"System.Threading.WaitHandle\"></xref> receives a signal.\n  remarks: \"<xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \\n  \\n The caller of this method blocks indefinitely until the current instance receives a signal. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \\n  \\n Calling this method overload is equivalent to calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload and specifying -1 or <xref:System.Threading.Timeout.Infinite?displayProperty=fullName> for the first parameter and `false` for the second parameter.  \\n  \\n Override this method to customize the behavior of derived classes.\"\n  example:\n  - \"The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.  \\n  \\n [!code-cpp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CPP/source1.cpp#1)]\\n [!code-csharp[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/CS/source1.cs#1)]\\n [!code-vb[System.Threading.WaitHandle.WaitOne1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne1/VB/source1.vb#1)]\"\n  syntax:\n    content: public virtual bool WaitOne ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the current instance receives a signal. If the current instance is never signaled, <xref href=\"System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\"></xref> never returns.'\n  overload: System.Threading.WaitHandle.WaitOne*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The current instance has already been disposed.\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitOne(System.Int32)\n  commentId: M:System.Threading.WaitHandle.WaitOne(System.Int32)\n  id: WaitOne(System.Int32)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitOne(Int32)\n  nameWithType: WaitHandle.WaitOne(Int32)\n  fullName: WaitHandle.WaitOne(Int32)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Blocks the current thread until the current <xref href=\"System.Threading.WaitHandle\"></xref> receives a signal, using a 32-bit signed integer to specify the time interval in milliseconds.\n  remarks: \"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handle and returns immediately.  \\n  \\n The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \\n  \\n Override this method to customize the behavior of derived classes.  \\n  \\n Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.\"\n  example:\n  - \"The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.  \\n  \\n [!code-cpp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CPP/source2.cpp#1)]\\n [!code-csharp[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/CS/source2.cs#1)]\\n [!code-vb[System.Threading.WaitHandle.WaitOne2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne2/VB/source2.vb#1)]\"\n  syntax:\n    content: public virtual bool WaitOne (int millisecondsTimeout);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely.\n    return:\n      type: System.Boolean\n      description: '`true` if the current instance receives a signal; otherwise, `false`.'\n  overload: System.Threading.WaitHandle.WaitOne*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The current instance has already been disposed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan)\n  commentId: M:System.Threading.WaitHandle.WaitOne(System.TimeSpan)\n  id: WaitOne(System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitOne(TimeSpan)\n  nameWithType: WaitHandle.WaitOne(TimeSpan)\n  fullName: WaitHandle.WaitOne(TimeSpan)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Blocks the current thread until the current instance receives a signal, using a <xref href=\"System.TimeSpan\"></xref> to specify the time interval.\n  remarks: \"If `timeout` is zero, the method does not block. It tests the state of the wait handle and returns immediately.  \\n  \\n The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \\n  \\n Override this method to customize the behavior of derived classes.  \\n  \\n The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \\n  \\n Calling this method overload is the same as calling the <xref:System.Threading.WaitHandle.WaitOne%28System.TimeSpan%2CSystem.Boolean%29> overload and specifying `false` for `exitContext`.\"\n  syntax:\n    content: public virtual bool WaitOne (TimeSpan timeout);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely.\n    return:\n      type: System.Boolean\n      description: '`true` if the current instance receives a signal; otherwise, `false`.'\n  overload: System.Threading.WaitHandle.WaitOne*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The current instance has already been disposed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  \\n  \\n -or-  \\n  \\n <code>timeout</code> is greater than <xref href=\\\"System.Int32.MaxValue\\\"></xref>.\"\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\n  commentId: M:System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\n  id: WaitOne(System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitOne(Int32, Boolean)\n  nameWithType: WaitHandle.WaitOne(Int32, Boolean)\n  fullName: WaitHandle.WaitOne(Int32, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading\n  summary: Blocks the current thread until the current <xref href=\"System.Threading.WaitHandle\"></xref> receives a signal, using a 32-bit signed integer to specify the time interval and specifying whether to exit the synchronization domain before the wait.\n  remarks: \"If `millisecondsTimeout` is zero, the method does not block. It tests the state of the wait handle and returns immediately.  \\n  \\n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \\n  \\n The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \\n  \\n Override this method to customize the behavior of derived classes.  \\n  \\n## Notes on Exiting the Context  \\n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \\n  \\n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.  \\n  \\n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.\"\n  example:\n  - \"The following example shows how the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%2CSystem.Boolean%29> method overload behaves when it is called within a synchronization domain. First, a thread waits with `exitContext` set to `false` and blocks until the wait timeout expires. A second thread executes after the first thread terminates and waits with `exitContext` set to `true`. The call to signal the wait handle for this second thread is not blocked, and the thread completes before the wait timeout.  \\n  \\n [!code-cpp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cpp/source.cpp#1)]\\n [!code-csharp[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/cs/source.cs#1)]\\n [!code-vb[System.Threading.WaitHandle.WaitOne4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.waithandle.waitone4/vb/source.vb#1)]\"\n  syntax:\n    content: public virtual bool WaitOne (int millisecondsTimeout, bool exitContext);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The number of milliseconds to wait, or <xref href=\"System.Threading.Timeout.Infinite\"></xref> (-1) to wait indefinitely.\n    - id: exitContext\n      type: System.Boolean\n      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'\n    return:\n      type: System.Boolean\n      description: '`true` if the current instance receives a signal; otherwise, `false`.'\n  overload: System.Threading.WaitHandle.WaitOne*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The current instance has already been disposed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> is a negative number other than -1, which represents an infinite time-out.\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)\n  commentId: M:System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)\n  id: WaitOne(System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitOne(TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitOne(TimeSpan, Boolean)\n  fullName: WaitHandle.WaitOne(TimeSpan, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Threading\n  summary: Blocks the current thread until the current instance receives a signal, using a <xref href=\"System.TimeSpan\"></xref> to specify the time interval and specifying whether to exit the synchronization domain before the wait.\n  remarks: \"If `timeout` is zero, the method does not block. It tests the state of the wait handle and returns immediately.  \\n  \\n <xref:System.Threading.AbandonedMutexException> is new in the .NET Framework version 2.0. In previous versions, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true` when a mutex is abandoned. An abandoned mutex often indicates a serious coding error. In the case of a system-wide mutex, it might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager). The exception contains information useful for debugging.  \\n  \\n The caller of this method blocks until the current instance receives a signal or a time-out occurs. Use this method to block until a <xref:System.Threading.WaitHandle> receives a signal from another thread, such as is generated when an asynchronous operation completes. For more information, see the <xref:System.IAsyncResult> interface.  \\n  \\n Override this method to customize the behavior of derived classes.  \\n  \\n The maximum value for `timeout` is <xref:System.Int32.MaxValue?displayProperty=fullName>.  \\n  \\n## Notes on Exiting the Context  \\n The `exitContext` parameter has no effect unless the <xref:System.Threading.WaitHandle.WaitOne%2A> method is called from inside a nondefault managed context. This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>. Even if you are currently executing a method on a class that does not derive from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.  \\n  \\n When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.WaitHandle.WaitOne%2A> method. The thread returns to the original nondefault context after the call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method completes.  \\n  \\n This can be useful when the context-bound class has <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute>. In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class. If code in the call stack of a member calls the <xref:System.Threading.WaitHandle.WaitOne%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed. When the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.\"\n  example:\n  - \"The following code example shows how to use a wait handle to keep a process from terminating while it waits for a background thread to finish executing.  \\n  \\n [!code-cpp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CPP/source3.cpp#1)]\\n [!code-csharp[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/CS/source3.cs#1)]\\n [!code-vb[System.Threading.WaitHandle.WaitOne3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitOne3/VB/source3.vb#1)]\"\n  syntax:\n    content: public virtual bool WaitOne (TimeSpan timeout, bool exitContext);\n    parameters:\n    - id: timeout\n      type: System.TimeSpan\n      description: A <xref href=\"System.TimeSpan\"></xref> that represents the number of milliseconds to wait, or a <xref href=\"System.TimeSpan\"></xref> that represents -1 milliseconds to wait indefinitely.\n    - id: exitContext\n      type: System.Boolean\n      description: '`true` to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it afterward; otherwise, `false`.'\n    return:\n      type: System.Boolean\n      description: '`true` if the current instance receives a signal; otherwise, `false`.'\n  overload: System.Threading.WaitHandle.WaitOne*\n  exceptions:\n  - type: System.ObjectDisposedException\n    commentId: T:System.ObjectDisposedException\n    description: The current instance has already been disposed.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>timeout</code> is a negative number other than -1 milliseconds, which represents an infinite time-out.  \\n  \\n -or-  \\n  \\n <code>timeout</code> is greater than <xref href=\\\"System.Int32.MaxValue\\\"></xref>.\"\n  - type: System.Threading.AbandonedMutexException\n    commentId: T:System.Threading.AbandonedMutexException\n    description: The wait completed because a thread exited without releasing a mutex. This exception is not thrown on Windows 98 or Windows Millennium Edition.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current instance is a transparent proxy for a <xref href=\"System.Threading.WaitHandle\"></xref> in another application domain.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.WaitHandle.WaitTimeout\n  commentId: F:System.Threading.WaitHandle.WaitTimeout\n  id: WaitTimeout\n  parent: System.Threading.WaitHandle\n  langs:\n  - csharp\n  name: WaitTimeout\n  nameWithType: WaitHandle.WaitTimeout\n  fullName: WaitHandle.WaitTimeout\n  type: Field\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Threading\n  summary: Indicates that a <xref href=\"System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\"></xref> operation timed out before any of the wait handles were signaled. This field is constant.\n  remarks: This field is one of the possible return values of `WaitAny`.\n  example:\n  - \"The following code example demonstrates how to use the thread pool to simultaneously search for a file on multiple disks. For space considerations, only the root directory of each disk is searched.  \\n  \\n [!code-cpp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CPP/source2.cpp#1)]\\n [!code-csharp[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/CS/source2.cs#1)]\\n [!code-vb[System.Threading.WaitHandle.WaitAny2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.WaitHandle.WaitAny2/VB/source2.vb#1)]\"\n  syntax:\n    content: public const int WaitTimeout = 258;\n    return:\n      type: System.Int32\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.NotSupportedException\n  parent: System\n  isExternal: false\n  name: NotSupportedException\n  nameWithType: NotSupportedException\n  fullName: System.NotSupportedException\n- uid: System.PlatformNotSupportedException\n  parent: System\n  isExternal: false\n  name: PlatformNotSupportedException\n  nameWithType: PlatformNotSupportedException\n  fullName: System.PlatformNotSupportedException\n- uid: System.InvalidOperationException\n  parent: System\n  isExternal: false\n  name: InvalidOperationException\n  nameWithType: InvalidOperationException\n  fullName: System.InvalidOperationException\n- uid: System.Threading.AbandonedMutexException\n  parent: System.Threading\n  isExternal: false\n  name: AbandonedMutexException\n  nameWithType: AbandonedMutexException\n  fullName: System.Threading.AbandonedMutexException\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.DuplicateWaitObjectException\n  parent: System\n  isExternal: false\n  name: DuplicateWaitObjectException\n  nameWithType: DuplicateWaitObjectException\n  fullName: System.DuplicateWaitObjectException\n- uid: System.ApplicationException\n  parent: System\n  isExternal: false\n  name: ApplicationException\n  nameWithType: ApplicationException\n  fullName: System.ApplicationException\n- uid: System.ArgumentException\n  parent: System\n  isExternal: false\n  name: ArgumentException\n  nameWithType: ArgumentException\n  fullName: System.ArgumentException\n- uid: System.ObjectDisposedException\n  parent: System\n  isExternal: false\n  name: ObjectDisposedException\n  nameWithType: ObjectDisposedException\n  fullName: System.ObjectDisposedException\n- uid: System.Threading.WaitHandle.#ctor\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitHandle()\n  nameWithType: WaitHandle.WaitHandle()\n  fullName: WaitHandle.WaitHandle()\n- uid: System.Threading.WaitHandle.Close\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Close()\n  nameWithType: WaitHandle.Close()\n  fullName: WaitHandle.Close()\n- uid: System.Threading.WaitHandle.Dispose\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Dispose()\n  nameWithType: WaitHandle.Dispose()\n  fullName: WaitHandle.Dispose()\n- uid: System.Threading.WaitHandle.Dispose(System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Dispose(Boolean)\n  nameWithType: WaitHandle.Dispose(Boolean)\n  fullName: WaitHandle.Dispose(Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Threading.WaitHandle.Handle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Handle\n  nameWithType: WaitHandle.Handle\n  fullName: WaitHandle.Handle\n- uid: System.IntPtr\n  parent: System\n  isExternal: false\n  name: IntPtr\n  nameWithType: IntPtr\n  fullName: System.IntPtr\n- uid: System.Threading.WaitHandle.InvalidHandle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: InvalidHandle\n  nameWithType: WaitHandle.InvalidHandle\n  fullName: WaitHandle.InvalidHandle\n- uid: System.Threading.WaitHandle.SafeWaitHandle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SafeWaitHandle\n  nameWithType: WaitHandle.SafeWaitHandle\n  fullName: WaitHandle.SafeWaitHandle\n- uid: Microsoft.Win32.SafeHandles.SafeWaitHandle\n  parent: Microsoft.Win32.SafeHandles\n  isExternal: false\n  name: SafeWaitHandle\n  nameWithType: SafeWaitHandle\n  fullName: Microsoft.Win32.SafeHandles.SafeWaitHandle\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle)\n- uid: System.Threading.WaitHandle\n  parent: System.Threading\n  isExternal: false\n  name: WaitHandle\n  nameWithType: WaitHandle\n  fullName: System.Threading.WaitHandle\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n- uid: System.TimeSpan\n  parent: System\n  isExternal: false\n  name: TimeSpan\n  nameWithType: TimeSpan\n  fullName: System.TimeSpan\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], TimeSpan, Boolean)\n  fullName: WaitHandle.WaitAll(WaitHandle[], TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle[]\n  parent: System.Threading\n  isExternal: false\n  name: WaitHandle[]\n  nameWithType: WaitHandle[]\n  fullName: System.Threading.WaitHandle[]\n  spec.csharp:\n  - uid: System.Threading.WaitHandle\n    name: WaitHandle\n    nameWithType: WaitHandle\n    fullName: System.Threading.WaitHandle\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], Int32, Boolean)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], Int32, Boolean)\n  fullName: WaitHandle.WaitAll(WaitHandle[], Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], TimeSpan)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], TimeSpan)\n  fullName: WaitHandle.WaitAll(WaitHandle[], TimeSpan)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], Int32)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], Int32)\n  fullName: WaitHandle.WaitAll(WaitHandle[], Int32)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[])\n  nameWithType: WaitHandle.WaitAll(WaitHandle[])\n  fullName: WaitHandle.WaitAll(WaitHandle[])\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[])\n  nameWithType: WaitHandle.WaitAny(WaitHandle[])\n  fullName: WaitHandle.WaitAny(WaitHandle[])\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], Int32)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], Int32)\n  fullName: WaitHandle.WaitAny(WaitHandle[], Int32)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], TimeSpan)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], TimeSpan)\n  fullName: WaitHandle.WaitAny(WaitHandle[], TimeSpan)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], Int32, Boolean)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], Int32, Boolean)\n  fullName: WaitHandle.WaitAny(WaitHandle[], Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], TimeSpan, Boolean)\n  fullName: WaitHandle.WaitAny(WaitHandle[], TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitOne\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne()\n  nameWithType: WaitHandle.WaitOne()\n  fullName: WaitHandle.WaitOne()\n- uid: System.Threading.WaitHandle.WaitOne(System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(Int32)\n  nameWithType: WaitHandle.WaitOne(Int32)\n  fullName: WaitHandle.WaitOne(Int32)\n- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(TimeSpan)\n  nameWithType: WaitHandle.WaitOne(TimeSpan)\n  fullName: WaitHandle.WaitOne(TimeSpan)\n- uid: System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(Int32, Boolean)\n  nameWithType: WaitHandle.WaitOne(Int32, Boolean)\n  fullName: WaitHandle.WaitOne(Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitOne(TimeSpan, Boolean)\n  fullName: WaitHandle.WaitOne(TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitTimeout\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitTimeout\n  nameWithType: WaitHandle.WaitTimeout\n  fullName: WaitHandle.WaitTimeout\n- uid: System.Threading.WaitHandle.#ctor*\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitHandle\n  nameWithType: WaitHandle.WaitHandle\n  fullName: WaitHandle.WaitHandle\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n- uid: System.Threading.WaitHandle.Close*\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Close\n  nameWithType: WaitHandle.Close\n  fullName: WaitHandle.Close\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n- uid: System.Threading.WaitHandle.Dispose*\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Dispose\n  nameWithType: WaitHandle.Dispose\n  fullName: WaitHandle.Dispose\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n- uid: System.Threading.WaitHandle.Handle*\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Handle\n  nameWithType: WaitHandle.Handle\n  fullName: WaitHandle.Handle\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n- uid: System.Threading.WaitHandle.SafeWaitHandle*\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SafeWaitHandle\n  nameWithType: WaitHandle.SafeWaitHandle\n  fullName: WaitHandle.SafeWaitHandle\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n- uid: System.Threading.WaitHandle.SignalAndWait*\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait\n  nameWithType: WaitHandle.SignalAndWait\n  fullName: WaitHandle.SignalAndWait\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n- uid: System.Threading.WaitHandle.WaitAll*\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll\n  nameWithType: WaitHandle.WaitAll\n  fullName: WaitHandle.WaitAll\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  - netcore-1.0\n  - netcore-1.1\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n- uid: System.Threading.WaitHandle.WaitAny*\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny\n  nameWithType: WaitHandle.WaitAny\n  fullName: WaitHandle.WaitAny\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n- uid: System.Threading.WaitHandle.WaitOne*\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne\n  nameWithType: WaitHandle.WaitOne\n  fullName: WaitHandle.WaitOne\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/WaitHandle.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.Threading.WaitHandleExtensions.GetSafeWaitHandle(System.Threading.WaitHandle)\n  parent: System.Threading.WaitHandleExtensions\n  isExternal: false\n  name: GetSafeWaitHandle(WaitHandle)\n  nameWithType: WaitHandleExtensions.GetSafeWaitHandle(WaitHandle)\n  fullName: WaitHandleExtensions.GetSafeWaitHandle(WaitHandle)\n- uid: System.Threading.WaitHandleExtensions.SetSafeWaitHandle(System.Threading.WaitHandle,Microsoft.Win32.SafeHandles.SafeWaitHandle)\n  parent: System.Threading.WaitHandleExtensions\n  isExternal: false\n  name: SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n  nameWithType: WaitHandleExtensions.SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n  fullName: WaitHandleExtensions.SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n- uid: System.IDisposable\n  parent: System\n  isExternal: false\n  name: IDisposable\n  nameWithType: IDisposable\n  fullName: System.IDisposable\n"}