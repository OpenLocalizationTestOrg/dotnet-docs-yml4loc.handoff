{"nodes":[{"content":"Controls the system garbage collector, a service that automatically reclaims unused memory.","nodes":[{"pos":[0,91],"content":"Controls the system garbage collector, a service that automatically reclaims unused memory.","nodes":[{"content":"Controls the system garbage collector, a service that automatically reclaims unused memory.","pos":[0,91]}]}],"pos":[1643,1735],"yaml":true},{"content":"The garbage collector is a common language runtime component that controls the allocation and release of managed memory. The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released. Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.  \n  \n The garbage collector tracks and reclaims objects allocated in managed memory. Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references. Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory. Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.  \n  \n Garbage collection consists of the following steps:  \n  \n1.  The garbage collector searches for managed objects that are referenced in managed code.  \n  \n2.  The garbage collector tries to finalize objects that are not referenced.  \n  \n3.  The garbage collector frees objects that are not referenced and reclaims their memory.  \n  \n This topic includes the following sections:  \n  \n [The garbage collector and unmanaged resources](#unmanaged)   \n [Object aging and generations](#generations)   \n [Disallowing garbage collection](#NoGCRegion)  \n  \n<a name=\"unmanaged\"></a>   \n## The garbage collector and unmanaged resources  \n During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code. However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so. The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.  \n  \n Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections. When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.  \n  \n In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=fullName> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=fullName>. In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object. However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called. Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.  \n  \n In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method that performs resource management and cleanup tasks. Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object. The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.  \n  \n For more information on object finalization and the dispose pattern, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).  \n  \n<a name=\"generations\"></a>   \n## Object aging and generations  \n The garbage collector in the common language runtime supports object aging using generations. A generation is a unit of measure of the relative age of objects in memory. The generation number, or age, of an object indicates the generation to which an object belongs. Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle. Objects in the most recent generation are in generation 0. This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2. You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.  \n  \n Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations. Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected.  \n  \n<a name=\"NoGCRegion\"></a>   \n## Disallowing garbage collection  \n Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance. The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector. If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.  \n  \n You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>. You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.  \n  \n You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.","nodes":[{"pos":[0,435],"content":"The garbage collector is a common language runtime component that controls the allocation and release of managed memory. The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released. Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.","nodes":[{"content":"The garbage collector is a common language runtime component that controls the allocation and release of managed memory. The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released. Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.","pos":[0,435],"nodes":[{"content":"The garbage collector is a common language runtime component that controls the allocation and release of managed memory.","pos":[0,120]},{"content":"The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.","pos":[121,262]},{"content":"Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.","pos":[263,435]}]}]},{"pos":[442,885],"content":"The garbage collector tracks and reclaims objects allocated in managed memory. Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references. Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory. Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.","nodes":[{"content":"The garbage collector tracks and reclaims objects allocated in managed memory. Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references. Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory. Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.","pos":[0,443],"nodes":[{"content":"The garbage collector tracks and reclaims objects allocated in managed memory.","pos":[0,78]},{"content":"Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.","pos":[79,222]},{"content":"Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.","pos":[223,338]},{"content":"Alternatively, an application can force garbage collection using the <ph id=\"ph1\">&lt;xref:System.GC.Collect%2A&gt;</ph> method.","pos":[339,443],"source":" Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method."}]}]},{"pos":[892,943],"content":"Garbage collection consists of the following steps:","nodes":[{"content":"Garbage collection consists of the following steps:","pos":[0,51]}]},{"pos":[953,1040],"content":"The garbage collector searches for managed objects that are referenced in managed code.","nodes":[{"content":"The garbage collector searches for managed objects that are referenced in managed code.","pos":[0,87]}]},{"pos":[1050,1122],"content":"The garbage collector tries to finalize objects that are not referenced.","nodes":[{"content":"The garbage collector tries to finalize objects that are not referenced.","pos":[0,72]}]},{"pos":[1132,1218],"content":"The garbage collector frees objects that are not referenced and reclaims their memory.","nodes":[{"content":"The garbage collector frees objects that are not referenced and reclaims their memory.","pos":[0,86]}]},{"pos":[1225,1268],"content":"This topic includes the following sections:","nodes":[{"content":"This topic includes the following sections:","pos":[0,43]}]},{"pos":[1275,1433],"content":"[The garbage collector and unmanaged resources](#unmanaged)   \n[Object aging and generations](#generations)   \n[Disallowing garbage collection](#NoGCRegion)","leadings":[""," "," "],"nodes":[{"content":"<bpt id=\"p1\">[</bpt>The garbage collector and unmanaged resources<ept id=\"p1\">](#unmanaged)</ept><ph id=\"ph1\"> </ph>","pos":[0,60],"source":"[The garbage collector and unmanaged resources](#unmanaged) "},{"content":"<bpt id=\"p1\">[</bpt>Object aging and generations<ept id=\"p1\">](#generations)</ept><ph id=\"ph1\"> </ph>","pos":[63,108],"source":"[Object aging and generations](#generations) "},{"content":"<bpt id=\"p1\">[</bpt>Disallowing garbage collection<ept id=\"p1\">](#NoGCRegion)</ept>","pos":[111,156],"source":"[Disallowing garbage collection](#NoGCRegion)"}]},{"pos":[1470,1515],"content":"The garbage collector and unmanaged resources","linkify":"The garbage collector and unmanaged resources","nodes":[{"content":"The garbage collector and unmanaged resources","pos":[0,45]}]},{"pos":[1519,2025],"content":"During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code. However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so. The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.","nodes":[{"content":"During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code. However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so. The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.","pos":[0,506],"nodes":[{"content":"During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.","pos":[0,132]},{"content":"However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.","pos":[133,343]},{"content":"The <ph id=\"ph1\">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.","pos":[344,506],"source":" The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code."}]}]},{"pos":[2032,2359],"content":"Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections. When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.","nodes":[{"content":"Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections. When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.","pos":[0,327],"nodes":[{"content":"Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.","pos":[0,188]},{"content":"When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.","pos":[189,327]}]}]},{"pos":[2366,3196],"content":"In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=fullName> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=fullName>. In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object. However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called. Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.","nodes":[{"content":"In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=fullName> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=fullName>. In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object. However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called. Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.","pos":[0,830],"nodes":[{"content":"In most cases, finalizers are implemented by overriding the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <ph id=\"ph2\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph>.","pos":[0,284],"source":"In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=fullName> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=fullName>."},{"content":"In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.","pos":[285,389]},{"content":"However, the garbage collector is not required to call finalizers in all situations; for example, the <ph id=\"ph1\">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method explicitly prevents an object's finalizer from being called.","pos":[390,596],"source":" However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called."},{"content":"Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.","pos":[597,830]}]}]},{"pos":[3203,3933],"content":"In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method that performs resource management and cleanup tasks. Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object. The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.","nodes":[{"content":"In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method that performs resource management and cleanup tasks. Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object. The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.","pos":[0,730],"nodes":[{"content":"In scenarios where resources must be released at a specific time, classes can implement the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface, which contains the <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> method that performs resource management and cleanup tasks.","pos":[0,269],"source":"In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method that performs resource management and cleanup tasks."},{"content":"Classes that implement <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.","pos":[270,444],"source":" Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object."},{"content":"The garbage collector does not, by default, call the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method; however, implementations of the <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method can call methods in the <ph id=\"ph3\">&lt;xref:System.GC&gt;</ph> class to customize the finalization behavior of the garbage collector.","pos":[445,730],"source":" The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector."}]}]},{"pos":[3940,4096],"content":"For more information on object finalization and the dispose pattern, see <bpt id=\"p1\">[</bpt>Cleaning Up Unmanaged Resources<ept id=\"p1\">](~/docs/standard/garbage-collection/unmanaged.md)</ept>.","source":"For more information on object finalization and the dispose pattern, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md)."},{"pos":[4135,4163],"content":"Object aging and generations","linkify":"Object aging and generations","nodes":[{"content":"Object aging and generations","pos":[0,28]}]},{"pos":[4167,4901],"content":"The garbage collector in the common language runtime supports object aging using generations. A generation is a unit of measure of the relative age of objects in memory. The generation number, or age, of an object indicates the generation to which an object belongs. Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle. Objects in the most recent generation are in generation 0. This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2. You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.","nodes":[{"content":"The garbage collector in the common language runtime supports object aging using generations. A generation is a unit of measure of the relative age of objects in memory. The generation number, or age, of an object indicates the generation to which an object belongs. Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle. Objects in the most recent generation are in generation 0. This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2. You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.","pos":[0,734],"nodes":[{"content":"The garbage collector in the common language runtime supports object aging using generations.","pos":[0,93]},{"content":"A generation is a unit of measure of the relative age of objects in memory.","pos":[94,169]},{"content":"The generation number, or age, of an object indicates the generation to which an object belongs.","pos":[170,266]},{"content":"Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.","pos":[267,421]},{"content":"Objects in the most recent generation are in generation 0.","pos":[422,480]},{"content":"This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.","pos":[481,589]},{"content":"You can retrieve the value of the <ph id=\"ph1\">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum generation number supported by the system.","pos":[590,734],"source":" You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system."}]}]},{"pos":[4908,5233],"content":"Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations. Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected.","nodes":[{"content":"Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.","pos":[0,167]},{"content":"Overloads of the <ph id=\"ph1\">&lt;xref:System.GC.Collect%2A&gt;</ph> method that include a <ph id=\"ph2\">`generation`</ph> parameter allow you to specify the oldest generation to be garbage collected.","pos":[168,325],"source":" Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected."}]},{"pos":[5271,5301],"content":"Disallowing garbage collection","linkify":"Disallowing garbage collection","nodes":[{"content":"Disallowing garbage collection","pos":[0,30]}]},{"pos":[5305,5839],"content":"Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance. The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector. If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.","nodes":[{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v46](~/includes/net-v46-md.md)]</ph>, the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.","pos":[0,250],"source":"Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance."},{"content":"The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.","pos":[251,397]},{"content":"If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.","pos":[398,534]}]},{"pos":[5846,6088],"content":"You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>. You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.","nodes":[{"content":"You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>. You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.","pos":[0,242],"nodes":[{"content":"You define the beginning of the critical path of the no GC region by calling one of the overloads of the <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph>.","pos":[0,144],"source":"You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>."},{"content":"You specify the end of its critical path by calling the <ph id=\"ph1\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.","pos":[145,242],"source":" You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method."}]}]},{"pos":[6095,6615],"content":"You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.","nodes":[{"content":"You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.","pos":[0,520],"nodes":[{"content":"You cannot nest calls to the <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id=\"ph2\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.","pos":[0,203],"source":"You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode."},{"content":"In other words, you should not call <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id=\"ph2\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id=\"ph3\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.","pos":[204,520],"source":" In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded."}]}]}],"pos":[1746,8412],"yaml":true,"extradata":"MT"},{"content":"Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.","nodes":[{"pos":[0,131],"content":"Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.","nodes":[{"content":"Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.","pos":[0,131]}]}],"pos":[10950,11082],"yaml":true},{"content":"In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated. If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection. The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.  \n  \n In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method. Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.  \n  \n In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.  \n  \n> [!CAUTION]\n>  You must ensure that you remove exactly the amount of pressure you add. Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.","nodes":[{"pos":[0,433],"content":"In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated. If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection. The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.","nodes":[{"content":"In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated. If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection. The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.","pos":[0,433],"nodes":[{"content":"In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.","pos":[0,120]},{"content":"If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.","pos":[121,318]},{"content":"The <ph id=\"ph1\">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method informs the runtime of this additional pressure on system memory.","pos":[319,433],"source":" The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory."}]}]},{"pos":[440,762],"content":"In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method. Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.","nodes":[{"content":"In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the <ph id=\"ph1\">`Dispose`</ph> or <ph id=\"ph2\">`Finalize`</ph> method.","pos":[0,148],"source":"In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method."},{"content":"Call the <ph id=\"ph1\">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method after allocating the unmanaged memory, and call the <ph id=\"ph2\">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method after releasing it.","pos":[149,322],"source":" Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it."}]},{"pos":[769,1067],"content":"In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.","nodes":[{"content":"In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <ph id=\"ph1\">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> methods to communicate these incremental changes to the runtime.","pos":[0,298],"source":"In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime."}]},{"pos":[1075,1279],"content":"[!CAUTION]\n You must ensure that you remove exactly the amount of pressure you add. Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.","leadings":["","> "],"nodes":[{"content":" You must ensure that you remove exactly the amount of pressure you add. Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.","pos":[11,202],"nodes":[{"content":"You must ensure that you remove exactly the amount of pressure you add.","pos":[1,72]},{"content":"Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.","pos":[73,191]}]}]}],"pos":[11093,12382],"yaml":true,"extradata":"MT"},{"content":"The incremental amount of unmanaged memory that has been allocated.","nodes":[{"pos":[0,67],"content":"The incremental amount of unmanaged memory that has been allocated.","nodes":[{"content":"The incremental amount of unmanaged memory that has been allocated.","pos":[0,67]}]}],"pos":[12601,12669],"yaml":true},{"content":"<code>bytesAllocated</code> is less than or equal to 0.  \n  \n -or-  \n  \n On a 32-bit computer, <code>bytesAllocated</code> is larger than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,55],"content":"<ph id=\"ph1\">&lt;code&gt;bytesAllocated&lt;/code&gt;</ph> is less than or equal to 0.","source":"<code>bytesAllocated</code> is less than or equal to 0."},{"pos":[62,66],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[73,181],"content":"On a 32-bit computer, <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytesAllocated</ph><ept id=\"p1\">&lt;/code&gt;</ept> is larger than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"On a 32-bit computer, <code>bytesAllocated</code> is larger than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[12838,13028],"yaml":true},{"content":"Cancels the registration of a garbage collection notification.","nodes":[{"pos":[0,62],"content":"Cancels the registration of a garbage collection notification.","nodes":[{"content":"Cancels the registration of a garbage collection notification.","pos":[0,62]}]}],"pos":[14538,14601],"yaml":true},{"content":"This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.","nodes":[{"pos":[0,309],"content":"This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.","nodes":[{"content":"This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.","pos":[0,309],"nodes":[{"content":"This method cancels a garbage collection notification that was registered by using the <ph id=\"ph1\">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.","pos":[0,144],"source":"This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method."},{"content":"You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <ph id=\"ph1\">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.","pos":[145,309],"source":" You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method."}]}]}],"pos":[14612,14922],"yaml":true,"extradata":"MT"},{"content":"This member is not available when concurrent garbage collection is enabled. See the [<gcConcurrent>](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.","nodes":[{"pos":[0,261],"content":"This member is not available when concurrent garbage collection is enabled. See the [<gcConcurrent>](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.","nodes":[{"content":"This member is not available when concurrent garbage collection is enabled.","pos":[0,75]},{"content":"See the <bpt id=\"p1\">[</bpt><ph id=\"ph1\">&lt;gcConcurrent&gt;</ph><ept id=\"p1\">](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md)</ept> runtime setting for information about how to disable concurrent garbage collection.","pos":[76,261],"source":" See the [<gcConcurrent>](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection."}]}],"pos":[15800,16062],"yaml":true},{"content":"Forces an immediate garbage collection of all generations.","nodes":[{"pos":[0,58],"content":"Forces an immediate garbage collection of all generations.","nodes":[{"content":"Forces an immediate garbage collection of all generations.","pos":[0,58]}]}],"pos":[17126,17185],"yaml":true},{"content":"Use this method to try to reclaim all memory that is inaccessible. It performs a blocking garbage collection of all generations.  \n  \n All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected. Use this method to force the system to try to reclaim the maximum amount of available memory.  \n  \n Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], you can compact the large object heap (LOH) by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName> before calling the <xref:System.GC.Collect%2A> method, as the following example illustrates.  \n  \n [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]\n [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]","nodes":[{"pos":[0,128],"content":"Use this method to try to reclaim all memory that is inaccessible. It performs a blocking garbage collection of all generations.","nodes":[{"content":"Use this method to try to reclaim all memory that is inaccessible. It performs a blocking garbage collection of all generations.","pos":[0,128],"nodes":[{"content":"Use this method to try to reclaim all memory that is inaccessible.","pos":[0,66]},{"content":"It performs a blocking garbage collection of all generations.","pos":[67,128]}]}]},{"pos":[135,393],"content":"All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected. Use this method to force the system to try to reclaim the maximum amount of available memory.","nodes":[{"content":"All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected. Use this method to force the system to try to reclaim the maximum amount of available memory.","pos":[0,258],"nodes":[{"content":"All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.","pos":[0,164]},{"content":"Use this method to force the system to try to reclaim the maximum amount of available memory.","pos":[165,258]}]}]},{"pos":[400,800],"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v451](~/includes/net-v451-md.md)]</ph>, you can compact the large object heap (LOH) by setting the <ph id=\"ph2\">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName&gt;</ph> property to <ph id=\"ph3\">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName&gt;</ph> before calling the <ph id=\"ph4\">&lt;xref:System.GC.Collect%2A&gt;</ph> method, as the following example illustrates.","source":"Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], you can compact the large object heap (LOH) by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName> before calling the <xref:System.GC.Collect%2A> method, as the following example illustrates."},{"pos":[807,1102],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Runtime.GCSettings#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Runtime.GCSettings#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]\n [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]"}],"pos":[17196,18308],"yaml":true,"extradata":"MT"},{"content":"Forces an immediate garbage collection from generation 0 through a specified generation.","nodes":[{"pos":[0,88],"content":"Forces an immediate garbage collection from generation 0 through a specified generation.","nodes":[{"content":"Forces an immediate garbage collection from generation 0 through a specified generation.","pos":[0,88]}]}],"pos":[20543,20632],"yaml":true},{"content":"Use this method to try to reclaim memory that is inaccessible. However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.  \n  \n If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation. If object aging is not implemented, the garbage collector considers all objects during the garbage collection.  \n  \n Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of the `generation` parameter.  \n  \n To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters. To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=fullName> method overload.","nodes":[{"pos":[0,179],"content":"Use this method to try to reclaim memory that is inaccessible. However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.","nodes":[{"content":"Use this method to try to reclaim memory that is inaccessible. However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.","pos":[0,179],"nodes":[{"content":"Use this method to try to reclaim memory that is inaccessible.","pos":[0,62]},{"content":"However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.","pos":[63,179]}]}]},{"pos":[186,446],"content":"If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation. If object aging is not implemented, the garbage collector considers all objects during the garbage collection.","nodes":[{"content":"If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation. If object aging is not implemented, the garbage collector considers all objects during the garbage collection.","pos":[0,260],"nodes":[{"content":"If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.","pos":[0,149]},{"content":"If object aging is not implemented, the garbage collector considers all objects during the garbage collection.","pos":[150,260]}]}]},{"pos":[453,571],"content":"Use the <ph id=\"ph1\">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum valid value of the <ph id=\"ph2\">`generation`</ph> parameter.","source":"Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of the `generation` parameter."},{"pos":[578,933],"content":"To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters. To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=fullName> method overload.","nodes":[{"content":"To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters. To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=fullName> method overload.","pos":[0,355],"nodes":[{"content":"To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.","pos":[0,139]},{"content":"To have the garbage collector reclaim objects based on a <ph id=\"ph1\">&lt;xref:System.GCCollectionMode&gt;</ph> setting, use the <ph id=\"ph2\">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=fullName&gt;</ph> method overload.","pos":[140,355],"source":" To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=fullName> method overload."}]}]}],"pos":[20643,21585],"yaml":true,"extradata":"MT"},{"content":"The number of the oldest generation to be garbage collected.","nodes":[{"pos":[0,60],"content":"The number of the oldest generation to be garbage collected.","nodes":[{"content":"The number of the oldest generation to be garbage collected.","pos":[0,60]}]}],"pos":[22458,22519],"yaml":true},{"content":"<code>generation</code> is not valid.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;generation&lt;/code&gt;</ph> is not valid.","source":"<code>generation</code> is not valid."}],"pos":[22678,22716],"yaml":true},{"content":"Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <xref href=\"System.GCCollectionMode\"></xref> value.","nodes":[{"pos":[0,154],"content":"Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id=\"ph1\">&lt;xref href=\"System.GCCollectionMode\"&gt;&lt;/xref&gt;</ph> value.","source":"Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <xref href=\"System.GCCollectionMode\"></xref> value."}],"pos":[24241,24396],"yaml":true},{"content":"Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects. Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.  \n  \n To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property.  \n  \n The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter. Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`.  \n  \n To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.  \n  \n To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=fullName> method overload. When you specify the maximum generation, all objects are collected.","nodes":[{"pos":[0,246],"content":"Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects. Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.","nodes":[{"content":"Use the <ph id=\"ph1\">`mode`</ph> parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.","pos":[0,138],"source":"Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects."},{"content":"Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.","pos":[139,246]}]},{"pos":[253,413],"content":"To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property.","nodes":[{"content":"To adjust the intrusiveness of garbage collection during critical periods in your application, set the <ph id=\"ph1\">&lt;xref:System.Runtime.GCSettings.LatencyMode%2A&gt;</ph> property.","pos":[0,160],"source":"To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property."}]},{"pos":[420,649],"content":"The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter. Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`.","nodes":[{"content":"The garbage collector does not collect objects with a generation number higher than specified by the <ph id=\"ph1\">`generation`</ph> parameter.","pos":[0,124],"source":"The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property to determine the maximum valid value of <ph id=\"ph2\">`generation`</ph>.","pos":[125,229],"source":" Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`."}]},{"pos":[656,795],"content":"To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.","nodes":[{"content":"To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.","pos":[0,139]}]},{"pos":[802,1049],"content":"To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=fullName> method overload. When you specify the maximum generation, all objects are collected.","nodes":[{"content":"To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=fullName> method overload. When you specify the maximum generation, all objects are collected.","pos":[0,247],"nodes":[{"content":"To have the garbage collector reclaim objects up to a specified generation of objects, use the <ph id=\"ph1\">&lt;xref:System.GC.Collect%28System.Int32%29?displayProperty=fullName&gt;</ph> method overload.","pos":[0,179],"source":"To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=fullName> method overload."},{"content":"When you specify the maximum generation, all objects are collected.","pos":[180,247]}]}]}],"pos":[24407,25467],"yaml":true,"extradata":"MT"},{"content":"The number of the oldest generation to be garbage collected.","nodes":[{"pos":[0,60],"content":"The number of the oldest generation to be garbage collected.","nodes":[{"content":"The number of the oldest generation to be garbage collected.","pos":[0,60]}]}],"pos":[26077,26138],"yaml":true},{"content":"An enumeration value that specifies whether the garbage collection is forced (<xref href=\"System.GCCollectionMode.Default\"></xref> or <xref href=\"System.GCCollectionMode.Forced\"></xref>) or optimized (<xref href=\"System.GCCollectionMode.Optimized\"></xref>).","nodes":[{"pos":[0,257],"content":"An enumeration value that specifies whether the garbage collection is forced (<ph id=\"ph1\">&lt;xref href=\"System.GCCollectionMode.Default\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.GCCollectionMode.Forced\"&gt;&lt;/xref&gt;</ph>) or optimized (<ph id=\"ph3\">&lt;xref href=\"System.GCCollectionMode.Optimized\"&gt;&lt;/xref&gt;</ph>).","source":"An enumeration value that specifies whether the garbage collection is forced (<xref href=\"System.GCCollectionMode.Default\"></xref> or <xref href=\"System.GCCollectionMode.Forced\"></xref>) or optimized (<xref href=\"System.GCCollectionMode.Optimized\"></xref>)."}],"pos":[26208,26466],"yaml":true},{"content":"<code>generation</code> is not valid.  \n  \n -or-  \n  \n <code>mode</code> is not one of the <xref href=\"System.GCCollectionMode\"></xref> values.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;generation&lt;/code&gt;</ph> is not valid.","source":"<code>generation</code> is not valid."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,143],"content":"<ph id=\"ph1\">&lt;code&gt;mode&lt;/code&gt;</ph> is not one of the <ph id=\"ph2\">&lt;xref href=\"System.GCCollectionMode\"&gt;&lt;/xref&gt;</ph> values.","source":"<code>mode</code> is not one of the <xref href=\"System.GCCollectionMode\"></xref> values."}],"pos":[26625,26777],"yaml":true},{"content":"Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <xref href=\"System.GCCollectionMode\"></xref> value, with a value specifying whether the collection should be blocking.","nodes":[{"pos":[0,221],"content":"Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id=\"ph1\">&lt;xref href=\"System.GCCollectionMode\"&gt;&lt;/xref&gt;</ph> value, with a value specifying whether the collection should be blocking.","source":"Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <xref href=\"System.GCCollectionMode\"></xref> value, with a value specifying whether the collection should be blocking."}],"pos":[28391,28613],"yaml":true},{"content":"The following table summarizes the interaction of the `mode` and `blocking` parameters:  \n  \n|`mode`|`blocking` is `true`|`blocking` is `false`|  \n|-|-|-|  \n|<xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default>|A blocking collection is performed as soon as possible. If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished. If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.|A collection is performed as soon as possible. The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed. If a background collection is already in progress, the method returns immediately.|  \n|<xref:System.GCCollectionMode.Optimized>|A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter. The garbage collector tries to provide optimal performance.|A collection may be performed, depending on the state of the garbage collector. The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed. The garbage collector tries to provide optimal performance. If a background collection is already in progress, the method returns immediately.|  \n  \n If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName> before calling the <xref:System.GC.Collect%2A> method.","nodes":[{"pos":[0,87],"content":"The following table summarizes the interaction of the <ph id=\"ph1\">`mode`</ph> and <ph id=\"ph2\">`blocking`</ph> parameters:","source":"The following table summarizes the interaction of the `mode` and `blocking` parameters:"},{"pos":[101,121],"content":"<ph id=\"ph1\">`blocking`</ph> is <ph id=\"ph2\">`true`</ph>","source":"`blocking` is `true`"},{"pos":[122,143],"content":"<ph id=\"ph1\">`blocking`</ph> is <ph id=\"ph2\">`false`</ph>","source":"`blocking` is `false`"},{"pos":[158,237],"content":"<xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default>","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.GCCollectionMode.Forced&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.GCCollectionMode.Default&gt;</ph>","pos":[0,79],"source":"<xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default>"}]},{"pos":[238,738],"content":"A blocking collection is performed as soon as possible. If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished. If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.","nodes":[{"content":"A blocking collection is performed as soon as possible.","pos":[0,55]},{"content":"If a background collection is in progress and <ph id=\"ph1\">`generation`</ph> is 0 or 1, the <ph id=\"ph2\">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method immediately triggers a blocking collection and returns when the collection is finished.","pos":[56,310],"source":" If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished."},{"content":"If a background collection is in progress and <ph id=\"ph1\">`generation`</ph> is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.","pos":[311,500],"source":" If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns."}]},{"pos":[739,1105],"content":"A collection is performed as soon as possible. The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed. If a background collection is already in progress, the method returns immediately.","nodes":[{"content":"A collection is performed as soon as possible. The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed. If a background collection is already in progress, the method returns immediately.","pos":[0,366],"nodes":[{"content":"A collection is performed as soon as possible.","pos":[0,46]},{"content":"The <ph id=\"ph1\">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.","pos":[47,283],"source":" The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed."},{"content":"If a background collection is already in progress, the method returns immediately.","pos":[284,366]}]}]},{"pos":[1110,1150],"content":"<xref:System.GCCollectionMode.Optimized>","nodes":[]},{"pos":[1151,1330],"content":"A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter. The garbage collector tries to provide optimal performance.","nodes":[{"content":"A blocking collection may be performed, depending on the state of the garbage collector and the <ph id=\"ph1\">`generation`</ph> parameter.","pos":[0,119],"source":"A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter."},{"content":"The garbage collector tries to provide optimal performance.","pos":[120,179]}]},{"pos":[1331,1790],"content":"A collection may be performed, depending on the state of the garbage collector. The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed. The garbage collector tries to provide optimal performance. If a background collection is already in progress, the method returns immediately.","nodes":[{"content":"A collection may be performed, depending on the state of the garbage collector. The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed. The garbage collector tries to provide optimal performance. If a background collection is already in progress, the method returns immediately.","pos":[0,459],"nodes":[{"content":"A collection may be performed, depending on the state of the garbage collector.","pos":[0,79]},{"content":"The <ph id=\"ph1\">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.","pos":[80,316],"source":" The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed."},{"content":"The garbage collector tries to provide optimal performance.","pos":[317,376]},{"content":"If a background collection is already in progress, the method returns immediately.","pos":[377,459]}]}]},{"pos":[1798,2247],"content":"If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName> before calling the <xref:System.GC.Collect%2A> method.","nodes":[{"content":"If a call to the <ph id=\"ph1\">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29&gt;</ph> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <ph id=\"ph2\">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName&gt;</ph> property to <ph id=\"ph3\">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName&gt;</ph> before calling the <ph id=\"ph4\">&lt;xref:System.GC.Collect%2A&gt;</ph> method.","pos":[0,449],"source":"If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName> before calling the <xref:System.GC.Collect%2A> method."}]}],"pos":[28624,30881],"yaml":true,"extradata":"MT"},{"content":"The number of the oldest generation to be garbage collected.","nodes":[{"pos":[0,60],"content":"The number of the oldest generation to be garbage collected.","nodes":[{"content":"The number of the oldest generation to be garbage collected.","pos":[0,60]}]}],"pos":[31068,31129],"yaml":true},{"content":"An enumeration value that specifies whether the garbage collection is forced (<xref href=\"System.GCCollectionMode.Default\"></xref> or <xref href=\"System.GCCollectionMode.Forced\"></xref>) or optimized (<xref href=\"System.GCCollectionMode.Optimized\"></xref>).","nodes":[{"pos":[0,257],"content":"An enumeration value that specifies whether the garbage collection is forced (<ph id=\"ph1\">&lt;xref href=\"System.GCCollectionMode.Default\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.GCCollectionMode.Forced\"&gt;&lt;/xref&gt;</ph>) or optimized (<ph id=\"ph3\">&lt;xref href=\"System.GCCollectionMode.Optimized\"&gt;&lt;/xref&gt;</ph>).","source":"An enumeration value that specifies whether the garbage collection is forced (<xref href=\"System.GCCollectionMode.Default\"></xref> or <xref href=\"System.GCCollectionMode.Forced\"></xref>) or optimized (<xref href=\"System.GCCollectionMode.Optimized\"></xref>)."}],"pos":[31199,31457],"yaml":true},{"content":"`true` to perform a blocking garbage collection; `false` to perform a background garbage collection where possible.","nodes":[{"pos":[0,115],"content":"<ph id=\"ph1\">`true`</ph> to perform a blocking garbage collection; <ph id=\"ph2\">`false`</ph> to perform a background garbage collection where possible.","source":"`true` to perform a blocking garbage collection; `false` to perform a background garbage collection where possible."}],"pos":[31522,31640],"yaml":true},{"content":"<code>generation</code> is not valid.  \n  \n -or-  \n  \n <code>mode</code> is not one of the <xref href=\"System.GCCollectionMode\"></xref> values.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;generation&lt;/code&gt;</ph> is not valid.","source":"<code>generation</code> is not valid."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,143],"content":"<ph id=\"ph1\">&lt;code&gt;mode&lt;/code&gt;</ph> is not one of the <ph id=\"ph2\">&lt;xref href=\"System.GCCollectionMode\"&gt;&lt;/xref&gt;</ph> values.","source":"<code>mode</code> is not one of the <xref href=\"System.GCCollectionMode\"></xref> values."}],"pos":[31799,31951],"yaml":true},{"content":"Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <xref href=\"System.GCCollectionMode\"></xref> value, with values that specify whether the collection should be blocking and compacting.","nodes":[{"pos":[0,237],"content":"Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <ph id=\"ph1\">&lt;xref href=\"System.GCCollectionMode\"&gt;&lt;/xref&gt;</ph> value, with values that specify whether the collection should be blocking and compacting.","source":"Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <xref href=\"System.GCCollectionMode\"></xref> value, with values that specify whether the collection should be blocking and compacting."}],"pos":[33637,33875],"yaml":true},{"content":"If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection. If `compacting` is `true`, it performs a blocking garbage collection.  \n  \n If `compacting` is `true`, the runtime compacts the small object heap (SOH). The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName>. Note that this includes all blocking garbage collections, not just full blocking garbage collections.  \n  \n You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.  \n  \n [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]\n [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  \n  \n Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection. Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName> ensures that both the LOH and SOH are compacted.","nodes":[{"pos":[0,176],"content":"If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection. If `compacting` is `true`, it performs a blocking garbage collection.","nodes":[{"content":"If <ph id=\"ph1\">`blocking`</ph> is <ph id=\"ph2\">`false`</ph>, the GC decides whether to perform a background or a blocking garbage collection.","pos":[0,106],"source":"If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection."},{"content":"If <ph id=\"ph1\">`compacting`</ph> is <ph id=\"ph2\">`true`</ph>, it performs a blocking garbage collection.","pos":[107,176],"source":" If `compacting` is `true`, it performs a blocking garbage collection."}]},{"pos":[183,607],"content":"If `compacting` is `true`, the runtime compacts the small object heap (SOH). The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName>. Note that this includes all blocking garbage collections, not just full blocking garbage collections.","nodes":[{"content":"If <ph id=\"ph1\">`compacting`</ph> is <ph id=\"ph2\">`true`</ph>, the runtime compacts the small object heap (SOH).","pos":[0,76],"source":"If `compacting` is `true`, the runtime compacts the small object heap (SOH)."},{"content":"The large object heap (LOH) is not compacted unless the <ph id=\"ph1\">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName&gt;</ph> property is set to <ph id=\"ph2\">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName&gt;</ph>.","pos":[77,322],"source":" The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName>."},{"content":"Note that this includes all blocking garbage collections, not just full blocking garbage collections.","pos":[323,424]}]},{"pos":[614,842],"content":"You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.","nodes":[{"content":"You can call the <ph id=\"ph1\">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.","pos":[0,228],"source":"You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates."}]},{"pos":[849,1092],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.GC.Collect#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.GC.Collect#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]\n [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]"},{"pos":[1099,1448],"content":"Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection. Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName> ensures that both the LOH and SOH are compacted.","nodes":[{"content":"Specifying <ph id=\"ph1\">`true`</ph> for the <ph id=\"ph2\">`compacting`</ph> argument guarantees a compacting, full blocking garbage collection.","pos":[0,106],"source":"Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection."},{"content":"Setting the <ph id=\"ph1\">&lt;xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName&gt;</ph> property to <ph id=\"ph2\">&lt;xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName&gt;</ph> ensures that both the LOH and SOH are compacted.","pos":[107,349],"source":" Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName> ensures that both the LOH and SOH are compacted."}]}],"pos":[33886,35346],"yaml":true,"extradata":"MT"},{"content":"The number of the oldest generation to be garbage collected.","nodes":[{"pos":[0,60],"content":"The number of the oldest generation to be garbage collected.","nodes":[{"content":"The number of the oldest generation to be garbage collected.","pos":[0,60]}]}],"pos":[35550,35611],"yaml":true},{"content":"An enumeration value that specifies whether the garbage collection is forced (<xref href=\"System.GCCollectionMode.Default\"></xref> or <xref href=\"System.GCCollectionMode.Forced\"></xref>) or optimized (<xref href=\"System.GCCollectionMode.Optimized\"></xref>).","nodes":[{"pos":[0,257],"content":"An enumeration value that specifies whether the garbage collection is forced (<ph id=\"ph1\">&lt;xref href=\"System.GCCollectionMode.Default\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.GCCollectionMode.Forced\"&gt;&lt;/xref&gt;</ph>) or optimized (<ph id=\"ph3\">&lt;xref href=\"System.GCCollectionMode.Optimized\"&gt;&lt;/xref&gt;</ph>).","source":"An enumeration value that specifies whether the garbage collection is forced (<xref href=\"System.GCCollectionMode.Default\"></xref> or <xref href=\"System.GCCollectionMode.Forced\"></xref>) or optimized (<xref href=\"System.GCCollectionMode.Optimized\"></xref>)."}],"pos":[35681,35939],"yaml":true},{"content":"`true` to perform a blocking garbage collection; `false` to perform a background garbage collection where possible.","nodes":[{"pos":[0,115],"content":"<ph id=\"ph1\">`true`</ph> to perform a blocking garbage collection; <ph id=\"ph2\">`false`</ph> to perform a background garbage collection where possible.","source":"`true` to perform a blocking garbage collection; `false` to perform a background garbage collection where possible."}],"pos":[36004,36122],"yaml":true},{"content":"`true` to compact the small object heap; `false` to sweep only.","nodes":[{"pos":[0,63],"content":"<ph id=\"ph1\">`true`</ph> to compact the small object heap; <ph id=\"ph2\">`false`</ph> to sweep only.","source":"`true` to compact the small object heap; `false` to sweep only."}],"pos":[36189,36255],"yaml":true},{"content":"Returns the number of times garbage collection has occurred for the specified generation of objects.","nodes":[{"pos":[0,100],"content":"Returns the number of times garbage collection has occurred for the specified generation of objects.","nodes":[{"content":"Returns the number of times garbage collection has occurred for the specified generation of objects.","pos":[0,100]}]}],"pos":[37289,37390],"yaml":true},{"content":"If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method. Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently. Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>. The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value. If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.","nodes":[{"pos":[0,698],"content":"If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method. Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently. Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>. The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value. If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.","nodes":[{"content":"If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method. Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently. Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>. The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value. If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.","pos":[0,698],"nodes":[{"content":"If you implement your own resource management, you might need to force garbage collection periodically by calling the <ph id=\"ph1\">&lt;xref:System.GC.Collect%2A&gt;</ph> method.","pos":[0,153],"source":"If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method."},{"content":"Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.","pos":[154,291]},{"content":"Save the value returned by <ph id=\"ph1\">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> immediately after calling <ph id=\"ph2\">&lt;xref:System.GC.Collect%2A&gt;</ph>.","pos":[292,409],"source":" Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>."},{"content":"The next time you need to call <ph id=\"ph1\">&lt;xref:System.GC.Collect%2A&gt;</ph>, compare the current value returned by <ph id=\"ph2\">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> to the saved value.","pos":[410,563],"source":" The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value."},{"content":"If the two values are equal, no collection has occurred in the interim and it is reasonable to call <ph id=\"ph1\">&lt;xref:System.GC.Collect%2A&gt;</ph> again.","pos":[564,698],"source":" If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again."}]}]}],"pos":[37401,38100],"yaml":true,"extradata":"MT"},{"content":"The generation of objects for which the garbage collection count is to be determined.","nodes":[{"pos":[0,85],"content":"The generation of objects for which the garbage collection count is to be determined.","nodes":[{"content":"The generation of objects for which the garbage collection count is to be determined.","pos":[0,85]}]}],"pos":[38256,38342],"yaml":true},{"content":"The number of times garbage collection has occurred for the specified generation since the process was started.","nodes":[{"pos":[0,111],"content":"The number of times garbage collection has occurred for the specified generation since the process was started.","nodes":[{"content":"The number of times garbage collection has occurred for the specified generation since the process was started.","pos":[0,111]}]}],"pos":[38398,38510],"yaml":true},{"content":"<code>generation</code> is less than 0.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;generation&lt;/code&gt;</ph> is less than 0.","source":"<code>generation</code> is less than 0."}],"pos":[38677,38717],"yaml":true},{"content":"Ends the no GC region latency mode.","nodes":[{"pos":[0,35],"content":"Ends the no GC region latency mode.","nodes":[{"content":"Ends the no GC region latency mode.","pos":[0,35]}]}],"pos":[40112,40148],"yaml":true},{"content":"The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode. This occurs under any of the following conditions:  \n  \n-   The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously.  \n  \n-   The call to the <xref:System.GC.TryStartNoGCRegion%2A> method returned `false`.  \n  \n-   The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception.  \n  \n You can prevent an exception for any of these reasons by using code such as the following:  \n  \n [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]\n [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]","nodes":[{"pos":[0,207],"content":"The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode. This occurs under any of the following conditions:","nodes":[{"content":"The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode. This occurs under any of the following conditions:","pos":[0,207],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method throws an <ph id=\"ph2\">&lt;xref:System.InvalidOperationException&gt;</ph> if the garbage collector is not in no GC region latency mode.","pos":[0,156],"source":"The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode."},{"content":"This occurs under any of the following conditions:","pos":[157,207]}]}]},{"pos":[217,293],"content":"The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method was not called previously.","pos":[0,76],"source":"The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously."}]},{"pos":[303,382],"content":"The call to the <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method returned <ph id=\"ph2\">`false`</ph>.","source":"The call to the <xref:System.GC.TryStartNoGCRegion%2A> method returned `false`."},{"pos":[392,473],"content":"The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception.","nodes":[{"content":"The call to the <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method threw an exception.","pos":[0,81],"source":"The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception."}]},{"pos":[480,570],"content":"You can prevent an exception for any of these reasons by using code such as the following:","nodes":[{"content":"You can prevent an exception for any of these reasons by using code such as the following:","pos":[0,90]}]},{"pos":[577,856],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.GC.EndNoGCRegion#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.GC.EndNoGCRegion#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)</ept><ept id=\"p3\">]</ept>","leadings":[""," "],"source":"[!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]\n[!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]"}],"pos":[40159,41029],"yaml":true,"extradata":"MT"},{"content":"The garbage collector is not in no GC region latency mode.  \n  \n -or-  \n  \n The no GC region latency mode was ended previously because a garbage collection was induced.  \n  \n -or-  \n  \n A memory allocation exceeded the amount specified in the call to the <xref href=\"System.GC.TryStartNoGCRegion(System.Int64)\"></xref> method.","nodes":[{"pos":[0,58],"content":"The garbage collector is not in no GC region latency mode.","nodes":[{"content":"The garbage collector is not in no GC region latency mode.","pos":[0,58]}]},{"pos":[65,69],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[76,168],"content":"The no GC region latency mode was ended previously because a garbage collection was induced.","nodes":[{"content":"The no GC region latency mode was ended previously because a garbage collection was induced.","pos":[0,92]}]},{"pos":[175,179],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[186,326],"content":"A memory allocation exceeded the amount specified in the call to the <ph id=\"ph1\">&lt;xref href=\"System.GC.TryStartNoGCRegion(System.Int64)\"&gt;&lt;/xref&gt;</ph> method.","source":"A memory allocation exceeded the amount specified in the call to the <xref href=\"System.GC.TryStartNoGCRegion(System.Int64)\"></xref> method."}],"pos":[41320,41659],"yaml":true},{"content":"Returns the current generation number of the specified object.","nodes":[{"pos":[0,62],"content":"Returns the current generation number of the specified object.","nodes":[{"content":"Returns the current generation number of the specified object.","pos":[0,62]}]}],"pos":[43463,43526],"yaml":true},{"content":"Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation. For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.","nodes":[{"pos":[0,333],"content":"Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation. For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.","nodes":[{"content":"Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation. For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.","pos":[0,333],"nodes":[{"content":"Use this method to determine the age of an object, and then use that information with the <ph id=\"ph1\">&lt;xref:System.GC.Collect%2A&gt;</ph> method to force the garbage collector to collect objects in the same generation.","pos":[0,198],"source":"Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation."},{"content":"For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.","pos":[199,333]}]}]}],"pos":[43537,43871],"yaml":true,"extradata":"MT"},{"content":"The object that generation information is retrieved for.","nodes":[{"pos":[0,56],"content":"The object that generation information is retrieved for.","nodes":[{"content":"The object that generation information is retrieved for.","pos":[0,56]}]}],"pos":[44731,44788],"yaml":true},{"content":"The current generation number of <code>obj</code>.","nodes":[{"pos":[0,50],"content":"The current generation number of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The current generation number of <code>obj</code>."}],"pos":[44844,44895],"yaml":true},{"content":"Returns the current generation number of the target of a specified weak reference.","nodes":[{"pos":[0,82],"content":"Returns the current generation number of the target of a specified weak reference.","nodes":[{"content":"Returns the current generation number of the target of a specified weak reference.","pos":[0,82]}]}],"pos":[46329,46412],"yaml":true},{"content":"A <xref href=\"System.WeakReference\"></xref> that refers to the target object whose generation number is to be determined.","nodes":[{"pos":[0,121],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.WeakReference\"&gt;&lt;/xref&gt;</ph> that refers to the target object whose generation number is to be determined.","source":"A <xref href=\"System.WeakReference\"></xref> that refers to the target object whose generation number is to be determined."}],"pos":[47270,47392],"yaml":true},{"content":"The current generation number of the target of <code>wo</code>.","nodes":[{"pos":[0,63],"content":"The current generation number of the target of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">wo</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The current generation number of the target of <code>wo</code>."}],"pos":[47448,47512],"yaml":true},{"content":"Garbage collection has already been performed on <code>wo</code>.","nodes":[{"pos":[0,65],"content":"Garbage collection has already been performed on <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">wo</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"Garbage collection has already been performed on <code>wo</code>."}],"pos":[47657,47723],"yaml":true},{"content":"Retrieves the number of bytes currently thought to be allocated. A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.","nodes":[{"pos":[0,211],"content":"Retrieves the number of bytes currently thought to be allocated. A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.","nodes":[{"content":"Retrieves the number of bytes currently thought to be allocated. A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.","pos":[0,211],"nodes":[{"content":"Retrieves the number of bytes currently thought to be allocated.","pos":[0,64]},{"content":"A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.","pos":[65,211]}]}]}],"pos":[48849,49061],"yaml":true},{"content":"If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects. The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles. The garbage collector does not guarantee that all inaccessible memory is collected.","nodes":[{"pos":[0,433],"content":"If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects. The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles. The garbage collector does not guarantee that all inaccessible memory is collected.","nodes":[{"content":"If the <ph id=\"ph1\">`forceFullCollection`</ph> parameter is <ph id=\"ph2\">`true`</ph>, this method waits a short interval before returning while the system collects garbage and finalizes objects.","pos":[0,158],"source":"If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects."},{"content":"The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.","pos":[159,349]},{"content":"The garbage collector does not guarantee that all inaccessible memory is collected.","pos":[350,433]}]}],"pos":[49072,49506],"yaml":true,"extradata":"MT"},{"content":"`true` to indicate that this method can wait for garbage collection to occur before returning; otherwise, `false`.","nodes":[{"pos":[0,114],"content":"<ph id=\"ph1\">`true`</ph> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to indicate that this method can wait for garbage collection to occur before returning; otherwise, `false`."}],"pos":[50308,50425],"yaml":true},{"content":"A number that is the best available approximation of the number of bytes currently allocated in managed memory.","nodes":[{"pos":[0,111],"content":"A number that is the best available approximation of the number of bytes currently allocated in managed memory.","nodes":[{"content":"A number that is the best available approximation of the number of bytes currently allocated in managed memory.","pos":[0,111]}]}],"pos":[50481,50593],"yaml":true},{"content":"References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.","nodes":[{"pos":[0,161],"content":"References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.","nodes":[{"content":"References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.","pos":[0,161]}]}],"pos":[52065,52227],"yaml":true},{"content":"The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector. A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.  \n  \n This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called. Code this method at the end, not the beginning, of the range of instructions where `obj` must be available.  \n  \n The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.","nodes":[{"pos":[0,403],"content":"The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector. A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.","nodes":[{"content":"The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector. A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.","pos":[0,403],"nodes":[{"content":"The purpose of the <ph id=\"ph1\">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.","pos":[0,183],"source":"The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector."},{"content":"A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.","pos":[184,403]}]}]},{"pos":[410,707],"content":"This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called. Code this method at the end, not the beginning, of the range of instructions where `obj` must be available.","nodes":[{"content":"This method references the <ph id=\"ph1\">`obj`</ph> parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.","pos":[0,189],"source":"This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called."},{"content":"Code this method at the end, not the beginning, of the range of instructions where <ph id=\"ph1\">`obj`</ph> must be available.","pos":[190,297],"source":" Code this method at the end, not the beginning, of the range of instructions where `obj` must be available."}]},{"pos":[714,879],"content":"The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.GC.KeepAlive%2A&gt;</ph> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.","pos":[0,165],"source":"The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter."}]}],"pos":[52238,53124],"yaml":true,"extradata":"MT"},{"content":"The object to reference.","nodes":[{"pos":[0,24],"content":"The object to reference.","nodes":[{"content":"The object to reference.","pos":[0,24]}]}],"pos":[54099,54124],"yaml":true},{"content":"Gets the maximum number of generations that the system currently supports.","nodes":[{"pos":[0,74],"content":"Gets the maximum number of generations that the system currently supports.","nodes":[{"content":"Gets the maximum number of generations that the system currently supports.","pos":[0,74]}]}],"pos":[55565,55640],"yaml":true},{"content":"The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan. The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.  \n  \n The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory. Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.  \n  \n If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero.","nodes":[{"pos":[0,308],"content":"The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan. The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.","nodes":[{"content":"The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan. The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.","pos":[0,308],"nodes":[{"content":"The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.","pos":[0,114]},{"content":"The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <ph id=\"ph1\">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property.","pos":[115,308],"source":" The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property."}]}]},{"pos":[315,631],"content":"The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory. Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.","nodes":[{"content":"The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory. Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.","pos":[0,316],"nodes":[{"content":"The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.","pos":[0,119]},{"content":"Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <ph id=\"ph1\">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property value can grow over time.","pos":[120,316],"source":" Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time."}]}]},{"pos":[638,813],"content":"If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero.","nodes":[{"content":"If object aging is implemented, the <ph id=\"ph1\">&lt;xref:System.GC.MaxGeneration%2A&gt;</ph> property returns the maximum generation number used by the system; otherwise, this property returns zero.","pos":[0,175],"source":"If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero."}]}],"pos":[55651,56471],"yaml":true,"extradata":"MT"},{"content":"A value that ranges from zero to the maximum number of supported generations.","nodes":[{"pos":[0,77],"content":"A value that ranges from zero to the maximum number of supported generations.","nodes":[{"content":"A value that ranges from zero to the maximum number of supported generations.","pos":[0,77]}]}],"pos":[57238,57316],"yaml":true},{"content":"Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.","nodes":[{"pos":[0,155],"content":"Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.","nodes":[{"content":"Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.","pos":[0,155]}]}],"pos":[59029,59185],"yaml":true},{"content":"For each generation, the garbage collector sets a threshold for allocations into that generation. When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation. For example, if generation 2’s threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection. Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).  \n  \n The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs. The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.  \n  \n If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable. In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:  \n  \n-   You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries). As a result, when the garbage collection occurs, it is able to reclaim more memory.  \n  \n-   You monitor for the completion of a full garbage collection so that you can collect some statistics.  For example, you might want to measure the size of the heap at GC completion so that you know the size of live data. (After a full GC, the heap is at its smallest size.)  \n  \n For more information about what represents a full garbage collection, see [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md).  \n  \n When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed. This pattern resembles how the operating system monitors for low memory notifications.  \n  \n Use the following guidelines for specifying the `maxGenerationThreshold` and `largeObjectHeapThreshold` parameters:  \n  \n-   The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.  \n  \n     A larger threshold value provides more opportunities for the runtime to check for an approaching collection. This increases the likelihood that you will be notified. However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.  \n  \n     When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.  \n  \n-   The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.","nodes":[{"pos":[0,769],"content":"For each generation, the garbage collector sets a threshold for allocations into that generation. When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation. For example, if generation 2’s threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection. Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).","nodes":[{"content":"For each generation, the garbage collector sets a threshold for allocations into that generation. When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation. For example, if generation 2’s threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection. Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).","pos":[0,769],"nodes":[{"content":"For each generation, the garbage collector sets a threshold for allocations into that generation.","pos":[0,97]},{"content":"When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.","pos":[98,204]},{"content":"For example, if generation 2’s threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.","pos":[205,502]},{"content":"Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).","pos":[503,769]}]}]},{"pos":[776,1054],"content":"The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs. The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.","nodes":[{"content":"The <ph id=\"ph1\">`maxGenerationThreshold`</ph> and <ph id=\"ph2\">`largeObjectHeapThreshold`</ph> thresholds control how much in advance you are notified before a full garbage collection occurs.","pos":[0,156],"source":"The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs."},{"content":"The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.","pos":[157,278]}]},{"pos":[1061,1563],"content":"If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable. In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:","nodes":[{"content":"If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable. In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:","pos":[0,502],"nodes":[{"content":"If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <ph id=\"ph1\">&lt;xref:System.GC.Collect%2A&gt;</ph> method) when conditions are still favorable.","pos":[0,377],"source":"If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable."},{"content":"In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:","pos":[378,502]}]}]},{"pos":[1573,1840],"content":"You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries). As a result, when the garbage collection occurs, it is able to reclaim more memory.","nodes":[{"content":"You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries). As a result, when the garbage collection occurs, it is able to reclaim more memory.","pos":[0,267],"nodes":[{"content":"You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).","pos":[0,183]},{"content":"As a result, when the garbage collection occurs, it is able to reclaim more memory.","pos":[184,267]}]}]},{"pos":[1850,2121],"content":"You monitor for the completion of a full garbage collection so that you can collect some statistics.  For example, you might want to measure the size of the heap at GC completion so that you know the size of live data. (After a full GC, the heap is at its smallest size.)","nodes":[{"content":"You monitor for the completion of a full garbage collection so that you can collect some statistics.  For example, you might want to measure the size of the heap at GC completion so that you know the size of live data. (After a full GC, the heap is at its smallest size.)","pos":[0,271],"nodes":[{"content":"You monitor for the completion of a full garbage collection so that you can collect some statistics.","pos":[0,100]},{"content":"For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.","pos":[102,218]},{"content":"(After a full GC, the heap is at its smallest size.)","pos":[219,271]}]}]},{"pos":[2128,2290],"content":"For more information about what represents a full garbage collection, see <bpt id=\"p1\">[</bpt>Garbage Collection Notifications<ept id=\"p1\">](~/docs/standard/garbage-collection/notifications.md)</ept>.","source":"For more information about what represents a full garbage collection, see [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md)."},{"pos":[2297,2532],"content":"When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed. This pattern resembles how the operating system monitors for low memory notifications.","nodes":[{"content":"When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed. This pattern resembles how the operating system monitors for low memory notifications.","pos":[0,235],"nodes":[{"content":"When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.","pos":[0,148]},{"content":"This pattern resembles how the operating system monitors for low memory notifications.","pos":[149,235]}]}]},{"pos":[2539,2654],"content":"Use the following guidelines for specifying the <ph id=\"ph1\">`maxGenerationThreshold`</ph> and <ph id=\"ph2\">`largeObjectHeapThreshold`</ph> parameters:","source":"Use the following guidelines for specifying the `maxGenerationThreshold` and `largeObjectHeapThreshold` parameters:"},{"pos":[2664,2785],"content":"The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.","nodes":[{"content":"The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.","pos":[0,121]}]},{"pos":[2796,3103],"content":"A larger threshold value provides more opportunities for the runtime to check for an approaching collection. This increases the likelihood that you will be notified. However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.","nodes":[{"content":"A larger threshold value provides more opportunities for the runtime to check for an approaching collection. This increases the likelihood that you will be notified. However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.","pos":[0,307],"nodes":[{"content":"A larger threshold value provides more opportunities for the runtime to check for an approaching collection.","pos":[0,108]},{"content":"This increases the likelihood that you will be notified.","pos":[109,165]},{"content":"However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.","pos":[166,307]}]}]},{"pos":[3114,3285],"content":"When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.","nodes":[{"content":"When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.","pos":[0,171]}]},{"pos":[3295,3407],"content":"The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.","nodes":[{"content":"The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.","pos":[0,112]}]}],"pos":[59196,62628],"yaml":true,"extradata":"MT"},{"content":"A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.","nodes":[{"pos":[0,127],"content":"A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.","nodes":[{"content":"A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.","pos":[0,127]}]}],"pos":[63564,63692],"yaml":true},{"content":"A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.","nodes":[{"pos":[0,132],"content":"A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.","nodes":[{"content":"A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.","pos":[0,132]}]}],"pos":[63771,63904],"yaml":true},{"content":"<code>maxGenerationThreshold</code> or <code>largeObjectHeapThreshold</code> is not between 1 and 99.","nodes":[{"pos":[0,101],"content":"<ph id=\"ph1\">&lt;code&gt;maxGenerationThreshold&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;largeObjectHeapThreshold&lt;/code&gt;</ph> is not between 1 and 99.","source":"<code>maxGenerationThreshold</code> or <code>largeObjectHeapThreshold</code> is not between 1 and 99."}],"pos":[64085,64187],"yaml":true},{"content":"Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.","nodes":[{"pos":[0,140],"content":"Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.","nodes":[{"content":"Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.","pos":[0,140]}]}],"pos":[65386,65527],"yaml":true},{"content":"In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated. If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection. The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.  \n  \n In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method. Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.  \n  \n In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.  \n  \n> [!CAUTION]\n>  You must ensure that you remove exactly the amount of pressure you add. Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.","nodes":[{"pos":[0,557],"content":"In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated. If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection. The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.","nodes":[{"content":"In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated. If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection. The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.","pos":[0,557],"nodes":[{"content":"In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.","pos":[0,120]},{"content":"If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.","pos":[121,318]},{"content":"The <ph id=\"ph1\">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method informs the runtime of this additional pressure on system memory, and the <ph id=\"ph2\">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method informs the runtime that the additional pressure has been released.","pos":[319,557],"source":" The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released."}]}]},{"pos":[564,886],"content":"In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method. Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.","nodes":[{"content":"In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the <ph id=\"ph1\">`Dispose`</ph> or <ph id=\"ph2\">`Finalize`</ph> method.","pos":[0,148],"source":"In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method."},{"content":"Call the <ph id=\"ph1\">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> method after allocating the unmanaged memory, and call the <ph id=\"ph2\">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> method after releasing it.","pos":[149,322],"source":" Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it."}]},{"pos":[893,1191],"content":"In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.","nodes":[{"content":"In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <ph id=\"ph1\">&lt;xref:System.GC.AddMemoryPressure%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.GC.RemoveMemoryPressure%2A&gt;</ph> methods to communicate these incremental changes to the runtime.","pos":[0,298],"source":"In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime."}]},{"pos":[1199,1403],"content":"[!CAUTION]\n You must ensure that you remove exactly the amount of pressure you add. Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.","leadings":["","> "],"nodes":[{"content":" You must ensure that you remove exactly the amount of pressure you add. Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.","pos":[11,202],"nodes":[{"content":"You must ensure that you remove exactly the amount of pressure you add.","pos":[1,72]},{"content":"Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.","pos":[73,191]}]}]}],"pos":[65538,66951],"yaml":true,"extradata":"MT"},{"content":"The amount of unmanaged memory that has been released.","nodes":[{"pos":[0,54],"content":"The amount of unmanaged memory that has been released.","nodes":[{"content":"The amount of unmanaged memory that has been released.","pos":[0,54]}]}],"pos":[67173,67228],"yaml":true},{"content":"<code>bytesAllocated</code> is less than or equal to 0.  \n  \n -or-  \n  \n On a 32-bit computer, <code>bytesAllocated</code> is larger than <xref href=\"System.Int32.MaxValue\"></xref>.","nodes":[{"pos":[0,55],"content":"<ph id=\"ph1\">&lt;code&gt;bytesAllocated&lt;/code&gt;</ph> is less than or equal to 0.","source":"<code>bytesAllocated</code> is less than or equal to 0."},{"pos":[62,66],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[73,181],"content":"On a 32-bit computer, <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytesAllocated</ph><ept id=\"p1\">&lt;/code&gt;</ept> is larger than <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph>.","source":"On a 32-bit computer, <code>bytesAllocated</code> is larger than <xref href=\"System.Int32.MaxValue\"></xref>."}],"pos":[67400,67590],"yaml":true},{"content":"Requests that the system call the finalizer for the specified object for which <xref href=\"System.GC.SuppressFinalize(System.Object)\"></xref> has previously been called.","nodes":[{"pos":[0,169],"content":"Requests that the system call the finalizer for the specified object for which <ph id=\"ph1\">&lt;xref href=\"System.GC.SuppressFinalize(System.Object)\"&gt;&lt;/xref&gt;</ph> has previously been called.","source":"Requests that the system call the finalizer for the specified object for which <xref href=\"System.GC.SuppressFinalize(System.Object)\"></xref> has previously been called."}],"pos":[69145,69315],"yaml":true},{"content":"The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object. The `obj` parameter must be the caller of this method.  \n  \n Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer.  \n  \n By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method.  \n  \n A finalizer can use this method to resurrect itself or an object that it references.","nodes":[{"pos":[0,228],"content":"The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object. The `obj` parameter must be the caller of this method.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> method adds the <ph id=\"ph2\">`obj`</ph> parameter to the list of objects that request finalization before the garbage collector frees the object.","pos":[0,173],"source":"The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object."},{"content":"The <ph id=\"ph1\">`obj`</ph> parameter must be the caller of this method.","pos":[174,228],"source":" The `obj` parameter must be the caller of this method."}]},{"pos":[235,374],"content":"Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer.","nodes":[{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.GC.ReRegisterForFinalize%2A&gt;</ph> method does not guarantee that the garbage collector will call an object's finalizer.","pos":[0,139],"source":"Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer."}]},{"pos":[381,639],"content":"By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method.","nodes":[{"content":"By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <ph id=\"ph1\">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method.","pos":[0,258],"source":"By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method."}]},{"pos":[646,730],"content":"A finalizer can use this method to resurrect itself or an object that it references.","nodes":[{"content":"A finalizer can use this method to resurrect itself or an object that it references.","pos":[0,84]}]}],"pos":[69326,70065],"yaml":true,"extradata":"MT"},{"content":"The object that a finalizer must be called for.","nodes":[{"pos":[0,47],"content":"The object that a finalizer must be called for.","nodes":[{"content":"The object that a finalizer must be called for.","pos":[0,47]}]}],"pos":[70874,70922],"yaml":true},{"content":"<code>obj</code> is `null`.","nodes":[{"pos":[0,27],"content":"<ph id=\"ph1\">&lt;code&gt;obj&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>obj</code> is `null`."}],"pos":[71083,71111],"yaml":true},{"content":"Requests that the common language runtime not call the finalizer for the specified object.","nodes":[{"pos":[0,90],"content":"Requests that the common language runtime not call the finalizer for the specified object.","nodes":[{"content":"Requests that the common language runtime not call the finalizer for the specified object.","pos":[0,90]}]}],"pos":[72587,72678],"yaml":true},{"content":"This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers. A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=fullName> method, is used to release unmanaged resources before an object is garbage-collected. If `obj` does not have a finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect.  \n  \n Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=fullName> on an object that does not require it. Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation.","nodes":[{"pos":[0,399],"content":"This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers. A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=fullName> method, is used to release unmanaged resources before an object is garbage-collected. If `obj` does not have a finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect.","nodes":[{"content":"This method sets a bit in the object header of <ph id=\"ph1\">`obj`</ph>, which the runtime checks when calling finalizers.","pos":[0,103],"source":"This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers."},{"content":"A finalizer, which is represented by the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method, is used to release unmanaged resources before an object is garbage-collected.","pos":[104,288],"source":" A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=fullName> method, is used to release unmanaged resources before an object is garbage-collected."},{"content":"If <ph id=\"ph1\">`obj`</ph> does not have a finalizer, the call to the <ph id=\"ph2\">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph> method has no effect.","pos":[289,399],"source":" If `obj` does not have a finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect."}]},{"pos":[406,925],"content":"Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=fullName> on an object that does not require it. Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation.","nodes":[{"content":"Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=fullName> on an object that does not require it. Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation.","pos":[0,519],"nodes":[{"content":"Objects that implement the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface can call this method from the object's <ph id=\"ph2\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation to prevent the garbage collector from calling <ph id=\"ph3\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> on an object that does not require it.","pos":[0,321],"source":"Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=fullName> on an object that does not require it."},{"content":"Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A?displayProperty=fullName&gt;</ph> implementation.","pos":[322,519],"source":" Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation."}]}]}],"pos":[72689,73619],"yaml":true,"extradata":"MT"},{"content":"The object whose finalizer must not be executed.","nodes":[{"pos":[0,48],"content":"The object whose finalizer must not be executed.","nodes":[{"content":"The object whose finalizer must not be executed.","pos":[0,48]}]}],"pos":[74475,74524],"yaml":true},{"content":"<code>obj</code> is `null`.","nodes":[{"pos":[0,27],"content":"<ph id=\"ph1\">&lt;code&gt;obj&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>obj</code> is `null`."}],"pos":[74680,74708],"yaml":true},{"content":"Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.","nodes":[{"pos":[0,125],"content":"Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.","nodes":[{"content":"Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.","pos":[0,125]}]}],"pos":[76190,76316],"yaml":true},{"content":"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.  If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory. The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap).  \n  \n `totalSize` must be large enough to handle all memory allocations that occur in the critical path. This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.  \n  \n> [!IMPORTANT]\n>  You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.  \n  \n You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.","nodes":[{"pos":[0,689],"content":"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.  If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory. The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap).","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.","pos":[0,218],"source":"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code."},{"content":"If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.","pos":[220,405]},{"content":"The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * <ph id=\"ph1\">`totalSize`</ph> bytes (it attempts to allocate <ph id=\"ph2\">`totalSize`</ph> bytes for the small object heap and <ph id=\"ph3\">`totalSize`</ph> bytes for the large object heap).","pos":[406,689],"source":" The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap)."}]},{"pos":[696,899],"content":"`totalSize` must be large enough to handle all memory allocations that occur in the critical path. This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.","nodes":[{"content":"<ph id=\"ph1\">`totalSize`</ph> must be large enough to handle all memory allocations that occur in the critical path.","pos":[0,98],"source":"`totalSize` must be large enough to handle all memory allocations that occur in the critical path."},{"content":"This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.","pos":[99,203]}]},{"pos":[907,1443],"content":"[!IMPORTANT]\n You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.","leadings":["","> "],"nodes":[{"content":" You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.","pos":[13,534],"nodes":[{"content":"You cannot nest calls to the <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id=\"ph2\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.","pos":[1,204],"source":" You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode."},{"content":"In other words, you should not call <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id=\"ph2\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id=\"ph3\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.","pos":[205,521],"source":" In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded."}]}]},{"pos":[1450,1545],"content":"You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.","nodes":[{"content":"You exit the no GC region latency mode by calling the <ph id=\"ph1\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.","pos":[0,95],"source":"You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method."}]}],"pos":[76327,77882],"yaml":true,"extradata":"MT"},{"content":"The amount of memory in bytes to allocate without triggering a garbage collection. It must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.","nodes":[{"pos":[0,361],"content":"The amount of memory in bytes to allocate without triggering a garbage collection. It must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.","nodes":[{"content":"The amount of memory in bytes to allocate without triggering a garbage collection.","pos":[0,82]},{"content":"It must be less than or equal to the size of an ephemeral segment.","pos":[83,149]},{"content":"For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the <bpt id=\"p1\">[</bpt>Fundamentals of Garbage Collection<ept id=\"p1\">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.","pos":[150,361],"source":" For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article."}]}],"pos":[78092,78454],"yaml":true},{"content":"`true` if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, `false`.","nodes":[{"pos":[0,160],"content":"<ph id=\"ph1\">`true`</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, `false`."}],"pos":[78512,78675],"yaml":true},{"content":"<code>totalSize</code> exceeds the ephemeral segment size.","nodes":[{"pos":[0,58],"content":"<ph id=\"ph1\">&lt;code&gt;totalSize&lt;/code&gt;</ph> exceeds the ephemeral segment size.","source":"<code>totalSize</code> exceeds the ephemeral segment size."}],"pos":[78845,78904],"yaml":true},{"content":"The process is already in no GC region latency mode.","nodes":[{"pos":[0,52],"content":"The process is already in no GC region latency mode.","nodes":[{"content":"The process is already in no GC region latency mode.","pos":[0,52]}]}],"pos":[79014,79067],"yaml":true},{"content":"Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.","nodes":[{"pos":[0,253],"content":"Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.","nodes":[{"content":"Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.","pos":[0,253]}]}],"pos":[80192,80446],"yaml":true},{"content":"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.  If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`. The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap).  \n  \n `totalSize` must be large enough to handle all memory allocations that occur in the critical path. This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.  \n  \n Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`. It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.  \n  \n> [!IMPORTANT]\n>  You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.  \n  \n You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.","nodes":[{"pos":[0,806],"content":"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.  If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`. The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap).","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.","pos":[0,235],"source":"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code."},{"content":"If the runtime is unable to initially allocate the requested amount of memory and the <ph id=\"ph1\">`disallowFullBlockingGC`</ph> argument is <ph id=\"ph2\">`false`</ph>, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns <ph id=\"ph3\">`false`</ph>.","pos":[237,540],"source":"  If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`."},{"content":"The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * <ph id=\"ph1\">`totalSize`</ph> (it attempts to allocate <ph id=\"ph2\">`totalSize`</ph> for the small object heap and <ph id=\"ph3\">`totalSize`</ph> for the large object heap).","pos":[541,806],"source":" The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap)."}]},{"pos":[813,1016],"content":"`totalSize` must be large enough to handle all memory allocations that occur in the critical path. This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.","nodes":[{"content":"<ph id=\"ph1\">`totalSize`</ph> must be large enough to handle all memory allocations that occur in the critical path.","pos":[0,98],"source":"`totalSize` must be large enough to handle all memory allocations that occur in the critical path."},{"content":"This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.","pos":[99,203]}]},{"pos":[1023,1592],"content":"Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`. It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.","nodes":[{"content":"Setting <ph id=\"ph1\">`disallowFullBlockingGC`</ph> to <ph id=\"ph2\">`true`</ph> to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns <ph id=\"ph3\">`true`</ph>, and have the load balancer redirect requests to other systems if it returns <ph id=\"ph4\">`false`</ph>.","pos":[0,361],"source":"Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`."},{"content":"It can then do a full blocking garbage collection when it's not handling requests by calling the <ph id=\"ph1\">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method.","pos":[362,569],"source":" It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method."}]},{"pos":[1600,2136],"content":"[!IMPORTANT]\n You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.","leadings":["","> "],"nodes":[{"content":" You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.","pos":[13,534],"nodes":[{"content":"You cannot nest calls to the <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id=\"ph2\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.","pos":[1,204],"source":" You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode."},{"content":"In other words, you should not call <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id=\"ph2\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id=\"ph3\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.","pos":[205,521],"source":" In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded."}]}]},{"pos":[2143,2238],"content":"You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.","nodes":[{"content":"You exit the no GC region latency mode by calling the <ph id=\"ph1\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.","pos":[0,95],"source":"You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method."}]}],"pos":[80457,82707],"yaml":true,"extradata":"MT"},{"content":"The amount of memory in bytes to allocate without triggering a garbage collection. It must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.","nodes":[{"pos":[0,361],"content":"The amount of memory in bytes to allocate without triggering a garbage collection. It must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.","nodes":[{"content":"The amount of memory in bytes to allocate without triggering a garbage collection.","pos":[0,82]},{"content":"It must be less than or equal to the size of an ephemeral segment.","pos":[83,149]},{"content":"For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the <bpt id=\"p1\">[</bpt>Fundamentals of Garbage Collection<ept id=\"p1\">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.","pos":[150,361],"source":" For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article."}]}],"pos":[82946,83308],"yaml":true},{"content":"`true` to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <code>totalSize</code> bytes; otherwise, `false`.","nodes":[{"pos":[0,156],"content":"<ph id=\"ph1\">`true`</ph> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">totalSize</ph><ept id=\"p1\">&lt;/code&gt;</ept> bytes; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <code>totalSize</code> bytes; otherwise, `false`."}],"pos":[83387,83546],"yaml":true},{"content":"`true` if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, `false`.","nodes":[{"pos":[0,160],"content":"<ph id=\"ph1\">`true`</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, `false`."}],"pos":[83604,83767],"yaml":true},{"content":"<code>totalSize</code> exceeds the ephemeral segment size.","nodes":[{"pos":[0,58],"content":"<ph id=\"ph1\">&lt;code&gt;totalSize&lt;/code&gt;</ph> exceeds the ephemeral segment size.","source":"<code>totalSize</code> exceeds the ephemeral segment size."}],"pos":[83937,83996],"yaml":true},{"content":"The process is already in no GC region latency mode.","nodes":[{"pos":[0,52],"content":"The process is already in no GC region latency mode.","nodes":[{"content":"The process is already in no GC region latency mode.","pos":[0,52]}]}],"pos":[84106,84159],"yaml":true},{"content":"Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.","nodes":[{"pos":[0,177],"content":"Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.","nodes":[{"content":"Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.","pos":[0,177]}]}],"pos":[85272,85450],"yaml":true},{"content":"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.  If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory. The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).  \n  \n `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH. This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.  \n  \n> [!IMPORTANT]\n>  You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.  \n  \n You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.","nodes":[{"pos":[0,584],"content":"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.  If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory. The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.","pos":[0,233],"source":"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code."},{"content":"If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.","pos":[235,420]},{"content":"The garbage collector enters no GC region latency mode if it is able to allocate <ph id=\"ph1\">`lohSize`</ph> for the LOH and <ph id=\"ph2\">`totalSize`</ph> – <ph id=\"ph3\">`lohSize`</ph> for the small object heap (SOH).","pos":[421,584],"source":" The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH)."}]},{"pos":[591,931],"content":"`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH. This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.","nodes":[{"content":"<ph id=\"ph1\">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the LOH, and <ph id=\"ph2\">`totalSize`</ph> – <ph id=\"ph3\">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the SOH.","pos":[0,235],"source":"`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH."},{"content":"This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.","pos":[236,340]}]},{"pos":[939,1475],"content":"[!IMPORTANT]\n You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.","leadings":["","> "],"nodes":[{"content":" You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.","pos":[13,534],"nodes":[{"content":"You cannot nest calls to the <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id=\"ph2\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.","pos":[1,204],"source":" You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode."},{"content":"In other words, you should not call <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id=\"ph2\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id=\"ph3\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.","pos":[205,521],"source":" In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded."}]}]},{"pos":[1482,1577],"content":"You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.","nodes":[{"content":"You exit the no GC region latency mode by calling the <ph id=\"ph1\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.","pos":[0,95],"source":"You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method."}]}],"pos":[85461,87048],"yaml":true,"extradata":"MT"},{"content":"The amount of memory in bytes to allocate without triggering a garbage collection. <code>totalSize</code> –<code>lohSize</code> must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.","nodes":[{"pos":[0,403],"content":"The amount of memory in bytes to allocate without triggering a garbage collection. <code>totalSize</code> –<code>lohSize</code> must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.","nodes":[{"content":"The amount of memory in bytes to allocate without triggering a garbage collection.","pos":[0,82]},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">totalSize</ph><ept id=\"p1\">&lt;/code&gt;</ept> –<bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">lohSize</ph><ept id=\"p2\">&lt;/code&gt;</ept> must be less than or equal to the size of an ephemeral segment.","pos":[83,191],"source":"<code>totalSize</code> –<code>lohSize</code> must be less than or equal to the size of an ephemeral segment."},{"content":"For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the <bpt id=\"p1\">[</bpt>Fundamentals of Garbage Collection<ept id=\"p1\">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.","pos":[192,403],"source":" For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article."}]}],"pos":[87272,87676],"yaml":true},{"content":"The number of bytes in <code>totalSize</code> to use for large object heap (LOH) allocations.","nodes":[{"pos":[0,93],"content":"The number of bytes in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">totalSize</ph><ept id=\"p1\">&lt;/code&gt;</ept> to use for large object heap (LOH) allocations.","source":"The number of bytes in <code>totalSize</code> to use for large object heap (LOH) allocations."}],"pos":[87738,87832],"yaml":true},{"content":"`true` if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, `false`.","nodes":[{"pos":[0,160],"content":"<ph id=\"ph1\">`true`</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, `false`."}],"pos":[87890,88053],"yaml":true},{"content":"<code>totalSize</code> – <code>lohSize</code> exceeds the ephemeral segment size.","nodes":[{"pos":[0,81],"content":"<ph id=\"ph1\">&lt;code&gt;totalSize&lt;/code&gt;</ph> – <ph id=\"ph2\">&lt;code&gt;lohSize&lt;/code&gt;</ph> exceeds the ephemeral segment size.","source":"<code>totalSize</code> – <code>lohSize</code> exceeds the ephemeral segment size."}],"pos":[88223,88305],"yaml":true},{"content":"The process is already in no GC region latency mode.","nodes":[{"pos":[0,52],"content":"The process is already in no GC region latency mode.","nodes":[{"content":"The process is already in no GC region latency mode.","pos":[0,52]}]}],"pos":[88415,88468],"yaml":true},{"content":"Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.","nodes":[{"pos":[0,305],"content":"Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.","nodes":[{"content":"Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.","pos":[0,305]}]}],"pos":[89653,89959],"yaml":true},{"content":"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.  If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`. The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).  \n  \n `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH. This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.  \n  \n Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`. It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.  \n  \n> [!IMPORTANT]\n>  You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.  \n  \n You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.","nodes":[{"pos":[0,719],"content":"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.  If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`. The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29&gt;</ph> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.","pos":[0,250],"source":"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code."},{"content":"If the runtime is unable to initially allocate the requested amount of memory and the <ph id=\"ph1\">`disallowFullBlockingGC`</ph> argument is <ph id=\"ph2\">`false`</ph>, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns <ph id=\"ph3\">`false`</ph>.","pos":[252,555],"source":"  If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`."},{"content":"The garbage collector enters no GC region latency mode if it is able to allocate <ph id=\"ph1\">`lohSize`</ph> for the LOH and <ph id=\"ph2\">`totalSize`</ph> – <ph id=\"ph3\">`lohSize`</ph> for the small object heap (SOH).","pos":[556,719],"source":" The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH)."}]},{"pos":[726,1066],"content":"`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH. This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.","nodes":[{"content":"<ph id=\"ph1\">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the LOH, and <ph id=\"ph2\">`totalSize`</ph> – <ph id=\"ph3\">`lohSize`</ph> must be large enough to handle all memory allocations that occur in the critical path for the SOH.","pos":[0,235],"source":"`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH."},{"content":"This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.","pos":[236,340]}]},{"pos":[1073,1642],"content":"Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`. It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.","nodes":[{"content":"Setting <ph id=\"ph1\">`disallowFullBlockingGC`</ph> to <ph id=\"ph2\">`true`</ph> to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns <ph id=\"ph3\">`true`</ph>, and have the load balancer redirect requests to other systems if it returns <ph id=\"ph4\">`false`</ph>.","pos":[0,361],"source":"Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`."},{"content":"It can then do a full blocking garbage collection when it's not handling requests by calling the <ph id=\"ph1\">&lt;xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method.","pos":[362,569],"source":" It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method."}]},{"pos":[1650,2186],"content":"[!IMPORTANT]\n You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.","leadings":["","> "],"nodes":[{"content":" You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.","pos":[13,534],"nodes":[{"content":"You cannot nest calls to the <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> method, and you should only call the <ph id=\"ph2\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method if the runtime is currently in no GC region latency mode.","pos":[1,204],"source":" You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode."},{"content":"In other words, you should not call <ph id=\"ph1\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <ph id=\"ph2\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> to succeed just because the first call to <ph id=\"ph3\">&lt;xref:System.GC.TryStartNoGCRegion%2A&gt;</ph> succeeded.","pos":[205,521],"source":" In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded."}]}]},{"pos":[2193,2288],"content":"You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.","nodes":[{"content":"You exit the no GC region latency mode by calling the <ph id=\"ph1\">&lt;xref:System.GC.EndNoGCRegion%2A&gt;</ph> method.","pos":[0,95],"source":"You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method."}]}],"pos":[89970,92270],"yaml":true,"extradata":"MT"},{"content":"The amount of memory in bytes to allocate without triggering a garbage collection. <code>totalSize</code> –<code>lohSize</code> must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.","nodes":[{"pos":[0,403],"content":"The amount of memory in bytes to allocate without triggering a garbage collection. <code>totalSize</code> –<code>lohSize</code> must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.","nodes":[{"content":"The amount of memory in bytes to allocate without triggering a garbage collection.","pos":[0,82]},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">totalSize</ph><ept id=\"p1\">&lt;/code&gt;</ept> –<bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">lohSize</ph><ept id=\"p2\">&lt;/code&gt;</ept> must be less than or equal to the size of an ephemeral segment.","pos":[83,191],"source":"<code>totalSize</code> –<code>lohSize</code> must be less than or equal to the size of an ephemeral segment."},{"content":"For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the <bpt id=\"p1\">[</bpt>Fundamentals of Garbage Collection<ept id=\"p1\">](~/docs/standard/garbage-collection/fundamentals.md)</ept> article.","pos":[192,403],"source":" For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article."}]}],"pos":[92523,92927],"yaml":true},{"content":"The number of bytes in <code>totalSize</code> to use for large object heap (LOH) allocations.","nodes":[{"pos":[0,93],"content":"The number of bytes in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">totalSize</ph><ept id=\"p1\">&lt;/code&gt;</ept> to use for large object heap (LOH) allocations.","source":"The number of bytes in <code>totalSize</code> to use for large object heap (LOH) allocations."}],"pos":[92989,93083],"yaml":true},{"content":"`true` to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, `false`.","nodes":[{"pos":[0,187],"content":"<ph id=\"ph1\">`true`</ph> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, `false`."}],"pos":[93162,93352],"yaml":true},{"content":"`true` if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, `false`.","nodes":[{"pos":[0,160],"content":"<ph id=\"ph1\">`true`</ph> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, `false`."}],"pos":[93410,93573],"yaml":true},{"content":"<code>totalSize</code> – <code>lohSize</code> exceeds the ephemeral segment size.","nodes":[{"pos":[0,81],"content":"<ph id=\"ph1\">&lt;code&gt;totalSize&lt;/code&gt;</ph> – <ph id=\"ph2\">&lt;code&gt;lohSize&lt;/code&gt;</ph> exceeds the ephemeral segment size.","source":"<code>totalSize</code> – <code>lohSize</code> exceeds the ephemeral segment size."}],"pos":[93743,93825],"yaml":true},{"content":"The process is already in no GC region latency mode.","nodes":[{"pos":[0,52],"content":"The process is already in no GC region latency mode.","nodes":[{"content":"The process is already in no GC region latency mode.","pos":[0,52]}]}],"pos":[93935,93988],"yaml":true},{"content":"Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.","nodes":[{"pos":[0,151],"content":"Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.","nodes":[{"content":"Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.","pos":[0,151]}]}],"pos":[95002,95154],"yaml":true},{"content":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.  \n  \n When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method. Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.  \n  \n This method waits indefinitely for a garbage collection notification to be obtained. If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=fullName> method overload. If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.  \n  \n You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection. Calling this method alone causes indeterminate results.","nodes":[{"pos":[0,374],"content":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.","nodes":[{"content":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.","pos":[0,374],"nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id=\"ph2\">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.","pos":[0,240],"source":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method."},{"content":"You can also use the <ph id=\"ph1\">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to determine whether the full garbage collection has completed.","pos":[241,374],"source":" You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed."}]}]},{"pos":[381,807],"content":"When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method. Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.","nodes":[{"content":"When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method. Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.","pos":[0,426],"nodes":[{"content":"When the enumeration returns <ph id=\"ph1\">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <ph id=\"ph2\">&lt;xref:System.GC.Collect%2A&gt;</ph> method.","pos":[0,230],"source":"When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method."},{"content":"Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.","pos":[231,426]}]}]},{"pos":[814,1277],"content":"This method waits indefinitely for a garbage collection notification to be obtained. If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=fullName> method overload. If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.","nodes":[{"content":"This method waits indefinitely for a garbage collection notification to be obtained. If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=fullName> method overload. If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.","pos":[0,463],"nodes":[{"content":"This method waits indefinitely for a garbage collection notification to be obtained.","pos":[0,84]},{"content":"If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <ph id=\"ph1\">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=fullName&gt;</ph> method overload.","pos":[85,297],"source":" If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=fullName> method overload."},{"content":"If you call this method without specifying a time-out, you can call the <ph id=\"ph1\">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method if you are waiting longer than preferred.","pos":[298,463],"source":" If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred."}]}]},{"pos":[1284,1495],"content":"You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection. Calling this method alone causes indeterminate results.","nodes":[{"content":"You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection. Calling this method alone causes indeterminate results.","pos":[0,211],"nodes":[{"content":"You should follow this method with a call to the <ph id=\"ph1\">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to make sure that you have had a full garbage collection.","pos":[0,155],"source":"You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection."},{"content":"Calling this method alone causes indeterminate results.","pos":[156,211]}]}]}],"pos":[95165,96669],"yaml":true,"extradata":"MT"},{"content":"The status of the registered garbage collection notification.","nodes":[{"pos":[0,61],"content":"The status of the registered garbage collection notification.","nodes":[{"content":"The status of the registered garbage collection notification.","pos":[0,61]}]}],"pos":[97721,97783],"yaml":true},{"content":"Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.","nodes":[{"pos":[0,184],"content":"Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.","nodes":[{"content":"Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.","pos":[0,184]}]}],"pos":[99050,99235],"yaml":true},{"content":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.  \n  \n Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`. If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.  \n  \n When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method. Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.  \n  \n You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.  \n  \n You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection. Calling this method alone causes indeterminate results.","nodes":[{"pos":[0,374],"content":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.","nodes":[{"content":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.","pos":[0,374],"nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id=\"ph2\">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.","pos":[0,240],"source":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method."},{"content":"You can also use the <ph id=\"ph1\">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to determine whether the full garbage collection has completed.","pos":[241,374],"source":" You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed."}]}]},{"pos":[381,715],"content":"Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`. If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.","nodes":[{"content":"Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by <ph id=\"ph1\">`millisecondsTimeout`</ph>.","pos":[0,164],"source":"Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`."},{"content":"If a garbage collection notification status is not obtained before <ph id=\"ph1\">`millisecondsTimeout`</ph> times out, this method returns <ph id=\"ph2\">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.","pos":[165,334],"source":" If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>."}]},{"pos":[722,1148],"content":"When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method. Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.","nodes":[{"content":"When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method. Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.","pos":[0,426],"nodes":[{"content":"When the enumeration returns <ph id=\"ph1\">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <ph id=\"ph2\">&lt;xref:System.GC.Collect%2A&gt;</ph> method.","pos":[0,230],"source":"When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method."},{"content":"Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.","pos":[231,426]}]}]},{"pos":[1155,1279],"content":"You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.","nodes":[{"content":"You can call the <ph id=\"ph1\">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method when you cannot wait for the time-out period to elapse.","pos":[0,124],"source":"You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse."}]},{"pos":[1286,1497],"content":"You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection. Calling this method alone causes indeterminate results.","nodes":[{"content":"You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection. Calling this method alone causes indeterminate results.","pos":[0,211],"nodes":[{"content":"You should follow this method with a call to the <ph id=\"ph1\">&lt;xref:System.GC.WaitForFullGCComplete%2A&gt;</ph> method to make sure that you have had a full garbage collection.","pos":[0,155],"source":"You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection."},{"content":"Calling this method alone causes indeterminate results.","pos":[156,211]}]}]}],"pos":[99246,100754],"yaml":true,"extradata":"MT"},{"content":"The length of time to wait before a notification status can be obtained. Specify -1 to wait indefinitely.","nodes":[{"pos":[0,105],"content":"The length of time to wait before a notification status can be obtained. Specify -1 to wait indefinitely.","nodes":[{"content":"The length of time to wait before a notification status can be obtained. Specify -1 to wait indefinitely.","pos":[0,105],"nodes":[{"content":"The length of time to wait before a notification status can be obtained.","pos":[0,72]},{"content":"Specify -1 to wait indefinitely.","pos":[73,105]}]}]}],"pos":[101002,101108],"yaml":true},{"content":"The status of the registered garbage collection notification.","nodes":[{"pos":[0,61],"content":"The status of the registered garbage collection notification.","nodes":[{"content":"The status of the registered garbage collection notification.","pos":[0,61]}]}],"pos":[101179,101241],"yaml":true},{"content":"<code>millisecondsTimeout</code> must be either non-negative or less than or equal to <xref href=\"System.Int32.MaxValue\"></xref> or -1.","nodes":[{"pos":[0,135],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> must be either non-negative or less than or equal to <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph> or -1.","source":"<code>millisecondsTimeout</code> must be either non-negative or less than or equal to <xref href=\"System.Int32.MaxValue\"></xref> or -1."}],"pos":[101414,101550],"yaml":true},{"content":"Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.","nodes":[{"pos":[0,153],"content":"Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.","nodes":[{"content":"Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.","pos":[0,153]}]}],"pos":[102698,102852],"yaml":true},{"content":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.  \n  \n When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.  \n  \n This method waits indefinitely for a garbage collection notification to be obtained. If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=fullName> method overload. If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.  \n  \n This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection. Calling this method alone can produce indeterminate results.","nodes":[{"pos":[0,370],"content":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.","nodes":[{"content":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.","pos":[0,370],"nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id=\"ph2\">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.","pos":[0,240],"source":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method."},{"content":"You can also use the <ph id=\"ph1\">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to determine whether a full garbage collection is imminent.","pos":[241,370],"source":" You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent."}]}]},{"pos":[377,578],"content":"When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.","nodes":[{"content":"When the enumeration returns <ph id=\"ph1\">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as resuming work and obtaining a collection count with the <ph id=\"ph2\">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> property.","pos":[0,201],"source":"When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property."}]},{"pos":[585,1048],"content":"This method waits indefinitely for a garbage collection notification to be obtained. If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=fullName> method overload. If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.","nodes":[{"content":"This method waits indefinitely for a garbage collection notification to be obtained. If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=fullName> method overload. If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.","pos":[0,463],"nodes":[{"content":"This method waits indefinitely for a garbage collection notification to be obtained.","pos":[0,84]},{"content":"If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <ph id=\"ph1\">&lt;xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=fullName&gt;</ph> method overload.","pos":[85,297],"source":" If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=fullName> method overload."},{"content":"If you call this method without specifying a time-out, you can call the <ph id=\"ph1\">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method if you are waiting longer than preferred.","pos":[298,463],"source":" If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred."}]}]},{"pos":[1055,1277],"content":"This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection. Calling this method alone can produce indeterminate results.","nodes":[{"content":"This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection. Calling this method alone can produce indeterminate results.","pos":[0,222],"nodes":[{"content":"This method call should be preceded with a call to the <ph id=\"ph1\">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to make sure that you have had a full garbage collection.","pos":[0,161],"source":"This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection."},{"content":"Calling this method alone can produce indeterminate results.","pos":[162,222]}]}]}],"pos":[102863,104149],"yaml":true,"extradata":"MT"},{"content":"The status of the registered garbage collection notification.","nodes":[{"pos":[0,61],"content":"The status of the registered garbage collection notification.","nodes":[{"content":"The status of the registered garbage collection notification.","pos":[0,61]}]}],"pos":[105189,105251],"yaml":true},{"content":"Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.","nodes":[{"pos":[0,186],"content":"Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.","nodes":[{"content":"Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.","pos":[0,186]}]}],"pos":[106518,106705],"yaml":true},{"content":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.  \n  \n Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`. If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.  \n  \n When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.  \n  \n You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.  \n  \n This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection. Calling this method alone can produce indeterminate results.","nodes":[{"pos":[0,370],"content":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.","nodes":[{"content":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.","pos":[0,370],"nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.GCNotificationStatus&gt;</ph> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <ph id=\"ph2\">&lt;xref:System.GC.RegisterForFullGCNotification%2A&gt;</ph> method.","pos":[0,240],"source":"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method."},{"content":"You can also use the <ph id=\"ph1\">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to determine whether a full garbage collection is imminent.","pos":[241,370],"source":" You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent."}]}]},{"pos":[377,711],"content":"Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`. If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.","nodes":[{"content":"Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by <ph id=\"ph1\">`millisecondsTimeout`</ph>.","pos":[0,164],"source":"Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`."},{"content":"If a garbage collection notification status is not obtained before <ph id=\"ph1\">`millisecondsTimeout`</ph> times out, this method returns <ph id=\"ph2\">&lt;xref:System.GCNotificationStatus.NotApplicable&gt;</ph>.","pos":[165,334],"source":" If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>."}]},{"pos":[718,919],"content":"When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.","nodes":[{"content":"When the enumeration returns <ph id=\"ph1\">&lt;xref:System.GCNotificationStatus.Succeeded&gt;</ph>, you can do tasks such as resuming work and obtaining a collection count with the <ph id=\"ph2\">&lt;xref:System.GC.CollectionCount%2A&gt;</ph> property.","pos":[0,201],"source":"When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property."}]},{"pos":[926,1050],"content":"You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.","nodes":[{"content":"You can call the <ph id=\"ph1\">&lt;xref:System.GC.CancelFullGCNotification%2A&gt;</ph> method when you cannot wait for the time-out period to elapse.","pos":[0,124],"source":"You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse."}]},{"pos":[1057,1279],"content":"This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection. Calling this method alone can produce indeterminate results.","nodes":[{"content":"This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection. Calling this method alone can produce indeterminate results.","pos":[0,222],"nodes":[{"content":"This method call should be preceded with a call to the <ph id=\"ph1\">&lt;xref:System.GC.WaitForFullGCApproach%2A&gt;</ph> method to make sure that you have had a full garbage collection.","pos":[0,161],"source":"This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection."},{"content":"Calling this method alone can produce indeterminate results.","pos":[162,222]}]}]}],"pos":[106716,108006],"yaml":true,"extradata":"MT"},{"content":"The length of time to wait before a notification status can be obtained. Specify -1 to wait indefinitely.","nodes":[{"pos":[0,105],"content":"The length of time to wait before a notification status can be obtained. Specify -1 to wait indefinitely.","nodes":[{"content":"The length of time to wait before a notification status can be obtained. Specify -1 to wait indefinitely.","pos":[0,105],"nodes":[{"content":"The length of time to wait before a notification status can be obtained.","pos":[0,72]},{"content":"Specify -1 to wait indefinitely.","pos":[73,105]}]}]}],"pos":[108254,108360],"yaml":true},{"content":"The status of the registered garbage collection notification.","nodes":[{"pos":[0,61],"content":"The status of the registered garbage collection notification.","nodes":[{"content":"The status of the registered garbage collection notification.","pos":[0,61]}]}],"pos":[108431,108493],"yaml":true},{"content":"<code>millisecondsTimeout</code> must be either non-negative or less than or equal to <xref href=\"System.Int32.MaxValue\"></xref> or -1.","nodes":[{"pos":[0,135],"content":"<ph id=\"ph1\">&lt;code&gt;millisecondsTimeout&lt;/code&gt;</ph> must be either non-negative or less than or equal to <ph id=\"ph2\">&lt;xref href=\"System.Int32.MaxValue\"&gt;&lt;/xref&gt;</ph> or -1.","source":"<code>millisecondsTimeout</code> must be either non-negative or less than or equal to <xref href=\"System.Int32.MaxValue\"></xref> or -1."}],"pos":[108662,108798],"yaml":true},{"content":"Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.","nodes":[{"pos":[0,111],"content":"Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.","nodes":[{"content":"Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.","pos":[0,111]}]}],"pos":[109964,110076],"yaml":true},{"content":"When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements. If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization. The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list. This method blocks until all finalizers have run to completion.  \n  \n The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate. However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress. For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.","nodes":[{"pos":[0,547],"content":"When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements. If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization. The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list. This method blocks until all finalizers have run to completion.","nodes":[{"content":"When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements. If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization. The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list. This method blocks until all finalizers have run to completion.","pos":[0,547],"nodes":[{"content":"When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.","pos":[0,138]},{"content":"If an object implements a finalizer and has not disabled finalization by calling <ph id=\"ph1\">&lt;xref:System.GC.SuppressFinalize%2A&gt;</ph>, the object is placed in a list of objects that are marked as ready for finalization.","pos":[139,342],"source":" If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization."},{"content":"The garbage collector calls the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A&gt;</ph> methods for the objects in this list and removes the entries from the list.","pos":[343,483],"source":" The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list."},{"content":"This method blocks until all finalizers have run to completion.","pos":[484,547]}]}]},{"pos":[554,943],"content":"The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate. However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress. For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.","nodes":[{"content":"The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate. However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress. For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.","pos":[0,389],"nodes":[{"content":"The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.","pos":[0,112]},{"content":"However, this thread can be interrupted by another thread while the <ph id=\"ph1\">&lt;xref:System.GC.WaitForPendingFinalizers%2A&gt;</ph> method is in progress.","pos":[113,248],"source":" However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress."},{"content":"For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.","pos":[249,389]}]}]}],"pos":[110087,111035],"yaml":true,"extradata":"MT"}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.GC\n  commentId: T:System.GC\n  id: GC\n  children:\n  - System.GC.AddMemoryPressure(System.Int64)\n  - System.GC.CancelFullGCNotification\n  - System.GC.Collect\n  - System.GC.Collect(System.Int32)\n  - System.GC.Collect(System.Int32,System.GCCollectionMode)\n  - System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)\n  - System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)\n  - System.GC.CollectionCount(System.Int32)\n  - System.GC.EndNoGCRegion\n  - System.GC.GetAllocatedBytesForCurrentThread\n  - System.GC.GetGeneration(System.Object)\n  - System.GC.GetGeneration(System.WeakReference)\n  - System.GC.GetTotalMemory(System.Boolean)\n  - System.GC.KeepAlive(System.Object)\n  - System.GC.MaxGeneration\n  - System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)\n  - System.GC.RemoveMemoryPressure(System.Int64)\n  - System.GC.ReRegisterForFinalize(System.Object)\n  - System.GC.SuppressFinalize(System.Object)\n  - System.GC.TryStartNoGCRegion(System.Int64)\n  - System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)\n  - System.GC.TryStartNoGCRegion(System.Int64,System.Int64)\n  - System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)\n  - System.GC.WaitForFullGCApproach\n  - System.GC.WaitForFullGCApproach(System.Int32)\n  - System.GC.WaitForFullGCComplete\n  - System.GC.WaitForFullGCComplete(System.Int32)\n  - System.GC.WaitForPendingFinalizers\n  langs:\n  - csharp\n  name: GC\n  nameWithType: GC\n  fullName: System.GC\n  type: Class\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Controls the system garbage collector, a service that automatically reclaims unused memory.\n  remarks: \"The garbage collector is a common language runtime component that controls the allocation and release of managed memory. The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released. Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.  \\n  \\n The garbage collector tracks and reclaims objects allocated in managed memory. Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references. Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory. Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.  \\n  \\n Garbage collection consists of the following steps:  \\n  \\n1.  The garbage collector searches for managed objects that are referenced in managed code.  \\n  \\n2.  The garbage collector tries to finalize objects that are not referenced.  \\n  \\n3.  The garbage collector frees objects that are not referenced and reclaims their memory.  \\n  \\n This topic includes the following sections:  \\n  \\n [The garbage collector and unmanaged resources](#unmanaged)   \\n [Object aging and generations](#generations)   \\n [Disallowing garbage collection](#NoGCRegion)  \\n  \\n<a name=\\\"unmanaged\\\"></a>   \\n## The garbage collector and unmanaged resources  \\n During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code. However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so. The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.  \\n  \\n Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections. When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.  \\n  \\n In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=fullName> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=fullName>. In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object. However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called. Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.  \\n  \\n In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> method that performs resource management and cleanup tasks. Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object. The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.  \\n  \\n For more information on object finalization and the dispose pattern, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).  \\n  \\n<a name=\\\"generations\\\"></a>   \\n## Object aging and generations  \\n The garbage collector in the common language runtime supports object aging using generations. A generation is a unit of measure of the relative age of objects in memory. The generation number, or age, of an object indicates the generation to which an object belongs. Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle. Objects in the most recent generation are in generation 0. This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2. You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.  \\n  \\n Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations. Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected.  \\n  \\n<a name=\\\"NoGCRegion\\\"></a>   \\n## Disallowing garbage collection  \\n Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance. The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector. If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.  \\n  \\n You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>. You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.  \\n  \\n You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.\"\n  example:\n  - \"The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console. The unused objects are then collected, and the resulting memory totals are displayed.  \\n  \\n [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]\\n [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]\\n [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]\"\n  syntax:\n    content: public static class GC\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.AddMemoryPressure(System.Int64)\n  commentId: M:System.GC.AddMemoryPressure(System.Int64)\n  id: AddMemoryPressure(System.Int64)\n  parent: System.GC\n  langs:\n  - csharp\n  name: AddMemoryPressure(Int64)\n  nameWithType: GC.AddMemoryPressure(Int64)\n  fullName: GC.AddMemoryPressure(Int64)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.\n  remarks: \"In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated. If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection. The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.  \\n  \\n In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method. Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.  \\n  \\n In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.  \\n  \\n> [!CAUTION]\\n>  You must ensure that you remove exactly the amount of pressure you add. Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static void AddMemoryPressure (long bytesAllocated);\n    parameters:\n    - id: bytesAllocated\n      type: System.Int64\n      description: The incremental amount of unmanaged memory that has been allocated.\n  overload: System.GC.AddMemoryPressure*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>bytesAllocated</code> is less than or equal to 0.  \\n  \\n -or-  \\n  \\n On a 32-bit computer, <code>bytesAllocated</code> is larger than <xref href=\\\"System.Int32.MaxValue\\\"></xref>.\"\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.CancelFullGCNotification\n  commentId: M:System.GC.CancelFullGCNotification\n  id: CancelFullGCNotification\n  parent: System.GC\n  langs:\n  - csharp\n  name: CancelFullGCNotification()\n  nameWithType: GC.CancelFullGCNotification()\n  fullName: GC.CancelFullGCNotification()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Cancels the registration of a garbage collection notification.\n  remarks: This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.\n  example:\n  - \"The following example cancels a garbage collection registration. This example is part of a larger example provided for the [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.  \\n  \\n [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]\\n [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]\\n [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static void CancelFullGCNotification ();\n    parameters: []\n  overload: System.GC.CancelFullGCNotification*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: This member is not available when concurrent garbage collection is enabled. See the [<gcConcurrent>](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.Collect\n  commentId: M:System.GC.Collect\n  id: Collect\n  parent: System.GC\n  langs:\n  - csharp\n  name: Collect()\n  nameWithType: GC.Collect()\n  fullName: GC.Collect()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Forces an immediate garbage collection of all generations.\n  remarks: \"Use this method to try to reclaim all memory that is inaccessible. It performs a blocking garbage collection of all generations.  \\n  \\n All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected. Use this method to force the system to try to reclaim the maximum amount of available memory.  \\n  \\n Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], you can compact the large object heap (LOH) by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName> before calling the <xref:System.GC.Collect%2A> method, as the following example illustrates.  \\n  \\n [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]\\n [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]\"\n  example:\n  - \"The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on all generations of memory. The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.  \\n  \\n [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]\\n [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]\\n [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]\"\n  syntax:\n    content: public static void Collect ();\n    parameters: []\n  overload: System.GC.Collect*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.Collect(System.Int32)\n  commentId: M:System.GC.Collect(System.Int32)\n  id: Collect(System.Int32)\n  parent: System.GC\n  langs:\n  - csharp\n  name: Collect(Int32)\n  nameWithType: GC.Collect(Int32)\n  fullName: GC.Collect(Int32)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Forces an immediate garbage collection from generation 0 through a specified generation.\n  remarks: \"Use this method to try to reclaim memory that is inaccessible. However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.  \\n  \\n If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation. If object aging is not implemented, the garbage collector considers all objects during the garbage collection.  \\n  \\n Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of the `generation` parameter.  \\n  \\n To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters. To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=fullName> method overload.\"\n  example:\n  - \"The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on individual layers of memory. The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.  \\n  \\n [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]\\n [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]\\n [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]\"\n  syntax:\n    content: public static void Collect (int generation);\n    parameters:\n    - id: generation\n      type: System.Int32\n      description: The number of the oldest generation to be garbage collected.\n  overload: System.GC.Collect*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>generation</code> is not valid.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.Collect(System.Int32,System.GCCollectionMode)\n  commentId: M:System.GC.Collect(System.Int32,System.GCCollectionMode)\n  id: Collect(System.Int32,System.GCCollectionMode)\n  parent: System.GC\n  langs:\n  - csharp\n  name: Collect(Int32, GCCollectionMode)\n  nameWithType: GC.Collect(Int32, GCCollectionMode)\n  fullName: GC.Collect(Int32, GCCollectionMode)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <xref href=\"System.GCCollectionMode\"></xref> value.\n  remarks: \"Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects. Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.  \\n  \\n To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property.  \\n  \\n The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter. Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`.  \\n  \\n To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.  \\n  \\n To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=fullName> method overload. When you specify the maximum generation, all objects are collected.\"\n  example:\n  - \"The following example forces a garbage collection for generation 2 objects with the <xref:System.GCCollectionMode.Optimized> setting.  \\n  \\n [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]\\n [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]\"\n  syntax:\n    content: public static void Collect (int generation, GCCollectionMode mode);\n    parameters:\n    - id: generation\n      type: System.Int32\n      description: The number of the oldest generation to be garbage collected.\n    - id: mode\n      type: System.GCCollectionMode\n      description: An enumeration value that specifies whether the garbage collection is forced (<xref href=\"System.GCCollectionMode.Default\"></xref> or <xref href=\"System.GCCollectionMode.Forced\"></xref>) or optimized (<xref href=\"System.GCCollectionMode.Optimized\"></xref>).\n  overload: System.GC.Collect*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>generation</code> is not valid.  \\n  \\n -or-  \\n  \\n <code>mode</code> is not one of the <xref href=\\\"System.GCCollectionMode\\\"></xref> values.\"\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)\n  commentId: M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)\n  id: Collect(System.Int32,System.GCCollectionMode,System.Boolean)\n  parent: System.GC\n  langs:\n  - csharp\n  name: Collect(Int32, GCCollectionMode, Boolean)\n  nameWithType: GC.Collect(Int32, GCCollectionMode, Boolean)\n  fullName: GC.Collect(Int32, GCCollectionMode, Boolean)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <xref href=\"System.GCCollectionMode\"></xref> value, with a value specifying whether the collection should be blocking.\n  remarks: \"The following table summarizes the interaction of the `mode` and `blocking` parameters:  \\n  \\n|`mode`|`blocking` is `true`|`blocking` is `false`|  \\n|-|-|-|  \\n|<xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default>|A blocking collection is performed as soon as possible. If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished. If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.|A collection is performed as soon as possible. The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed. If a background collection is already in progress, the method returns immediately.|  \\n|<xref:System.GCCollectionMode.Optimized>|A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter. The garbage collector tries to provide optimal performance.|A collection may be performed, depending on the state of the garbage collector. The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed. The garbage collector tries to provide optimal performance. If a background collection is already in progress, the method returns immediately.|  \\n  \\n If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName> before calling the <xref:System.GC.Collect%2A> method.\"\n  syntax:\n    content: public static void Collect (int generation, GCCollectionMode mode, bool blocking);\n    parameters:\n    - id: generation\n      type: System.Int32\n      description: The number of the oldest generation to be garbage collected.\n    - id: mode\n      type: System.GCCollectionMode\n      description: An enumeration value that specifies whether the garbage collection is forced (<xref href=\"System.GCCollectionMode.Default\"></xref> or <xref href=\"System.GCCollectionMode.Forced\"></xref>) or optimized (<xref href=\"System.GCCollectionMode.Optimized\"></xref>).\n    - id: blocking\n      type: System.Boolean\n      description: '`true` to perform a blocking garbage collection; `false` to perform a background garbage collection where possible.'\n  overload: System.GC.Collect*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>generation</code> is not valid.  \\n  \\n -or-  \\n  \\n <code>mode</code> is not one of the <xref href=\\\"System.GCCollectionMode\\\"></xref> values.\"\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)\n  commentId: M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)\n  id: Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)\n  parent: System.GC\n  langs:\n  - csharp\n  name: Collect(Int32, GCCollectionMode, Boolean, Boolean)\n  nameWithType: GC.Collect(Int32, GCCollectionMode, Boolean, Boolean)\n  fullName: GC.Collect(Int32, GCCollectionMode, Boolean, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <xref href=\"System.GCCollectionMode\"></xref> value, with values that specify whether the collection should be blocking and compacting.\n  remarks: \"If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection. If `compacting` is `true`, it performs a blocking garbage collection.  \\n  \\n If `compacting` is `true`, the runtime compacts the small object heap (SOH). The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName>. Note that this includes all blocking garbage collections, not just full blocking garbage collections.  \\n  \\n You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.  \\n  \\n [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]\\n [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  \\n  \\n Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection. Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=fullName> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode?displayProperty=fullName> ensures that both the LOH and SOH are compacted.\"\n  syntax:\n    content: public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);\n    parameters:\n    - id: generation\n      type: System.Int32\n      description: The number of the oldest generation to be garbage collected.\n    - id: mode\n      type: System.GCCollectionMode\n      description: An enumeration value that specifies whether the garbage collection is forced (<xref href=\"System.GCCollectionMode.Default\"></xref> or <xref href=\"System.GCCollectionMode.Forced\"></xref>) or optimized (<xref href=\"System.GCCollectionMode.Optimized\"></xref>).\n    - id: blocking\n      type: System.Boolean\n      description: '`true` to perform a blocking garbage collection; `false` to perform a background garbage collection where possible.'\n    - id: compacting\n      type: System.Boolean\n      description: '`true` to compact the small object heap; `false` to sweep only.'\n  overload: System.GC.Collect*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.CollectionCount(System.Int32)\n  commentId: M:System.GC.CollectionCount(System.Int32)\n  id: CollectionCount(System.Int32)\n  parent: System.GC\n  langs:\n  - csharp\n  name: CollectionCount(Int32)\n  nameWithType: GC.CollectionCount(Int32)\n  fullName: GC.CollectionCount(Int32)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns the number of times garbage collection has occurred for the specified generation of objects.\n  remarks: If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method. Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently. Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>. The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value. If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.\n  syntax:\n    content: public static int CollectionCount (int generation);\n    parameters:\n    - id: generation\n      type: System.Int32\n      description: The generation of objects for which the garbage collection count is to be determined.\n    return:\n      type: System.Int32\n      description: The number of times garbage collection has occurred for the specified generation since the process was started.\n  overload: System.GC.CollectionCount*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>generation</code> is less than 0.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.EndNoGCRegion\n  commentId: M:System.GC.EndNoGCRegion\n  id: EndNoGCRegion\n  parent: System.GC\n  langs:\n  - csharp\n  name: EndNoGCRegion()\n  nameWithType: GC.EndNoGCRegion()\n  fullName: GC.EndNoGCRegion()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Ends the no GC region latency mode.\n  remarks: \"The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode. This occurs under any of the following conditions:  \\n  \\n-   The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously.  \\n  \\n-   The call to the <xref:System.GC.TryStartNoGCRegion%2A> method returned `false`.  \\n  \\n-   The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception.  \\n  \\n You can prevent an exception for any of these reasons by using code such as the following:  \\n  \\n [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]\\n [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static void EndNoGCRegion ();\n    parameters: []\n  overload: System.GC.EndNoGCRegion*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: \"The garbage collector is not in no GC region latency mode.  \\n  \\n -or-  \\n  \\n The no GC region latency mode was ended previously because a garbage collection was induced.  \\n  \\n -or-  \\n  \\n A memory allocation exceeded the amount specified in the call to the <xref href=\\\"System.GC.TryStartNoGCRegion(System.Int64)\\\"></xref> method.\"\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.GetAllocatedBytesForCurrentThread\n  commentId: M:System.GC.GetAllocatedBytesForCurrentThread\n  id: GetAllocatedBytesForCurrentThread\n  parent: System.GC\n  langs:\n  - csharp\n  name: GetAllocatedBytesForCurrentThread()\n  nameWithType: GC.GetAllocatedBytesForCurrentThread()\n  fullName: GC.GetAllocatedBytesForCurrentThread()\n  type: Method\n  assemblies:\n  - System.Runtime\n  namespace: System\n  syntax:\n    content: public static long GetAllocatedBytesForCurrentThread ();\n    parameters: []\n    return:\n      type: System.Int64\n      description: ''\n  overload: System.GC.GetAllocatedBytesForCurrentThread*\n  exceptions: []\n  version:\n  - netcore-2.0\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.GetGeneration(System.Object)\n  commentId: M:System.GC.GetGeneration(System.Object)\n  id: GetGeneration(System.Object)\n  parent: System.GC\n  langs:\n  - csharp\n  name: GetGeneration(Object)\n  nameWithType: GC.GetGeneration(Object)\n  fullName: GC.GetGeneration(Object)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns the current generation number of the specified object.\n  remarks: Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation. For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.\n  example:\n  - \"The following example demonstrates how to use the <xref:System.GC.GetGeneration%2A> method to determine the age of an object. The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.  \\n  \\n [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]\\n [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]\\n [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]\"\n  syntax:\n    content: public static int GetGeneration (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object that generation information is retrieved for.\n    return:\n      type: System.Int32\n      description: The current generation number of <code>obj</code>.\n  overload: System.GC.GetGeneration*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.GetGeneration(System.WeakReference)\n  commentId: M:System.GC.GetGeneration(System.WeakReference)\n  id: GetGeneration(System.WeakReference)\n  parent: System.GC\n  langs:\n  - csharp\n  name: GetGeneration(WeakReference)\n  nameWithType: GC.GetGeneration(WeakReference)\n  fullName: GC.GetGeneration(WeakReference)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns the current generation number of the target of a specified weak reference.\n  remarks: ''\n  example:\n  - \"The following example demonstrates the use of the <xref:System.GC.GetGeneration%2A> method to determine the age of a weak reference object.  \\n  \\n [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]\\n [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]\\n [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]\"\n  syntax:\n    content: public static int GetGeneration (WeakReference wo);\n    parameters:\n    - id: wo\n      type: System.WeakReference\n      description: A <xref href=\"System.WeakReference\"></xref> that refers to the target object whose generation number is to be determined.\n    return:\n      type: System.Int32\n      description: The current generation number of the target of <code>wo</code>.\n  overload: System.GC.GetGeneration*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: Garbage collection has already been performed on <code>wo</code>.\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.GetTotalMemory(System.Boolean)\n  commentId: M:System.GC.GetTotalMemory(System.Boolean)\n  id: GetTotalMemory(System.Boolean)\n  parent: System.GC\n  langs:\n  - csharp\n  name: GetTotalMemory(Boolean)\n  nameWithType: GC.GetTotalMemory(Boolean)\n  fullName: GC.GetTotalMemory(Boolean)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Retrieves the number of bytes currently thought to be allocated. A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.\n  remarks: If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects. The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles. The garbage collector does not guarantee that all inaccessible memory is collected.\n  example:\n  - \"The following example demonstrates how to use the <xref:System.GC.GetTotalMemory%2A> method to get and display the number of bytes currently allocated in managed memory.  \\n  \\n [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]\\n [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]\\n [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]\"\n  syntax:\n    content: public static long GetTotalMemory (bool forceFullCollection);\n    parameters:\n    - id: forceFullCollection\n      type: System.Boolean\n      description: '`true` to indicate that this method can wait for garbage collection to occur before returning; otherwise, `false`.'\n    return:\n      type: System.Int64\n      description: A number that is the best available approximation of the number of bytes currently allocated in managed memory.\n  overload: System.GC.GetTotalMemory*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.KeepAlive(System.Object)\n  commentId: M:System.GC.KeepAlive(System.Object)\n  id: KeepAlive(System.Object)\n  parent: System.GC\n  langs:\n  - csharp\n  name: KeepAlive(Object)\n  nameWithType: GC.KeepAlive(Object)\n  fullName: GC.KeepAlive(Object)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.\n  remarks: \"The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector. A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.  \\n  \\n This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called. Code this method at the end, not the beginning, of the range of instructions where `obj` must be available.  \\n  \\n The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.\"\n  example:\n  - \"The following code example creates an object at the beginning of its `Main` method and does not refer to the object again until the end, when the <xref:System.GC.KeepAlive%2A> method is called. The object persists for the 30-second duration of the `Main` method, despite calls to the <xref:System.GC.Collect%2A> and <xref:System.GC.WaitForPendingFinalizers%2A> methods.  \\n  \\n [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]\\n [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]\\n [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]\"\n  syntax:\n    content: public static void KeepAlive (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object to reference.\n  overload: System.GC.KeepAlive*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.MaxGeneration\n  commentId: P:System.GC.MaxGeneration\n  id: MaxGeneration\n  parent: System.GC\n  langs:\n  - csharp\n  name: MaxGeneration\n  nameWithType: GC.MaxGeneration\n  fullName: GC.MaxGeneration\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets the maximum number of generations that the system currently supports.\n  remarks: \"The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan. The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.  \\n  \\n The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory. Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.  \\n  \\n If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero.\"\n  example:\n  - \"The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.  \\n  \\n [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]\\n [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]\\n [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]\"\n  syntax:\n    content: >-\n      [get: System.Security.SecuritySafeCritical]\n\n      public static int MaxGeneration { get; }\n    return:\n      type: System.Int32\n      description: A value that ranges from zero to the maximum number of supported generations.\n  overload: System.GC.MaxGeneration*\n  exceptions: []\n  attributes:\n  - type: 'get: System.Security.SecuritySafeCritical'\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)\n  commentId: M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)\n  id: RegisterForFullGCNotification(System.Int32,System.Int32)\n  parent: System.GC\n  langs:\n  - csharp\n  name: RegisterForFullGCNotification(Int32, Int32)\n  nameWithType: GC.RegisterForFullGCNotification(Int32, Int32)\n  fullName: GC.RegisterForFullGCNotification(Int32, Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.\n  remarks: \"For each generation, the garbage collector sets a threshold for allocations into that generation. When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation. For example, if generation 2’s threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection. Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).  \\n  \\n The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs. The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.  \\n  \\n If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable. In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:  \\n  \\n-   You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries). As a result, when the garbage collection occurs, it is able to reclaim more memory.  \\n  \\n-   You monitor for the completion of a full garbage collection so that you can collect some statistics.  For example, you might want to measure the size of the heap at GC completion so that you know the size of live data. (After a full GC, the heap is at its smallest size.)  \\n  \\n For more information about what represents a full garbage collection, see [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md).  \\n  \\n When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed. This pattern resembles how the operating system monitors for low memory notifications.  \\n  \\n Use the following guidelines for specifying the `maxGenerationThreshold` and `largeObjectHeapThreshold` parameters:  \\n  \\n-   The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.  \\n  \\n     A larger threshold value provides more opportunities for the runtime to check for an approaching collection. This increases the likelihood that you will be notified. However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.  \\n  \\n     When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.  \\n  \\n-   The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.\"\n  example:\n  - \"The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification. This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.  \\n  \\n [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]\\n [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]\\n [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);\n    parameters:\n    - id: maxGenerationThreshold\n      type: System.Int32\n      description: A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.\n    - id: largeObjectHeapThreshold\n      type: System.Int32\n      description: A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.\n  overload: System.GC.RegisterForFullGCNotification*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>maxGenerationThreshold</code> or <code>largeObjectHeapThreshold</code> is not between 1 and 99.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.RemoveMemoryPressure(System.Int64)\n  commentId: M:System.GC.RemoveMemoryPressure(System.Int64)\n  id: RemoveMemoryPressure(System.Int64)\n  parent: System.GC\n  langs:\n  - csharp\n  name: RemoveMemoryPressure(Int64)\n  nameWithType: GC.RemoveMemoryPressure(Int64)\n  fullName: GC.RemoveMemoryPressure(Int64)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.\n  remarks: \"In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated. If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection. The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.  \\n  \\n In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method. Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.  \\n  \\n In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.  \\n  \\n> [!CAUTION]\\n>  You must ensure that you remove exactly the amount of pressure you add. Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static void RemoveMemoryPressure (long bytesAllocated);\n    parameters:\n    - id: bytesAllocated\n      type: System.Int64\n      description: The amount of unmanaged memory that has been released.\n  overload: System.GC.RemoveMemoryPressure*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>bytesAllocated</code> is less than or equal to 0.  \\n  \\n -or-  \\n  \\n On a 32-bit computer, <code>bytesAllocated</code> is larger than <xref href=\\\"System.Int32.MaxValue\\\"></xref>.\"\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.ReRegisterForFinalize(System.Object)\n  commentId: M:System.GC.ReRegisterForFinalize(System.Object)\n  id: ReRegisterForFinalize(System.Object)\n  parent: System.GC\n  langs:\n  - csharp\n  name: ReRegisterForFinalize(Object)\n  nameWithType: GC.ReRegisterForFinalize(Object)\n  fullName: GC.ReRegisterForFinalize(Object)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Requests that the system call the finalizer for the specified object for which <xref href=\"System.GC.SuppressFinalize(System.Object)\"></xref> has previously been called.\n  remarks: \"The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object. The `obj` parameter must be the caller of this method.  \\n  \\n Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer.  \\n  \\n By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method.  \\n  \\n A finalizer can use this method to resurrect itself or an object that it references.\"\n  example:\n  - \"The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.  \\n  \\n [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]\\n [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]\\n [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]\"\n  syntax:\n    content: public static void ReRegisterForFinalize (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object that a finalizer must be called for.\n  overload: System.GC.ReRegisterForFinalize*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>obj</code> is `null`.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.SuppressFinalize(System.Object)\n  commentId: M:System.GC.SuppressFinalize(System.Object)\n  id: SuppressFinalize(System.Object)\n  parent: System.GC\n  langs:\n  - csharp\n  name: SuppressFinalize(Object)\n  nameWithType: GC.SuppressFinalize(Object)\n  fullName: GC.SuppressFinalize(Object)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Requests that the common language runtime not call the finalizer for the specified object.\n  remarks: \"This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers. A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=fullName> method, is used to release unmanaged resources before an object is garbage-collected. If `obj` does not have a finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect.  \\n  \\n Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=fullName> on an object that does not require it. Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=fullName> implementation.\"\n  example:\n  - \"The following example demonstrates how to use the <xref:System.GC.SuppressFinalize%2A> method in a resource class to prevent a redundant garbage collection from being called. The example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) to free both managed resources (that is, objects that implement <xref:System.IDisposable>) and unmanaged resources.  \\n  \\n [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]\\n [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]\"\n  syntax:\n    content: public static void SuppressFinalize (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The object whose finalizer must not be executed.\n  overload: System.GC.SuppressFinalize*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>obj</code> is `null`.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.TryStartNoGCRegion(System.Int64)\n  commentId: M:System.GC.TryStartNoGCRegion(System.Int64)\n  id: TryStartNoGCRegion(System.Int64)\n  parent: System.GC\n  langs:\n  - csharp\n  name: TryStartNoGCRegion(Int64)\n  nameWithType: GC.TryStartNoGCRegion(Int64)\n  fullName: GC.TryStartNoGCRegion(Int64)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.\n  remarks: \"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.  If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory. The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap).  \\n  \\n `totalSize` must be large enough to handle all memory allocations that occur in the critical path. This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.  \\n  \\n> [!IMPORTANT]\\n>  You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.  \\n  \\n You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static bool TryStartNoGCRegion (long totalSize);\n    parameters:\n    - id: totalSize\n      type: System.Int64\n      description: The amount of memory in bytes to allocate without triggering a garbage collection. It must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.\n    return:\n      type: System.Boolean\n      description: '`true` if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, `false`.'\n  overload: System.GC.TryStartNoGCRegion*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>totalSize</code> exceeds the ephemeral segment size.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The process is already in no GC region latency mode.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)\n  commentId: M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)\n  id: TryStartNoGCRegion(System.Int64,System.Boolean)\n  parent: System.GC\n  langs:\n  - csharp\n  name: TryStartNoGCRegion(Int64, Boolean)\n  nameWithType: GC.TryStartNoGCRegion(Int64, Boolean)\n  fullName: GC.TryStartNoGCRegion(Int64, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.\n  remarks: \"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.  If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`. The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 * `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap).  \\n  \\n `totalSize` must be large enough to handle all memory allocations that occur in the critical path. This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.  \\n  \\n Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`. It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.  \\n  \\n> [!IMPORTANT]\\n>  You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.  \\n  \\n You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);\n    parameters:\n    - id: totalSize\n      type: System.Int64\n      description: The amount of memory in bytes to allocate without triggering a garbage collection. It must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.\n    - id: disallowFullBlockingGC\n      type: System.Boolean\n      description: '`true` to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <code>totalSize</code> bytes; otherwise, `false`.'\n    return:\n      type: System.Boolean\n      description: '`true` if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, `false`.'\n  overload: System.GC.TryStartNoGCRegion*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>totalSize</code> exceeds the ephemeral segment size.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The process is already in no GC region latency mode.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.TryStartNoGCRegion(System.Int64,System.Int64)\n  commentId: M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)\n  id: TryStartNoGCRegion(System.Int64,System.Int64)\n  parent: System.GC\n  langs:\n  - csharp\n  name: TryStartNoGCRegion(Int64, Int64)\n  nameWithType: GC.TryStartNoGCRegion(Int64, Int64)\n  fullName: GC.TryStartNoGCRegion(Int64, Int64)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.\n  remarks: \"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.  If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory. The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).  \\n  \\n `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH. This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.  \\n  \\n> [!IMPORTANT]\\n>  You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.  \\n  \\n You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static bool TryStartNoGCRegion (long totalSize, long lohSize);\n    parameters:\n    - id: totalSize\n      type: System.Int64\n      description: The amount of memory in bytes to allocate without triggering a garbage collection. <code>totalSize</code> –<code>lohSize</code> must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.\n    - id: lohSize\n      type: System.Int64\n      description: The number of bytes in <code>totalSize</code> to use for large object heap (LOH) allocations.\n    return:\n      type: System.Boolean\n      description: '`true` if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, `false`.'\n  overload: System.GC.TryStartNoGCRegion*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>totalSize</code> – <code>lohSize</code> exceeds the ephemeral segment size.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The process is already in no GC region latency mode.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)\n  commentId: M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)\n  id: TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)\n  parent: System.GC\n  langs:\n  - csharp\n  name: TryStartNoGCRegion(Int64, Int64, Boolean)\n  nameWithType: GC.TryStartNoGCRegion(Int64, Int64, Boolean)\n  fullName: GC.TryStartNoGCRegion(Int64, Int64, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.\n  remarks: \"The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.  If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`. The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).  \\n  \\n `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH. This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.  \\n  \\n Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`. It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.  \\n  \\n> [!IMPORTANT]\\n>  You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode. In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.  \\n  \\n You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);\n    parameters:\n    - id: totalSize\n      type: System.Int64\n      description: The amount of memory in bytes to allocate without triggering a garbage collection. <code>totalSize</code> –<code>lohSize</code> must be less than or equal to the size of an ephemeral segment. For information on the size of an ephemeral segement, see the \"Ephemeral generations and segments\" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.\n    - id: lohSize\n      type: System.Int64\n      description: The number of bytes in <code>totalSize</code> to use for large object heap (LOH) allocations.\n    - id: disallowFullBlockingGC\n      type: System.Boolean\n      description: '`true` to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, `false`.'\n    return:\n      type: System.Boolean\n      description: '`true` if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, `false`.'\n  overload: System.GC.TryStartNoGCRegion*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>totalSize</code> – <code>lohSize</code> exceeds the ephemeral segment size.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The process is already in no GC region latency mode.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.WaitForFullGCApproach\n  commentId: M:System.GC.WaitForFullGCApproach\n  id: WaitForFullGCApproach\n  parent: System.GC\n  langs:\n  - csharp\n  name: WaitForFullGCApproach()\n  nameWithType: GC.WaitForFullGCApproach()\n  fullName: GC.WaitForFullGCApproach()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.\n  remarks: \"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.  \\n  \\n When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method. Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.  \\n  \\n This method waits indefinitely for a garbage collection notification to be obtained. If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=fullName> method overload. If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.  \\n  \\n You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection. Calling this method alone causes indeterminate results.\"\n  example:\n  - \"The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching. Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCApproachNotify` is called to perform actions in response to the approaching collection. This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.  \\n  \\n [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]\\n [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]\\n [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static GCNotificationStatus WaitForFullGCApproach ();\n    parameters: []\n    return:\n      type: System.GCNotificationStatus\n      description: The status of the registered garbage collection notification.\n  overload: System.GC.WaitForFullGCApproach*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.WaitForFullGCApproach(System.Int32)\n  commentId: M:System.GC.WaitForFullGCApproach(System.Int32)\n  id: WaitForFullGCApproach(System.Int32)\n  parent: System.GC\n  langs:\n  - csharp\n  name: WaitForFullGCApproach(Int32)\n  nameWithType: GC.WaitForFullGCApproach(Int32)\n  fullName: GC.WaitForFullGCApproach(Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.\n  remarks: \"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.  \\n  \\n Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`. If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.  \\n  \\n When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method. Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.  \\n  \\n You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.  \\n  \\n You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection. Calling this method alone causes indeterminate results.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The length of time to wait before a notification status can be obtained. Specify -1 to wait indefinitely.\n    return:\n      type: System.GCNotificationStatus\n      description: The status of the registered garbage collection notification.\n  overload: System.GC.WaitForFullGCApproach*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>millisecondsTimeout</code> must be either non-negative or less than or equal to <xref href=\"System.Int32.MaxValue\"></xref> or -1.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.WaitForFullGCComplete\n  commentId: M:System.GC.WaitForFullGCComplete\n  id: WaitForFullGCComplete\n  parent: System.GC\n  langs:\n  - csharp\n  name: WaitForFullGCComplete()\n  nameWithType: GC.WaitForFullGCComplete()\n  fullName: GC.WaitForFullGCComplete()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.\n  remarks: \"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.  \\n  \\n When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.  \\n  \\n This method waits indefinitely for a garbage collection notification to be obtained. If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=fullName> method overload. If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.  \\n  \\n This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection. Calling this method alone can produce indeterminate results.\"\n  example:\n  - \"The following example shows how to use this method to determine whether a full garbage collection has completed. Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCCompletedNotify` is called to perform actions in response to the completed collection. This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.  \\n  \\n [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]\\n [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]\\n [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static GCNotificationStatus WaitForFullGCComplete ();\n    parameters: []\n    return:\n      type: System.GCNotificationStatus\n      description: The status of the registered garbage collection notification.\n  overload: System.GC.WaitForFullGCComplete*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.WaitForFullGCComplete(System.Int32)\n  commentId: M:System.GC.WaitForFullGCComplete(System.Int32)\n  id: WaitForFullGCComplete(System.Int32)\n  parent: System.GC\n  langs:\n  - csharp\n  name: WaitForFullGCComplete(Int32)\n  nameWithType: GC.WaitForFullGCComplete(Int32)\n  fullName: GC.WaitForFullGCComplete(Int32)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.\n  remarks: \"Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method. You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.  \\n  \\n Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`. If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.  \\n  \\n When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.  \\n  \\n You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.  \\n  \\n This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection. Calling this method alone can produce indeterminate results.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);\n    parameters:\n    - id: millisecondsTimeout\n      type: System.Int32\n      description: The length of time to wait before a notification status can be obtained. Specify -1 to wait indefinitely.\n    return:\n      type: System.GCNotificationStatus\n      description: The status of the registered garbage collection notification.\n  overload: System.GC.WaitForFullGCComplete*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <code>millisecondsTimeout</code> must be either non-negative or less than or equal to <xref href=\"System.Int32.MaxValue\"></xref> or -1.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.GC.WaitForPendingFinalizers\n  commentId: M:System.GC.WaitForPendingFinalizers\n  id: WaitForPendingFinalizers\n  parent: System.GC\n  langs:\n  - csharp\n  name: WaitForPendingFinalizers()\n  nameWithType: GC.WaitForPendingFinalizers()\n  fullName: GC.WaitForPendingFinalizers()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.\n  remarks: \"When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements. If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization. The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list. This method blocks until all finalizers have run to completion.  \\n  \\n The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate. However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress. For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.\"\n  example:\n  - \"The following example demonstrates how to use the <xref:System.GC.WaitForPendingFinalizers%2A> method to suspend the current thread until finalization of all the collected objects is complete.  \\n  \\n [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]\\n [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]\\n [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]\"\n  syntax:\n    content: public static void WaitForPendingFinalizers ();\n    parameters: []\n  overload: System.GC.WaitForPendingFinalizers*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.InvalidOperationException\n  parent: System\n  isExternal: false\n  name: InvalidOperationException\n  nameWithType: InvalidOperationException\n  fullName: System.InvalidOperationException\n- uid: System.ArgumentException\n  parent: System\n  isExternal: false\n  name: ArgumentException\n  nameWithType: ArgumentException\n  fullName: System.ArgumentException\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.GC.AddMemoryPressure(System.Int64)\n  parent: System.GC\n  isExternal: false\n  name: AddMemoryPressure(Int64)\n  nameWithType: GC.AddMemoryPressure(Int64)\n  fullName: GC.AddMemoryPressure(Int64)\n- uid: System.Int64\n  parent: System\n  isExternal: false\n  name: Int64\n  nameWithType: Int64\n  fullName: System.Int64\n- uid: System.GC.CancelFullGCNotification\n  parent: System.GC\n  isExternal: false\n  name: CancelFullGCNotification()\n  nameWithType: GC.CancelFullGCNotification()\n  fullName: GC.CancelFullGCNotification()\n- uid: System.GC.Collect\n  parent: System.GC\n  isExternal: false\n  name: Collect()\n  nameWithType: GC.Collect()\n  fullName: GC.Collect()\n- uid: System.GC.Collect(System.Int32)\n  parent: System.GC\n  isExternal: false\n  name: Collect(Int32)\n  nameWithType: GC.Collect(Int32)\n  fullName: GC.Collect(Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.GC.Collect(System.Int32,System.GCCollectionMode)\n  parent: System.GC\n  isExternal: false\n  name: Collect(Int32, GCCollectionMode)\n  nameWithType: GC.Collect(Int32, GCCollectionMode)\n  fullName: GC.Collect(Int32, GCCollectionMode)\n- uid: System.GCCollectionMode\n  parent: System\n  isExternal: false\n  name: GCCollectionMode\n  nameWithType: GCCollectionMode\n  fullName: System.GCCollectionMode\n- uid: System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)\n  parent: System.GC\n  isExternal: false\n  name: Collect(Int32, GCCollectionMode, Boolean)\n  nameWithType: GC.Collect(Int32, GCCollectionMode, Boolean)\n  fullName: GC.Collect(Int32, GCCollectionMode, Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)\n  parent: System.GC\n  isExternal: false\n  name: Collect(Int32, GCCollectionMode, Boolean, Boolean)\n  nameWithType: GC.Collect(Int32, GCCollectionMode, Boolean, Boolean)\n  fullName: GC.Collect(Int32, GCCollectionMode, Boolean, Boolean)\n- uid: System.GC.CollectionCount(System.Int32)\n  parent: System.GC\n  isExternal: false\n  name: CollectionCount(Int32)\n  nameWithType: GC.CollectionCount(Int32)\n  fullName: GC.CollectionCount(Int32)\n- uid: System.GC.EndNoGCRegion\n  parent: System.GC\n  isExternal: false\n  name: EndNoGCRegion()\n  nameWithType: GC.EndNoGCRegion()\n  fullName: GC.EndNoGCRegion()\n- uid: System.GC.GetAllocatedBytesForCurrentThread\n  parent: System.GC\n  isExternal: false\n  name: GetAllocatedBytesForCurrentThread()\n  nameWithType: GC.GetAllocatedBytesForCurrentThread()\n  fullName: GC.GetAllocatedBytesForCurrentThread()\n- uid: System.GC.GetGeneration(System.Object)\n  parent: System.GC\n  isExternal: false\n  name: GetGeneration(Object)\n  nameWithType: GC.GetGeneration(Object)\n  fullName: GC.GetGeneration(Object)\n- uid: System.GC.GetGeneration(System.WeakReference)\n  parent: System.GC\n  isExternal: false\n  name: GetGeneration(WeakReference)\n  nameWithType: GC.GetGeneration(WeakReference)\n  fullName: GC.GetGeneration(WeakReference)\n- uid: System.WeakReference\n  parent: System\n  isExternal: false\n  name: WeakReference\n  nameWithType: WeakReference\n  fullName: System.WeakReference\n- uid: System.GC.GetTotalMemory(System.Boolean)\n  parent: System.GC\n  isExternal: false\n  name: GetTotalMemory(Boolean)\n  nameWithType: GC.GetTotalMemory(Boolean)\n  fullName: GC.GetTotalMemory(Boolean)\n- uid: System.GC.KeepAlive(System.Object)\n  parent: System.GC\n  isExternal: false\n  name: KeepAlive(Object)\n  nameWithType: GC.KeepAlive(Object)\n  fullName: GC.KeepAlive(Object)\n- uid: System.GC.MaxGeneration\n  parent: System.GC\n  isExternal: false\n  name: MaxGeneration\n  nameWithType: GC.MaxGeneration\n  fullName: GC.MaxGeneration\n- uid: System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)\n  parent: System.GC\n  isExternal: false\n  name: RegisterForFullGCNotification(Int32, Int32)\n  nameWithType: GC.RegisterForFullGCNotification(Int32, Int32)\n  fullName: GC.RegisterForFullGCNotification(Int32, Int32)\n- uid: System.GC.RemoveMemoryPressure(System.Int64)\n  parent: System.GC\n  isExternal: false\n  name: RemoveMemoryPressure(Int64)\n  nameWithType: GC.RemoveMemoryPressure(Int64)\n  fullName: GC.RemoveMemoryPressure(Int64)\n- uid: System.GC.ReRegisterForFinalize(System.Object)\n  parent: System.GC\n  isExternal: false\n  name: ReRegisterForFinalize(Object)\n  nameWithType: GC.ReRegisterForFinalize(Object)\n  fullName: GC.ReRegisterForFinalize(Object)\n- uid: System.GC.SuppressFinalize(System.Object)\n  parent: System.GC\n  isExternal: false\n  name: SuppressFinalize(Object)\n  nameWithType: GC.SuppressFinalize(Object)\n  fullName: GC.SuppressFinalize(Object)\n- uid: System.GC.TryStartNoGCRegion(System.Int64)\n  parent: System.GC\n  isExternal: false\n  name: TryStartNoGCRegion(Int64)\n  nameWithType: GC.TryStartNoGCRegion(Int64)\n  fullName: GC.TryStartNoGCRegion(Int64)\n- uid: System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)\n  parent: System.GC\n  isExternal: false\n  name: TryStartNoGCRegion(Int64, Boolean)\n  nameWithType: GC.TryStartNoGCRegion(Int64, Boolean)\n  fullName: GC.TryStartNoGCRegion(Int64, Boolean)\n- uid: System.GC.TryStartNoGCRegion(System.Int64,System.Int64)\n  parent: System.GC\n  isExternal: false\n  name: TryStartNoGCRegion(Int64, Int64)\n  nameWithType: GC.TryStartNoGCRegion(Int64, Int64)\n  fullName: GC.TryStartNoGCRegion(Int64, Int64)\n- uid: System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)\n  parent: System.GC\n  isExternal: false\n  name: TryStartNoGCRegion(Int64, Int64, Boolean)\n  nameWithType: GC.TryStartNoGCRegion(Int64, Int64, Boolean)\n  fullName: GC.TryStartNoGCRegion(Int64, Int64, Boolean)\n- uid: System.GC.WaitForFullGCApproach\n  parent: System.GC\n  isExternal: false\n  name: WaitForFullGCApproach()\n  nameWithType: GC.WaitForFullGCApproach()\n  fullName: GC.WaitForFullGCApproach()\n- uid: System.GCNotificationStatus\n  parent: System\n  isExternal: false\n  name: GCNotificationStatus\n  nameWithType: GCNotificationStatus\n  fullName: System.GCNotificationStatus\n- uid: System.GC.WaitForFullGCApproach(System.Int32)\n  parent: System.GC\n  isExternal: false\n  name: WaitForFullGCApproach(Int32)\n  nameWithType: GC.WaitForFullGCApproach(Int32)\n  fullName: GC.WaitForFullGCApproach(Int32)\n- uid: System.GC.WaitForFullGCComplete\n  parent: System.GC\n  isExternal: false\n  name: WaitForFullGCComplete()\n  nameWithType: GC.WaitForFullGCComplete()\n  fullName: GC.WaitForFullGCComplete()\n- uid: System.GC.WaitForFullGCComplete(System.Int32)\n  parent: System.GC\n  isExternal: false\n  name: WaitForFullGCComplete(Int32)\n  nameWithType: GC.WaitForFullGCComplete(Int32)\n  fullName: GC.WaitForFullGCComplete(Int32)\n- uid: System.GC.WaitForPendingFinalizers\n  parent: System.GC\n  isExternal: false\n  name: WaitForPendingFinalizers()\n  nameWithType: GC.WaitForPendingFinalizers()\n  fullName: GC.WaitForPendingFinalizers()\n- uid: System.GC.TryStartNoGCRegion*\n  parent: System.GC\n  isExternal: false\n  name: TryStartNoGCRegion\n  nameWithType: GC.TryStartNoGCRegion\n  fullName: GC.TryStartNoGCRegion\n  monikers:\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.AddMemoryPressure*\n  parent: System.GC\n  isExternal: false\n  name: AddMemoryPressure\n  nameWithType: GC.AddMemoryPressure\n  fullName: GC.AddMemoryPressure\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.CancelFullGCNotification*\n  parent: System.GC\n  isExternal: false\n  name: CancelFullGCNotification\n  nameWithType: GC.CancelFullGCNotification\n  fullName: GC.CancelFullGCNotification\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.Collect*\n  parent: System.GC\n  isExternal: false\n  name: Collect\n  nameWithType: GC.Collect\n  fullName: GC.Collect\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.CollectionCount*\n  parent: System.GC\n  isExternal: false\n  name: CollectionCount\n  nameWithType: GC.CollectionCount\n  fullName: GC.CollectionCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.EndNoGCRegion*\n  parent: System.GC\n  isExternal: false\n  name: EndNoGCRegion\n  nameWithType: GC.EndNoGCRegion\n  fullName: GC.EndNoGCRegion\n  monikers:\n  - netcore-2.0\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.GetAllocatedBytesForCurrentThread*\n  parent: System.GC\n  isExternal: false\n  name: GetAllocatedBytesForCurrentThread\n  nameWithType: GC.GetAllocatedBytesForCurrentThread\n  fullName: GC.GetAllocatedBytesForCurrentThread\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.GetGeneration*\n  parent: System.GC\n  isExternal: false\n  name: GetGeneration\n  nameWithType: GC.GetGeneration\n  fullName: GC.GetGeneration\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.GetTotalMemory*\n  parent: System.GC\n  isExternal: false\n  name: GetTotalMemory\n  nameWithType: GC.GetTotalMemory\n  fullName: GC.GetTotalMemory\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.KeepAlive*\n  parent: System.GC\n  isExternal: false\n  name: KeepAlive\n  nameWithType: GC.KeepAlive\n  fullName: GC.KeepAlive\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.MaxGeneration*\n  parent: System.GC\n  isExternal: false\n  name: MaxGeneration\n  nameWithType: GC.MaxGeneration\n  fullName: GC.MaxGeneration\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.RegisterForFullGCNotification*\n  parent: System.GC\n  isExternal: false\n  name: RegisterForFullGCNotification\n  nameWithType: GC.RegisterForFullGCNotification\n  fullName: GC.RegisterForFullGCNotification\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.RemoveMemoryPressure*\n  parent: System.GC\n  isExternal: false\n  name: RemoveMemoryPressure\n  nameWithType: GC.RemoveMemoryPressure\n  fullName: GC.RemoveMemoryPressure\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.ReRegisterForFinalize*\n  parent: System.GC\n  isExternal: false\n  name: ReRegisterForFinalize\n  nameWithType: GC.ReRegisterForFinalize\n  fullName: GC.ReRegisterForFinalize\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.SuppressFinalize*\n  parent: System.GC\n  isExternal: false\n  name: SuppressFinalize\n  nameWithType: GC.SuppressFinalize\n  fullName: GC.SuppressFinalize\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.WaitForFullGCApproach*\n  parent: System.GC\n  isExternal: false\n  name: WaitForFullGCApproach\n  nameWithType: GC.WaitForFullGCApproach\n  fullName: GC.WaitForFullGCApproach\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.WaitForFullGCComplete*\n  parent: System.GC\n  isExternal: false\n  name: WaitForFullGCComplete\n  nameWithType: GC.WaitForFullGCComplete\n  fullName: GC.WaitForFullGCComplete\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.GC.WaitForPendingFinalizers*\n  parent: System.GC\n  isExternal: false\n  name: WaitForPendingFinalizers\n  nameWithType: GC.WaitForPendingFinalizers\n  fullName: GC.WaitForPendingFinalizers\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/GC.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n"}