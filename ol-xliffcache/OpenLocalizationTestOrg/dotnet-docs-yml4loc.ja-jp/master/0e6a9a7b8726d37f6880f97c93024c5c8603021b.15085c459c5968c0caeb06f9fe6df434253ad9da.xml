{"nodes":[{"content":"Limits the number of threads that can access a resource or pool of resources concurrently.","nodes":[{"pos":[0,90],"content":"Limits the number of threads that can access a resource or pool of resources concurrently.","nodes":[{"content":"Limits the number of threads that can access a resource or pool of resources concurrently.","pos":[0,90]}]}],"pos":[1365,1456],"yaml":true},{"content":"Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources. Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.  \n  \n The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore. When the count is zero, subsequent requests block until other threads release the semaphore. When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.  \n  \n There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.  \n  \n A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly. To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.  \n  \n The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>. It is the programmer's responsibility to ensure that threads do not release the semaphore too many times. For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore. If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed. The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.  \n  \n Semaphores are of two types: local semaphores and named system semaphores. If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name. Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.  \n  \n A local semaphore exists only within your process. It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object. Each <xref:System.Threading.Semaphore> object is a separate local semaphore.","nodes":[{"pos":[0,350],"content":"Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources. Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.","nodes":[{"content":"Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources. Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.","pos":[0,350],"nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> class to control access to a pool of resources.","pos":[0,89],"source":"Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources."},{"content":"Threads enter the semaphore by calling the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method, which is inherited from the <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle&gt;</ph> class, and release the semaphore by calling the <ph id=\"ph3\">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.","pos":[90,350],"source":" Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method."}]}]},{"pos":[357,706],"content":"The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore. When the count is zero, subsequent requests block until other threads release the semaphore. When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.","nodes":[{"content":"The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore. When the count is zero, subsequent requests block until other threads release the semaphore. When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.","pos":[0,349],"nodes":[{"content":"The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore.","pos":[0,134]},{"content":"When the count is zero, subsequent requests block until other threads release the semaphore.","pos":[135,227]},{"content":"When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.","pos":[228,349]}]}]},{"pos":[713,810],"content":"There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.","nodes":[{"content":"There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.","pos":[0,97]}]},{"pos":[817,1246],"content":"A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly. To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.","nodes":[{"content":"A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly. To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.","pos":[0,429],"nodes":[{"content":"A thread can enter the semaphore multiple times, by calling the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method repeatedly.","pos":[0,128],"source":"A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly."},{"content":"To release some or all of these entries, the thread can call the parameterless <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.Release&gt;</ph> method overload multiple times, or it can call the <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore.Release%28System.Int32%29&gt;</ph> method overload that specifies the number of entries to be released.","pos":[129,429],"source":" To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released."}]}]},{"pos":[1253,1962],"content":"The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>. It is the programmer's responsibility to ensure that threads do not release the semaphore too many times. For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore. If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed. The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.","nodes":[{"content":"The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>. It is the programmer's responsibility to ensure that threads do not release the semaphore too many times. For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore. If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed. The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.","pos":[0,709],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> class does not enforce thread identity on calls to <ph id=\"ph2\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>.","pos":[0,183],"source":"The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>."},{"content":"It is the programmer's responsibility to ensure that threads do not release the semaphore too many times.","pos":[184,289]},{"content":"For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore.","pos":[290,407]},{"content":"If a programming error in thread B causes it to call <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> twice, both calls succeed.","pos":[408,532],"source":" If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed."},{"content":"The count on the semaphore is full, and when thread A eventually calls <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph>, a <ph id=\"ph2\">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown.","pos":[533,709],"source":" The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown."}]}]},{"pos":[1969,2571],"content":"Semaphores are of two types: local semaphores and named system semaphores. If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name. Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.","nodes":[{"content":"Semaphores are of two types: local semaphores and named system semaphores. If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name. Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.","pos":[0,602],"nodes":[{"content":"Semaphores are of two types: local semaphores and named system semaphores.","pos":[0,74]},{"content":"If you create a <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name.","pos":[75,238],"source":" If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name."},{"content":"Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes.","pos":[239,367]},{"content":"You can create multiple <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore, and you can use the <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method to open an existing named system semaphore.","pos":[368,602],"source":" You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore."}]}]},{"pos":[2578,2826],"content":"A local semaphore exists only within your process. It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object. Each <xref:System.Threading.Semaphore> object is a separate local semaphore.","nodes":[{"content":"A local semaphore exists only within your process. It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object. Each <xref:System.Threading.Semaphore> object is a separate local semaphore.","pos":[0,248],"nodes":[{"content":"A local semaphore exists only within your process.","pos":[0,50]},{"content":"It can be used by any thread in your process that has a reference to the local <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> object.","pos":[51,171],"source":" It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object."},{"content":"Each <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> object is a separate local semaphore.","pos":[172,248],"source":" Each <xref:System.Threading.Semaphore> object is a separate local semaphore."}]}]}],"pos":[1467,4308],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Threading.Semaphore\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries.","nodes":[{"pos":[0,175],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Semaphore\"&gt;&lt;/xref&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries.","source":"Initializes a new instance of the <xref href=\"System.Threading.Semaphore\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries."}],"pos":[10026,10202],"yaml":true},{"content":"This constructor initializes an unnamed semaphore. All threads that use an instance of such a semaphore must have references to the instance.  \n  \n If `initialCount` is less than `maximumCount`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times. If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for `maximumCount` and `initialCount`.","nodes":[{"pos":[0,141],"content":"This constructor initializes an unnamed semaphore. All threads that use an instance of such a semaphore must have references to the instance.","nodes":[{"content":"This constructor initializes an unnamed semaphore. All threads that use an instance of such a semaphore must have references to the instance.","pos":[0,141],"nodes":[{"content":"This constructor initializes an unnamed semaphore.","pos":[0,50]},{"content":"All threads that use an instance of such a semaphore must have references to the instance.","pos":[51,141]}]}]},{"pos":[148,488],"content":"If `initialCount` is less than `maximumCount`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times. If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for `maximumCount` and `initialCount`.","nodes":[{"content":"If <ph id=\"ph1\">`initialCount`</ph> is less than <ph id=\"ph2\">`maximumCount`</ph>, the effect is the same as if the current thread had called <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id=\"ph4\">`maximumCount`</ph> minus <ph id=\"ph5\">`initialCount`</ph>) times.","pos":[0,196],"source":"If `initialCount` is less than `maximumCount`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times."},{"content":"If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for <ph id=\"ph1\">`maximumCount`</ph> and <ph id=\"ph2\">`initialCount`</ph>.","pos":[197,340],"source":" If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for `maximumCount` and `initialCount`."}]}],"pos":[10213,10706],"yaml":true,"extradata":"MT"},{"content":"The initial number of requests for the semaphore that can be granted concurrently.","nodes":[{"pos":[0,82],"content":"The initial number of requests for the semaphore that can be granted concurrently.","nodes":[{"content":"The initial number of requests for the semaphore that can be granted concurrently.","pos":[0,82]}]}],"pos":[12138,12221],"yaml":true},{"content":"The maximum number of requests for the semaphore that can be granted concurrently.","nodes":[{"pos":[0,82],"content":"The maximum number of requests for the semaphore that can be granted concurrently.","nodes":[{"content":"The maximum number of requests for the semaphore that can be granted concurrently.","pos":[0,82]}]}],"pos":[12288,12371],"yaml":true},{"content":"<code>initialCount</code> is greater than <code>maximumCount</code>.","nodes":[{"pos":[0,68],"content":"<ph id=\"ph1\">&lt;code&gt;initialCount&lt;/code&gt;</ph> is greater than <ph id=\"ph2\">&lt;code&gt;maximumCount&lt;/code&gt;</ph>.","source":"<code>initialCount</code> is greater than <code>maximumCount</code>."}],"pos":[12525,12594],"yaml":true},{"content":"<code>maximumCount</code> is less than 1.  \n  \n -or-  \n  \n <code>initialCount</code> is less than 0.","nodes":[{"pos":[0,41],"content":"<ph id=\"ph1\">&lt;code&gt;maximumCount&lt;/code&gt;</ph> is less than 1.","source":"<code>maximumCount</code> is less than 1."},{"pos":[48,52],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[59,100],"content":"<ph id=\"ph1\">&lt;code&gt;initialCount&lt;/code&gt;</ph> is less than 0.","source":"<code>initialCount</code> is less than 0."}],"pos":[12708,12815],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Threading.Semaphore\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.","nodes":[{"pos":[0,240],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Semaphore\"&gt;&lt;/xref&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.","source":"Initializes a new instance of the <xref href=\"System.Threading.Semaphore\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object."}],"pos":[14416,14657],"yaml":true},{"content":"This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.  \n  \n If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`. If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions. If you need to determine whether or not a named system semaphore was created, use the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> constructor overload instead.  \n  \n> [!IMPORTANT]\n>  When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`. If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times. However, with this constructor overload there is no way to determine whether a named system semaphore was created.  \n  \n If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.  \n  \n Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.  \n  \n If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method. The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.","nodes":[{"pos":[0,227],"content":"This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.","nodes":[{"content":"This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.","pos":[0,227],"nodes":[{"content":"This constructor initializes a <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.","pos":[0,113],"source":"This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore."},{"content":"You can create multiple <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.","pos":[114,227],"source":" You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore."}]}]},{"pos":[234,751],"content":"If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`. If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions. If you need to determine whether or not a named system semaphore was created, use the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> constructor overload instead.","nodes":[{"content":"If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id=\"ph1\">`initialCount`</ph> and <ph id=\"ph2\">`maximumCount`</ph>.","pos":[0,148],"source":"If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`."},{"content":"If the named system semaphore already exists, <ph id=\"ph1\">`initialCount`</ph> and <ph id=\"ph2\">`maximumCount`</ph> are not used, although invalid values still cause exceptions.","pos":[149,290],"source":" If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions."},{"content":"If you need to determine whether or not a named system semaphore was created, use the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29&gt;</ph> constructor overload instead.","pos":[291,517],"source":" If you need to determine whether or not a named system semaphore was created, use the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> constructor overload instead."}]},{"pos":[759,1261],"content":"[!IMPORTANT]\n When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`. If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times. However, with this constructor overload there is no way to determine whether a named system semaphore was created.","leadings":["","> "],"nodes":[{"content":" When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`. If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times. However, with this constructor overload there is no way to determine whether a named system semaphore was created.","pos":[13,500],"nodes":[{"content":"When you use this constructor overload, the recommended practice is to specify the same number for <ph id=\"ph1\">`initialCount`</ph> and <ph id=\"ph2\">`maximumCount`</ph>.","pos":[1,134],"source":" When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`."},{"content":"If <ph id=\"ph1\">`initialCount`</ph> is less than <ph id=\"ph2\">`maximumCount`</ph>, and a named system semaphore is created, the effect is the same as if the current thread had called <ph id=\"ph3\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id=\"ph4\">`maximumCount`</ph> minus <ph id=\"ph5\">`initialCount`</ph>) times.","pos":[135,372],"source":" If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times."},{"content":"However, with this constructor overload there is no way to determine whether a named system semaphore was created.","pos":[373,487]}]}]},{"pos":[1268,1472],"content":"If you specify <ph id=\"ph1\">`null`</ph> or an empty string for <ph id=\"ph2\">`name`</ph>, a local semaphore is created, as if you had called the <ph id=\"ph3\">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.","source":"If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload."},{"pos":[1479,1619],"content":"Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.","nodes":[{"content":"Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.","pos":[0,140]}]},{"pos":[1626,1927],"content":"If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method. The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.","nodes":[{"content":"If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method. The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.","pos":[0,301],"nodes":[{"content":"If you want to find out whether a named system semaphore exists, use the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method.","pos":[0,130],"source":"If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.","pos":[131,301],"source":" The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist."}]}]}],"pos":[14668,16609],"yaml":true,"extradata":"MT"},{"content":"The initial number of requests for the semaphore that can be granted concurrently.","nodes":[{"pos":[0,82],"content":"The initial number of requests for the semaphore that can be granted concurrently.","nodes":[{"content":"The initial number of requests for the semaphore that can be granted concurrently.","pos":[0,82]}]}],"pos":[17818,17901],"yaml":true},{"content":"The maximum number of requests for the semaphore that can be granted concurrently.","nodes":[{"pos":[0,82],"content":"The maximum number of requests for the semaphore that can be granted concurrently.","nodes":[{"content":"The maximum number of requests for the semaphore that can be granted concurrently.","pos":[0,82]}]}],"pos":[17968,18051],"yaml":true},{"content":"The name of a named system semaphore object.","nodes":[{"pos":[0,44],"content":"The name of a named system semaphore object.","nodes":[{"content":"The name of a named system semaphore object.","pos":[0,44]}]}],"pos":[18111,18156],"yaml":true},{"content":"<code>initialCount</code> is greater than <code>maximumCount</code>.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,68],"content":"<ph id=\"ph1\">&lt;code&gt;initialCount&lt;/code&gt;</ph> is greater than <ph id=\"ph2\">&lt;code&gt;maximumCount&lt;/code&gt;</ph>.","source":"<code>initialCount</code> is greater than <code>maximumCount</code>."},{"pos":[75,79],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[86,134],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[18310,18451],"yaml":true},{"content":"<code>maximumCount</code> is less than 1.  \n  \n -or-  \n  \n <code>initialCount</code> is less than 0.","nodes":[{"pos":[0,41],"content":"<ph id=\"ph1\">&lt;code&gt;maximumCount&lt;/code&gt;</ph> is less than 1.","source":"<code>maximumCount</code> is less than 1."},{"pos":[48,52],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[59,100],"content":"<ph id=\"ph1\">&lt;code&gt;initialCount&lt;/code&gt;</ph> is less than 0.","source":"<code>initialCount</code> is less than 0."}],"pos":[18565,18672],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[18760,18784],"yaml":true},{"content":"The named semaphore exists and has access control security, and the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.FullControl\"></xref>.","nodes":[{"pos":[0,166],"content":"The named semaphore exists and has access control security, and the user does not have <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.SemaphoreRights.FullControl\"&gt;&lt;/xref&gt;</ph>.","source":"The named semaphore exists and has access control security, and the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.FullControl\"></xref>."}],"pos":[18898,19065],"yaml":true},{"content":"The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"pos":[0,107],"content":"The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"content":"The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.","pos":[0,107]}]}],"pos":[19211,19319],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Threading.Semaphore\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.","nodes":[{"pos":[0,339],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Semaphore\"&gt;&lt;/xref&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.","source":"Initializes a new instance of the <xref href=\"System.Threading.Semaphore\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created."}],"pos":[20978,21318],"yaml":true},{"content":"This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.  \n  \n If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`. If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions. Use `createdNew` to determine whether the system semaphore was created.  \n  \n If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.  \n  \n If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload. In this case, `createdNew` is always `true`.  \n  \n Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.","nodes":[{"pos":[0,227],"content":"This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.","nodes":[{"content":"This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.","pos":[0,227],"nodes":[{"content":"This constructor initializes a <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.","pos":[0,113],"source":"This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore."},{"content":"You can create multiple <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.","pos":[114,227],"source":" You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore."}]}]},{"pos":[234,596],"content":"If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`. If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions. Use `createdNew` to determine whether the system semaphore was created.","nodes":[{"content":"If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id=\"ph1\">`initialCount`</ph> and <ph id=\"ph2\">`maximumCount`</ph>.","pos":[0,148],"source":"If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`."},{"content":"If the named system semaphore already exists, <ph id=\"ph1\">`initialCount`</ph> and <ph id=\"ph2\">`maximumCount`</ph> are not used, although invalid values still cause exceptions.","pos":[149,290],"source":" If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions."},{"content":"Use <ph id=\"ph1\">`createdNew`</ph> to determine whether the system semaphore was created.","pos":[291,362],"source":" Use `createdNew` to determine whether the system semaphore was created."}]},{"pos":[603,827],"content":"If <ph id=\"ph1\">`initialCount`</ph> is less than <ph id=\"ph2\">`maximumCount`</ph>, and <ph id=\"ph3\">`createdNew`</ph> is <ph id=\"ph4\">`true`</ph>, the effect is the same as if the current thread had called <ph id=\"ph5\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id=\"ph6\">`maximumCount`</ph> minus <ph id=\"ph7\">`initialCount`</ph>) times.","source":"If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times."},{"pos":[834,1083],"content":"If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload. In this case, `createdNew` is always `true`.","nodes":[{"content":"If you specify <ph id=\"ph1\">`null`</ph> or an empty string for <ph id=\"ph2\">`name`</ph>, a local semaphore is created, as if you had called the <ph id=\"ph3\">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.","pos":[0,204],"source":"If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload."},{"content":"In this case, <ph id=\"ph1\">`createdNew`</ph> is always <ph id=\"ph2\">`true`</ph>.","pos":[205,249],"source":" In this case, `createdNew` is always `true`."}]},{"pos":[1090,1230],"content":"Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.","nodes":[{"content":"Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.","pos":[0,140]}]}],"pos":[21329,22570],"yaml":true,"extradata":"MT"},{"content":"The initial number of requests for the semaphore that can be satisfied concurrently.","nodes":[{"pos":[0,84],"content":"The initial number of requests for the semaphore that can be satisfied concurrently.","nodes":[{"content":"The initial number of requests for the semaphore that can be satisfied concurrently.","pos":[0,84]}]}],"pos":[23904,23989],"yaml":true},{"content":"The maximum number of requests for the semaphore that can be satisfied concurrently.","nodes":[{"pos":[0,84],"content":"The maximum number of requests for the semaphore that can be satisfied concurrently.","nodes":[{"content":"The maximum number of requests for the semaphore that can be satisfied concurrently.","pos":[0,84]}]}],"pos":[24056,24141],"yaml":true},{"content":"The name of a named system semaphore object.","nodes":[{"pos":[0,44],"content":"The name of a named system semaphore object.","nodes":[{"content":"The name of a named system semaphore object.","pos":[0,44]}]}],"pos":[24201,24246],"yaml":true},{"content":"When this method returns, contains `true` if a local semaphore was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system semaphore was created; `false` if the specified named system semaphore already existed. This parameter is passed uninitialized.","nodes":[{"pos":[0,296],"content":"When this method returns, contains `true` if a local semaphore was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system semaphore was created; `false` if the specified named system semaphore already existed. This parameter is passed uninitialized.","nodes":[{"content":"When this method returns, contains <ph id=\"ph1\">`true`</ph> if a local semaphore was created (that is, if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">name</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph3\">`null`</ph> or an empty string) or if the specified named system semaphore was created; <ph id=\"ph4\">`false`</ph> if the specified named system semaphore already existed.","pos":[0,256],"source":"When this method returns, contains `true` if a local semaphore was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system semaphore was created; `false` if the specified named system semaphore already existed."},{"content":"This parameter is passed uninitialized.","pos":[257,296]}]}],"pos":[24313,24610],"yaml":true},{"content":"<code>initialCount</code> is greater than <code>maximumCount</code>.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,68],"content":"<ph id=\"ph1\">&lt;code&gt;initialCount&lt;/code&gt;</ph> is greater than <ph id=\"ph2\">&lt;code&gt;maximumCount&lt;/code&gt;</ph>.","source":"<code>initialCount</code> is greater than <code>maximumCount</code>."},{"pos":[75,79],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[86,134],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[24764,24905],"yaml":true},{"content":"<code>maximumCount</code> is less than 1.  \n  \n -or-  \n  \n <code>initialCount</code> is less than 0.","nodes":[{"pos":[0,41],"content":"<ph id=\"ph1\">&lt;code&gt;maximumCount&lt;/code&gt;</ph> is less than 1.","source":"<code>maximumCount</code> is less than 1."},{"pos":[48,52],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[59,100],"content":"<ph id=\"ph1\">&lt;code&gt;initialCount&lt;/code&gt;</ph> is less than 0.","source":"<code>initialCount</code> is less than 0."}],"pos":[25019,25126],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[25214,25238],"yaml":true},{"content":"The named semaphore exists and has access control security, and the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.FullControl\"></xref>.","nodes":[{"pos":[0,166],"content":"The named semaphore exists and has access control security, and the user does not have <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.SemaphoreRights.FullControl\"&gt;&lt;/xref&gt;</ph>.","source":"The named semaphore exists and has access control security, and the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.FullControl\"></xref>."}],"pos":[25352,25519],"yaml":true},{"content":"The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"pos":[0,107],"content":"The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"content":"The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.","pos":[0,107]}]}],"pos":[25665,25773],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Threading.Semaphore\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.","nodes":[{"pos":[0,400],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Semaphore\"&gt;&lt;/xref&gt;</ph> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.","source":"Initializes a new instance of the <xref href=\"System.Threading.Semaphore\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore."}],"pos":[27596,27997],"yaml":true},{"content":"Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.  \n  \n This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.  \n  \n If the named system semaphore does not exist, it is created with the specified access control security. If the named semaphore exists, the specified access control security is ignored.  \n  \n> [!NOTE]\n>  The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.  \n  \n If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`. If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions. Use the `createdNew` parameter to determine whether the system semaphore was created by this constructor.  \n  \n If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.  \n  \n If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload. In this case, `createdNew` is always `true`.  \n  \n Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.","nodes":[{"pos":[0,161],"content":"Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.","nodes":[{"content":"Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.","pos":[0,161]}]},{"pos":[168,395],"content":"This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.","nodes":[{"content":"This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.","pos":[0,227],"nodes":[{"content":"This constructor initializes a <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> object that represents a named system semaphore.","pos":[0,113],"source":"This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore."},{"content":"You can create multiple <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent the same named system semaphore.","pos":[114,227],"source":" You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore."}]}]},{"pos":[402,586],"content":"If the named system semaphore does not exist, it is created with the specified access control security. If the named semaphore exists, the specified access control security is ignored.","nodes":[{"content":"If the named system semaphore does not exist, it is created with the specified access control security. If the named semaphore exists, the specified access control security is ignored.","pos":[0,184],"nodes":[{"content":"If the named system semaphore does not exist, it is created with the specified access control security.","pos":[0,103]},{"content":"If the named semaphore exists, the specified access control security is ignored.","pos":[104,184]}]}]},{"pos":[594,1058],"content":"[!NOTE]\n The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.","leadings":["","> "],"nodes":[{"content":" The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.","pos":[8,462],"nodes":[{"content":"The caller has full control over the newly created <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> object even if <ph id=\"ph2\">`semaphoreSecurity`</ph> denies or fails to grant some access rights to the current user.","pos":[1,185],"source":" The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user."},{"content":"However, if the current user attempts to get another <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> object to represent the same named semaphore, using either a constructor or the <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method, Windows access control security is applied.","pos":[186,454],"source":" However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied."}]}]},{"pos":[1065,1461],"content":"If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`. If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions. Use the `createdNew` parameter to determine whether the system semaphore was created by this constructor.","nodes":[{"content":"If the named system semaphore does not exist, it is created with the initial count and maximum count specified by <ph id=\"ph1\">`initialCount`</ph> and <ph id=\"ph2\">`maximumCount`</ph>.","pos":[0,148],"source":"If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`."},{"content":"If the named system semaphore already exists, <ph id=\"ph1\">`initialCount`</ph> and <ph id=\"ph2\">`maximumCount`</ph> are not used, although invalid values still cause exceptions.","pos":[149,290],"source":" If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions."},{"content":"Use the <ph id=\"ph1\">`createdNew`</ph> parameter to determine whether the system semaphore was created by this constructor.","pos":[291,396],"source":" Use the `createdNew` parameter to determine whether the system semaphore was created by this constructor."}]},{"pos":[1468,1692],"content":"If <ph id=\"ph1\">`initialCount`</ph> is less than <ph id=\"ph2\">`maximumCount`</ph>, and <ph id=\"ph3\">`createdNew`</ph> is <ph id=\"ph4\">`true`</ph>, the effect is the same as if the current thread had called <ph id=\"ph5\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> (<ph id=\"ph6\">`maximumCount`</ph> minus <ph id=\"ph7\">`initialCount`</ph>) times.","source":"If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times."},{"pos":[1699,1948],"content":"If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload. In this case, `createdNew` is always `true`.","nodes":[{"content":"If you specify <ph id=\"ph1\">`null`</ph> or an empty string for <ph id=\"ph2\">`name`</ph>, a local semaphore is created, as if you had called the <ph id=\"ph3\">&lt;xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29&gt;</ph> constructor overload.","pos":[0,204],"source":"If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload."},{"content":"In this case, <ph id=\"ph1\">`createdNew`</ph> is always <ph id=\"ph2\">`true`</ph>.","pos":[205,249],"source":" In this case, `createdNew` is always `true`."}]},{"pos":[1955,2095],"content":"Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.","nodes":[{"content":"Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.","pos":[0,140]}]}],"pos":[28008,30121],"yaml":true,"extradata":"MT"},{"content":"The initial number of requests for the semaphore that can be satisfied concurrently.","nodes":[{"pos":[0,84],"content":"The initial number of requests for the semaphore that can be satisfied concurrently.","nodes":[{"content":"The initial number of requests for the semaphore that can be satisfied concurrently.","pos":[0,84]}]}],"pos":[32090,32175],"yaml":true},{"content":"The maximum number of requests for the semaphore that can be satisfied concurrently.","nodes":[{"pos":[0,84],"content":"The maximum number of requests for the semaphore that can be satisfied concurrently.","nodes":[{"content":"The maximum number of requests for the semaphore that can be satisfied concurrently.","pos":[0,84]}]}],"pos":[32242,32327],"yaml":true},{"content":"The name of a named system semaphore object.","nodes":[{"pos":[0,44],"content":"The name of a named system semaphore object.","nodes":[{"content":"The name of a named system semaphore object.","pos":[0,44]}]}],"pos":[32387,32432],"yaml":true},{"content":"When this method returns, contains `true` if a local semaphore was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system semaphore was created; `false` if the specified named system semaphore already existed. This parameter is passed uninitialized.","nodes":[{"pos":[0,296],"content":"When this method returns, contains `true` if a local semaphore was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system semaphore was created; `false` if the specified named system semaphore already existed. This parameter is passed uninitialized.","nodes":[{"content":"When this method returns, contains <ph id=\"ph1\">`true`</ph> if a local semaphore was created (that is, if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">name</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph3\">`null`</ph> or an empty string) or if the specified named system semaphore was created; <ph id=\"ph4\">`false`</ph> if the specified named system semaphore already existed.","pos":[0,256],"source":"When this method returns, contains `true` if a local semaphore was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system semaphore was created; `false` if the specified named system semaphore already existed."},{"content":"This parameter is passed uninitialized.","pos":[257,296]}]}],"pos":[32499,32796],"yaml":true},{"content":"A <xref href=\"System.Security.AccessControl.SemaphoreSecurity\"></xref> object that represents the access control security to be applied to the named system semaphore.","nodes":[{"pos":[0,166],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.SemaphoreSecurity\"&gt;&lt;/xref&gt;</ph> object that represents the access control security to be applied to the named system semaphore.","source":"A <xref href=\"System.Security.AccessControl.SemaphoreSecurity\"></xref> object that represents the access control security to be applied to the named system semaphore."}],"pos":[32903,33070],"yaml":true},{"content":"<code>initialCount</code> is greater than <code>maximumCount</code>.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,68],"content":"<ph id=\"ph1\">&lt;code&gt;initialCount&lt;/code&gt;</ph> is greater than <ph id=\"ph2\">&lt;code&gt;maximumCount&lt;/code&gt;</ph>.","source":"<code>initialCount</code> is greater than <code>maximumCount</code>."},{"pos":[75,79],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[86,134],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[33224,33365],"yaml":true},{"content":"<code>maximumCount</code> is less than 1.  \n  \n -or-  \n  \n <code>initialCount</code> is less than 0.","nodes":[{"pos":[0,41],"content":"<ph id=\"ph1\">&lt;code&gt;maximumCount&lt;/code&gt;</ph> is less than 1.","source":"<code>maximumCount</code> is less than 1."},{"pos":[48,52],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[59,100],"content":"<ph id=\"ph1\">&lt;code&gt;initialCount&lt;/code&gt;</ph> is less than 0.","source":"<code>initialCount</code> is less than 0."}],"pos":[33479,33586],"yaml":true},{"content":"The named semaphore exists and has access control security, and the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.FullControl\"></xref>.","nodes":[{"pos":[0,166],"content":"The named semaphore exists and has access control security, and the user does not have <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.SemaphoreRights.FullControl\"&gt;&lt;/xref&gt;</ph>.","source":"The named semaphore exists and has access control security, and the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.FullControl\"></xref>."}],"pos":[33700,33867],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[33955,33979],"yaml":true},{"content":"The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"pos":[0,107],"content":"The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.","nodes":[{"content":"The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.","pos":[0,107]}]}],"pos":[34125,34233],"yaml":true},{"content":"Gets the access control security for a named system semaphore.","nodes":[{"pos":[0,62],"content":"Gets the access control security for a named system semaphore.","nodes":[{"content":"Gets the access control security for a named system semaphore.","pos":[0,62]}]}],"pos":[35268,35331],"yaml":true},{"content":"The <xref:System.Threading.Semaphore.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, and <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>.  \n  \n The user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights.  \n  \n On a local semaphore, access control security is irrelevant. If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user.","nodes":[{"pos":[0,432],"content":"The <xref:System.Threading.Semaphore.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, and <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.GetAccessControl%2A&gt;</ph> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName&gt;</ph>.","pos":[0,432],"source":"The <xref:System.Threading.Semaphore.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, and <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>."}]},{"pos":[439,694],"content":"The user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights.","nodes":[{"content":"The user must have <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> rights to call this method, and the semaphore must have been opened with <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> rights.","pos":[0,255],"source":"The user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights."}]},{"pos":[701,974],"content":"On a local semaphore, access control security is irrelevant. If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user.","nodes":[{"content":"On a local semaphore, access control security is irrelevant. If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user.","pos":[0,273],"nodes":[{"content":"On a local semaphore, access control security is irrelevant.","pos":[0,60]},{"content":"If the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> object does not represent a named system semaphore, this method returns a <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.SemaphoreSecurity&gt;</ph> object that grants all rights to any user.","pos":[61,273],"source":" If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user."}]}]}],"pos":[35342,36323],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Security.AccessControl.SemaphoreSecurity\"></xref> object that represents the access control security for the named system semaphore.","nodes":[{"pos":[0,153],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.SemaphoreSecurity\"&gt;&lt;/xref&gt;</ph> object that represents the access control security for the named system semaphore.","source":"A <xref href=\"System.Security.AccessControl.SemaphoreSecurity\"></xref> object that represents the access control security for the named system semaphore."}],"pos":[38393,38547],"yaml":true},{"content":"The current <xref href=\"System.Threading.Semaphore\"></xref> object represents a named system semaphore, and the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.ReadPermissions\"></xref> rights.  \n  \n -or-  \n  \n The current <xref href=\"System.Threading.Semaphore\"></xref> object represents a named system semaphore and was not opened with <xref href=\"System.Security.AccessControl.SemaphoreRights.ReadPermissions\"></xref> rights.","nodes":[{"pos":[0,221],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Threading.Semaphore\"&gt;&lt;/xref&gt;</ph> object represents a named system semaphore, and the user does not have <ph id=\"ph2\">&lt;xref href=\"System.Security.AccessControl.SemaphoreRights.ReadPermissions\"&gt;&lt;/xref&gt;</ph> rights.","source":"The current <xref href=\"System.Threading.Semaphore\"></xref> object represents a named system semaphore, and the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.ReadPermissions\"></xref> rights."},{"pos":[228,232],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[239,456],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Threading.Semaphore\"&gt;&lt;/xref&gt;</ph> object represents a named system semaphore and was not opened with <ph id=\"ph2\">&lt;xref href=\"System.Security.AccessControl.SemaphoreRights.ReadPermissions\"&gt;&lt;/xref&gt;</ph> rights.","source":"The current <xref href=\"System.Threading.Semaphore\"></xref> object represents a named system semaphore and was not opened with <xref href=\"System.Security.AccessControl.SemaphoreRights.ReadPermissions\"></xref> rights."}],"pos":[38732,39203],"yaml":true},{"content":"Not supported for Windows 98 or Windows Millennium Edition.","nodes":[{"pos":[0,59],"content":"Not supported for Windows 98 or Windows Millennium Edition.","nodes":[{"content":"Not supported for Windows 98 or Windows Millennium Edition.","pos":[0,59]}]}],"pos":[39305,39365],"yaml":true},{"content":"Opens the specified named semaphore, if it already exists.","nodes":[{"pos":[0,58],"content":"Opens the specified named semaphore, if it already exists.","nodes":[{"content":"Opens the specified named semaphore, if it already exists.","pos":[0,58]}]}],"pos":[40476,40535],"yaml":true},{"content":"The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open the specified named semaphore. If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore. To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.  \n  \n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.  \n  \n This method overload is equivalent to calling the <xref:System.Threading.Semaphore.OpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> and <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights, combined by using the bitwise OR operation.  \n  \n Specifying the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to enter the semaphore, and specifying the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.","nodes":[{"pos":[0,384],"content":"The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open the specified named semaphore. If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore. To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method tries to open the specified named semaphore.","pos":[0,105],"source":"The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open the specified named semaphore."},{"content":"If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.","pos":[106,219]},{"content":"To create the system semaphore when it does not already exist, use one of the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id=\"ph2\">`name`</ph> parameter.","pos":[220,384],"source":" To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter."}]},{"pos":[391,617],"content":"Multiple calls to this method that use the same value for <ph id=\"ph1\">`name`</ph> do not necessarily return the same <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.","source":"Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore."},{"pos":[624,966],"content":"This method overload is equivalent to calling the <xref:System.Threading.Semaphore.OpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> and <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights, combined by using the bitwise OR operation.","nodes":[{"content":"This method overload is equivalent to calling the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method overload and specifying <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> rights, combined by using the bitwise OR operation.","pos":[0,342],"source":"This method overload is equivalent to calling the <xref:System.Threading.Semaphore.OpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> and <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights, combined by using the bitwise OR operation."}]},{"pos":[973,1293],"content":"Specifying the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to enter the semaphore, and specifying the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.","nodes":[{"content":"Specifying the <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> flag allows a thread to enter the semaphore, and specifying the <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> flag allows a thread to call the <ph id=\"ph3\">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.","pos":[0,320],"source":"Specifying the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to enter the semaphore, and specifying the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method."}]}],"pos":[40546,41848],"yaml":true,"extradata":"MT"},{"content":"The name of the system semaphore to open.","nodes":[{"pos":[0,41],"content":"The name of the system semaphore to open.","nodes":[{"content":"The name of the system semaphore to open.","pos":[0,41]}]}],"pos":[43758,43800],"yaml":true},{"content":"An object that represents the named system semaphore.","nodes":[{"pos":[0,53],"content":"An object that represents the named system semaphore.","nodes":[{"content":"An object that represents the named system semaphore.","pos":[0,53]}]}],"pos":[43870,43924],"yaml":true},{"content":"<code>name</code> is an empty string.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.","source":"<code>name</code> is an empty string."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,103],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[44085,44195],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[44297,44326],"yaml":true},{"content":"The named semaphore does not exist.","nodes":[{"pos":[0,35],"content":"The named semaphore does not exist.","nodes":[{"content":"The named semaphore does not exist.","pos":[0,35]}]}],"pos":[44472,44508],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[44596,44620],"yaml":true},{"content":"The named semaphore exists, but the user does not have the security access required to use it.","nodes":[{"pos":[0,94],"content":"The named semaphore exists, but the user does not have the security access required to use it.","nodes":[{"content":"The named semaphore exists, but the user does not have the security access required to use it.","pos":[0,94]}]}],"pos":[44734,44829],"yaml":true},{"content":"Opens the specified named semaphore, if it already exists, with the desired security access.","nodes":[{"pos":[0,92],"content":"Opens the specified named semaphore, if it already exists, with the desired security access.","nodes":[{"content":"Opens the specified named semaphore, if it already exists, with the desired security access.","pos":[0,92]}]}],"pos":[46468,46561],"yaml":true},{"content":"The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.  \n  \n The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open an existing named semaphore. If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore. To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.  \n  \n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.","nodes":[{"pos":[0,336],"content":"The <ph id=\"ph1\">`rights`</ph> parameter must include the <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> flag to allow threads to enter the semaphore, and the <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> flag to allow threads to call the <ph id=\"ph4\">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.","source":"The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method."},{"pos":[343,725],"content":"The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open an existing named semaphore. If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore. To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.OpenExisting%2A&gt;</ph> method tries to open an existing named semaphore.","pos":[0,103],"source":"The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open an existing named semaphore."},{"content":"If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore.","pos":[104,217]},{"content":"To create the system semaphore when it does not already exist, use one of the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id=\"ph2\">`name`</ph> parameter.","pos":[218,382],"source":" To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter."}]},{"pos":[732,958],"content":"Multiple calls to this method that use the same value for <ph id=\"ph1\">`name`</ph> do not necessarily return the same <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.","source":"Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore."}],"pos":[46572,47537],"yaml":true,"extradata":"MT"},{"content":"The name of the system semaphore to open.","nodes":[{"pos":[0,41],"content":"The name of the system semaphore to open.","nodes":[{"content":"The name of the system semaphore to open.","pos":[0,41]}]}],"pos":[49486,49528],"yaml":true},{"content":"A bitwise combination of the enumeration values that represent the desired security access.","nodes":[{"pos":[0,91],"content":"A bitwise combination of the enumeration values that represent the desired security access.","nodes":[{"content":"A bitwise combination of the enumeration values that represent the desired security access.","pos":[0,91]}]}],"pos":[49622,49714],"yaml":true},{"content":"An object that represents the named system semaphore.","nodes":[{"pos":[0,53],"content":"An object that represents the named system semaphore.","nodes":[{"content":"An object that represents the named system semaphore.","pos":[0,53]}]}],"pos":[49784,49838],"yaml":true},{"content":"<code>name</code> is an empty string.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.","source":"<code>name</code> is an empty string."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,103],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[49999,50109],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[50211,50240],"yaml":true},{"content":"The named semaphore does not exist.","nodes":[{"pos":[0,35],"content":"The named semaphore does not exist.","nodes":[{"content":"The named semaphore does not exist.","pos":[0,35]}]}],"pos":[50386,50422],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[50510,50534],"yaml":true},{"content":"The named semaphore exists, but the user does not have the desired security access rights.","nodes":[{"pos":[0,90],"content":"The named semaphore exists, but the user does not have the desired security access rights.","nodes":[{"content":"The named semaphore exists, but the user does not have the desired security access rights.","pos":[0,90]}]}],"pos":[50648,50739],"yaml":true},{"content":"Exits the semaphore and returns the previous count.","nodes":[{"pos":[0,51],"content":"Exits the semaphore and returns the previous count.","nodes":[{"content":"Exits the semaphore and returns the previous count.","pos":[0,51]}]}],"pos":[51757,51809],"yaml":true},{"content":"Threads typically use the <xref:System.Threading.WaitHandle.WaitOne%2A> method to enter the semaphore, and they typically use this method overload to exit.  \n  \n If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread. A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.  \n  \n If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights.","nodes":[{"pos":[0,155],"content":"Threads typically use the <xref:System.Threading.WaitHandle.WaitOne%2A> method to enter the semaphore, and they typically use this method overload to exit.","nodes":[{"content":"Threads typically use the <ph id=\"ph1\">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph> method to enter the semaphore, and they typically use this method overload to exit.","pos":[0,155],"source":"Threads typically use the <xref:System.Threading.WaitHandle.WaitOne%2A> method to enter the semaphore, and they typically use this method overload to exit."}]},{"pos":[162,469],"content":"If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread. A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.","nodes":[{"content":"If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread. A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.","pos":[0,307],"nodes":[{"content":"If a <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown by the <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method, it does not necessarily indicate a problem with the calling thread.","pos":[0,189],"source":"If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread."},{"content":"A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.","pos":[190,307]}]}]},{"pos":[476,803],"content":"If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> object represents a named system semaphore, the user must have <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> rights and the semaphore must have been opened with <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> rights.","pos":[0,327],"source":"If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights."}]}],"pos":[51820,52630],"yaml":true,"extradata":"MT"},{"content":"The count on the semaphore before the <xref href=\"System.Threading.Semaphore.Release*\"></xref> method was called.","nodes":[{"pos":[0,113],"content":"The count on the semaphore before the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Semaphore.Release*\"&gt;&lt;/xref&gt;</ph> method was called.","source":"The count on the semaphore before the <xref href=\"System.Threading.Semaphore.Release*\"></xref> method was called."}],"pos":[54035,54149],"yaml":true},{"content":"The semaphore count is already at the maximum value.","nodes":[{"pos":[0,52],"content":"The semaphore count is already at the maximum value.","nodes":[{"content":"The semaphore count is already at the maximum value.","pos":[0,52]}]}],"pos":[54335,54388],"yaml":true},{"content":"A Win32 error occurred with a named semaphore.","nodes":[{"pos":[0,46],"content":"A Win32 error occurred with a named semaphore.","nodes":[{"content":"A Win32 error occurred with a named semaphore.","pos":[0,46]}]}],"pos":[54476,54523],"yaml":true},{"content":"The current semaphore represents a named system semaphore, but the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\"></xref>.  \n  \n -or-  \n  \n The current semaphore represents a named system semaphore, but it was not opened with <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\"></xref>.","nodes":[{"pos":[0,160],"content":"The current semaphore represents a named system semaphore, but the user does not have <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\"&gt;&lt;/xref&gt;</ph>.","source":"The current semaphore represents a named system semaphore, but the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\"></xref>."},{"pos":[167,171],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[178,338],"content":"The current semaphore represents a named system semaphore, but it was not opened with <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\"&gt;&lt;/xref&gt;</ph>.","source":"The current semaphore represents a named system semaphore, but it was not opened with <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\"></xref>."}],"pos":[54637,54986],"yaml":true},{"content":"Exits the semaphore a specified number of times and returns the previous count.","nodes":[{"pos":[0,79],"content":"Exits the semaphore a specified number of times and returns the previous count.","nodes":[{"content":"Exits the semaphore a specified number of times and returns the previous count.","pos":[0,79]}]}],"pos":[56454,56534],"yaml":true},{"content":"If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.  \n  \n If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread. A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.  \n  \n If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights.","nodes":[{"pos":[0,138],"content":"If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.","nodes":[{"content":"If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.","pos":[0,138]}]},{"pos":[145,452],"content":"If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread. A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.","nodes":[{"content":"If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread. A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.","pos":[0,307],"nodes":[{"content":"If a <ph id=\"ph1\">&lt;xref:System.Threading.SemaphoreFullException&gt;</ph> is thrown by the <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method, it does not necessarily indicate a problem with the calling thread.","pos":[0,189],"source":"If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread."},{"content":"A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.","pos":[190,307]}]}]},{"pos":[459,786],"content":"If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> object represents a named system semaphore, the user must have <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> rights and the semaphore must have been opened with <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> rights.","pos":[0,327],"source":"If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights."}]}],"pos":[56545,57338],"yaml":true,"extradata":"MT"},{"content":"The number of times to exit the semaphore.","nodes":[{"pos":[0,42],"content":"The number of times to exit the semaphore.","nodes":[{"content":"The number of times to exit the semaphore.","pos":[0,42]}]}],"pos":[58767,58810],"yaml":true},{"content":"The count on the semaphore before the <xref href=\"System.Threading.Semaphore.Release*\"></xref> method was called.","nodes":[{"pos":[0,113],"content":"The count on the semaphore before the <ph id=\"ph1\">&lt;xref href=\"System.Threading.Semaphore.Release*\"&gt;&lt;/xref&gt;</ph> method was called.","source":"The count on the semaphore before the <xref href=\"System.Threading.Semaphore.Release*\"></xref> method was called."}],"pos":[58866,58980],"yaml":true},{"content":"<code>releaseCount</code> is less than 1.","nodes":[{"pos":[0,41],"content":"<ph id=\"ph1\">&lt;code&gt;releaseCount&lt;/code&gt;</ph> is less than 1.","source":"<code>releaseCount</code> is less than 1."}],"pos":[59156,59198],"yaml":true},{"content":"The semaphore count is already at the maximum value.","nodes":[{"pos":[0,52],"content":"The semaphore count is already at the maximum value.","nodes":[{"content":"The semaphore count is already at the maximum value.","pos":[0,52]}]}],"pos":[59322,59375],"yaml":true},{"content":"A Win32 error occurred with a named semaphore.","nodes":[{"pos":[0,46],"content":"A Win32 error occurred with a named semaphore.","nodes":[{"content":"A Win32 error occurred with a named semaphore.","pos":[0,46]}]}],"pos":[59463,59510],"yaml":true},{"content":"The current semaphore represents a named system semaphore, but the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\"></xref> rights.  \n  \n -or-  \n  \n The current semaphore represents a named system semaphore, but it was not opened with <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\"></xref> rights.","nodes":[{"pos":[0,167],"content":"The current semaphore represents a named system semaphore, but the user does not have <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\"&gt;&lt;/xref&gt;</ph> rights.","source":"The current semaphore represents a named system semaphore, but the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\"></xref> rights."},{"pos":[174,178],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[185,352],"content":"The current semaphore represents a named system semaphore, but it was not opened with <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\"&gt;&lt;/xref&gt;</ph> rights.","source":"The current semaphore represents a named system semaphore, but it was not opened with <xref href=\"System.Security.AccessControl.SemaphoreRights.Modify\"></xref> rights."}],"pos":[59624,59987],"yaml":true},{"content":"Sets the access control security for a named system semaphore.","nodes":[{"pos":[0,62],"content":"Sets the access control security for a named system semaphore.","nodes":[{"content":"Sets the access control security for a named system semaphore.","pos":[0,62]}]}],"pos":[61613,61676],"yaml":true},{"content":"You can set access control security only on <xref:System.Threading.Semaphore> objects that represent named system semaphores.  \n  \n The user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights.","nodes":[{"pos":[0,125],"content":"You can set access control security only on <xref:System.Threading.Semaphore> objects that represent named system semaphores.","nodes":[{"content":"You can set access control security only on <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore&gt;</ph> objects that represent named system semaphores.","pos":[0,125],"source":"You can set access control security only on <xref:System.Threading.Semaphore> objects that represent named system semaphores."}]},{"pos":[132,387],"content":"The user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights.","nodes":[{"content":"The user must have <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> rights to call this method, and the semaphore must have been opened with <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> rights.","pos":[0,255],"source":"The user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights."}]}],"pos":[61687,62079],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Security.AccessControl.SemaphoreSecurity\"></xref> object that represents the access control security to be applied to the named system semaphore.","nodes":[{"pos":[0,166],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.SemaphoreSecurity\"&gt;&lt;/xref&gt;</ph> object that represents the access control security to be applied to the named system semaphore.","source":"A <xref href=\"System.Security.AccessControl.SemaphoreSecurity\"></xref> object that represents the access control security to be applied to the named system semaphore."}],"pos":[64118,64285],"yaml":true},{"content":"<code>semaphoreSecurity</code> is `null`.","nodes":[{"pos":[0,41],"content":"<ph id=\"ph1\">&lt;code&gt;semaphoreSecurity&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>semaphoreSecurity</code> is `null`."}],"pos":[64458,64500],"yaml":true},{"content":"The user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.ChangePermissions\"></xref> rights.  \n  \n -or-  \n  \n The semaphore was not opened with <xref href=\"System.Security.AccessControl.SemaphoreRights.ChangePermissions\"></xref> rights.","nodes":[{"pos":[0,115],"content":"The user does not have <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.SemaphoreRights.ChangePermissions\"&gt;&lt;/xref&gt;</ph> rights.","source":"The user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.ChangePermissions\"></xref> rights."},{"pos":[122,126],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[133,259],"content":"The semaphore was not opened with <ph id=\"ph1\">&lt;xref href=\"System.Security.AccessControl.SemaphoreRights.ChangePermissions\"&gt;&lt;/xref&gt;</ph> rights.","source":"The semaphore was not opened with <xref href=\"System.Security.AccessControl.SemaphoreRights.ChangePermissions\"></xref> rights."}],"pos":[64614,64884],"yaml":true},{"content":"The current <xref href=\"System.Threading.Semaphore\"></xref> object does not represent a named system semaphore.","nodes":[{"pos":[0,111],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Threading.Semaphore\"&gt;&lt;/xref&gt;</ph> object does not represent a named system semaphore.","source":"The current <xref href=\"System.Threading.Semaphore\"></xref> object does not represent a named system semaphore."}],"pos":[64986,65098],"yaml":true},{"content":"Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.","nodes":[{"pos":[0,126],"content":"Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.","nodes":[{"content":"Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.","pos":[0,126]}]}],"pos":[66344,66471],"yaml":true},{"content":"If the named semaphore does not exist, this method does not create it. To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.  \n  \n If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist.  \n  \n This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> and <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.","nodes":[{"pos":[0,235],"content":"If the named semaphore does not exist, this method does not create it. To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.","nodes":[{"content":"If the named semaphore does not exist, this method does not create it.","pos":[0,70]},{"content":"To create the system semaphore when it does not already exist, use one of the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id=\"ph2\">`name`</ph> parameter.","pos":[71,235],"source":" To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter."}]},{"pos":[242,478],"content":"If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist.","nodes":[{"content":"If you are uncertain whether a named semaphore exists, use this method overload instead of the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%29&gt;</ph> method overload, which throws an exception if the semaphore does not exist.","pos":[0,236],"source":"If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist."}]},{"pos":[485,1153],"content":"This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> and <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.","nodes":[{"content":"This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> and <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.","pos":[0,668],"nodes":[{"content":"This method overload is equivalent to calling the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.TryOpenExisting%2A&gt;</ph> method overload and specifying <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> rights, combined by using the bitwise OR operation.","pos":[0,345],"source":"This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> and <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights, combined by using the bitwise OR operation."},{"content":"Specifying the <ph id=\"ph1\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> flag allows a thread to enter the semaphore, and specifying the   <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> flag allows a thread to call the <ph id=\"ph3\">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.","pos":[346,668],"source":" Specifying the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method."}]}]}],"pos":[66482,67642],"yaml":true,"extradata":"MT"},{"content":"The name of the system semaphore to open.","nodes":[{"pos":[0,41],"content":"The name of the system semaphore to open.","nodes":[{"content":"The name of the system semaphore to open.","pos":[0,41]}]}],"pos":[67830,67872],"yaml":true},{"content":"When this method returns, contains a <xref href=\"System.Threading.Semaphore\"></xref> object that represents the named semaphore if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.","nodes":[{"pos":[0,224],"content":"When this method returns, contains a <xref href=\"System.Threading.Semaphore\"></xref> object that represents the named semaphore if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.","nodes":[{"content":"When this method returns, contains a <ph id=\"ph1\">&lt;xref href=\"System.Threading.Semaphore\"&gt;&lt;/xref&gt;</ph> object that represents the named semaphore if the call succeeded, or <ph id=\"ph2\">`null`</ph> if the call failed.","pos":[0,180],"source":"When this method returns, contains a <xref href=\"System.Threading.Semaphore\"></xref> object that represents the named semaphore if the call succeeded, or `null` if the call failed."},{"content":"This parameter is treated as uninitialized.","pos":[181,224]}]}],"pos":[67947,68172],"yaml":true},{"content":"`true` if the named semaphore was opened successfully; otherwise, `false`.","nodes":[{"pos":[0,74],"content":"<ph id=\"ph1\">`true`</ph> if the named semaphore was opened successfully; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the named semaphore was opened successfully; otherwise, `false`."}],"pos":[68230,68307],"yaml":true},{"content":"<code>name</code> is an empty string.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.","source":"<code>name</code> is an empty string."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,103],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[68471,68581],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[68683,68712],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[68800,68824],"yaml":true},{"content":"The named semaphore exists, but the user does not have the security access required to use it.","nodes":[{"pos":[0,94],"content":"The named semaphore exists, but the user does not have the security access required to use it.","nodes":[{"content":"The named semaphore exists, but the user does not have the security access required to use it.","pos":[0,94]}]}],"pos":[68938,69033],"yaml":true},{"content":"Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.","nodes":[{"pos":[0,160],"content":"Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.","nodes":[{"content":"Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.","pos":[0,160]}]}],"pos":[70807,70968],"yaml":true},{"content":"If the named semaphore does not exist, this method does not create it. To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.  \n  \n If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist.  \n  \n The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.  \n  \n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.","nodes":[{"pos":[0,235],"content":"If the named semaphore does not exist, this method does not create it. To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.","nodes":[{"content":"If the named semaphore does not exist, this method does not create it.","pos":[0,70]},{"content":"To create the system semaphore when it does not already exist, use one of the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.%23ctor%2A&gt;</ph> constructors that has a <ph id=\"ph2\">`name`</ph> parameter.","pos":[71,235],"source":" To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter."}]},{"pos":[242,526],"content":"If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist.","nodes":[{"content":"If you are uncertain whether a named semaphore exists, use this method overload instead of the <ph id=\"ph1\">&lt;xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29&gt;</ph> method overload, which throws an exception if the semaphore does not exist.","pos":[0,284],"source":"If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist."}]},{"pos":[533,869],"content":"The <ph id=\"ph1\">`rights`</ph> parameter must include the <ph id=\"ph2\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> flag to allow threads to enter the semaphore, and the <ph id=\"ph3\">&lt;xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName&gt;</ph> flag to allow threads to call the <ph id=\"ph4\">&lt;xref:System.Threading.Semaphore.Release%2A&gt;</ph> method.","source":"The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method."},{"pos":[876,1102],"content":"Multiple calls to this method that use the same value for <ph id=\"ph1\">`name`</ph> do not necessarily return the same <ph id=\"ph2\">&lt;xref:System.Threading.Semaphore&gt;</ph> object, even though the objects that are returned represent the same named system semaphore.","source":"Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore."}],"pos":[70979,72090],"yaml":true,"extradata":"MT"},{"content":"The name of the system semaphore to open.","nodes":[{"pos":[0,41],"content":"The name of the system semaphore to open.","nodes":[{"content":"The name of the system semaphore to open.","pos":[0,41]}]}],"pos":[72332,72374],"yaml":true},{"content":"A bitwise combination of the enumeration values that represent the desired security access.","nodes":[{"pos":[0,91],"content":"A bitwise combination of the enumeration values that represent the desired security access.","nodes":[{"content":"A bitwise combination of the enumeration values that represent the desired security access.","pos":[0,91]}]}],"pos":[72468,72560],"yaml":true},{"content":"When this method returns, contains a <xref href=\"System.Threading.Semaphore\"></xref> object that represents the named semaphore if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.","nodes":[{"pos":[0,224],"content":"When this method returns, contains a <xref href=\"System.Threading.Semaphore\"></xref> object that represents the named semaphore if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.","nodes":[{"content":"When this method returns, contains a <ph id=\"ph1\">&lt;xref href=\"System.Threading.Semaphore\"&gt;&lt;/xref&gt;</ph> object that represents the named semaphore if the call succeeded, or <ph id=\"ph2\">`null`</ph> if the call failed.","pos":[0,180],"source":"When this method returns, contains a <xref href=\"System.Threading.Semaphore\"></xref> object that represents the named semaphore if the call succeeded, or `null` if the call failed."},{"content":"This parameter is treated as uninitialized.","pos":[181,224]}]}],"pos":[72635,72860],"yaml":true},{"content":"`true` if the named semaphore was opened successfully; otherwise, `false`.","nodes":[{"pos":[0,74],"content":"<ph id=\"ph1\">`true`</ph> if the named semaphore was opened successfully; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the named semaphore was opened successfully; otherwise, `false`."}],"pos":[72918,72995],"yaml":true},{"content":"<code>name</code> is an empty string.  \n  \n -or-  \n  \n <code>name</code> is longer than 260 characters.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is an empty string.","source":"<code>name</code> is an empty string."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,103],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is longer than 260 characters.","source":"<code>name</code> is longer than 260 characters."}],"pos":[73159,73269],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[73371,73400],"yaml":true},{"content":"A Win32 error occurred.","nodes":[{"pos":[0,23],"content":"A Win32 error occurred.","nodes":[{"content":"A Win32 error occurred.","pos":[0,23]}]}],"pos":[73488,73512],"yaml":true},{"content":"The named semaphore exists, but the user does not have the security access required to use it.","nodes":[{"pos":[0,94],"content":"The named semaphore exists, but the user does not have the security access required to use it.","nodes":[{"content":"The named semaphore exists, but the user does not have the security access required to use it.","pos":[0,94]}]}],"pos":[73626,73721],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Threading.Semaphore\n  commentId: T:System.Threading.Semaphore\n  id: Semaphore\n  children:\n  - System.Threading.Semaphore.#ctor(System.Int32,System.Int32)\n  - System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)\n  - System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)\n  - System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)\n  - System.Threading.Semaphore.GetAccessControl\n  - System.Threading.Semaphore.OpenExisting(System.String)\n  - System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)\n  - System.Threading.Semaphore.Release\n  - System.Threading.Semaphore.Release(System.Int32)\n  - System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)\n  - System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)\n  - System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)\n  langs:\n  - csharp\n  name: Semaphore\n  nameWithType: Semaphore\n  fullName: System.Threading.Semaphore\n  type: Class\n  assemblies:\n  - System.Threading\n  - System\n  - netstandard\n  namespace: System.Threading\n  summary: Limits the number of threads that can access a resource or pool of resources concurrently.\n  remarks: \"Use the <xref:System.Threading.Semaphore> class to control access to a pool of resources. Threads enter the semaphore by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method, which is inherited from the <xref:System.Threading.WaitHandle> class, and release the semaphore by calling the <xref:System.Threading.Semaphore.Release%2A> method.  \\n  \\n The count on a semaphore is decremented each time a thread enters the semaphore, and incremented when a thread releases the semaphore. When the count is zero, subsequent requests block until other threads release the semaphore. When all threads have released the semaphore, the count is at the maximum value specified when the semaphore was created.  \\n  \\n There is no guaranteed order, such as FIFO or LIFO, in which blocked threads enter the semaphore.  \\n  \\n A thread can enter the semaphore multiple times, by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method repeatedly. To release some or all of these entries, the thread can call the parameterless <xref:System.Threading.Semaphore.Release> method overload multiple times, or it can call the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload that specifies the number of entries to be released.  \\n  \\n The <xref:System.Threading.Semaphore> class does not enforce thread identity on calls to <xref:System.Threading.WaitHandle.WaitOne%2A> or <xref:System.Threading.Semaphore.Release%2A>. It is the programmer's responsibility to ensure that threads do not release the semaphore too many times. For example, suppose a semaphore has a maximum count of two, and that thread A and thread B both enter the semaphore. If a programming error in thread B causes it to call <xref:System.Threading.Semaphore.Release%2A> twice, both calls succeed. The count on the semaphore is full, and when thread A eventually calls <xref:System.Threading.Semaphore.Release%2A>, a <xref:System.Threading.SemaphoreFullException> is thrown.  \\n  \\n Semaphores are of two types: local semaphores and named system semaphores. If you create a <xref:System.Threading.Semaphore> object using a constructor that accepts a name, it is associated with an operating-system semaphore of that name. Named system semaphores are visible throughout the operating system, and can be used to synchronize the activities of processes. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore, and you can use the <xref:System.Threading.Semaphore.OpenExisting%2A> method to open an existing named system semaphore.  \\n  \\n A local semaphore exists only within your process. It can be used by any thread in your process that has a reference to the local <xref:System.Threading.Semaphore> object. Each <xref:System.Threading.Semaphore> object is a separate local semaphore.\"\n  example:\n  - \"The following code example creates a semaphore with a maximum count of three and an initial count of zero. The example starts five threads, which block waiting for the semaphore. The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore. Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore. Each time the semaphore is released, the previous semaphore count is displayed. Console messages track semaphore use. The simulated work interval is increased slightly for each thread, to make the output easier to read.  \\n  \\n [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]\\n [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(false)]\n\n      public sealed class Semaphore : System.Threading.WaitHandle\n  inheritance:\n  - System.Object\n  - System.Threading.WaitHandle\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  - System.Threading.WaitHandle.Close\n  - System.Threading.WaitHandle.Dispose\n  - System.Threading.WaitHandle.Dispose(System.Boolean)\n  - System.Threading.WaitHandle.Handle\n  - System.Threading.WaitHandle.InvalidHandle\n  - System.Threading.WaitHandle.SafeWaitHandle\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)\n  - System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)\n  - System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitOne\n  - System.Threading.WaitHandle.WaitOne(System.Int32)\n  - System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\n  - System.Threading.WaitHandle.WaitOne(System.TimeSpan)\n  - System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)\n  - System.Threading.WaitHandle.WaitTimeout\n  extensionMethods:\n  - System.Threading.ThreadingAclExtensions.GetAccessControl(System.Threading.Semaphore)\n  - System.Threading.ThreadingAclExtensions.SetAccessControl(System.Threading.Semaphore,System.Security.AccessControl.SemaphoreSecurity)\n  - System.Threading.WaitHandleExtensions.GetSafeWaitHandle(System.Threading.WaitHandle)\n  - System.Threading.WaitHandleExtensions.SetSafeWaitHandle(System.Threading.WaitHandle,Microsoft.Win32.SafeHandles.SafeWaitHandle)\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Semaphore.#ctor(System.Int32,System.Int32)\n  commentId: M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32)\n  id: '#ctor(System.Int32,System.Int32)'\n  parent: System.Threading.Semaphore\n  langs:\n  - csharp\n  name: Semaphore(Int32, Int32)\n  nameWithType: Semaphore.Semaphore(Int32, Int32)\n  fullName: Semaphore.Semaphore(Int32, Int32)\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - System\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.Semaphore\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries.\n  remarks: \"This constructor initializes an unnamed semaphore. All threads that use an instance of such a semaphore must have references to the instance.  \\n  \\n If `initialCount` is less than `maximumCount`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times. If you do not want to reserve any entries for the thread that creates the semaphore, use the same number for `maximumCount` and `initialCount`.\"\n  example:\n  - \"The following example creates a semaphore with a maximum count of three and an initial count of zero. The example starts five threads, which block waiting for the semaphore. The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore. Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore. Each time the semaphore is released, the previous semaphore count is displayed. Console messages track semaphore use. The simulated work interval is increased slightly for each thread, to make the output easier to read.  \\n  \\n [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]\\n [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]\"\n  syntax:\n    content: public Semaphore (int initialCount, int maximumCount);\n    parameters:\n    - id: initialCount\n      type: System.Int32\n      description: The initial number of requests for the semaphore that can be granted concurrently.\n    - id: maximumCount\n      type: System.Int32\n      description: The maximum number of requests for the semaphore that can be granted concurrently.\n  overload: System.Threading.Semaphore.#ctor*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>initialCount</code> is greater than <code>maximumCount</code>.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>maximumCount</code> is less than 1.  \\n  \\n -or-  \\n  \\n <code>initialCount</code> is less than 0.\"\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)\n  commentId: M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)\n  id: '#ctor(System.Int32,System.Int32,System.String)'\n  parent: System.Threading.Semaphore\n  langs:\n  - csharp\n  name: Semaphore(Int32, Int32, String)\n  nameWithType: Semaphore.Semaphore(Int32, Int32, String)\n  fullName: Semaphore.Semaphore(Int32, Int32, String)\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - System\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.Semaphore\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries, and optionally specifying the name of a system semaphore object.\n  remarks: \"This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.  \\n  \\n If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`. If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions. If you need to determine whether or not a named system semaphore was created, use the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.String%2CSystem.Boolean%40%29> constructor overload instead.  \\n  \\n> [!IMPORTANT]\\n>  When you use this constructor overload, the recommended practice is to specify the same number for `initialCount` and `maximumCount`. If `initialCount` is less than `maximumCount`, and a named system semaphore is created, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times. However, with this constructor overload there is no way to determine whether a named system semaphore was created.  \\n  \\n If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload.  \\n  \\n Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.  \\n  \\n If you want to find out whether a named system semaphore exists, use the <xref:System.Threading.Semaphore.OpenExisting%2A> method. The <xref:System.Threading.Semaphore.OpenExisting%2A> method attempts to open an existing named semaphore, and throws an exception if the system semaphore does not exist.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named semaphore. The example creates a named semaphore with a maximum count of five and an initial count of five. The program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method. Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>. Release one or more entries in the first copy of the program to unblock the second.  \\n  \\n [!code-cpp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/CS/source.cs#1)]\\n [!code-vb[System.Threading.Semaphore.ctor named 3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 3/VB/source.vb#1)]\"\n  syntax:\n    content: public Semaphore (int initialCount, int maximumCount, string name);\n    parameters:\n    - id: initialCount\n      type: System.Int32\n      description: The initial number of requests for the semaphore that can be granted concurrently.\n    - id: maximumCount\n      type: System.Int32\n      description: The maximum number of requests for the semaphore that can be granted concurrently.\n    - id: name\n      type: System.String\n      description: The name of a named system semaphore object.\n  overload: System.Threading.Semaphore.#ctor*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>initialCount</code> is greater than <code>maximumCount</code>.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>maximumCount</code> is less than 1.  \\n  \\n -or-  \\n  \\n <code>initialCount</code> is less than 0.\"\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named semaphore exists and has access control security, and the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.FullControl\"></xref>.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)\n  commentId: M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)\n  id: '#ctor(System.Int32,System.Int32,System.String,System.Boolean@)'\n  parent: System.Threading.Semaphore\n  langs:\n  - csharp\n  name: Semaphore(Int32, Int32, String, Boolean)\n  nameWithType: Semaphore.Semaphore(Int32, Int32, String, Boolean)\n  fullName: Semaphore.Semaphore(Int32, Int32, String, Boolean)\n  type: Constructor\n  assemblies:\n  - System.Threading\n  - System\n  - netstandard\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.Semaphore\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, and specifying a variable that receives a value indicating whether a new system semaphore was created.\n  remarks: \"This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.  \\n  \\n If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`. If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions. Use `createdNew` to determine whether the system semaphore was created.  \\n  \\n If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.  \\n  \\n If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload. In this case, `createdNew` is always `true`.  \\n  \\n Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named semaphore. The example creates a named semaphore with a maximum count of five and an initial count of two. That is, it reserves three entries for the thread that calls the constructor. If `createNew` is `false`, the program makes three calls to the <xref:System.Threading.WaitHandle.WaitOne%2A> method. Thus, if you run the compiled example from two command windows, the second copy will block on the third call to <xref:System.Threading.WaitHandle.WaitOne%2A>. Release one or more entries in the first copy of the program to unblock the second.  \\n  \\n [!code-cpp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/CS/source.cs#1)]\\n [!code-vb[System.Threading.Semaphore.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 4/VB/source.vb#1)]\"\n  syntax:\n    content: public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew);\n    parameters:\n    - id: initialCount\n      type: System.Int32\n      description: The initial number of requests for the semaphore that can be satisfied concurrently.\n    - id: maximumCount\n      type: System.Int32\n      description: The maximum number of requests for the semaphore that can be satisfied concurrently.\n    - id: name\n      type: System.String\n      description: The name of a named system semaphore object.\n    - id: createdNew\n      type: System.Boolean\n      description: When this method returns, contains `true` if a local semaphore was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system semaphore was created; `false` if the specified named system semaphore already existed. This parameter is passed uninitialized.\n  overload: System.Threading.Semaphore.#ctor*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>initialCount</code> is greater than <code>maximumCount</code>.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>maximumCount</code> is less than 1.  \\n  \\n -or-  \\n  \\n <code>initialCount</code> is less than 0.\"\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named semaphore exists and has access control security, and the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.FullControl\"></xref>.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)\n  commentId: M:System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)\n  id: '#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)'\n  parent: System.Threading.Semaphore\n  langs:\n  - csharp\n  name: Semaphore(Int32, Int32, String, Boolean, SemaphoreSecurity)\n  nameWithType: Semaphore.Semaphore(Int32, Int32, String, Boolean, SemaphoreSecurity)\n  fullName: Semaphore.Semaphore(Int32, Int32, String, Boolean, SemaphoreSecurity)\n  type: Constructor\n  assemblies:\n  - System\n  namespace: System.Threading\n  summary: Initializes a new instance of the <xref href=\"System.Threading.Semaphore\"></xref> class, specifying the initial number of entries and the maximum number of concurrent entries, optionally specifying the name of a system semaphore object, specifying a variable that receives a value indicating whether a new system semaphore was created, and specifying security access control for the system semaphore.\n  remarks: \"Use this constructor to apply access control security to a named system semaphore when it is created, preventing other code from taking control of the semaphore.  \\n  \\n This constructor initializes a <xref:System.Threading.Semaphore> object that represents a named system semaphore. You can create multiple <xref:System.Threading.Semaphore> objects that represent the same named system semaphore.  \\n  \\n If the named system semaphore does not exist, it is created with the specified access control security. If the named semaphore exists, the specified access control security is ignored.  \\n  \\n> [!NOTE]\\n>  The caller has full control over the newly created <xref:System.Threading.Semaphore> object even if `semaphoreSecurity` denies or fails to grant some access rights to the current user. However, if the current user attempts to get another <xref:System.Threading.Semaphore> object to represent the same named semaphore, using either a constructor or the <xref:System.Threading.Semaphore.OpenExisting%2A> method, Windows access control security is applied.  \\n  \\n If the named system semaphore does not exist, it is created with the initial count and maximum count specified by `initialCount` and `maximumCount`. If the named system semaphore already exists, `initialCount` and `maximumCount` are not used, although invalid values still cause exceptions. Use the `createdNew` parameter to determine whether the system semaphore was created by this constructor.  \\n  \\n If `initialCount` is less than `maximumCount`, and `createdNew` is `true`, the effect is the same as if the current thread had called <xref:System.Threading.WaitHandle.WaitOne%2A> (`maximumCount` minus `initialCount`) times.  \\n  \\n If you specify `null` or an empty string for `name`, a local semaphore is created, as if you had called the <xref:System.Threading.Semaphore.%23ctor%28System.Int32%2CSystem.Int32%29> constructor overload. In this case, `createdNew` is always `true`.  \\n  \\n Because named semaphores are visible throughout the operating system, they can be used to coordinate resource use across process boundaries.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named semaphore with access control security. The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore. If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore. If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method. The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.  \\n  \\n After the permissions are changed, the semaphore is opened with the rights required to enter and release. If you run the compiled example from a third command window, it runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]\\n [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]\"\n  syntax:\n    content: public Semaphore (int initialCount, int maximumCount, string name, out bool createdNew, System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);\n    parameters:\n    - id: initialCount\n      type: System.Int32\n      description: The initial number of requests for the semaphore that can be satisfied concurrently.\n    - id: maximumCount\n      type: System.Int32\n      description: The maximum number of requests for the semaphore that can be satisfied concurrently.\n    - id: name\n      type: System.String\n      description: The name of a named system semaphore object.\n    - id: createdNew\n      type: System.Boolean\n      description: When this method returns, contains `true` if a local semaphore was created (that is, if <code>name</code> is `null` or an empty string) or if the specified named system semaphore was created; `false` if the specified named system semaphore already existed. This parameter is passed uninitialized.\n    - id: semaphoreSecurity\n      type: System.Security.AccessControl.SemaphoreSecurity\n      description: A <xref href=\"System.Security.AccessControl.SemaphoreSecurity\"></xref> object that represents the access control security to be applied to the named system semaphore.\n  overload: System.Threading.Semaphore.#ctor*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>initialCount</code> is greater than <code>maximumCount</code>.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>maximumCount</code> is less than 1.  \\n  \\n -or-  \\n  \\n <code>initialCount</code> is less than 0.\"\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named semaphore exists and has access control security, and the user does not have <xref href=\"System.Security.AccessControl.SemaphoreRights.FullControl\"></xref>.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named semaphore cannot be created, perhaps because a wait handle of a different type has the same name.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Semaphore.GetAccessControl\n  commentId: M:System.Threading.Semaphore.GetAccessControl\n  id: GetAccessControl\n  parent: System.Threading.Semaphore\n  langs:\n  - csharp\n  name: GetAccessControl()\n  nameWithType: Semaphore.GetAccessControl()\n  fullName: Semaphore.GetAccessControl()\n  type: Method\n  assemblies:\n  - System\n  namespace: System.Threading\n  summary: Gets the access control security for a named system semaphore.\n  remarks: \"The <xref:System.Threading.Semaphore.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>, and <xref:System.Security.AccessControl.AccessControlSections?displayProperty=fullName>.  \\n  \\n The user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights.  \\n  \\n On a local semaphore, access control security is irrelevant. If the <xref:System.Threading.Semaphore> object does not represent a named system semaphore, this method returns a <xref:System.Security.AccessControl.SemaphoreSecurity> object that grants all rights to any user.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named semaphore with access control security. The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.  \\n  \\n If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.  \\n  \\n If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method. The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions. The access control security for the system semaphore is obtained using the <xref:System.Threading.Semaphore.GetAccessControl%2A> method.  \\n  \\n After the permissions are changed, the semaphore is opened with the rights required to enter and release. If you run the compiled example from a third command window, it runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]\\n [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]\"\n  syntax:\n    content: public System.Security.AccessControl.SemaphoreSecurity GetAccessControl ();\n    parameters: []\n    return:\n      type: System.Security.AccessControl.SemaphoreSecurity\n      description: A <xref href=\"System.Security.AccessControl.SemaphoreSecurity\"></xref> object that represents the access control security for the named system semaphore.\n  overload: System.Threading.Semaphore.GetAccessControl*\n  exceptions:\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: \"The current <xref href=\\\"System.Threading.Semaphore\\\"></xref> object represents a named system semaphore, and the user does not have <xref href=\\\"System.Security.AccessControl.SemaphoreRights.ReadPermissions\\\"></xref> rights.  \\n  \\n -or-  \\n  \\n The current <xref href=\\\"System.Threading.Semaphore\\\"></xref> object represents a named system semaphore and was not opened with <xref href=\\\"System.Security.AccessControl.SemaphoreRights.ReadPermissions\\\"></xref> rights.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: Not supported for Windows 98 or Windows Millennium Edition.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Semaphore.OpenExisting(System.String)\n  commentId: M:System.Threading.Semaphore.OpenExisting(System.String)\n  id: OpenExisting(System.String)\n  parent: System.Threading.Semaphore\n  langs:\n  - csharp\n  name: OpenExisting(String)\n  nameWithType: Semaphore.OpenExisting(String)\n  fullName: Semaphore.OpenExisting(String)\n  type: Method\n  assemblies:\n  - System.Threading\n  - System\n  - netstandard\n  namespace: System.Threading\n  summary: Opens the specified named semaphore, if it already exists.\n  remarks: \"The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open the specified named semaphore. If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore. To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.  \\n  \\n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.  \\n  \\n This method overload is equivalent to calling the <xref:System.Threading.Semaphore.OpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> and <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights, combined by using the bitwise OR operation.  \\n  \\n Specifying the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to enter the semaphore, and specifying the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named semaphore with access control security. The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.  \\n  \\n If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but which grants the right to read and change permissions on the semaphore.  \\n  \\n If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload. The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.  \\n  \\n After the permissions are changed, the semaphore is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]\\n [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]\"\n  syntax:\n    content: public static System.Threading.Semaphore OpenExisting (string name);\n    parameters:\n    - id: name\n      type: System.String\n      description: The name of the system semaphore to open.\n    return:\n      type: System.Threading.Semaphore\n      description: An object that represents the named system semaphore.\n  overload: System.Threading.Semaphore.OpenExisting*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>name</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named semaphore does not exist.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named semaphore exists, but the user does not have the security access required to use it.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)\n  commentId: M:System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)\n  id: OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)\n  parent: System.Threading.Semaphore\n  langs:\n  - csharp\n  name: OpenExisting(String, SemaphoreRights)\n  nameWithType: Semaphore.OpenExisting(String, SemaphoreRights)\n  fullName: Semaphore.OpenExisting(String, SemaphoreRights)\n  type: Method\n  assemblies:\n  - System\n  namespace: System.Threading\n  summary: Opens the specified named semaphore, if it already exists, with the desired security access.\n  remarks: \"The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.  \\n  \\n The <xref:System.Threading.Semaphore.OpenExisting%2A> method tries to open an existing named semaphore. If the system semaphore does not exist, this method throws an exception instead of creating the system semaphore. To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.  \\n  \\n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named semaphore with access control security. The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.  \\n  \\n If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore, but grants the right to read and change permissions on the semaphore.  \\n  \\n If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method. The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.  \\n  \\n After the permissions are changed, the semaphore is opened with the rights required to enter and release it. If you run the compiled example from a third command window, it runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]\\n [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]\"\n  syntax:\n    content: public static System.Threading.Semaphore OpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights);\n    parameters:\n    - id: name\n      type: System.String\n      description: The name of the system semaphore to open.\n    - id: rights\n      type: System.Security.AccessControl.SemaphoreRights\n      description: A bitwise combination of the enumeration values that represent the desired security access.\n    return:\n      type: System.Threading.Semaphore\n      description: An object that represents the named system semaphore.\n  overload: System.Threading.Semaphore.OpenExisting*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>name</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.Threading.WaitHandleCannotBeOpenedException\n    commentId: T:System.Threading.WaitHandleCannotBeOpenedException\n    description: The named semaphore does not exist.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named semaphore exists, but the user does not have the desired security access rights.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Semaphore.Release\n  commentId: M:System.Threading.Semaphore.Release\n  id: Release\n  parent: System.Threading.Semaphore\n  langs:\n  - csharp\n  name: Release()\n  nameWithType: Semaphore.Release()\n  fullName: Semaphore.Release()\n  type: Method\n  assemblies:\n  - System.Threading\n  - System\n  - netstandard\n  namespace: System.Threading\n  summary: Exits the semaphore and returns the previous count.\n  remarks: \"Threads typically use the <xref:System.Threading.WaitHandle.WaitOne%2A> method to enter the semaphore, and they typically use this method overload to exit.  \\n  \\n If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread. A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.  \\n  \\n If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights.\"\n  example:\n  - \"The following code example creates a semaphore with a maximum count of three and an initial count of zero. The example starts five threads, which block waiting for the semaphore. The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore. Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.  \\n  \\n Each time the semaphore is released, the previous semaphore count is displayed. Console messages track semaphore use. The simulated work interval is increased slightly for each thread, to make the output easier to read.  \\n  \\n [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]\\n [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]\"\n  syntax:\n    content: public int Release ();\n    parameters: []\n    return:\n      type: System.Int32\n      description: The count on the semaphore before the <xref href=\"System.Threading.Semaphore.Release*\"></xref> method was called.\n  overload: System.Threading.Semaphore.Release*\n  exceptions:\n  - type: System.Threading.SemaphoreFullException\n    commentId: T:System.Threading.SemaphoreFullException\n    description: The semaphore count is already at the maximum value.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred with a named semaphore.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: \"The current semaphore represents a named system semaphore, but the user does not have <xref href=\\\"System.Security.AccessControl.SemaphoreRights.Modify\\\"></xref>.  \\n  \\n -or-  \\n  \\n The current semaphore represents a named system semaphore, but it was not opened with <xref href=\\\"System.Security.AccessControl.SemaphoreRights.Modify\\\"></xref>.\"\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Semaphore.Release(System.Int32)\n  commentId: M:System.Threading.Semaphore.Release(System.Int32)\n  id: Release(System.Int32)\n  parent: System.Threading.Semaphore\n  langs:\n  - csharp\n  name: Release(Int32)\n  nameWithType: Semaphore.Release(Int32)\n  fullName: Semaphore.Release(Int32)\n  type: Method\n  assemblies:\n  - System.Threading\n  - System\n  - netstandard\n  namespace: System.Threading\n  summary: Exits the semaphore a specified number of times and returns the previous count.\n  remarks: \"If a thread has entered the semaphore multiple times, this method overload allows the entire semaphore count to be restored with one call.  \\n  \\n If a <xref:System.Threading.SemaphoreFullException> is thrown by the <xref:System.Threading.Semaphore.Release%2A> method, it does not necessarily indicate a problem with the calling thread. A programming error in another thread might have caused that thread to exit the semaphore more times than it entered.  \\n  \\n If the current <xref:System.Threading.Semaphore> object represents a named system semaphore, the user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights.\"\n  example:\n  - \"The following code example creates a semaphore with a maximum count of three and an initial count of zero. The example starts five threads, which block waiting for the semaphore. The main thread uses the <xref:System.Threading.Semaphore.Release%28System.Int32%29> method overload to increase the semaphore count to its maximum, allowing three threads to enter the semaphore. Each thread uses the <xref:System.Threading.Thread.Sleep%2A?displayProperty=fullName> method to wait for one second, to simulate work, and then calls the <xref:System.Threading.Semaphore.Release> method overload to release the semaphore.  \\n  \\n Each time the semaphore is released, the previous semaphore count is displayed. Console messages track semaphore use. The simulated work interval is increased slightly for each thread, to make the output easier to read.  \\n  \\n [!code-cpp[System.Threading.Semaphore2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Semaphore2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore2/CS/source.cs#1)]\\n [!code-vb[System.Threading.Semaphore2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore2/VB/source.vb#1)]\"\n  syntax:\n    content: public int Release (int releaseCount);\n    parameters:\n    - id: releaseCount\n      type: System.Int32\n      description: The number of times to exit the semaphore.\n    return:\n      type: System.Int32\n      description: The count on the semaphore before the <xref href=\"System.Threading.Semaphore.Release*\"></xref> method was called.\n  overload: System.Threading.Semaphore.Release*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>releaseCount</code> is less than 1.\n  - type: System.Threading.SemaphoreFullException\n    commentId: T:System.Threading.SemaphoreFullException\n    description: The semaphore count is already at the maximum value.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred with a named semaphore.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: \"The current semaphore represents a named system semaphore, but the user does not have <xref href=\\\"System.Security.AccessControl.SemaphoreRights.Modify\\\"></xref> rights.  \\n  \\n -or-  \\n  \\n The current semaphore represents a named system semaphore, but it was not opened with <xref href=\\\"System.Security.AccessControl.SemaphoreRights.Modify\\\"></xref> rights.\"\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)\n  commentId: M:System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)\n  id: SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)\n  parent: System.Threading.Semaphore\n  langs:\n  - csharp\n  name: SetAccessControl(SemaphoreSecurity)\n  nameWithType: Semaphore.SetAccessControl(SemaphoreSecurity)\n  fullName: Semaphore.SetAccessControl(SemaphoreSecurity)\n  type: Method\n  assemblies:\n  - System\n  namespace: System.Threading\n  summary: Sets the access control security for a named system semaphore.\n  remarks: \"You can set access control security only on <xref:System.Threading.Semaphore> objects that represent named system semaphores.  \\n  \\n The user must have <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights to call this method, and the semaphore must have been opened with <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights.\"\n  example:\n  - \"The following code example demonstrates the cross-process behavior of a named semaphore with access control security. The example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload to test for the existence of a named semaphore.  \\n  \\n If the semaphore does not exist, it is created with a maximum count of two and with access control security that denies the current user the right to use the semaphore but grants the right to read and change permissions on the semaphore.  \\n  \\n If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method. The exception is caught, and the example uses the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload to open the semaphore with the rights needed to read and change the permissions.  \\n  \\n After the permissions are changed, using the <xref:System.Threading.Semaphore.SetAccessControl%2A> method, the semaphore is opened with the rights required to enter and release. If you run the compiled example from a third command window, it runs using the new permissions.  \\n  \\n [!code-cpp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CPP/source.cpp#1)]\\n [!code-csharp[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/CS/source.cs#1)]\\n [!code-vb[System.Threading.Semaphore.ctor named 5a#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Semaphore.ctor named 5a/VB/source.vb#1)]\"\n  syntax:\n    content: public void SetAccessControl (System.Security.AccessControl.SemaphoreSecurity semaphoreSecurity);\n    parameters:\n    - id: semaphoreSecurity\n      type: System.Security.AccessControl.SemaphoreSecurity\n      description: A <xref href=\"System.Security.AccessControl.SemaphoreSecurity\"></xref> object that represents the access control security to be applied to the named system semaphore.\n  overload: System.Threading.Semaphore.SetAccessControl*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>semaphoreSecurity</code> is `null`.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: \"The user does not have <xref href=\\\"System.Security.AccessControl.SemaphoreRights.ChangePermissions\\\"></xref> rights.  \\n  \\n -or-  \\n  \\n The semaphore was not opened with <xref href=\\\"System.Security.AccessControl.SemaphoreRights.ChangePermissions\\\"></xref> rights.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The current <xref href=\"System.Threading.Semaphore\"></xref> object does not represent a named system semaphore.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)\n  commentId: M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)\n  id: TryOpenExisting(System.String,System.Threading.Semaphore@)\n  parent: System.Threading.Semaphore\n  langs:\n  - csharp\n  name: TryOpenExisting(String, Semaphore)\n  nameWithType: Semaphore.TryOpenExisting(String, Semaphore)\n  fullName: Semaphore.TryOpenExisting(String, Semaphore)\n  type: Method\n  assemblies:\n  - System.Threading\n  - System\n  - netstandard\n  namespace: System.Threading\n  summary: Opens the specified named semaphore, if it already exists, and returns a value that indicates whether the operation succeeded.\n  remarks: \"If the named semaphore does not exist, this method does not create it. To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.  \\n  \\n If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%29> method overload, which throws an exception if the semaphore does not exist.  \\n  \\n This method overload is equivalent to calling the <xref:System.Threading.Semaphore.TryOpenExisting%2A> method overload and specifying <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> and <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> rights, combined by using the bitwise OR operation. Specifying the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to enter the semaphore, and specifying the   <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag allows a thread to call the <xref:System.Threading.Semaphore.Release%2A> method.\"\n  syntax:\n    content: public static bool TryOpenExisting (string name, out System.Threading.Semaphore result);\n    parameters:\n    - id: name\n      type: System.String\n      description: The name of the system semaphore to open.\n    - id: result\n      type: System.Threading.Semaphore\n      description: When this method returns, contains a <xref href=\"System.Threading.Semaphore\"></xref> object that represents the named semaphore if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.\n    return:\n      type: System.Boolean\n      description: '`true` if the named semaphore was opened successfully; otherwise, `false`.'\n  overload: System.Threading.Semaphore.TryOpenExisting*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>name</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named semaphore exists, but the user does not have the security access required to use it.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)\n  commentId: M:System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)\n  id: TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)\n  parent: System.Threading.Semaphore\n  langs:\n  - csharp\n  name: TryOpenExisting(String, SemaphoreRights, Semaphore)\n  nameWithType: Semaphore.TryOpenExisting(String, SemaphoreRights, Semaphore)\n  fullName: Semaphore.TryOpenExisting(String, SemaphoreRights, Semaphore)\n  type: Method\n  assemblies:\n  - System\n  namespace: System.Threading\n  summary: Opens the specified named semaphore, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.\n  remarks: \"If the named semaphore does not exist, this method does not create it. To create the system semaphore when it does not already exist, use one of the <xref:System.Threading.Semaphore.%23ctor%2A> constructors that has a `name` parameter.  \\n  \\n If you are uncertain whether a named semaphore exists, use this method overload instead of the <xref:System.Threading.Semaphore.OpenExisting%28System.String%2CSystem.Security.AccessControl.SemaphoreRights%29> method overload, which throws an exception if the semaphore does not exist.  \\n  \\n The `rights` parameter must include the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag to allow threads to enter the semaphore, and the <xref:System.Security.AccessControl.SemaphoreRights?displayProperty=fullName> flag to allow threads to call the <xref:System.Threading.Semaphore.Release%2A> method.  \\n  \\n Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Semaphore> object, even though the objects that are returned represent the same named system semaphore.\"\n  syntax:\n    content: public static bool TryOpenExisting (string name, System.Security.AccessControl.SemaphoreRights rights, out System.Threading.Semaphore result);\n    parameters:\n    - id: name\n      type: System.String\n      description: The name of the system semaphore to open.\n    - id: rights\n      type: System.Security.AccessControl.SemaphoreRights\n      description: A bitwise combination of the enumeration values that represent the desired security access.\n    - id: result\n      type: System.Threading.Semaphore\n      description: When this method returns, contains a <xref href=\"System.Threading.Semaphore\"></xref> object that represents the named semaphore if the call succeeded, or `null` if the call failed. This parameter is treated as uninitialized.\n    return:\n      type: System.Boolean\n      description: '`true` if the named semaphore was opened successfully; otherwise, `false`.'\n  overload: System.Threading.Semaphore.TryOpenExisting*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>name</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>name</code> is longer than 260 characters.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.IO.IOException\n    commentId: T:System.IO.IOException\n    description: A Win32 error occurred.\n  - type: System.UnauthorizedAccessException\n    commentId: T:System.UnauthorizedAccessException\n    description: The named semaphore exists, but the user does not have the security access required to use it.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Threading.WaitHandle\n  parent: System.Threading\n  isExternal: false\n  name: WaitHandle\n  nameWithType: WaitHandle\n  fullName: System.Threading.WaitHandle\n- uid: System.ArgumentException\n  parent: System\n  isExternal: false\n  name: ArgumentException\n  nameWithType: ArgumentException\n  fullName: System.ArgumentException\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.IO.IOException\n  parent: System.IO\n  isExternal: false\n  name: IOException\n  nameWithType: IOException\n  fullName: System.IO.IOException\n- uid: System.UnauthorizedAccessException\n  parent: System\n  isExternal: false\n  name: UnauthorizedAccessException\n  nameWithType: UnauthorizedAccessException\n  fullName: System.UnauthorizedAccessException\n- uid: System.Threading.WaitHandleCannotBeOpenedException\n  parent: System.Threading\n  isExternal: false\n  name: WaitHandleCannotBeOpenedException\n  nameWithType: WaitHandleCannotBeOpenedException\n  fullName: System.Threading.WaitHandleCannotBeOpenedException\n- uid: System.NotSupportedException\n  parent: System\n  isExternal: false\n  name: NotSupportedException\n  nameWithType: NotSupportedException\n  fullName: System.NotSupportedException\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.Threading.SemaphoreFullException\n  parent: System.Threading\n  isExternal: false\n  name: SemaphoreFullException\n  nameWithType: SemaphoreFullException\n  fullName: System.Threading.SemaphoreFullException\n- uid: System.Threading.Semaphore.#ctor(System.Int32,System.Int32)\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: Semaphore(Int32, Int32)\n  nameWithType: Semaphore.Semaphore(Int32, Int32)\n  fullName: Semaphore.Semaphore(Int32, Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String)\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: Semaphore(Int32, Int32, String)\n  nameWithType: Semaphore.Semaphore(Int32, Int32, String)\n  fullName: Semaphore.Semaphore(Int32, Int32, String)\n- uid: System.String\n  parent: System\n  isExternal: false\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@)\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: Semaphore(Int32, Int32, String, Boolean)\n  nameWithType: Semaphore.Semaphore(Int32, Int32, String, Boolean)\n  fullName: Semaphore.Semaphore(Int32, Int32, String, Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Threading.Semaphore.#ctor(System.Int32,System.Int32,System.String,System.Boolean@,System.Security.AccessControl.SemaphoreSecurity)\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: Semaphore(Int32, Int32, String, Boolean, SemaphoreSecurity)\n  nameWithType: Semaphore.Semaphore(Int32, Int32, String, Boolean, SemaphoreSecurity)\n  fullName: Semaphore.Semaphore(Int32, Int32, String, Boolean, SemaphoreSecurity)\n- uid: System.Security.AccessControl.SemaphoreSecurity\n  parent: System.Security.AccessControl\n  isExternal: false\n  name: SemaphoreSecurity\n  nameWithType: SemaphoreSecurity\n  fullName: System.Security.AccessControl.SemaphoreSecurity\n- uid: System.Threading.Semaphore.GetAccessControl\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: GetAccessControl()\n  nameWithType: Semaphore.GetAccessControl()\n  fullName: Semaphore.GetAccessControl()\n- uid: System.Threading.Semaphore.OpenExisting(System.String)\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: OpenExisting(String)\n  nameWithType: Semaphore.OpenExisting(String)\n  fullName: Semaphore.OpenExisting(String)\n- uid: System.Threading.Semaphore\n  parent: System.Threading\n  isExternal: false\n  name: Semaphore\n  nameWithType: Semaphore\n  fullName: System.Threading.Semaphore\n- uid: System.Threading.Semaphore.OpenExisting(System.String,System.Security.AccessControl.SemaphoreRights)\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: OpenExisting(String, SemaphoreRights)\n  nameWithType: Semaphore.OpenExisting(String, SemaphoreRights)\n  fullName: Semaphore.OpenExisting(String, SemaphoreRights)\n- uid: System.Security.AccessControl.SemaphoreRights\n  parent: System.Security.AccessControl\n  isExternal: false\n  name: SemaphoreRights\n  nameWithType: SemaphoreRights\n  fullName: System.Security.AccessControl.SemaphoreRights\n- uid: System.Threading.Semaphore.Release\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: Release()\n  nameWithType: Semaphore.Release()\n  fullName: Semaphore.Release()\n- uid: System.Threading.Semaphore.Release(System.Int32)\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: Release(Int32)\n  nameWithType: Semaphore.Release(Int32)\n  fullName: Semaphore.Release(Int32)\n- uid: System.Threading.Semaphore.SetAccessControl(System.Security.AccessControl.SemaphoreSecurity)\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: SetAccessControl(SemaphoreSecurity)\n  nameWithType: Semaphore.SetAccessControl(SemaphoreSecurity)\n  fullName: Semaphore.SetAccessControl(SemaphoreSecurity)\n- uid: System.Threading.Semaphore.TryOpenExisting(System.String,System.Threading.Semaphore@)\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: TryOpenExisting(String, Semaphore)\n  nameWithType: Semaphore.TryOpenExisting(String, Semaphore)\n  fullName: Semaphore.TryOpenExisting(String, Semaphore)\n- uid: System.Threading.Semaphore.TryOpenExisting(System.String,System.Security.AccessControl.SemaphoreRights,System.Threading.Semaphore@)\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: TryOpenExisting(String, SemaphoreRights, Semaphore)\n  nameWithType: Semaphore.TryOpenExisting(String, SemaphoreRights, Semaphore)\n  fullName: Semaphore.TryOpenExisting(String, SemaphoreRights, Semaphore)\n- uid: System.Threading.Semaphore.#ctor*\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: Semaphore\n  nameWithType: Semaphore.Semaphore\n  fullName: Semaphore.Semaphore\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n- uid: System.Threading.Semaphore.GetAccessControl*\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: GetAccessControl\n  nameWithType: Semaphore.GetAccessControl\n  fullName: Semaphore.GetAccessControl\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n- uid: System.Threading.Semaphore.OpenExisting*\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: OpenExisting\n  nameWithType: Semaphore.OpenExisting\n  fullName: Semaphore.OpenExisting\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n- uid: System.Threading.Semaphore.Release*\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: Release\n  nameWithType: Semaphore.Release\n  fullName: Semaphore.Release\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n- uid: System.Threading.Semaphore.SetAccessControl*\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: SetAccessControl\n  nameWithType: Semaphore.SetAccessControl\n  fullName: Semaphore.SetAccessControl\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n- uid: System.Threading.Semaphore.TryOpenExisting*\n  parent: System.Threading.Semaphore\n  isExternal: false\n  name: TryOpenExisting\n  nameWithType: Semaphore.TryOpenExisting\n  fullName: Semaphore.TryOpenExisting\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Threading/Semaphore.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.Threading.WaitHandle.Close\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Close()\n  nameWithType: WaitHandle.Close()\n  fullName: WaitHandle.Close()\n- uid: System.Threading.WaitHandle.Dispose\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Dispose()\n  nameWithType: WaitHandle.Dispose()\n  fullName: WaitHandle.Dispose()\n- uid: System.Threading.WaitHandle.Dispose(System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Dispose(Boolean)\n  nameWithType: WaitHandle.Dispose(Boolean)\n  fullName: WaitHandle.Dispose(Boolean)\n- uid: System.Threading.WaitHandle.Handle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: Handle\n  nameWithType: WaitHandle.Handle\n  fullName: WaitHandle.Handle\n- uid: System.Threading.WaitHandle.InvalidHandle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: InvalidHandle\n  nameWithType: WaitHandle.InvalidHandle\n  fullName: WaitHandle.InvalidHandle\n- uid: System.Threading.WaitHandle.SafeWaitHandle\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SafeWaitHandle\n  nameWithType: WaitHandle.SafeWaitHandle\n  fullName: WaitHandle.SafeWaitHandle\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle)\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, Int32, Boolean)\n- uid: System.Threading.WaitHandle.SignalAndWait(System.Threading.WaitHandle,System.Threading.WaitHandle,System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n  nameWithType: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n  fullName: WaitHandle.SignalAndWait(WaitHandle, WaitHandle, TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], TimeSpan, Boolean)\n  fullName: WaitHandle.WaitAll(WaitHandle[], TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], Int32, Boolean)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], Int32, Boolean)\n  fullName: WaitHandle.WaitAll(WaitHandle[], Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], TimeSpan)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], TimeSpan)\n  fullName: WaitHandle.WaitAll(WaitHandle[], TimeSpan)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[],System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[], Int32)\n  nameWithType: WaitHandle.WaitAll(WaitHandle[], Int32)\n  fullName: WaitHandle.WaitAll(WaitHandle[], Int32)\n- uid: System.Threading.WaitHandle.WaitAll(System.Threading.WaitHandle[])\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAll(WaitHandle[])\n  nameWithType: WaitHandle.WaitAll(WaitHandle[])\n  fullName: WaitHandle.WaitAll(WaitHandle[])\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[])\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[])\n  nameWithType: WaitHandle.WaitAny(WaitHandle[])\n  fullName: WaitHandle.WaitAny(WaitHandle[])\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], Int32)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], Int32)\n  fullName: WaitHandle.WaitAny(WaitHandle[], Int32)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], TimeSpan)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], TimeSpan)\n  fullName: WaitHandle.WaitAny(WaitHandle[], TimeSpan)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], Int32, Boolean)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], Int32, Boolean)\n  fullName: WaitHandle.WaitAny(WaitHandle[], Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitAny(System.Threading.WaitHandle[],System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitAny(WaitHandle[], TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitAny(WaitHandle[], TimeSpan, Boolean)\n  fullName: WaitHandle.WaitAny(WaitHandle[], TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitOne\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne()\n  nameWithType: WaitHandle.WaitOne()\n  fullName: WaitHandle.WaitOne()\n- uid: System.Threading.WaitHandle.WaitOne(System.Int32)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(Int32)\n  nameWithType: WaitHandle.WaitOne(Int32)\n  fullName: WaitHandle.WaitOne(Int32)\n- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(TimeSpan)\n  nameWithType: WaitHandle.WaitOne(TimeSpan)\n  fullName: WaitHandle.WaitOne(TimeSpan)\n- uid: System.Threading.WaitHandle.WaitOne(System.Int32,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(Int32, Boolean)\n  nameWithType: WaitHandle.WaitOne(Int32, Boolean)\n  fullName: WaitHandle.WaitOne(Int32, Boolean)\n- uid: System.Threading.WaitHandle.WaitOne(System.TimeSpan,System.Boolean)\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitOne(TimeSpan, Boolean)\n  nameWithType: WaitHandle.WaitOne(TimeSpan, Boolean)\n  fullName: WaitHandle.WaitOne(TimeSpan, Boolean)\n- uid: System.Threading.WaitHandle.WaitTimeout\n  parent: System.Threading.WaitHandle\n  isExternal: false\n  name: WaitTimeout\n  nameWithType: WaitHandle.WaitTimeout\n  fullName: WaitHandle.WaitTimeout\n- uid: System.Threading.ThreadingAclExtensions.GetAccessControl(System.Threading.Semaphore)\n  parent: System.Threading.ThreadingAclExtensions\n  isExternal: false\n  name: GetAccessControl(Semaphore)\n  nameWithType: ThreadingAclExtensions.GetAccessControl(Semaphore)\n  fullName: ThreadingAclExtensions.GetAccessControl(Semaphore)\n- uid: System.Threading.ThreadingAclExtensions.SetAccessControl(System.Threading.Semaphore,System.Security.AccessControl.SemaphoreSecurity)\n  parent: System.Threading.ThreadingAclExtensions\n  isExternal: false\n  name: SetAccessControl(Semaphore, SemaphoreSecurity)\n  nameWithType: ThreadingAclExtensions.SetAccessControl(Semaphore, SemaphoreSecurity)\n  fullName: ThreadingAclExtensions.SetAccessControl(Semaphore, SemaphoreSecurity)\n- uid: System.Threading.WaitHandleExtensions.GetSafeWaitHandle(System.Threading.WaitHandle)\n  parent: System.Threading.WaitHandleExtensions\n  isExternal: false\n  name: GetSafeWaitHandle(WaitHandle)\n  nameWithType: WaitHandleExtensions.GetSafeWaitHandle(WaitHandle)\n  fullName: WaitHandleExtensions.GetSafeWaitHandle(WaitHandle)\n- uid: System.Threading.WaitHandleExtensions.SetSafeWaitHandle(System.Threading.WaitHandle,Microsoft.Win32.SafeHandles.SafeWaitHandle)\n  parent: System.Threading.WaitHandleExtensions\n  isExternal: false\n  name: SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n  nameWithType: WaitHandleExtensions.SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n  fullName: WaitHandleExtensions.SetSafeWaitHandle(WaitHandle, SafeWaitHandle)\n"}