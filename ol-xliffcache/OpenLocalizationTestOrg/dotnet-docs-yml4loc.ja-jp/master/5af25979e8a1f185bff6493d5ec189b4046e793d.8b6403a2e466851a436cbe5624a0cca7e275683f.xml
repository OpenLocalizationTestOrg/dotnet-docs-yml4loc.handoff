{"nodes":[{"content":"Provides a set of static methods and properties that provide support for compilers. This class cannot be inherited.","nodes":[{"pos":[0,115],"content":"Provides a set of static methods and properties that provide support for compilers. This class cannot be inherited.","nodes":[{"content":"Provides a set of static methods and properties that provide support for compilers. This class cannot be inherited.","pos":[0,115],"nodes":[{"content":"Provides a set of static methods and properties that provide support for compilers.","pos":[0,83]},{"content":"This class cannot be inherited.","pos":[84,115]}]}]}],"pos":[2240,2356],"yaml":true},{"content":"Ensures that the remaining stack space is large enough to execute the average .NET Framework function.","nodes":[{"pos":[0,102],"content":"Ensures that the remaining stack space is large enough to execute the average .NET Framework function.","nodes":[{"content":"Ensures that the remaining stack space is large enough to execute the average .NET Framework function.","pos":[0,102]}]}],"pos":[5468,5571],"yaml":true},{"content":"<xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken. The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.  \n  \n This method is useful in situations where stack overflow might occur as a result of unbounded recursion. It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.  \n  \n If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.  \n  \n> [!NOTE]\n>  This method is not part of the constrained execution region (CER) support, and should not be confused with the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=fullName> method.","nodes":[{"pos":[0,369],"content":"<xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken. The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.","nodes":[{"content":"<xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken. The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.","pos":[0,369],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A&gt;</ph> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken.","pos":[0,235],"source":"<xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken."},{"content":"The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.","pos":[236,369]}]}]},{"pos":[376,603],"content":"This method is useful in situations where stack overflow might occur as a result of unbounded recursion. It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.","nodes":[{"content":"This method is useful in situations where stack overflow might occur as a result of unbounded recursion. It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.","pos":[0,227],"nodes":[{"content":"This method is useful in situations where stack overflow might occur as a result of unbounded recursion.","pos":[0,104]},{"content":"It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.","pos":[105,227]}]}]},{"pos":[610,735],"content":"If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.","nodes":[{"content":"If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.","pos":[0,125]}]},{"pos":[743,978],"content":"[!NOTE]\n This method is not part of the constrained execution region (CER) support, and should not be confused with the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=fullName> method.","leadings":["","> "],"nodes":[{"content":"This method is not part of the constrained execution region (CER) support, and should not be confused with the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=fullName&gt;</ph> method.","pos":[9,233],"source":" This method is not part of the constrained execution region (CER) support, and should not be confused with the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=fullName> method."}]}],"pos":[5582,6570],"yaml":true,"extradata":"MT"},{"content":"The available stack space is insufficient to execute the average .NET Framework function.","nodes":[{"pos":[0,89],"content":"The available stack space is insufficient to execute the average .NET Framework function.","nodes":[{"content":"The available stack space is insufficient to execute the average .NET Framework function.","pos":[0,89]}]}],"pos":[6901,6991],"yaml":true},{"content":"Determines whether the specified <xref href=\"System.Object\"></xref> instances are considered equal.","nodes":[{"pos":[0,99],"content":"Determines whether the specified <ph id=\"ph1\">&lt;xref href=\"System.Object\"&gt;&lt;/xref&gt;</ph> instances are considered equal.","source":"Determines whether the specified <xref href=\"System.Object\"></xref> instances are considered equal."}],"pos":[8550,8650],"yaml":true},{"content":"This method is used by compilers.","nodes":[{"pos":[0,33],"content":"This method is used by compilers.","nodes":[{"content":"This method is used by compilers.","pos":[0,33]}]}],"pos":[8661,8695],"yaml":true,"extradata":"MT"},{"content":"The first object to compare.","nodes":[{"pos":[0,28],"content":"The first object to compare.","nodes":[{"content":"The first object to compare.","pos":[0,28]}]}],"pos":[9359,9388],"yaml":true},{"content":"The second object to compare.","nodes":[{"pos":[0,29],"content":"The second object to compare.","nodes":[{"content":"The second object to compare.","pos":[0,29]}]}],"pos":[9446,9476],"yaml":true},{"content":"`true` if the <code>o1</code> parameter is the same instance as the <code>o2</code> parameter, or if both are `null`, or if <code>o1.Equals(o2)</code> returns `true`; otherwise, `false`.","nodes":[{"pos":[0,186],"content":"<ph id=\"ph1\">`true`</ph> if the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">o1</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is the same instance as the <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">o2</ph><ept id=\"p2\">&lt;/code&gt;</ept> parameter, or if both are <ph id=\"ph4\">`null`</ph>, or if <bpt id=\"p3\">&lt;code&gt;</bpt><ph id=\"ph5\">o1.Equals(o2)</ph><ept id=\"p3\">&lt;/code&gt;</ept> returns <ph id=\"ph6\">`true`</ph>; otherwise, <ph id=\"ph7\">`false`</ph>.","source":"`true` if the <code>o1</code> parameter is the same instance as the <code>o2</code> parameter, or if both are `null`, or if <code>o1.Equals(o2)</code> returns `true`; otherwise, `false`."}],"pos":[9534,9723],"yaml":true},{"content":"Executes code using a <xref href=\"System.Delegate\"></xref> while using another <xref href=\"System.Delegate\"></xref> to execute additional code in case of an exception.","nodes":[{"pos":[0,167],"content":"Executes code using a <ph id=\"ph1\">&lt;xref href=\"System.Delegate\"&gt;&lt;/xref&gt;</ph> while using another <ph id=\"ph2\">&lt;xref href=\"System.Delegate\"&gt;&lt;/xref&gt;</ph> to execute additional code in case of an exception.","source":"Executes code using a <xref href=\"System.Delegate\"></xref> while using another <xref href=\"System.Delegate\"></xref> to execute additional code in case of an exception."}],"pos":[11713,11881],"yaml":true},{"content":"This method is used by compilers.","nodes":[{"pos":[0,33],"content":"This method is used by compilers.","nodes":[{"content":"This method is used by compilers.","pos":[0,33]}]}],"pos":[11892,11926],"yaml":true,"extradata":"MT"},{"content":"A delegate to the code to try.","nodes":[{"pos":[0,30],"content":"A delegate to the code to try.","nodes":[{"content":"A delegate to the code to try.","pos":[0,30]}]}],"pos":[12270,12301],"yaml":true},{"content":"A delegate to the code to run if an exception occurs.","nodes":[{"pos":[0,53],"content":"A delegate to the code to run if an exception occurs.","nodes":[{"content":"A delegate to the code to run if an exception occurs.","pos":[0,53]}]}],"pos":[12413,12467],"yaml":true},{"content":"The data to pass to <code>code</code> and <code>backoutCode</code>.","nodes":[{"pos":[0,67],"content":"The data to pass to <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">code</ph><ept id=\"p1\">&lt;/code&gt;</ept> and <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">backoutCode</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","source":"The data to pass to <code>code</code> and <code>backoutCode</code>."}],"pos":[12531,12599],"yaml":true},{"content":"Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.","nodes":[{"pos":[0,151],"content":"Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.","nodes":[{"content":"Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.","pos":[0,151]}]}],"pos":[13991,14143],"yaml":true},{"content":"The <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> method always calls the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method non-virtually, even if the object's type has overridden the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method. Therefore, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> might differ from calling `GetHashCode` directly on the object with the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method.  \n  \n> [!WARNING]\n>  Although the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference. To test for object identify (that is, to test that two objects reference the same object in memory), call the <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> method. Nor should you use <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> to test whether two strings represent equal object references, because the string is interned. To test for string interning, call the <xref:System.String.IsInterned%2A?displayProperty=fullName> method.  \n  \n The <xref:System.Object.GetHashCode%2A?displayProperty=fullName> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> methods differ as follows:  \n  \n-   <xref:System.Object.GetHashCode%2A?displayProperty=fullName> returns a hash code that is based on the object's definition of equality. For example, two strings with identical contents will return the same value for <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.  \n  \n-   <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> returns a hash code that indicates object identity. That is, two string variables whose contents are identical and that represent a string that is interned (see the [String Interning](#interning) section) or that represent a single string in memory return identical hash codes.  \n  \n> [!IMPORTANT]\n>  Note that <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> always returns identical hash codes for equal object references. However, the reverse is not true: equal hash codes do not indicate equal object references. A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.  \n  \n This method is used by compilers.  \n  \n<a name=\"interning\"></a>   \n## String Interning  \n The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool. If two strings (for example, `str1` and `str2`) are formed from an identical string literal, the CLR will set `str1` and `str2` to point to the same location on the managed heap to conserve memory. Calling <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.  \n  \n The CLR adds only literals to the pool. Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal. Therefore, if `str2` was created as the result of a concatenation operation, and `str2` is identical to `str1`, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> on these two string objects will not produce the same hash code.  \n  \n If you want to add a concatenated string to the pool explicitly, use the <xref:System.String.Intern%2A?displayProperty=fullName> method.  \n  \n You can also use the <xref:System.String.IsInterned%2A?displayProperty=fullName> method to check whether a string has an interned reference.","nodes":[{"pos":[0,570],"content":"The <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> method always calls the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method non-virtually, even if the object's type has overridden the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method. Therefore, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> might differ from calling `GetHashCode` directly on the object with the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph> method always calls the <ph id=\"ph2\">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> method non-virtually, even if the object's type has overridden the <ph id=\"ph3\">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> method.","pos":[0,318],"source":"The <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> method always calls the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method non-virtually, even if the object's type has overridden the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method."},{"content":"Therefore, using <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph> might differ from calling <ph id=\"ph2\">`GetHashCode`</ph> directly on the object with the <ph id=\"ph3\">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> method.","pos":[319,570],"source":" Therefore, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> might differ from calling `GetHashCode` directly on the object with the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method."}]},{"pos":[578,1371],"content":"[!WARNING]\n Although the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference. To test for object identify (that is, to test that two objects reference the same object in memory), call the <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> method. Nor should you use <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> to test whether two strings represent equal object references, because the string is interned. To test for string interning, call the <xref:System.String.IsInterned%2A?displayProperty=fullName> method.","leadings":["","> "],"nodes":[{"content":" Although the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference. To test for object identify (that is, to test that two objects reference the same object in memory), call the <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> method. Nor should you use <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> to test whether two strings represent equal object references, because the string is interned. To test for string interning, call the <xref:System.String.IsInterned%2A?displayProperty=fullName> method.","pos":[11,791],"nodes":[{"content":"Although the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference.","pos":[1,307],"source":" Although the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference."},{"content":"To test for object identify (that is, to test that two objects reference the same object in memory), call the <ph id=\"ph1\">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=fullName&gt;</ph> method.","pos":[308,490],"source":" To test for object identify (that is, to test that two objects reference the same object in memory), call the <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> method."},{"content":"Nor should you use <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> to test whether two strings represent equal object references, because the string is interned.","pos":[491,673],"source":" Nor should you use <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> to test whether two strings represent equal object references, because the string is interned."},{"content":"To test for string interning, call the <ph id=\"ph1\">&lt;xref:System.String.IsInterned%2A?displayProperty=fullName&gt;</ph> method.","pos":[674,780],"source":" To test for string interning, call the <xref:System.String.IsInterned%2A?displayProperty=fullName> method."}]}]},{"pos":[1378,1567],"content":"The <xref:System.Object.GetHashCode%2A?displayProperty=fullName> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> methods differ as follows:","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph> methods differ as follows:","pos":[0,189],"source":"The <xref:System.Object.GetHashCode%2A?displayProperty=fullName> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> methods differ as follows:"}]},{"pos":[1577,1853],"content":"<xref:System.Object.GetHashCode%2A?displayProperty=fullName> returns a hash code that is based on the object's definition of equality. For example, two strings with identical contents will return the same value for <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.","nodes":[{"content":"<xref:System.Object.GetHashCode%2A?displayProperty=fullName> returns a hash code that is based on the object's definition of equality. For example, two strings with identical contents will return the same value for <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.","pos":[0,276],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> returns a hash code that is based on the object's definition of equality.","pos":[0,134],"source":"<xref:System.Object.GetHashCode%2A?displayProperty=fullName> returns a hash code that is based on the object's definition of equality."},{"content":"For example, two strings with identical contents will return the same value for <ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.","pos":[135,276],"source":" For example, two strings with identical contents will return the same value for <xref:System.Object.GetHashCode%2A?displayProperty=fullName>."}]}]},{"pos":[1863,2234],"content":"<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> returns a hash code that indicates object identity. That is, two string variables whose contents are identical and that represent a string that is interned (see the [String Interning](#interning) section) or that represent a single string in memory return identical hash codes.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph> returns a hash code that indicates object identity.","pos":[0,145],"source":"<xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> returns a hash code that indicates object identity."},{"content":"That is, two string variables whose contents are identical and that represent a string that is interned (see the <bpt id=\"p1\">[</bpt>String Interning<ept id=\"p1\">](#interning)</ept> section) or that represent a single string in memory return identical hash codes.","pos":[146,371],"source":" That is, two string variables whose contents are identical and that represent a string that is interned (see the [String Interning](#interning) section) or that represent a single string in memory return identical hash codes."}]},{"pos":[2242,2633],"content":"[!IMPORTANT]\n Note that <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> always returns identical hash codes for equal object references. However, the reverse is not true: equal hash codes do not indicate equal object references. A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.","leadings":["","> "],"nodes":[{"content":" Note that <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> always returns identical hash codes for equal object references. However, the reverse is not true: equal hash codes do not indicate equal object references. A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.","pos":[13,389],"nodes":[{"content":"Note that <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> always returns identical hash codes for equal object references.","pos":[1,144],"source":" Note that <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> always returns identical hash codes for equal object references."},{"content":"However, the reverse is not true: equal hash codes do not indicate equal object references.","pos":[145,236]},{"content":"A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.","pos":[237,376]}]}]},{"pos":[2640,2673],"content":"This method is used by compilers.","nodes":[{"content":"This method is used by compilers.","pos":[0,33]}]},{"pos":[2710,2726],"content":"String Interning","linkify":"String Interning","nodes":[{"content":"String Interning","pos":[0,16]}]},{"pos":[2730,3257],"content":"The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool. If two strings (for example, `str1` and `str2`) are formed from an identical string literal, the CLR will set `str1` and `str2` to point to the same location on the managed heap to conserve memory. Calling <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.","nodes":[{"content":"The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool.","pos":[0,104]},{"content":"If two strings (for example, <ph id=\"ph1\">`str1`</ph> and <ph id=\"ph2\">`str2`</ph>) are formed from an identical string literal, the CLR will set <ph id=\"ph3\">`str1`</ph> and <ph id=\"ph4\">`str2`</ph> to point to the same location on the managed heap to conserve memory.","pos":[105,302],"source":" If two strings (for example, `str1` and `str2`) are formed from an identical string literal, the CLR will set `str1` and `str2` to point to the same location on the managed heap to conserve memory."},{"content":"Calling <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.","pos":[303,527],"source":" Calling <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section."}]},{"pos":[3264,3740],"content":"The CLR adds only literals to the pool. Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal. Therefore, if `str2` was created as the result of a concatenation operation, and `str2` is identical to `str1`, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> on these two string objects will not produce the same hash code.","nodes":[{"content":"The CLR adds only literals to the pool.","pos":[0,39]},{"content":"Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal.","pos":[40,199]},{"content":"Therefore, if <ph id=\"ph1\">`str2`</ph> was created as the result of a concatenation operation, and <ph id=\"ph2\">`str2`</ph> is identical to <ph id=\"ph3\">`str1`</ph>, using <ph id=\"ph4\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph> on these two string objects will not produce the same hash code.","pos":[200,476],"source":" Therefore, if `str2` was created as the result of a concatenation operation, and `str2` is identical to `str1`, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> on these two string objects will not produce the same hash code."}]},{"pos":[3747,3883],"content":"If you want to add a concatenated string to the pool explicitly, use the <xref:System.String.Intern%2A?displayProperty=fullName> method.","nodes":[{"content":"If you want to add a concatenated string to the pool explicitly, use the <ph id=\"ph1\">&lt;xref:System.String.Intern%2A?displayProperty=fullName&gt;</ph> method.","pos":[0,136],"source":"If you want to add a concatenated string to the pool explicitly, use the <xref:System.String.Intern%2A?displayProperty=fullName> method."}]},{"pos":[3890,4030],"content":"You can also use the <xref:System.String.IsInterned%2A?displayProperty=fullName> method to check whether a string has an interned reference.","nodes":[{"content":"You can also use the <ph id=\"ph1\">&lt;xref:System.String.IsInterned%2A?displayProperty=fullName&gt;</ph> method to check whether a string has an interned reference.","pos":[0,140],"source":"You can also use the <xref:System.String.IsInterned%2A?displayProperty=fullName> method to check whether a string has an interned reference."}]}],"pos":[14154,18213],"yaml":true,"extradata":"MT"},{"content":"An object to retrieve the hash code for.","nodes":[{"pos":[0,40],"content":"An object to retrieve the hash code for.","nodes":[{"content":"An object to retrieve the hash code for.","pos":[0,40]}]}],"pos":[20279,20320],"yaml":true},{"content":"A hash code for the object identified by the <code>o</code> parameter.","nodes":[{"pos":[0,70],"content":"A hash code for the object identified by the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">o</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"A hash code for the object identified by the <code>o</code> parameter."}],"pos":[20376,20447],"yaml":true},{"content":"Boxes a value type.","nodes":[{"pos":[0,19],"content":"Boxes a value type.","nodes":[{"content":"Boxes a value type.","pos":[0,19]}]}],"pos":[22180,22200],"yaml":true},{"content":"Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.  \n  \n This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.  \n  \n The return value depends on whether the value class is mutable or immutable:  \n  \n-   If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.  \n  \n-   If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.  \n  \n Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types. That is, boxed value types get cloned when you pass them around, and they are always passed by value. The compiler can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> to assign a value type to an object or to pass a value type as a parameter of a type object.  \n  \n This method is used by compilers.","nodes":[{"pos":[0,128],"content":"Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.","nodes":[{"content":"Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.","pos":[0,128]}]},{"pos":[135,255],"content":"This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.","nodes":[{"content":"This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.","pos":[0,120]}]},{"pos":[262,338],"content":"The return value depends on whether the value class is mutable or immutable:","nodes":[{"content":"The return value depends on whether the value class is mutable or immutable:","pos":[0,76]}]},{"pos":[348,492],"content":"If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.","nodes":[{"content":"If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.","pos":[0,144]}]},{"pos":[502,628],"content":"If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.","nodes":[{"content":"If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.","pos":[0,126]}]},{"pos":[635,1061],"content":"Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types. That is, boxed value types get cloned when you pass them around, and they are always passed by value. The compiler can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> to assign a value type to an object or to pass a value type as a parameter of a type object.","nodes":[{"content":"Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types. That is, boxed value types get cloned when you pass them around, and they are always passed by value. The compiler can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> to assign a value type to an object or to pass a value type as a parameter of a type object.","pos":[0,426],"nodes":[{"content":"Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types.","pos":[0,137]},{"content":"That is, boxed value types get cloned when you pass them around, and they are always passed by value.","pos":[138,239]},{"content":"The compiler can call <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> to assign a value type to an object or to pass a value type as a parameter of a type object.","pos":[240,426],"source":" The compiler can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> to assign a value type to an object or to pass a value type as a parameter of a type object."}]}]},{"pos":[1068,1101],"content":"This method is used by compilers.","nodes":[{"content":"This method is used by compilers.","pos":[0,33]}]}],"pos":[22211,23327],"yaml":true,"extradata":"MT"},{"content":"The value type to be boxed.","nodes":[{"pos":[0,27],"content":"The value type to be boxed.","nodes":[{"content":"The value type to be boxed.","pos":[0,27]}]}],"pos":[24030,24058],"yaml":true},{"content":"A boxed copy of <code>obj</code> if it is a value class; otherwise, <code>obj</code> itself.","nodes":[{"pos":[0,92],"content":"A boxed copy of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">obj</ph><ept id=\"p1\">&lt;/code&gt;</ept> if it is a value class; otherwise, <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">obj</ph><ept id=\"p2\">&lt;/code&gt;</ept> itself.","source":"A boxed copy of <code>obj</code> if it is a value class; otherwise, <code>obj</code> itself."}],"pos":[24115,24208],"yaml":true},{"content":"Provides a fast way to initialize an array from data that is stored in a module.","nodes":[{"pos":[0,80],"content":"Provides a fast way to initialize an array from data that is stored in a module.","nodes":[{"content":"Provides a fast way to initialize an array from data that is stored in a module.","pos":[0,80]}]}],"pos":[27124,27205],"yaml":true},{"content":"This method is used by compilers.","nodes":[{"pos":[0,33],"content":"This method is used by compilers.","nodes":[{"content":"This method is used by compilers.","pos":[0,33]}]}],"pos":[27216,27250],"yaml":true,"extradata":"MT"},{"content":"The array to be initialized.","nodes":[{"pos":[0,28],"content":"The array to be initialized.","nodes":[{"content":"The array to be initialized.","pos":[0,28]}]}],"pos":[27429,27458],"yaml":true},{"content":"A field handle that specifies the location of the data used to initialize the array.","nodes":[{"pos":[0,84],"content":"A field handle that specifies the location of the data used to initialize the array.","nodes":[{"content":"A field handle that specifies the location of the data used to initialize the array.","pos":[0,84]}]}],"pos":[27535,27620],"yaml":true},{"content":"Gets the offset, in bytes, to the data in the given string.","nodes":[{"pos":[0,59],"content":"Gets the offset, in bytes, to the data in the given string.","nodes":[{"content":"Gets the offset, in bytes, to the data in the given string.","pos":[0,59]}]}],"pos":[30387,30447],"yaml":true},{"content":"Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string. Compilers should pin the string against movement by the garbage collector before use. Note that common language runtime strings are immutable; that is, their contents can be read but not changed.","nodes":[{"pos":[0,308],"content":"Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string. Compilers should pin the string against movement by the garbage collector before use. Note that common language runtime strings are immutable; that is, their contents can be read but not changed.","nodes":[{"content":"Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string. Compilers should pin the string against movement by the garbage collector before use. Note that common language runtime strings are immutable; that is, their contents can be read but not changed.","pos":[0,308],"nodes":[{"content":"Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string.","pos":[0,112]},{"content":"Compilers should pin the string against movement by the garbage collector before use.","pos":[113,198]},{"content":"Note that common language runtime strings are immutable; that is, their contents can be read but not changed.","pos":[199,308]}]}]}],"pos":[30458,30767],"yaml":true,"extradata":"MT"},{"content":"The byte offset, from the start of the <xref href=\"System.String\"></xref> object to the first character in the string.","nodes":[{"pos":[0,118],"content":"The byte offset, from the start of the <ph id=\"ph1\">&lt;xref href=\"System.String\"&gt;&lt;/xref&gt;</ph> object to the first character in the string.","source":"The byte offset, from the start of the <xref href=\"System.String\"></xref> object to the first character in the string."}],"pos":[30892,31011],"yaml":true},{"content":"Designates a body of code as a constrained execution region (CER).","nodes":[{"pos":[0,66],"content":"Designates a body of code as a constrained execution region (CER).","nodes":[{"content":"Designates a body of code as a constrained execution region (CER).","pos":[0,66]}]}],"pos":[32754,32821],"yaml":true},{"content":"Compilers use this method to mark `catch`, `finally`, and `fault` blocks as constrained execution regions (CERs). Code that is marked as a constrained region must only call other code with strong reliability contracts. It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.  \n  \n Note that no intermediate language opcodes, except `NOP`, are allowed between a call to the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method and the `try` block. For more information about CERs, see the classes in the <xref:System.Runtime.ConstrainedExecution> namespace.  \n  \n CERs that are marked using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method do not work perfectly when a <xref:System.StackOverflowException> is generated from the `try` block. For more information, see the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method.  \n  \n The <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method calls the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method.","nodes":[{"pos":[0,341],"content":"Compilers use this method to mark `catch`, `finally`, and `fault` blocks as constrained execution regions (CERs). Code that is marked as a constrained region must only call other code with strong reliability contracts. It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.","nodes":[{"content":"Compilers use this method to mark <ph id=\"ph1\">`catch`</ph>, <ph id=\"ph2\">`finally`</ph>, and <ph id=\"ph3\">`fault`</ph> blocks as constrained execution regions (CERs).","pos":[0,113],"source":"Compilers use this method to mark `catch`, `finally`, and `fault` blocks as constrained execution regions (CERs)."},{"content":"Code that is marked as a constrained region must only call other code with strong reliability contracts.","pos":[114,218]},{"content":"It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.","pos":[219,341]}]},{"pos":[348,660],"content":"Note that no intermediate language opcodes, except `NOP`, are allowed between a call to the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method and the `try` block. For more information about CERs, see the classes in the <xref:System.Runtime.ConstrainedExecution> namespace.","nodes":[{"content":"Note that no intermediate language opcodes, except <ph id=\"ph1\">`NOP`</ph>, are allowed between a call to the <ph id=\"ph2\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method and the <ph id=\"ph3\">`try`</ph> block.","pos":[0,202],"source":"Note that no intermediate language opcodes, except `NOP`, are allowed between a call to the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method and the `try` block."},{"content":"For more information about CERs, see the classes in the <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution&gt;</ph> namespace.","pos":[203,312],"source":" For more information about CERs, see the classes in the <xref:System.Runtime.ConstrainedExecution> namespace."}]},{"pos":[667,1016],"content":"CERs that are marked using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method do not work perfectly when a <xref:System.StackOverflowException> is generated from the `try` block. For more information, see the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method.","nodes":[{"content":"CERs that are marked using the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method do not work perfectly when a <ph id=\"ph2\">&lt;xref:System.StackOverflowException&gt;</ph> is generated from the <ph id=\"ph3\">`try`</ph> block.","pos":[0,221],"source":"CERs that are marked using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method do not work perfectly when a <xref:System.StackOverflowException> is generated from the `try` block."},{"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A&gt;</ph> method.","pos":[222,349],"source":" For more information, see the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method."}]},{"pos":[1023,1215],"content":"The <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method calls the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method calls the <ph id=\"ph2\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> method.","pos":[0,192],"source":"The <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method calls the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method."}]}],"pos":[32832,34056],"yaml":true,"extradata":"MT"},{"content":"Designates a body of code as a constrained execution region (CER) without performing any probing.","nodes":[{"pos":[0,97],"content":"Designates a body of code as a constrained execution region (CER) without performing any probing.","nodes":[{"content":"Designates a body of code as a constrained execution region (CER) without performing any probing.","pos":[0,97]}]}],"pos":[36666,36764],"yaml":true},{"content":"Compilers should not call this method directly. Instead, define a CER by calling the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName> method.","nodes":[{"pos":[0,200],"content":"Compilers should not call this method directly. Instead, define a CER by calling the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName> method.","nodes":[{"content":"Compilers should not call this method directly. Instead, define a CER by calling the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName> method.","pos":[0,200],"nodes":[{"content":"Compilers should not call this method directly.","pos":[0,47]},{"content":"Instead, define a CER by calling the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName&gt;</ph> method.","pos":[48,200],"source":" Instead, define a CER by calling the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName> method."}]}]}],"pos":[36775,36976],"yaml":true,"extradata":"MT"},{"content":"Provides a way for applications to dynamically prepare <xref href=\"System.AppDomain\"></xref> event delegates.","nodes":[{"pos":[0,109],"content":"Provides a way for applications to dynamically prepare <ph id=\"ph1\">&lt;xref href=\"System.AppDomain\"&gt;&lt;/xref&gt;</ph> event delegates.","source":"Provides a way for applications to dynamically prepare <xref href=\"System.AppDomain\"></xref> event delegates."}],"pos":[38573,38683],"yaml":true},{"content":"<xref:System.AppDomain> event delegates such as <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, and <xref:System.AppDomain.UnhandledException> are not automatically prepared at startup. You can use the following methods to prepare them:  \n  \n-   Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute.  \n  \n-   Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute.  \n  \n-   Call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> method to dynamically prepare the delegate.  \n  \n For more information, see the article [Keep Your Code Running with the Reliability Features of the .NET Framework](http://go.microsoft.com/fwlink/?LinkId=145491) in the MSDN Magazine.","nodes":[{"pos":[0,263],"content":"<xref:System.AppDomain> event delegates such as <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, and <xref:System.AppDomain.UnhandledException> are not automatically prepared at startup. You can use the following methods to prepare them:","nodes":[{"content":"<xref:System.AppDomain> event delegates such as <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, and <xref:System.AppDomain.UnhandledException> are not automatically prepared at startup. You can use the following methods to prepare them:","pos":[0,263],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> event delegates such as <ph id=\"ph2\">&lt;xref:System.AppDomain.DomainUnload&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.AppDomain.ProcessExit&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> are not automatically prepared at startup.","pos":[0,212],"source":"<xref:System.AppDomain> event delegates such as <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, and <xref:System.AppDomain.UnhandledException> are not automatically prepared at startup."},{"content":"You can use the following methods to prepare them:","pos":[213,263]}]}]},{"pos":[273,386],"content":"Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute.","nodes":[{"content":"Attribute the method by using the <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute&gt;</ph> attribute.","pos":[0,113],"source":"Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute."}]},{"pos":[396,512],"content":"Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute.","nodes":[{"content":"Attribute the method by using the <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute.","pos":[0,116],"source":"Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute."}]},{"pos":[522,657],"content":"Call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> method to dynamically prepare the delegate.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A&gt;</ph> method to dynamically prepare the delegate.","pos":[0,135],"source":"Call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> method to dynamically prepare the delegate."}]},{"pos":[664,847],"content":"For more information, see the article <bpt id=\"p1\">[</bpt>Keep Your Code Running with the Reliability Features of the .NET Framework<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=145491)</ept> in the MSDN Magazine.","source":"For more information, see the article [Keep Your Code Running with the Reliability Features of the .NET Framework](http://go.microsoft.com/fwlink/?LinkId=145491) in the MSDN Magazine."}],"pos":[38694,39552],"yaml":true,"extradata":"MT"},{"content":"The event delegate to prepare.","nodes":[{"pos":[0,30],"content":"The event delegate to prepare.","nodes":[{"content":"The event delegate to prepare.","pos":[0,30]}]}],"pos":[39760,39791],"yaml":true},{"content":"Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).","nodes":[{"pos":[0,111],"content":"Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).","nodes":[{"content":"Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).","pos":[0,111]}]}],"pos":[41278,41390],"yaml":true},{"content":"Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).","nodes":[{"pos":[0,209],"content":"Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).","nodes":[{"content":"Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).","pos":[0,209]}]}],"pos":[41401,41611],"yaml":true,"extradata":"MT"},{"content":"The delegate type to prepare.","nodes":[{"pos":[0,29],"content":"The delegate type to prepare.","nodes":[{"content":"The delegate type to prepare.","pos":[0,29]}]}],"pos":[41809,41839],"yaml":true},{"content":"Prepares a method for inclusion in a constrained execution region (CER).","nodes":[{"pos":[0,72],"content":"Prepares a method for inclusion in a constrained execution region (CER).","nodes":[{"content":"Prepares a method for inclusion in a constrained execution region (CER).","pos":[0,72]}]}],"pos":[43370,43443],"yaml":true},{"content":"Compilers use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> method to handle virtual calls that are made inside a constrained execution region (CER). At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call. Therefore, the runtime does not initially prepare that segment of the call graph. If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.","nodes":[{"pos":[0,778],"content":"Compilers use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> method to handle virtual calls that are made inside a constrained execution region (CER). At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call. Therefore, the runtime does not initially prepare that segment of the call graph. If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.","nodes":[{"content":"Compilers use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> method to handle virtual calls that are made inside a constrained execution region (CER). At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call. Therefore, the runtime does not initially prepare that segment of the call graph. If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.","pos":[0,778],"nodes":[{"content":"Compilers use the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> method to handle virtual calls that are made inside a constrained execution region (CER).","pos":[0,207],"source":"Compilers use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> method to handle virtual calls that are made inside a constrained execution region (CER)."},{"content":"At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call.","pos":[208,337]},{"content":"Therefore, the runtime does not initially prepare that segment of the call graph.","pos":[338,419]},{"content":"If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.","pos":[420,778],"source":" If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument."}]}]}],"pos":[43454,44233],"yaml":true,"extradata":"MT"},{"content":"A handle to the method to prepare.","nodes":[{"pos":[0,34],"content":"A handle to the method to prepare.","nodes":[{"content":"A handle to the method to prepare.","pos":[0,34]}]}],"pos":[44410,44445],"yaml":true},{"content":"Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.","nodes":[{"pos":[0,105],"content":"Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.","nodes":[{"content":"Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.","pos":[0,105]}]}],"pos":[46052,46158],"yaml":true},{"content":"You can provide generics support for compilers by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method. The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.  \n  \n You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any). The runtime prepares that instantiation of the method. (This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style `try` clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <xref:System.Int32> or other value types. To instantiate reference types such as <xref:System.String>, you must use an explicit <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method on the CER root method first.","nodes":[{"pos":[0,485],"content":"You can provide generics support for compilers by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method. The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.","nodes":[{"content":"You can provide generics support for compilers by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method. The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.","pos":[0,485],"nodes":[{"content":"You can provide generics support for compilers by using the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> method.","pos":[0,200],"source":"You can provide generics support for compilers by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method."},{"content":"The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.","pos":[201,485]}]}]},{"pos":[492,1284],"content":"You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any). The runtime prepares that instantiation of the method. (This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style `try` clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <xref:System.Int32> or other value types. To instantiate reference types such as <xref:System.String>, you must use an explicit <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method on the CER root method first.","nodes":[{"content":"You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any).","pos":[0,181]},{"content":"The runtime prepares that instantiation of the method.","pos":[182,236]},{"content":"(This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style <ph id=\"ph1\">`try`</ph> clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph> or other value types.","pos":[237,536],"source":" (This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style `try` clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <xref:System.Int32> or other value types."},{"content":"To instantiate reference types such as <ph id=\"ph1\">&lt;xref:System.String&gt;</ph>, you must use an explicit <ph id=\"ph2\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> method on the CER root method first.","pos":[537,792],"source":" To instantiate reference types such as <xref:System.String>, you must use an explicit <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method on the CER root method first."}]}],"pos":[46169,47458],"yaml":true,"extradata":"MT"},{"content":"A handle to the method to prepare.","nodes":[{"pos":[0,34],"content":"A handle to the method to prepare.","nodes":[{"content":"A handle to the method to prepare.","pos":[0,34]}]}],"pos":[47670,47705],"yaml":true},{"content":"The instantiation to pass to the method.","nodes":[{"pos":[0,40],"content":"The instantiation to pass to the method.","nodes":[{"content":"The instantiation to pass to the method.","pos":[0,40]}]}],"pos":[47787,47828],"yaml":true},{"content":"Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space). We recommend that you use a constrained execution region (CER) instead of this method.","nodes":[{"pos":[0,290],"content":"Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space). We recommend that you use a constrained execution region (CER) instead of this method.","nodes":[{"content":"Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space). We recommend that you use a constrained execution region (CER) instead of this method.","pos":[0,290],"nodes":[{"content":"Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space).","pos":[0,203]},{"content":"We recommend that you use a constrained execution region (CER) instead of this method.","pos":[204,290]}]}]}],"pos":[49210,49501],"yaml":true},{"content":"This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server. This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.  \n  \n This method is also used by compilers.  \n  \n Instead of using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method, you should use a standard CER. That is, if you are planning to use a moderate amount of stack space, call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName> method immediately before your `try`/`finally` or `try`/`catch` block. If you are calling a recursive method or plan to use a lot of stack space, you must use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=fullName> method.","nodes":[{"pos":[0,345],"content":"This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server. This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.","nodes":[{"content":"This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server. This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.","pos":[0,345],"nodes":[{"content":"This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server.","pos":[0,195]},{"content":"This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.","pos":[196,345]}]}]},{"pos":[352,390],"content":"This method is also used by compilers.","nodes":[{"content":"This method is also used by compilers.","pos":[0,38]}]},{"pos":[397,1010],"content":"Instead of using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method, you should use a standard CER. That is, if you are planning to use a moderate amount of stack space, call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName> method immediately before your `try`/`finally` or `try`/`catch` block. If you are calling a recursive method or plan to use a lot of stack space, you must use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=fullName> method.","nodes":[{"content":"Instead of using the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> method, you should use a standard CER.","pos":[0,140],"source":"Instead of using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method, you should use a standard CER."},{"content":"That is, if you are planning to use a moderate amount of stack space, call the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName&gt;</ph> method immediately before your <ph id=\"ph2\">`try`</ph><ph id=\"ph3\">/</ph><ph id=\"ph4\">`finally`</ph> or <ph id=\"ph5\">`try`</ph><ph id=\"ph6\">/</ph><ph id=\"ph7\">`catch`</ph> block.","pos":[141,398],"source":" That is, if you are planning to use a moderate amount of stack space, call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName> method immediately before your `try`/`finally` or `try`/`catch` block."},{"content":"If you are calling a recursive method or plan to use a lot of stack space, you must use the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=fullName&gt;</ph> method.","pos":[399,613],"source":" If you are calling a recursive method or plan to use a lot of stack space, you must use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=fullName> method."}]}],"pos":[49512,50529],"yaml":true,"extradata":"MT"},{"content":"Runs a specified class constructor method.","nodes":[{"pos":[0,42],"content":"Runs a specified class constructor method.","nodes":[{"content":"Runs a specified class constructor method.","pos":[0,42]}]}],"pos":[52132,52175],"yaml":true},{"content":"This method is used by compilers.","nodes":[{"pos":[0,33],"content":"This method is used by compilers.","nodes":[{"content":"This method is used by compilers.","pos":[0,33]}]}],"pos":[52186,52220],"yaml":true,"extradata":"MT"},{"content":"A type handle that specifies the class constructor method to run.","nodes":[{"pos":[0,65],"content":"A type handle that specifies the class constructor method to run.","nodes":[{"content":"A type handle that specifies the class constructor method to run.","pos":[0,65]}]}],"pos":[52395,52461],"yaml":true},{"content":"The class initializer throws an exception.","nodes":[{"pos":[0,42],"content":"The class initializer throws an exception.","nodes":[{"content":"The class initializer throws an exception.","pos":[0,42]}]}],"pos":[52669,52712],"yaml":true},{"content":"Runs a specified module constructor method.","nodes":[{"pos":[0,43],"content":"Runs a specified module constructor method.","nodes":[{"content":"Runs a specified module constructor method.","pos":[0,43]}]}],"pos":[54428,54472],"yaml":true},{"content":"This method is used by compilers.","nodes":[{"pos":[0,33],"content":"This method is used by compilers.","nodes":[{"content":"This method is used by compilers.","pos":[0,33]}]}],"pos":[54483,54517],"yaml":true,"extradata":"MT"},{"content":"A handle that specifies the module constructor method to run.","nodes":[{"pos":[0,61],"content":"A handle that specifies the module constructor method to run.","nodes":[{"content":"A handle that specifies the module constructor method to run.","pos":[0,61]}]}],"pos":[54687,54749],"yaml":true},{"content":"The module constructor throws an exception.","nodes":[{"pos":[0,43],"content":"The module constructor throws an exception.","nodes":[{"content":"The module constructor throws an exception.","pos":[0,43]}]}],"pos":[54958,55002],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Runtime.CompilerServices.RuntimeHelpers\n  commentId: T:System.Runtime.CompilerServices.RuntimeHelpers\n  id: RuntimeHelpers\n  children:\n  - System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack\n  - System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)\n  - System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)\n  - System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)\n  - System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)\n  - System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject(System.Type)\n  - System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)\n  - System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1\n  - System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData\n  - System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions\n  - System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP\n  - System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)\n  - System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)\n  - System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)\n  - System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])\n  - System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack\n  - System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)\n  - System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)\n  - System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack\n  langs:\n  - csharp\n  name: RuntimeHelpers\n  nameWithType: RuntimeHelpers\n  fullName: System.Runtime.CompilerServices.RuntimeHelpers\n  type: Class\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Runtime.CompilerServices\n  summary: Provides a set of static methods and properties that provide support for compilers. This class cannot be inherited.\n  remarks: ''\n  example:\n  - \"The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method. To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic. Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked.  You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.  \\n  \\n [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]\\n [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]\"\n  syntax:\n    content: public static class RuntimeHelpers\n  inheritance:\n  - System.Object\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack\n  id: EnsureSufficientExecutionStack\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: EnsureSufficientExecutionStack()\n  nameWithType: RuntimeHelpers.EnsureSufficientExecutionStack()\n  fullName: RuntimeHelpers.EnsureSufficientExecutionStack()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Runtime.CompilerServices\n  summary: Ensures that the remaining stack space is large enough to execute the average .NET Framework function.\n  remarks: \"<xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken. The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.  \\n  \\n This method is useful in situations where stack overflow might occur as a result of unbounded recursion. It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.  \\n  \\n If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.  \\n  \\n> [!NOTE]\\n>  This method is not part of the constrained execution region (CER) support, and should not be confused with the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=fullName> method.\"\n  syntax:\n    content: public static void EnsureSufficientExecutionStack ();\n    parameters: []\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack*\n  exceptions:\n  - type: System.InsufficientExecutionStackException\n    commentId: T:System.InsufficientExecutionStackException\n    description: The available stack space is insufficient to execute the average .NET Framework function.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)\n  id: Equals(System.Object,System.Object)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: Equals(Object, Object)\n  nameWithType: RuntimeHelpers.Equals(Object, Object)\n  fullName: RuntimeHelpers.Equals(Object, Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.CompilerServices\n  summary: Determines whether the specified <xref href=\"System.Object\"></xref> instances are considered equal.\n  remarks: This method is used by compilers.\n  example:\n  - \"The following example demonstrates how to compare two objects by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.Equals%2A> method.  \\n  \\n [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/cs/example.cs#1)]\\n [!code-vb[Runtime.CompilerServices.RuntimeHelpers.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.Equals/vb/example.vb#1)]\"\n  syntax:\n    content: public static bool Equals (object o1, object o2);\n    parameters:\n    - id: o1\n      type: System.Object\n      description: The first object to compare.\n    - id: o2\n      type: System.Object\n      description: The second object to compare.\n    return:\n      type: System.Boolean\n      description: '`true` if the <code>o1</code> parameter is the same instance as the <code>o2</code> parameter, or if both are `null`, or if <code>o1.Equals(o2)</code> returns `true`; otherwise, `false`.'\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.Equals*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)\n  id: ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: ExecuteCodeWithGuaranteedCleanup(RuntimeHelpers+TryCode, RuntimeHelpers+CleanupCode, Object)\n  nameWithType: RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(RuntimeHelpers+TryCode, RuntimeHelpers+CleanupCode, Object)\n  fullName: RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(RuntimeHelpers+TryCode, RuntimeHelpers+CleanupCode, Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.CompilerServices\n  summary: Executes code using a <xref href=\"System.Delegate\"></xref> while using another <xref href=\"System.Delegate\"></xref> to execute additional code in case of an exception.\n  remarks: This method is used by compilers.\n  syntax:\n    content: public static void ExecuteCodeWithGuaranteedCleanup (System.Runtime.CompilerServices.RuntimeHelpers.TryCode code, System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode backoutCode, object userData);\n    parameters:\n    - id: code\n      type: System.Runtime.CompilerServices.RuntimeHelpers+TryCode\n      description: A delegate to the code to try.\n    - id: backoutCode\n      type: System.Runtime.CompilerServices.RuntimeHelpers+CleanupCode\n      description: A delegate to the code to run if an exception occurs.\n    - id: userData\n      type: System.Object\n      description: The data to pass to <code>code</code> and <code>backoutCode</code>.\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)\n  id: GetHashCode(System.Object)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: GetHashCode(Object)\n  nameWithType: RuntimeHelpers.GetHashCode(Object)\n  fullName: RuntimeHelpers.GetHashCode(Object)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Runtime.CompilerServices\n  summary: Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.\n  remarks: \"The <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> method always calls the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method non-virtually, even if the object's type has overridden the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method. Therefore, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> might differ from calling `GetHashCode` directly on the object with the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> method.  \\n  \\n> [!WARNING]\\n>  Although the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference. To test for object identify (that is, to test that two objects reference the same object in memory), call the <xref:System.Object.ReferenceEquals%2A?displayProperty=fullName> method. Nor should you use <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> to test whether two strings represent equal object references, because the string is interned. To test for string interning, call the <xref:System.String.IsInterned%2A?displayProperty=fullName> method.  \\n  \\n The <xref:System.Object.GetHashCode%2A?displayProperty=fullName> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> methods differ as follows:  \\n  \\n-   <xref:System.Object.GetHashCode%2A?displayProperty=fullName> returns a hash code that is based on the object's definition of equality. For example, two strings with identical contents will return the same value for <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.  \\n  \\n-   <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> returns a hash code that indicates object identity. That is, two string variables whose contents are identical and that represent a string that is interned (see the [String Interning](#interning) section) or that represent a single string in memory return identical hash codes.  \\n  \\n> [!IMPORTANT]\\n>  Note that <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A> always returns identical hash codes for equal object references. However, the reverse is not true: equal hash codes do not indicate equal object references. A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.  \\n  \\n This method is used by compilers.  \\n  \\n<a name=\\\"interning\\\"></a>   \\n## String Interning  \\n The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool. If two strings (for example, `str1` and `str2`) are formed from an identical string literal, the CLR will set `str1` and `str2` to point to the same location on the managed heap to conserve memory. Calling <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.  \\n  \\n The CLR adds only literals to the pool. Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal. Therefore, if `str2` was created as the result of a concatenation operation, and `str2` is identical to `str1`, using <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> on these two string objects will not produce the same hash code.  \\n  \\n If you want to add a concatenated string to the pool explicitly, use the <xref:System.String.Intern%2A?displayProperty=fullName> method.  \\n  \\n You can also use the <xref:System.String.IsInterned%2A?displayProperty=fullName> method to check whether a string has an interned reference.\"\n  example:\n  - \"The following example demonstrates the difference between the <xref:System.Object.GetHashCode%2A?displayProperty=fullName> and <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> methods. The output from the example illustrates the following:  \\n  \\n-   Both sets of hash codes for the first set of strings passed to the `ShowHashCodes` method are different, because the strings are completely different.  \\n  \\n-   <xref:System.Object.GetHashCode%2A?displayProperty=fullName> generates the same hash code for the second set of strings passed to the `ShowHashCodes` method, because the strings are equal. However, the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName> method does not. The first string is defined by using a string literal and so is interned. Although the value of the second string is the same, it is not interned, because it is returned by a call to the <xref:System.String.Format%2A?displayProperty=fullName> method.  \\n  \\n-   In the case of the third string, the hash codes produced by <xref:System.Object.GetHashCode%2A?displayProperty=fullName> for both strings are identical, as are the hash codes produced by <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName>. This is because the compiler has treated the value assigned to both strings as a single string literal, and so the string variables refer to the same interned string.  \\n  \\n [!code-csharp[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/cs/gethashcodeex1.cs#1)]\\n [!code-vb[System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.compilerservices.runtimehelpers.gethashcode/vb/gethashcodeex1.vb#1)]\"\n  syntax:\n    content: public static int GetHashCode (object o);\n    parameters:\n    - id: o\n      type: System.Object\n      description: An object to retrieve the hash code for.\n    return:\n      type: System.Int32\n      description: A hash code for the object identified by the <code>o</code> parameter.\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)\n  id: GetObjectValue(System.Object)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: GetObjectValue(Object)\n  nameWithType: RuntimeHelpers.GetObjectValue(Object)\n  fullName: RuntimeHelpers.GetObjectValue(Object)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Runtime.CompilerServices\n  summary: Boxes a value type.\n  remarks: \"Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.  \\n  \\n This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.  \\n  \\n The return value depends on whether the value class is mutable or immutable:  \\n  \\n-   If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.  \\n  \\n-   If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.  \\n  \\n Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types. That is, boxed value types get cloned when you pass them around, and they are always passed by value. The compiler can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> to assign a value type to an object or to pass a value type as a parameter of a type object.  \\n  \\n This method is used by compilers.\"\n  example:\n  - \"The following example demonstrates how to box a value class by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A> method.  \\n  \\n [!code-csharp[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/csharp/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/cs/example.cs#1)]\\n [!code-vb[Runtime.CompilerServices.RuntimeHelpers.GetObjectValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Runtime.CompilerServices.RuntimeHelpers.GetObjectValue/vb/example.vb#1)]\"\n  syntax:\n    content: public static object GetObjectValue (object obj);\n    parameters:\n    - id: obj\n      type: System.Object\n      description: The value type to be boxed.\n    return:\n      type: System.Object\n      description: A boxed copy of <code>obj</code> if it is a value class; otherwise, <code>obj</code> itself.\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject(System.Type)\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject(System.Type)\n  id: GetUninitializedObject(System.Type)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: GetUninitializedObject(Type)\n  nameWithType: RuntimeHelpers.GetUninitializedObject(Type)\n  fullName: RuntimeHelpers.GetUninitializedObject(Type)\n  type: Method\n  assemblies:\n  - System.Runtime\n  namespace: System.Runtime.CompilerServices\n  syntax:\n    content: public static object GetUninitializedObject (Type type);\n    parameters:\n    - id: type\n      type: System.Type\n      description: ''\n    return:\n      type: System.Object\n      description: ''\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject*\n  exceptions: []\n  version:\n  - netcore-2.0\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)\n  id: InitializeArray(System.Array,System.RuntimeFieldHandle)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: InitializeArray(Array, RuntimeFieldHandle)\n  nameWithType: RuntimeHelpers.InitializeArray(Array, RuntimeFieldHandle)\n  fullName: RuntimeHelpers.InitializeArray(Array, RuntimeFieldHandle)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Runtime.CompilerServices\n  summary: Provides a fast way to initialize an array from data that is stored in a module.\n  remarks: This method is used by compilers.\n  syntax:\n    content: public static void InitializeArray (Array array, RuntimeFieldHandle fldHandle);\n    parameters:\n    - id: array\n      type: System.Array\n      description: The array to be initialized.\n    - id: fldHandle\n      type: System.RuntimeFieldHandle\n      description: A field handle that specifies the location of the data used to initialize the array.\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1\n  id: IsReferenceOrContainsReferences``1\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: IsReferenceOrContainsReferences<T>()\n  nameWithType: RuntimeHelpers.IsReferenceOrContainsReferences<T>()\n  fullName: RuntimeHelpers.IsReferenceOrContainsReferences<T>()\n  type: Method\n  assemblies:\n  - System.Runtime\n  namespace: System.Runtime.CompilerServices\n  syntax:\n    content: public static bool IsReferenceOrContainsReferences<T> ();\n    parameters: []\n    typeParameters:\n    - id: T\n      description: ''\n    return:\n      type: System.Boolean\n      description: ''\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1*\n  exceptions: []\n  version:\n  - netcore-2.0\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData\n  commentId: P:System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData\n  id: OffsetToStringData\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: OffsetToStringData\n  nameWithType: RuntimeHelpers.OffsetToStringData\n  fullName: RuntimeHelpers.OffsetToStringData\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Runtime.CompilerServices\n  summary: Gets the offset, in bytes, to the data in the given string.\n  remarks: Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string. Compilers should pin the string against movement by the garbage collector before use. Note that common language runtime strings are immutable; that is, their contents can be read but not changed.\n  syntax:\n    content: public static int OffsetToStringData { get; }\n    return:\n      type: System.Int32\n      description: The byte offset, from the start of the <xref href=\"System.String\"></xref> object to the first character in the string.\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions\n  id: PrepareConstrainedRegions\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: PrepareConstrainedRegions()\n  nameWithType: RuntimeHelpers.PrepareConstrainedRegions()\n  fullName: RuntimeHelpers.PrepareConstrainedRegions()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.CompilerServices\n  summary: Designates a body of code as a constrained execution region (CER).\n  remarks: \"Compilers use this method to mark `catch`, `finally`, and `fault` blocks as constrained execution regions (CERs). Code that is marked as a constrained region must only call other code with strong reliability contracts. It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.  \\n  \\n Note that no intermediate language opcodes, except `NOP`, are allowed between a call to the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method and the `try` block. For more information about CERs, see the classes in the <xref:System.Runtime.ConstrainedExecution> namespace.  \\n  \\n CERs that are marked using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method do not work perfectly when a <xref:System.StackOverflowException> is generated from the `try` block. For more information, see the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A> method.  \\n  \\n The <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method calls the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method.\"\n  example:\n  - \"The following example shows how to reliably set handles by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method. To reliably set a handle to a specified pre-existing handle, you must ensure that the allocation of the native handle and the subsequent recording of that handle within a <xref:System.Runtime.InteropServices.SafeHandle> object is atomic. Any failure between these operations (such as a thread abort or out-of-memory exception) will result in the native handle being leaked. You can use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A> method to make sure that the handle is not leaked.  \\n  \\n [!code-csharp[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/cs/sample.cs#1)]\\n [!code-vb[SafeHandle-RuntimeHelpers.PrepareConstrainedRegions#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/SafeHandle-RuntimeHelpers.PrepareConstrainedRegions/vb/sample.vb#1)]\"\n  syntax:\n    content: public static void PrepareConstrainedRegions ();\n    parameters: []\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP\n  id: PrepareConstrainedRegionsNoOP\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: PrepareConstrainedRegionsNoOP()\n  nameWithType: RuntimeHelpers.PrepareConstrainedRegionsNoOP()\n  fullName: RuntimeHelpers.PrepareConstrainedRegionsNoOP()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.CompilerServices\n  summary: Designates a body of code as a constrained execution region (CER) without performing any probing.\n  remarks: Compilers should not call this method directly. Instead, define a CER by calling the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName> method.\n  syntax:\n    content: public static void PrepareConstrainedRegionsNoOP ();\n    parameters: []\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)\n  id: PrepareContractedDelegate(System.Delegate)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: PrepareContractedDelegate(Delegate)\n  nameWithType: RuntimeHelpers.PrepareContractedDelegate(Delegate)\n  fullName: RuntimeHelpers.PrepareContractedDelegate(Delegate)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.CompilerServices\n  summary: Provides a way for applications to dynamically prepare <xref href=\"System.AppDomain\"></xref> event delegates.\n  remarks: \"<xref:System.AppDomain> event delegates such as <xref:System.AppDomain.DomainUnload>, <xref:System.AppDomain.ProcessExit>, and <xref:System.AppDomain.UnhandledException> are not automatically prepared at startup. You can use the following methods to prepare them:  \\n  \\n-   Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute> attribute.  \\n  \\n-   Attribute the method by using the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute.  \\n  \\n-   Call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A> method to dynamically prepare the delegate.  \\n  \\n For more information, see the article [Keep Your Code Running with the Reliability Features of the .NET Framework](http://go.microsoft.com/fwlink/?LinkId=145491) in the MSDN Magazine.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static void PrepareContractedDelegate (Delegate d);\n    parameters:\n    - id: d\n      type: System.Delegate\n      description: The event delegate to prepare.\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)\n  id: PrepareDelegate(System.Delegate)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: PrepareDelegate(Delegate)\n  nameWithType: RuntimeHelpers.PrepareDelegate(Delegate)\n  fullName: RuntimeHelpers.PrepareDelegate(Delegate)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.CompilerServices\n  summary: Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).\n  remarks: Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static void PrepareDelegate (Delegate d);\n    parameters:\n    - id: d\n      type: System.Delegate\n      description: The delegate type to prepare.\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)\n  id: PrepareMethod(System.RuntimeMethodHandle)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: PrepareMethod(RuntimeMethodHandle)\n  nameWithType: RuntimeHelpers.PrepareMethod(RuntimeMethodHandle)\n  fullName: RuntimeHelpers.PrepareMethod(RuntimeMethodHandle)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.CompilerServices\n  summary: Prepares a method for inclusion in a constrained execution region (CER).\n  remarks: Compilers use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> method to handle virtual calls that are made inside a constrained execution region (CER). At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call. Therefore, the runtime does not initially prepare that segment of the call graph. If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.\n  syntax:\n    content: public static void PrepareMethod (RuntimeMethodHandle method);\n    parameters:\n    - id: method\n      type: System.RuntimeMethodHandle\n      description: A handle to the method to prepare.\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])\n  id: PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: PrepareMethod(RuntimeMethodHandle, RuntimeTypeHandle[])\n  nameWithType: RuntimeHelpers.PrepareMethod(RuntimeMethodHandle, RuntimeTypeHandle[])\n  fullName: RuntimeHelpers.PrepareMethod(RuntimeMethodHandle, RuntimeTypeHandle[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.CompilerServices\n  summary: Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.\n  remarks: \"You can provide generics support for compilers by using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method. The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.  \\n  \\n You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any). The runtime prepares that instantiation of the method. (This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style `try` clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <xref:System.Int32> or other value types. To instantiate reference types such as <xref:System.String>, you must use an explicit <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29> method on the CER root method first.\"\n  syntax:\n    content: public static void PrepareMethod (RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);\n    parameters:\n    - id: method\n      type: System.RuntimeMethodHandle\n      description: A handle to the method to prepare.\n    - id: instantiation\n      type: System.RuntimeTypeHandle[]\n      description: The instantiation to pass to the method.\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack\n  id: ProbeForSufficientStack\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: ProbeForSufficientStack()\n  nameWithType: RuntimeHelpers.ProbeForSufficientStack()\n  fullName: RuntimeHelpers.ProbeForSufficientStack()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.CompilerServices\n  summary: Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space). We recommend that you use a constrained execution region (CER) instead of this method.\n  remarks: \"This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server. This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.  \\n  \\n This method is also used by compilers.  \\n  \\n Instead of using the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A> method, you should use a standard CER. That is, if you are planning to use a moderate amount of stack space, call the <xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName> method immediately before your `try`/`finally` or `try`/`catch` block. If you are calling a recursive method or plan to use a lot of stack space, you must use the <xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=fullName> method.\"\n  syntax:\n    content: public static void ProbeForSufficientStack ();\n    parameters: []\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)\n  id: RunClassConstructor(System.RuntimeTypeHandle)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: RunClassConstructor(RuntimeTypeHandle)\n  nameWithType: RuntimeHelpers.RunClassConstructor(RuntimeTypeHandle)\n  fullName: RuntimeHelpers.RunClassConstructor(RuntimeTypeHandle)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Runtime.CompilerServices\n  summary: Runs a specified class constructor method.\n  remarks: This method is used by compilers.\n  syntax:\n    content: public static void RunClassConstructor (RuntimeTypeHandle type);\n    parameters:\n    - id: type\n      type: System.RuntimeTypeHandle\n      description: A type handle that specifies the class constructor method to run.\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor*\n  exceptions:\n  - type: System.TypeInitializationException\n    commentId: T:System.TypeInitializationException\n    description: The class initializer throws an exception.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)\n  id: RunModuleConstructor(System.ModuleHandle)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: RunModuleConstructor(ModuleHandle)\n  nameWithType: RuntimeHelpers.RunModuleConstructor(ModuleHandle)\n  fullName: RuntimeHelpers.RunModuleConstructor(ModuleHandle)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.CompilerServices\n  summary: Runs a specified module constructor method.\n  remarks: This method is used by compilers.\n  syntax:\n    content: public static void RunModuleConstructor (ModuleHandle module);\n    parameters:\n    - id: module\n      type: System.ModuleHandle\n      description: A handle that specifies the module constructor method to run.\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor*\n  exceptions:\n  - type: System.TypeInitializationException\n    commentId: T:System.TypeInitializationException\n    description: The module constructor throws an exception.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack\n  commentId: M:System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack\n  id: TryEnsureSufficientExecutionStack\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  langs:\n  - csharp\n  name: TryEnsureSufficientExecutionStack()\n  nameWithType: RuntimeHelpers.TryEnsureSufficientExecutionStack()\n  fullName: RuntimeHelpers.TryEnsureSufficientExecutionStack()\n  type: Method\n  assemblies:\n  - System.Runtime\n  namespace: System.Runtime.CompilerServices\n  syntax:\n    content: public static bool TryEnsureSufficientExecutionStack ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: ''\n  overload: System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack*\n  exceptions: []\n  version:\n  - netcore-2.0\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.InsufficientExecutionStackException\n  parent: System\n  isExternal: false\n  name: InsufficientExecutionStackException\n  nameWithType: InsufficientExecutionStackException\n  fullName: System.InsufficientExecutionStackException\n- uid: System.TypeInitializationException\n  parent: System\n  isExternal: false\n  name: TypeInitializationException\n  nameWithType: TypeInitializationException\n  fullName: System.TypeInitializationException\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: EnsureSufficientExecutionStack()\n  nameWithType: RuntimeHelpers.EnsureSufficientExecutionStack()\n  fullName: RuntimeHelpers.EnsureSufficientExecutionStack()\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.Equals(System.Object,System.Object)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: RuntimeHelpers.Equals(Object, Object)\n  fullName: RuntimeHelpers.Equals(Object, Object)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(System.Runtime.CompilerServices.RuntimeHelpers.TryCode,System.Runtime.CompilerServices.RuntimeHelpers.CleanupCode,System.Object)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: ExecuteCodeWithGuaranteedCleanup(RuntimeHelpers+TryCode, RuntimeHelpers+CleanupCode, Object)\n  nameWithType: RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(RuntimeHelpers+TryCode, RuntimeHelpers+CleanupCode, Object)\n  fullName: RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup(RuntimeHelpers+TryCode, RuntimeHelpers+CleanupCode, Object)\n- uid: System.Runtime.CompilerServices.RuntimeHelpers\n  parent: System.Runtime.CompilerServices\n  isExternal: false\n  name: RuntimeHelpers\n  nameWithType: RuntimeHelpers\n  fullName: System.Runtime.CompilerServices.RuntimeHelpers+TryCode\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: GetHashCode(Object)\n  nameWithType: RuntimeHelpers.GetHashCode(Object)\n  fullName: RuntimeHelpers.GetHashCode(Object)\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue(System.Object)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: GetObjectValue(Object)\n  nameWithType: RuntimeHelpers.GetObjectValue(Object)\n  fullName: RuntimeHelpers.GetObjectValue(Object)\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject(System.Type)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: GetUninitializedObject(Type)\n  nameWithType: RuntimeHelpers.GetUninitializedObject(Type)\n  fullName: RuntimeHelpers.GetUninitializedObject(Type)\n- uid: System.Type\n  parent: System\n  isExternal: false\n  name: Type\n  nameWithType: Type\n  fullName: System.Type\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray(System.Array,System.RuntimeFieldHandle)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: InitializeArray(Array, RuntimeFieldHandle)\n  nameWithType: RuntimeHelpers.InitializeArray(Array, RuntimeFieldHandle)\n  fullName: RuntimeHelpers.InitializeArray(Array, RuntimeFieldHandle)\n- uid: System.Array\n  parent: System\n  isExternal: false\n  name: Array\n  nameWithType: Array\n  fullName: System.Array\n- uid: System.RuntimeFieldHandle\n  parent: System\n  isExternal: false\n  name: RuntimeFieldHandle\n  nameWithType: RuntimeFieldHandle\n  fullName: System.RuntimeFieldHandle\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: IsReferenceOrContainsReferences<T>()\n  nameWithType: RuntimeHelpers.IsReferenceOrContainsReferences<T>()\n  fullName: RuntimeHelpers.IsReferenceOrContainsReferences<T>()\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: OffsetToStringData\n  nameWithType: RuntimeHelpers.OffsetToStringData\n  fullName: RuntimeHelpers.OffsetToStringData\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: PrepareConstrainedRegions()\n  nameWithType: RuntimeHelpers.PrepareConstrainedRegions()\n  fullName: RuntimeHelpers.PrepareConstrainedRegions()\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: PrepareConstrainedRegionsNoOP()\n  nameWithType: RuntimeHelpers.PrepareConstrainedRegionsNoOP()\n  fullName: RuntimeHelpers.PrepareConstrainedRegionsNoOP()\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate(System.Delegate)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: PrepareContractedDelegate(Delegate)\n  nameWithType: RuntimeHelpers.PrepareContractedDelegate(Delegate)\n  fullName: RuntimeHelpers.PrepareContractedDelegate(Delegate)\n- uid: System.Delegate\n  parent: System\n  isExternal: false\n  name: Delegate\n  nameWithType: Delegate\n  fullName: System.Delegate\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate(System.Delegate)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: PrepareDelegate(Delegate)\n  nameWithType: RuntimeHelpers.PrepareDelegate(Delegate)\n  fullName: RuntimeHelpers.PrepareDelegate(Delegate)\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: PrepareMethod(RuntimeMethodHandle)\n  nameWithType: RuntimeHelpers.PrepareMethod(RuntimeMethodHandle)\n  fullName: RuntimeHelpers.PrepareMethod(RuntimeMethodHandle)\n- uid: System.RuntimeMethodHandle\n  parent: System\n  isExternal: false\n  name: RuntimeMethodHandle\n  nameWithType: RuntimeMethodHandle\n  fullName: System.RuntimeMethodHandle\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod(System.RuntimeMethodHandle,System.RuntimeTypeHandle[])\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: PrepareMethod(RuntimeMethodHandle, RuntimeTypeHandle[])\n  nameWithType: RuntimeHelpers.PrepareMethod(RuntimeMethodHandle, RuntimeTypeHandle[])\n  fullName: RuntimeHelpers.PrepareMethod(RuntimeMethodHandle, RuntimeTypeHandle[])\n- uid: System.RuntimeTypeHandle\n  name: RuntimeTypeHandle\n  nameWithType: RuntimeTypeHandle\n  fullName: System.RuntimeTypeHandle\n- uid: System.RuntimeTypeHandle[]\n  parent: System\n  isExternal: false\n  name: RuntimeTypeHandle[]\n  nameWithType: RuntimeTypeHandle[]\n  fullName: System.RuntimeTypeHandle[]\n  spec.csharp:\n  - uid: System.RuntimeTypeHandle\n    name: RuntimeTypeHandle\n    nameWithType: RuntimeTypeHandle\n    fullName: System.RuntimeTypeHandle\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: ProbeForSufficientStack()\n  nameWithType: RuntimeHelpers.ProbeForSufficientStack()\n  fullName: RuntimeHelpers.ProbeForSufficientStack()\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor(System.RuntimeTypeHandle)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: RunClassConstructor(RuntimeTypeHandle)\n  nameWithType: RuntimeHelpers.RunClassConstructor(RuntimeTypeHandle)\n  fullName: RuntimeHelpers.RunClassConstructor(RuntimeTypeHandle)\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor(System.ModuleHandle)\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: RunModuleConstructor(ModuleHandle)\n  nameWithType: RuntimeHelpers.RunModuleConstructor(ModuleHandle)\n  fullName: RuntimeHelpers.RunModuleConstructor(ModuleHandle)\n- uid: System.ModuleHandle\n  parent: System\n  isExternal: false\n  name: ModuleHandle\n  nameWithType: ModuleHandle\n  fullName: System.ModuleHandle\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: TryEnsureSufficientExecutionStack()\n  nameWithType: RuntimeHelpers.TryEnsureSufficientExecutionStack()\n  fullName: RuntimeHelpers.TryEnsureSufficientExecutionStack()\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: EnsureSufficientExecutionStack\n  nameWithType: RuntimeHelpers.EnsureSufficientExecutionStack\n  fullName: RuntimeHelpers.EnsureSufficientExecutionStack\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.Equals*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: Equals\n  nameWithType: RuntimeHelpers.Equals\n  fullName: RuntimeHelpers.Equals\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: ExecuteCodeWithGuaranteedCleanup\n  nameWithType: RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup\n  fullName: RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: GetHashCode\n  nameWithType: RuntimeHelpers.GetHashCode\n  fullName: RuntimeHelpers.GetHashCode\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: GetObjectValue\n  nameWithType: RuntimeHelpers.GetObjectValue\n  fullName: RuntimeHelpers.GetObjectValue\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.GetUninitializedObject*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: GetUninitializedObject\n  nameWithType: RuntimeHelpers.GetUninitializedObject\n  fullName: RuntimeHelpers.GetUninitializedObject\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.InitializeArray*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: InitializeArray\n  nameWithType: RuntimeHelpers.InitializeArray\n  fullName: RuntimeHelpers.InitializeArray\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.IsReferenceOrContainsReferences``1*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: IsReferenceOrContainsReferences<T>\n  nameWithType: RuntimeHelpers.IsReferenceOrContainsReferences<T>\n  fullName: RuntimeHelpers.IsReferenceOrContainsReferences<T>\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.OffsetToStringData*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: OffsetToStringData\n  nameWithType: RuntimeHelpers.OffsetToStringData\n  fullName: RuntimeHelpers.OffsetToStringData\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: PrepareConstrainedRegions\n  nameWithType: RuntimeHelpers.PrepareConstrainedRegions\n  fullName: RuntimeHelpers.PrepareConstrainedRegions\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegionsNoOP*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: PrepareConstrainedRegionsNoOP\n  nameWithType: RuntimeHelpers.PrepareConstrainedRegionsNoOP\n  fullName: RuntimeHelpers.PrepareConstrainedRegionsNoOP\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: PrepareContractedDelegate\n  nameWithType: RuntimeHelpers.PrepareContractedDelegate\n  fullName: RuntimeHelpers.PrepareContractedDelegate\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareDelegate*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: PrepareDelegate\n  nameWithType: RuntimeHelpers.PrepareDelegate\n  fullName: RuntimeHelpers.PrepareDelegate\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: PrepareMethod\n  nameWithType: RuntimeHelpers.PrepareMethod\n  fullName: RuntimeHelpers.PrepareMethod\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: ProbeForSufficientStack\n  nameWithType: RuntimeHelpers.ProbeForSufficientStack\n  fullName: RuntimeHelpers.ProbeForSufficientStack\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.RunClassConstructor*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: RunClassConstructor\n  nameWithType: RuntimeHelpers.RunClassConstructor\n  fullName: RuntimeHelpers.RunClassConstructor\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.RunModuleConstructor*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: RunModuleConstructor\n  nameWithType: RuntimeHelpers.RunModuleConstructor\n  fullName: RuntimeHelpers.RunModuleConstructor\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Runtime.CompilerServices.RuntimeHelpers.TryEnsureSufficientExecutionStack*\n  parent: System.Runtime.CompilerServices.RuntimeHelpers\n  isExternal: false\n  name: TryEnsureSufficientExecutionStack\n  nameWithType: RuntimeHelpers.TryEnsureSufficientExecutionStack\n  fullName: RuntimeHelpers.TryEnsureSufficientExecutionStack\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.CompilerServices/RuntimeHelpers.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n"}