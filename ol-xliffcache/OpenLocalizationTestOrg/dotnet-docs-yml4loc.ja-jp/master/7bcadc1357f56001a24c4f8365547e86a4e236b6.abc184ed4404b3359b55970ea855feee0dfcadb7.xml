{"nodes":[{"content":"Represents a UTF-32 encoding of Unicode characters.","nodes":[{"pos":[0,51],"content":"Represents a UTF-32 encoding of Unicode characters.","nodes":[{"content":"Represents a UTF-32 encoding of Unicode characters.","pos":[0,51]}]}],"pos":[1856,1908],"yaml":true},{"content":"Encoding is the process of transforming a set of Unicode characters into a sequence of bytes. Decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.  \n  \n The [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) assigns a code point (a number) to each character in every supported script. A Unicode Transformation Format (UTF) is a way to encode that code point. The [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) uses the following UTFs:  \n  \n-   UTF-8, which represents each code point as a sequence of one to four bytes.  \n  \n-   UTF-16, which represents each code point as a sequence of one to two 16-bit integers.  \n  \n-   UTF-32, which represents each code point as a 32-bit integer.  \n  \n For more information about the UTFs and other encodings supported by <xref:System.Text>, see .  \n  \n The <xref:System.Text.UTF32Encoding> class represents a UTF-32 encoding. The encoder can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first). For example, the Latin Capital Letter A (code point U+0041) is serialized as follows (in hexadecimal):  \n  \n-   Big endian byte order: 00 00 00 41  \n  \n-   Little endian byte order: 41 00 00 00  \n  \n It is generally more efficient to store Unicode characters using the native byte order. For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers. <xref:System.Text.UTF32Encoding> corresponds to the Windows code pages 12000 (little endian byte order) and 12001 (big endian byte order). You can determine the \"endianness\" of a particular architecture by calling the <xref:System.BitConverter.IsLittleEndian?displayProperty=fullName> method.  \n  \n Optionally, the <xref:System.Text.UTF32Encoding> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process. If the preamble contains a byte order mark (BOM), it helps the decoder determine the byte order and the transformation format or UTF of a byte array.  \n  \n If the <xref:System.Text.UTF32Encoding> instance is configured to provide a BOM, you can retrieve it by calling the <xref:System.Text.UTF32Encoding.GetPreamble%2A> method; otherwise, the method returns an empty array. Note that, even if a <xref:System.Text.UTF32Encoding> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <xref:System.Text.UTF32Encoding> class do not do this automatically.  \n  \n To enable error detection and to make the class instance more secure, you should instantiate a <xref:System.Text.UTF32Encoding> object by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidBytes` argument to `true`. With error detection, a method that detects an invalid sequence of characters or bytes throws an <xref:System.ArgumentException> exception. Without error detection, no exception is thrown, and the invalid sequence is generally ignored.  \n  \n You can instantiate a <xref:System.Text.UTF32Encoding> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM), whether you want big-endian or little-endian encoding, and whether you want to enable error detection. The following table lists the <xref:System.Text.UTF32Encoding> constructors and the <xref:System.Text.Encoding> properties that return a <xref:System.Text.UnicodeEncoding> object.  \n  \n|Member|Endianness|BOM|Error detection|  \n|------------|----------------|---------|---------------------|  \n|<xref:System.Text.Encoding.UTF32%2A?displayProperty=fullName>|Little-endian|Yes|No (Replacement fallback)|  \n|<xref:System.Text.UTF32Encoding.%23ctor?displayProperty=fullName>|Little-endian|Yes|No (Replacement fallback)|  \n|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=fullName>|Configurable|Configurable|No (Replacement fallback)|  \n|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName>|Configurable|Configurable|Configurable|  \n  \n The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.UTF32Encoding.GetBytes%2A> method performs the actual encoding.  \n  \n Likewise, the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.UTF32Encoding.GetChars%2A> and <xref:System.Text.UTF32Encoding.GetString%2A> methods perform the actual decoding.  \n  \n For an encoder or decoder that is able to save state information when encoding or decoding data that spans multiple blocks (such as string of 1 million characters that is encoded in 100,000-character segments), use the <xref:System.Text.UTF32Encoding.GetEncoder%2A> and <xref:System.Text.UTF32Encoding.GetDecoder%2A> properties, respectively.","nodes":[{"pos":[0,195],"content":"Encoding is the process of transforming a set of Unicode characters into a sequence of bytes. Decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.","nodes":[{"content":"Encoding is the process of transforming a set of Unicode characters into a sequence of bytes. Decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.","pos":[0,195],"nodes":[{"content":"Encoding is the process of transforming a set of Unicode characters into a sequence of bytes.","pos":[0,93]},{"content":"Decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.","pos":[94,195]}]}]},{"pos":[202,515],"content":"The [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) assigns a code point (a number) to each character in every supported script. A Unicode Transformation Format (UTF) is a way to encode that code point. The [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) uses the following UTFs:","nodes":[{"content":"The <bpt id=\"p1\">[</bpt>Unicode Standard<ept id=\"p1\">](http://go.microsoft.com/fwlink/?linkid=37123)</ept> assigns a code point (a number) to each character in every supported script.","pos":[0,145],"source":"The [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) assigns a code point (a number) to each character in every supported script."},{"content":"A Unicode Transformation Format (UTF) is a way to encode that code point.","pos":[146,219]},{"content":"The <bpt id=\"p1\">[</bpt>Unicode Standard<ept id=\"p1\">](http://go.microsoft.com/fwlink/?linkid=37123)</ept> uses the following UTFs:","pos":[220,313],"source":" The [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) uses the following UTFs:"}]},{"pos":[525,600],"content":"UTF-8, which represents each code point as a sequence of one to four bytes.","nodes":[{"content":"UTF-8, which represents each code point as a sequence of one to four bytes.","pos":[0,75]}]},{"pos":[610,695],"content":"UTF-16, which represents each code point as a sequence of one to two 16-bit integers.","nodes":[{"content":"UTF-16, which represents each code point as a sequence of one to two 16-bit integers.","pos":[0,85]}]},{"pos":[705,766],"content":"UTF-32, which represents each code point as a 32-bit integer.","nodes":[{"content":"UTF-32, which represents each code point as a 32-bit integer.","pos":[0,61]}]},{"pos":[773,867],"content":"For more information about the UTFs and other encodings supported by <xref:System.Text>, see .","nodes":[{"content":"For more information about the UTFs and other encodings supported by <ph id=\"ph1\">&lt;xref:System.Text&gt;</ph>, see .","pos":[0,94],"source":"For more information about the UTFs and other encodings supported by <xref:System.Text>, see ."}]},{"pos":[874,1189],"content":"The <xref:System.Text.UTF32Encoding> class represents a UTF-32 encoding. The encoder can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first). For example, the Latin Capital Letter A (code point U+0041) is serialized as follows (in hexadecimal):","nodes":[{"content":"The <xref:System.Text.UTF32Encoding> class represents a UTF-32 encoding. The encoder can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first). For example, the Latin Capital Letter A (code point U+0041) is serialized as follows (in hexadecimal):","pos":[0,315],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class represents a UTF-32 encoding.","pos":[0,72],"source":"The <xref:System.Text.UTF32Encoding> class represents a UTF-32 encoding."},{"content":"The encoder can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first).","pos":[73,212]},{"content":"For example, the Latin Capital Letter A (code point U+0041) is serialized as follows (in hexadecimal):","pos":[213,315]}]}]},{"pos":[1199,1233],"content":"Big endian byte order: 00 00 00 41","nodes":[{"content":"Big endian byte order: 00 00 00 41","pos":[0,34]}]},{"pos":[1243,1280],"content":"Little endian byte order: 41 00 00 00","nodes":[{"content":"Little endian byte order: 41 00 00 00","pos":[0,37]}]},{"pos":[1287,1782],"content":"It is generally more efficient to store Unicode characters using the native byte order. For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers. <xref:System.Text.UTF32Encoding> corresponds to the Windows code pages 12000 (little endian byte order) and 12001 (big endian byte order). You can determine the \"endianness\" of a particular architecture by calling the <xref:System.BitConverter.IsLittleEndian?displayProperty=fullName> method.","nodes":[{"content":"It is generally more efficient to store Unicode characters using the native byte order. For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers. <xref:System.Text.UTF32Encoding> corresponds to the Windows code pages 12000 (little endian byte order) and 12001 (big endian byte order). You can determine the \"endianness\" of a particular architecture by calling the <xref:System.BitConverter.IsLittleEndian?displayProperty=fullName> method.","pos":[0,495],"nodes":[{"content":"It is generally more efficient to store Unicode characters using the native byte order.","pos":[0,87]},{"content":"For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers.","pos":[88,202]},{"content":"<ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> corresponds to the Windows code pages 12000 (little endian byte order) and 12001 (big endian byte order).","pos":[203,341],"source":" <xref:System.Text.UTF32Encoding> corresponds to the Windows code pages 12000 (little endian byte order) and 12001 (big endian byte order)."},{"content":"You can determine the \"endianness\" of a particular architecture by calling the <ph id=\"ph1\">&lt;xref:System.BitConverter.IsLittleEndian?displayProperty=fullName&gt;</ph> method.","pos":[342,495],"source":" You can determine the \"endianness\" of a particular architecture by calling the <xref:System.BitConverter.IsLittleEndian?displayProperty=fullName> method."}]}]},{"pos":[1789,2138],"content":"Optionally, the <xref:System.Text.UTF32Encoding> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process. If the preamble contains a byte order mark (BOM), it helps the decoder determine the byte order and the transformation format or UTF of a byte array.","nodes":[{"content":"Optionally, the <xref:System.Text.UTF32Encoding> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process. If the preamble contains a byte order mark (BOM), it helps the decoder determine the byte order and the transformation format or UTF of a byte array.","pos":[0,349],"nodes":[{"content":"Optionally, the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.","pos":[0,199],"source":"Optionally, the <xref:System.Text.UTF32Encoding> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process."},{"content":"If the preamble contains a byte order mark (BOM), it helps the decoder determine the byte order and the transformation format or UTF of a byte array.","pos":[200,349]}]}]},{"pos":[2145,2636],"content":"If the <xref:System.Text.UTF32Encoding> instance is configured to provide a BOM, you can retrieve it by calling the <xref:System.Text.UTF32Encoding.GetPreamble%2A> method; otherwise, the method returns an empty array. Note that, even if a <xref:System.Text.UTF32Encoding> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <xref:System.Text.UTF32Encoding> class do not do this automatically.","nodes":[{"content":"If the <xref:System.Text.UTF32Encoding> instance is configured to provide a BOM, you can retrieve it by calling the <xref:System.Text.UTF32Encoding.GetPreamble%2A> method; otherwise, the method returns an empty array. Note that, even if a <xref:System.Text.UTF32Encoding> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <xref:System.Text.UTF32Encoding> class do not do this automatically.","pos":[0,491],"nodes":[{"content":"If the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> instance is configured to provide a BOM, you can retrieve it by calling the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetPreamble%2A&gt;</ph> method; otherwise, the method returns an empty array.","pos":[0,217],"source":"If the <xref:System.Text.UTF32Encoding> instance is configured to provide a BOM, you can retrieve it by calling the <xref:System.Text.UTF32Encoding.GetPreamble%2A> method; otherwise, the method returns an empty array."},{"content":"Note that, even if a <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> class do not do this automatically.","pos":[218,491],"source":" Note that, even if a <xref:System.Text.UTF32Encoding> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <xref:System.Text.UTF32Encoding> class do not do this automatically."}]}]},{"pos":[2643,3193],"content":"To enable error detection and to make the class instance more secure, you should instantiate a <xref:System.Text.UTF32Encoding> object by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidBytes` argument to `true`. With error detection, a method that detects an invalid sequence of characters or bytes throws an <xref:System.ArgumentException> exception. Without error detection, no exception is thrown, and the invalid sequence is generally ignored.","nodes":[{"content":"To enable error detection and to make the class instance more secure, you should instantiate a <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object by calling the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> constructor and setting its <ph id=\"ph3\">`throwOnInvalidBytes`</ph> argument to <ph id=\"ph4\">`true`</ph>.","pos":[0,314],"source":"To enable error detection and to make the class instance more secure, you should instantiate a <xref:System.Text.UTF32Encoding> object by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidBytes` argument to `true`."},{"content":"With error detection, a method that detects an invalid sequence of characters or bytes throws an <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph> exception.","pos":[315,454],"source":" With error detection, a method that detects an invalid sequence of characters or bytes throws an <xref:System.ArgumentException> exception."},{"content":"Without error detection, no exception is thrown, and the invalid sequence is generally ignored.","pos":[455,550]}]},{"pos":[3200,3637],"content":"You can instantiate a <xref:System.Text.UTF32Encoding> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM), whether you want big-endian or little-endian encoding, and whether you want to enable error detection. The following table lists the <xref:System.Text.UTF32Encoding> constructors and the <xref:System.Text.Encoding> properties that return a <xref:System.Text.UnicodeEncoding> object.","nodes":[{"content":"You can instantiate a <xref:System.Text.UTF32Encoding> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM), whether you want big-endian or little-endian encoding, and whether you want to enable error detection. The following table lists the <xref:System.Text.UTF32Encoding> constructors and the <xref:System.Text.Encoding> properties that return a <xref:System.Text.UnicodeEncoding> object.","pos":[0,437],"nodes":[{"content":"You can instantiate a <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM), whether you want big-endian or little-endian encoding, and whether you want to enable error detection.","pos":[0,257],"source":"You can instantiate a <xref:System.Text.UTF32Encoding> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM), whether you want big-endian or little-endian encoding, and whether you want to enable error detection."},{"content":"The following table lists the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> constructors and the <ph id=\"ph2\">&lt;xref:System.Text.Encoding&gt;</ph> properties that return a <ph id=\"ph3\">&lt;xref:System.Text.UnicodeEncoding&gt;</ph> object.","pos":[258,437],"source":" The following table lists the <xref:System.Text.UTF32Encoding> constructors and the <xref:System.Text.Encoding> properties that return a <xref:System.Text.UnicodeEncoding> object."}]}]},{"pos":[3644,3650],"content":"Member","nodes":[{"content":"Member","pos":[0,6]}]},{"pos":[3651,3661],"content":"Endianness","nodes":[{"content":"Endianness","pos":[0,10]}]},{"pos":[3662,3665],"content":"BOM","nodes":[{"content":"BOM","pos":[0,3]}]},{"pos":[3666,3681],"content":"Error detection","nodes":[{"content":"Error detection","pos":[0,15]}]},{"pos":[3752,3813],"content":"<xref:System.Text.Encoding.UTF32%2A?displayProperty=fullName>","nodes":[]},{"pos":[3814,3827],"content":"Little-endian","nodes":[{"content":"Little-endian","pos":[0,13]}]},{"pos":[3828,3831],"content":"Yes","nodes":[{"content":"Yes","pos":[0,3]}]},{"pos":[3832,3857],"content":"No (Replacement fallback)","nodes":[{"content":"No (Replacement fallback)","pos":[0,25]}]},{"pos":[3862,3927],"content":"<xref:System.Text.UTF32Encoding.%23ctor?displayProperty=fullName>","nodes":[]},{"pos":[3928,3941],"content":"Little-endian","nodes":[{"content":"Little-endian","pos":[0,13]}]},{"pos":[3942,3945],"content":"Yes","nodes":[{"content":"Yes","pos":[0,3]}]},{"pos":[3946,3971],"content":"No (Replacement fallback)","nodes":[{"content":"No (Replacement fallback)","pos":[0,25]}]},{"pos":[3976,4078],"content":"<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=fullName>","nodes":[]},{"pos":[4079,4091],"content":"Configurable","nodes":[{"content":"Configurable","pos":[0,12]}]},{"pos":[4092,4104],"content":"Configurable","nodes":[{"content":"Configurable","pos":[0,12]}]},{"pos":[4105,4130],"content":"No (Replacement fallback)","nodes":[{"content":"No (Replacement fallback)","pos":[0,25]}]},{"pos":[4135,4254],"content":"<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName>","nodes":[]},{"pos":[4255,4267],"content":"Configurable","nodes":[{"content":"Configurable","pos":[0,12]}]},{"pos":[4268,4280],"content":"Configurable","nodes":[{"content":"Configurable","pos":[0,12]}]},{"pos":[4281,4293],"content":"Configurable","nodes":[{"content":"Configurable","pos":[0,12]}]},{"pos":[4301,4524],"content":"The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.UTF32Encoding.GetBytes%2A> method performs the actual encoding.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method determines how many bytes result in encoding a set of Unicode characters, and the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph> method performs the actual encoding.","pos":[0,223],"source":"The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.UTF32Encoding.GetBytes%2A> method performs the actual encoding."}]},{"pos":[4531,4811],"content":"Likewise, the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.UTF32Encoding.GetChars%2A> and <xref:System.Text.UTF32Encoding.GetString%2A> methods perform the actual decoding.","nodes":[{"content":"Likewise, the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetCharCount%2A&gt;</ph> method determines how many characters result in decoding a sequence of bytes, and the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetChars%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Text.UTF32Encoding.GetString%2A&gt;</ph> methods perform the actual decoding.","pos":[0,280],"source":"Likewise, the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.UTF32Encoding.GetChars%2A> and <xref:System.Text.UTF32Encoding.GetString%2A> methods perform the actual decoding."}]},{"pos":[4818,5160],"content":"For an encoder or decoder that is able to save state information when encoding or decoding data that spans multiple blocks (such as string of 1 million characters that is encoded in 100,000-character segments), use the <xref:System.Text.UTF32Encoding.GetEncoder%2A> and <xref:System.Text.UTF32Encoding.GetDecoder%2A> properties, respectively.","nodes":[{"content":"For an encoder or decoder that is able to save state information when encoding or decoding data that spans multiple blocks (such as string of 1 million characters that is encoded in 100,000-character segments), use the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetEncoder%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetDecoder%2A&gt;</ph> properties, respectively.","pos":[0,342],"source":"For an encoder or decoder that is able to save state information when encoding or decoding data that spans multiple blocks (such as string of 1 million characters that is encoded in 100,000-character segments), use the <xref:System.Text.UTF32Encoding.GetEncoder%2A> and <xref:System.Text.UTF32Encoding.GetDecoder%2A> properties, respectively."}]}],"pos":[1919,7123],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Text.UTF32Encoding\"></xref> class.","nodes":[{"pos":[0,87],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Text.UTF32Encoding\"&gt;&lt;/xref&gt;</ph> class.","source":"Initializes a new instance of the <xref href=\"System.Text.UTF32Encoding\"></xref> class."}],"pos":[13294,13382],"yaml":true},{"content":"This constructor creates an instance that uses the little endian byte order, provides a Unicode byte order mark, and does not throw an exception when an invalid encoding is detected.  \n  \n> [!NOTE]\n>  For security reasons, you should enable error detection by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidCharacters` argument to `true`.","nodes":[{"pos":[0,182],"content":"This constructor creates an instance that uses the little endian byte order, provides a Unicode byte order mark, and does not throw an exception when an invalid encoding is detected.","nodes":[{"content":"This constructor creates an instance that uses the little endian byte order, provides a Unicode byte order mark, and does not throw an exception when an invalid encoding is detected.","pos":[0,182]}]},{"pos":[190,441],"content":"[!NOTE]\n For security reasons, you should enable error detection by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidCharacters` argument to `true`.","leadings":["","> "],"nodes":[{"content":"For security reasons, you should enable error detection by calling the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> constructor and setting its <ph id=\"ph2\">`throwOnInvalidCharacters`</ph> argument to <ph id=\"ph3\">`true`</ph>.","pos":[9,249],"source":" For security reasons, you should enable error detection by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidCharacters` argument to `true`."}]}],"pos":[13393,13840],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Text.UTF32Encoding\"></xref> class. Parameters specify whether to use the big endian byte order and whether the <xref href=\"System.Text.UTF32Encoding.GetPreamble\"></xref> method returns a Unicode Unicode byte order mark.","nodes":[{"pos":[0,272],"content":"Initializes a new instance of the <xref href=\"System.Text.UTF32Encoding\"></xref> class. Parameters specify whether to use the big endian byte order and whether the <xref href=\"System.Text.UTF32Encoding.GetPreamble\"></xref> method returns a Unicode Unicode byte order mark.","nodes":[{"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Text.UTF32Encoding\"&gt;&lt;/xref&gt;</ph> class.","pos":[0,87],"source":"Initializes a new instance of the <xref href=\"System.Text.UTF32Encoding\"></xref> class."},{"content":"Parameters specify whether to use the big endian byte order and whether the <ph id=\"ph1\">&lt;xref href=\"System.Text.UTF32Encoding.GetPreamble\"&gt;&lt;/xref&gt;</ph> method returns a Unicode Unicode byte order mark.","pos":[88,272],"source":" Parameters specify whether to use the big endian byte order and whether the <xref href=\"System.Text.UTF32Encoding.GetPreamble\"></xref> method returns a Unicode Unicode byte order mark."}]}],"pos":[16060,16333],"yaml":true},{"content":"This constructor creates an instance that does not throw an exception when an invalid encoding is detected.  \n  \n> [!NOTE]\n>  For security reasons, you should enable error detection by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidCharacters` argument to `true`.","nodes":[{"pos":[0,107],"content":"This constructor creates an instance that does not throw an exception when an invalid encoding is detected.","nodes":[{"content":"This constructor creates an instance that does not throw an exception when an invalid encoding is detected.","pos":[0,107]}]},{"pos":[115,366],"content":"[!NOTE]\n For security reasons, you should enable error detection by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidCharacters` argument to `true`.","leadings":["","> "],"nodes":[{"content":"For security reasons, you should enable error detection by calling the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> constructor and setting its <ph id=\"ph2\">`throwOnInvalidCharacters`</ph> argument to <ph id=\"ph3\">`true`</ph>.","pos":[9,249],"source":" For security reasons, you should enable error detection by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidCharacters` argument to `true`."}]}],"pos":[16344,16716],"yaml":true,"extradata":"MT"},{"content":"`true` to use the big endian byte order (most significant byte first), or `false` to use the little endian byte order (least significant byte first).","nodes":[{"pos":[0,149],"content":"<ph id=\"ph1\">`true`</ph> to use the big endian byte order (most significant byte first), or <ph id=\"ph2\">`false`</ph> to use the little endian byte order (least significant byte first).","source":"`true` to use the big endian byte order (most significant byte first), or `false` to use the little endian byte order (least significant byte first)."}],"pos":[17521,17673],"yaml":true},{"content":"`true` to specify that a Unicode byte order mark is provided; otherwise, `false`.","nodes":[{"pos":[0,81],"content":"<ph id=\"ph1\">`true`</ph> to specify that a Unicode byte order mark is provided; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to specify that a Unicode byte order mark is provided; otherwise, `false`."}],"pos":[17743,17827],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Text.UTF32Encoding\"></xref> class. Parameters specify whether to use the big endian byte order, whether to provide a Unicode byte order mark, and whether to throw an exception when an invalid encoding is detected.","nodes":[{"pos":[0,266],"content":"Initializes a new instance of the <xref href=\"System.Text.UTF32Encoding\"></xref> class. Parameters specify whether to use the big endian byte order, whether to provide a Unicode byte order mark, and whether to throw an exception when an invalid encoding is detected.","nodes":[{"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Text.UTF32Encoding\"&gt;&lt;/xref&gt;</ph> class.","pos":[0,87],"source":"Initializes a new instance of the <xref href=\"System.Text.UTF32Encoding\"></xref> class."},{"content":"Parameters specify whether to use the big endian byte order, whether to provide a Unicode byte order mark, and whether to throw an exception when an invalid encoding is detected.","pos":[88,266]}]}],"pos":[19411,19678],"yaml":true},{"content":"If `throwOnInvalidCharacters` is `true`, a method that detects an invalid byte sequence throws <xref:System.ArgumentException?displayProperty=fullName>. Otherwise, the method does not throw an exception, and the invalid sequence is ignored.  \n  \n> [!NOTE]\n>  For security reasons, you should enable error detection by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidCharacters` argument to `true`.","nodes":[{"pos":[0,240],"content":"If `throwOnInvalidCharacters` is `true`, a method that detects an invalid byte sequence throws <xref:System.ArgumentException?displayProperty=fullName>. Otherwise, the method does not throw an exception, and the invalid sequence is ignored.","nodes":[{"content":"If <ph id=\"ph1\">`throwOnInvalidCharacters`</ph> is <ph id=\"ph2\">`true`</ph>, a method that detects an invalid byte sequence throws <ph id=\"ph3\">&lt;xref:System.ArgumentException?displayProperty=fullName&gt;</ph>.","pos":[0,152],"source":"If `throwOnInvalidCharacters` is `true`, a method that detects an invalid byte sequence throws <xref:System.ArgumentException?displayProperty=fullName>."},{"content":"Otherwise, the method does not throw an exception, and the invalid sequence is ignored.","pos":[153,240]}]},{"pos":[248,499],"content":"[!NOTE]\n For security reasons, you should enable error detection by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidCharacters` argument to `true`.","leadings":["","> "],"nodes":[{"content":"For security reasons, you should enable error detection by calling the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> constructor and setting its <ph id=\"ph2\">`throwOnInvalidCharacters`</ph> argument to <ph id=\"ph3\">`true`</ph>.","pos":[9,249],"source":" For security reasons, you should enable error detection by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidCharacters` argument to `true`."}]}],"pos":[19689,20194],"yaml":true,"extradata":"MT"},{"content":"`true` to use the big endian byte order (most significant byte first), or `false` to use the little endian byte order (least significant byte first).","nodes":[{"pos":[0,149],"content":"<ph id=\"ph1\">`true`</ph> to use the big endian byte order (most significant byte first), or <ph id=\"ph2\">`false`</ph> to use the little endian byte order (least significant byte first).","source":"`true` to use the big endian byte order (most significant byte first), or `false` to use the little endian byte order (least significant byte first)."}],"pos":[21066,21218],"yaml":true},{"content":"`true` to specify that a Unicode byte order mark is provided; otherwise, `false`.","nodes":[{"pos":[0,81],"content":"<ph id=\"ph1\">`true`</ph> to specify that a Unicode byte order mark is provided; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to specify that a Unicode byte order mark is provided; otherwise, `false`."}],"pos":[21288,21372],"yaml":true},{"content":"`true` to specify that an exception should be thrown when an invalid encoding is detected; otherwise, `false`.","nodes":[{"pos":[0,110],"content":"<ph id=\"ph1\">`true`</ph> to specify that an exception should be thrown when an invalid encoding is detected; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` to specify that an exception should be thrown when an invalid encoding is detected; otherwise, `false`."}],"pos":[21453,21566],"yaml":true},{"content":"Determines whether the specified <xref href=\"System.Object\"></xref> is equal to the current <xref href=\"System.Text.UTF32Encoding\"></xref> object.","nodes":[{"pos":[0,146],"content":"Determines whether the specified <ph id=\"ph1\">&lt;xref href=\"System.Object\"&gt;&lt;/xref&gt;</ph> is equal to the current <ph id=\"ph2\">&lt;xref href=\"System.Text.UTF32Encoding\"&gt;&lt;/xref&gt;</ph> object.","source":"Determines whether the specified <xref href=\"System.Object\"></xref> is equal to the current <xref href=\"System.Text.UTF32Encoding\"></xref> object."}],"pos":[22975,23122],"yaml":true},{"content":"Two <xref:System.Text.UTF32Encoding> objects are considered equal if all of the following conditions are true:  \n  \n-   Both objects use the same byte order.  \n  \n-   Both objects provide the byte order mark, or both do not.  \n  \n-   Both objects use the same encoder fallback.  \n  \n-   Both objects use the same decoder fallback.","nodes":[{"pos":[0,110],"content":"Two <xref:System.Text.UTF32Encoding> objects are considered equal if all of the following conditions are true:","nodes":[{"content":"Two <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> objects are considered equal if all of the following conditions are true:","pos":[0,110],"source":"Two <xref:System.Text.UTF32Encoding> objects are considered equal if all of the following conditions are true:"}]},{"pos":[120,157],"content":"Both objects use the same byte order.","nodes":[{"content":"Both objects use the same byte order.","pos":[0,37]}]},{"pos":[167,224],"content":"Both objects provide the byte order mark, or both do not.","nodes":[{"content":"Both objects provide the byte order mark, or both do not.","pos":[0,57]}]},{"pos":[234,277],"content":"Both objects use the same encoder fallback.","nodes":[{"content":"Both objects use the same encoder fallback.","pos":[0,43]}]},{"pos":[287,330],"content":"Both objects use the same decoder fallback.","nodes":[{"content":"Both objects use the same decoder fallback.","pos":[0,43]}]}],"pos":[23133,23474],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Object\"></xref> to compare with the current object.","nodes":[{"pos":[0,74],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Object\"&gt;&lt;/xref&gt;</ph> to compare with the current object.","source":"The <xref href=\"System.Object\"></xref> to compare with the current object."}],"pos":[24230,24305],"yaml":true},{"content":"`true` if <code>value</code> is an instance of <xref href=\"System.Text.UTF32Encoding\"></xref> and is equal to the current object; otherwise, `false`.","nodes":[{"pos":[0,149],"content":"<ph id=\"ph1\">`true`</ph> if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">value</ph><ept id=\"p1\">&lt;/code&gt;</ept> is an instance of <ph id=\"ph3\">&lt;xref href=\"System.Text.UTF32Encoding\"&gt;&lt;/xref&gt;</ph> and is equal to the current object; otherwise, <ph id=\"ph4\">`false`</ph>.","source":"`true` if <code>value</code> is an instance of <xref href=\"System.Text.UTF32Encoding\"></xref> and is equal to the current object; otherwise, `false`."}],"pos":[24363,24515],"yaml":true},{"content":"Calculates the number of bytes produced by encoding the characters in the specified <xref href=\"System.String\"></xref>.","nodes":[{"pos":[0,119],"content":"Calculates the number of bytes produced by encoding the characters in the specified <ph id=\"ph1\">&lt;xref href=\"System.String\"&gt;&lt;/xref&gt;</ph>.","source":"Calculates the number of bytes produced by encoding the characters in the specified <xref href=\"System.String\"></xref>."}],"pos":[25961,26081],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \n  \n To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method.","nodes":[{"pos":[0,489],"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,489],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,190],"source":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, you call the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> method.","pos":[191,300],"source":" To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[301,489],"source":" The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[496,684],"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[0,188],"nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[0,104],"source":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>."},{"content":"Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[105,188]}]}]},{"pos":[691,1155],"content":"To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method.","nodes":[{"content":"To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method.","pos":[0,464],"nodes":[{"content":"To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.","pos":[0,157]},{"content":"Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method.","pos":[158,464],"source":" Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method."}]}]}],"pos":[26092,27254],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.String\"></xref> containing the set of characters to encode.","nodes":[{"pos":[0,82],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.String\"&gt;&lt;/xref&gt;</ph> containing the set of characters to encode.","source":"The <xref href=\"System.String\"></xref> containing the set of characters to encode."}],"pos":[28105,28188],"yaml":true},{"content":"The number of bytes produced by encoding the specified characters.","nodes":[{"pos":[0,66],"content":"The number of bytes produced by encoding the specified characters.","nodes":[{"content":"The number of bytes produced by encoding the specified characters.","pos":[0,66]}]}],"pos":[28244,28311],"yaml":true},{"content":"<code>s</code> is `null`.","nodes":[{"pos":[0,25],"content":"<ph id=\"ph1\">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>s</code> is `null`."}],"pos":[28479,28505],"yaml":true},{"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","nodes":[{"pos":[0,100],"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","nodes":[{"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","pos":[0,100]}]}],"pos":[28619,28720],"yaml":true},{"content":"Error detection is enabled, and <code>s</code> contains an invalid sequence of characters.","nodes":[{"pos":[0,90],"content":"Error detection is enabled, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">s</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains an invalid sequence of characters.","source":"Error detection is enabled, and <code>s</code> contains an invalid sequence of characters."}],"pos":[28814,28905],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[29023,29322],"yaml":true},{"content":"Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.","nodes":[{"pos":[0,116],"content":"Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.","nodes":[{"content":"Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.","pos":[0,116]}]}],"pos":[30776,30893],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \n  \n To ensure that the encoded bytes are decoded properly when they are saved as a file or a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method.","nodes":[{"pos":[0,482],"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,482],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,190],"source":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, you call the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph>.","pos":[191,293],"source":" To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[294,482],"source":" The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[489,678],"content":"With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","nodes":[{"content":"With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[0,189],"nodes":[{"content":"With error detection, an invalid sequence causes this method to throw an <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[0,105],"source":"With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException>."},{"content":"Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[106,189]}]}]},{"pos":[685,1144],"content":"To ensure that the encoded bytes are decoded properly when they are saved as a file or a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method.","nodes":[{"content":"To ensure that the encoded bytes are decoded properly when they are saved as a file or a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method.","pos":[0,459],"nodes":[{"content":"To ensure that the encoded bytes are decoded properly when they are saved as a file or a stream, you can prefix a stream of encoded bytes with a preamble.","pos":[0,154]},{"content":"Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method.","pos":[155,459],"source":" Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method."}]}]}],"pos":[30904,32055],"yaml":true,"extradata":"MT"},{"content":"A pointer to the first character to encode.","nodes":[{"pos":[0,43],"content":"A pointer to the first character to encode.","nodes":[{"content":"A pointer to the first character to encode.","pos":[0,43]}]}],"pos":[32300,32344],"yaml":true},{"content":"The number of characters to encode.","nodes":[{"pos":[0,35],"content":"The number of characters to encode.","nodes":[{"content":"The number of characters to encode.","pos":[0,35]}]}],"pos":[32404,32440],"yaml":true},{"content":"The number of bytes produced by encoding the specified characters.","nodes":[{"pos":[0,66],"content":"The number of bytes produced by encoding the specified characters.","nodes":[{"content":"The number of bytes produced by encoding the specified characters.","pos":[0,66]}]}],"pos":[32496,32563],"yaml":true},{"content":"<code>chars</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."}],"pos":[32731,32761],"yaml":true},{"content":"<code>count</code> is less than zero.  \n  \n -or-  \n  \n The resulting number of bytes is greater than the maximum number that can be returned as an integer.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.","source":"<code>count</code> is less than zero."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,155],"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","nodes":[{"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","pos":[0,100]}]}],"pos":[32875,33037],"yaml":true},{"content":"Error detection is enabled, and <code>chars</code> contains an invalid sequence of characters.","nodes":[{"pos":[0,94],"content":"Error detection is enabled, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">chars</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains an invalid sequence of characters.","source":"Error detection is enabled, and <code>chars</code> contains an invalid sequence of characters."}],"pos":[33131,33226],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[33344,33643],"yaml":true},{"content":"Calculates the number of bytes produced by encoding a set of characters from the specified character array.","nodes":[{"pos":[0,107],"content":"Calculates the number of bytes produced by encoding a set of characters from the specified character array.","nodes":[{"content":"Calculates the number of bytes produced by encoding a set of characters from the specified character array.","pos":[0,107]}]}],"pos":[35251,35359],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \n  \n To ensure that the encoded bytes are decoded properly when they are saved as a file or a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method.","nodes":[{"pos":[0,489],"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,489],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,190],"source":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, you call the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> method.","pos":[191,300],"source":" To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[301,489],"source":" The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[496,684],"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[0,188],"nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[0,104],"source":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>."},{"content":"Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[105,188]}]}]},{"pos":[691,1150],"content":"To ensure that the encoded bytes are decoded properly when they are saved as a file or a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method.","nodes":[{"content":"To ensure that the encoded bytes are decoded properly when they are saved as a file or a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method.","pos":[0,459],"nodes":[{"content":"To ensure that the encoded bytes are decoded properly when they are saved as a file or a stream, you can prefix a stream of encoded bytes with a preamble.","pos":[0,154]},{"content":"Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method.","pos":[155,459],"source":" Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method."}]}]}],"pos":[35370,36527],"yaml":true,"extradata":"MT"},{"content":"The character array containing the set of characters to encode.","nodes":[{"pos":[0,63],"content":"The character array containing the set of characters to encode.","nodes":[{"content":"The character array containing the set of characters to encode.","pos":[0,63]}]}],"pos":[38268,38332],"yaml":true},{"content":"The index of the first character to encode.","nodes":[{"pos":[0,43],"content":"The index of the first character to encode.","nodes":[{"content":"The index of the first character to encode.","pos":[0,43]}]}],"pos":[38392,38436],"yaml":true},{"content":"The number of characters to encode.","nodes":[{"pos":[0,35],"content":"The number of characters to encode.","nodes":[{"content":"The number of characters to encode.","pos":[0,35]}]}],"pos":[38496,38532],"yaml":true},{"content":"The number of bytes produced by encoding the specified characters.","nodes":[{"pos":[0,66],"content":"The number of bytes produced by encoding the specified characters.","nodes":[{"content":"The number of bytes produced by encoding the specified characters.","pos":[0,66]}]}],"pos":[38588,38655],"yaml":true},{"content":"<code>chars</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."}],"pos":[38823,38853],"yaml":true},{"content":"<code>index</code> or <code>count</code> is less than zero.  \n  \n -or-  \n  \n <code>index</code> and <code>count</code> do not denote a valid range in <code>chars</code>.  \n  \n -or-  \n  \n The resulting number of bytes is greater than the maximum number that can be returned as an integer.","nodes":[{"pos":[0,59],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.","source":"<code>index</code> or <code>count</code> is less than zero."},{"pos":[66,70],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[77,169],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range in <ph id=\"ph3\">&lt;code&gt;chars&lt;/code&gt;</ph>.","source":"<code>index</code> and <code>count</code> do not denote a valid range in <code>chars</code>."},{"pos":[176,180],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[187,287],"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","nodes":[{"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","pos":[0,100]}]}],"pos":[38967,39265],"yaml":true},{"content":"Error detection is enabled, and <code>chars</code> contains an invalid sequence of characters.","nodes":[{"pos":[0,94],"content":"Error detection is enabled, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">chars</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains an invalid sequence of characters.","source":"Error detection is enabled, and <code>chars</code> contains an invalid sequence of characters."}],"pos":[39359,39454],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[39572,39871],"yaml":true},{"content":"Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.","nodes":[{"pos":[0,152],"content":"Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.","nodes":[{"content":"Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.","pos":[0,152]}]}],"pos":[41421,41574],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \n  \n Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.  \n  \n> [!NOTE]\n>  To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility. The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.","nodes":[{"pos":[0,489],"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,489],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,190],"source":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, you call the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> method.","pos":[191,300],"source":" To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[301,489],"source":" The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[496,684],"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[0,188],"nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[0,104],"source":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>."},{"content":"Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[105,188]}]}]},{"pos":[691,1123],"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","nodes":[{"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","pos":[0,432],"nodes":[{"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks.","pos":[0,100]},{"content":"In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.UTF32Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.UTF32Encoding.GetEncoder%2A&gt;</ph> method, respectively.","pos":[101,432],"source":" In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively."}]}]},{"pos":[1131,1594],"content":"[!NOTE]\n To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility. The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.","leadings":["","> "],"nodes":[{"content":" To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility. The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.","pos":[8,461],"nodes":[{"content":"To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.","pos":[1,158]},{"content":"Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.","pos":[159,320]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.","pos":[321,453],"source":" The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes."}]}]}],"pos":[41585,43189],"yaml":true,"extradata":"MT"},{"content":"A pointer to the first character to encode.","nodes":[{"pos":[0,43],"content":"A pointer to the first character to encode.","nodes":[{"content":"A pointer to the first character to encode.","pos":[0,43]}]}],"pos":[43462,43506],"yaml":true},{"content":"The number of characters to encode.","nodes":[{"pos":[0,35],"content":"The number of characters to encode.","nodes":[{"content":"The number of characters to encode.","pos":[0,35]}]}],"pos":[43570,43606],"yaml":true},{"content":"A pointer to the location at which to start writing the resulting sequence of bytes.","nodes":[{"pos":[0,84],"content":"A pointer to the location at which to start writing the resulting sequence of bytes.","nodes":[{"content":"A pointer to the location at which to start writing the resulting sequence of bytes.","pos":[0,84]}]}],"pos":[43666,43751],"yaml":true},{"content":"The maximum number of bytes to write.","nodes":[{"pos":[0,37],"content":"The maximum number of bytes to write.","nodes":[{"content":"The maximum number of bytes to write.","pos":[0,37]}]}],"pos":[43815,43853],"yaml":true},{"content":"The actual number of bytes written at the location indicated by the <code>bytes</code> parameter.","nodes":[{"pos":[0,97],"content":"The actual number of bytes written at the location indicated by the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter.","source":"The actual number of bytes written at the location indicated by the <code>bytes</code> parameter."}],"pos":[43909,44007],"yaml":true},{"content":"<code>chars</code> is `null`.  \n  \n -or-  \n  \n <code>bytes</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."},{"pos":[36,40],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[47,76],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[44171,44254],"yaml":true},{"content":"<code>charCount</code> or <code>byteCount</code> is less than zero.","nodes":[{"pos":[0,67],"content":"<ph id=\"ph1\">&lt;code&gt;charCount&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;byteCount&lt;/code&gt;</ph> is less than zero.","source":"<code>charCount</code> or <code>byteCount</code> is less than zero."}],"pos":[44368,44436],"yaml":true},{"content":"Error detection is enabled, and <code>chars</code> contains an invalid sequence of characters.  \n  \n -or-  \n  \n <code>byteCount</code> is less than the resulting number of bytes.","nodes":[{"pos":[0,94],"content":"Error detection is enabled, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">chars</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains an invalid sequence of characters.","source":"Error detection is enabled, and <code>chars</code> contains an invalid sequence of characters."},{"pos":[101,105],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[112,178],"content":"<ph id=\"ph1\">&lt;code&gt;byteCount&lt;/code&gt;</ph> is less than the resulting number of bytes.","source":"<code>byteCount</code> is less than the resulting number of bytes."}],"pos":[44530,44715],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[44833,45132],"yaml":true},{"content":"Encodes a set of characters from the specified character array into the specified byte array.","nodes":[{"pos":[0,93],"content":"Encodes a set of characters from the specified character array into the specified byte array.","nodes":[{"content":"Encodes a set of characters from the specified character array into the specified byte array.","pos":[0,93]}]}],"pos":[46842,46936],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \n  \n Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.  \n  \n> [!NOTE]\n>  To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility. The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.","nodes":[{"pos":[0,489],"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,489],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,190],"source":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, you call the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> method.","pos":[191,300],"source":" To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[301,489],"source":" The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[496,684],"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[0,188],"nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[0,104],"source":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>."},{"content":"Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[105,188]}]}]},{"pos":[691,1123],"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","nodes":[{"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","pos":[0,432],"nodes":[{"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks.","pos":[0,100]},{"content":"In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.UTF32Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.UTF32Encoding.GetEncoder%2A&gt;</ph> method, respectively.","pos":[101,432],"source":" In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively."}]}]},{"pos":[1131,1594],"content":"[!NOTE]\n To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility. The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.","leadings":["","> "],"nodes":[{"content":" To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility. The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.","pos":[8,461],"nodes":[{"content":"To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.","pos":[1,158]},{"content":"Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.","pos":[159,320]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.","pos":[321,453],"source":" The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes."}]}]}],"pos":[46947,48551],"yaml":true,"extradata":"MT"},{"content":"The character array containing the set of characters to encode.","nodes":[{"pos":[0,63],"content":"The character array containing the set of characters to encode.","nodes":[{"content":"The character array containing the set of characters to encode.","pos":[0,63]}]}],"pos":[49493,49557],"yaml":true},{"content":"The index of the first character to encode.","nodes":[{"pos":[0,43],"content":"The index of the first character to encode.","nodes":[{"content":"The index of the first character to encode.","pos":[0,43]}]}],"pos":[49621,49665],"yaml":true},{"content":"The number of characters to encode.","nodes":[{"pos":[0,35],"content":"The number of characters to encode.","nodes":[{"content":"The number of characters to encode.","pos":[0,35]}]}],"pos":[49729,49765],"yaml":true},{"content":"The byte array to contain the resulting sequence of bytes.","nodes":[{"pos":[0,58],"content":"The byte array to contain the resulting sequence of bytes.","nodes":[{"content":"The byte array to contain the resulting sequence of bytes.","pos":[0,58]}]}],"pos":[49826,49885],"yaml":true},{"content":"The index at which to start writing the resulting sequence of bytes.","nodes":[{"pos":[0,68],"content":"The index at which to start writing the resulting sequence of bytes.","nodes":[{"content":"The index at which to start writing the resulting sequence of bytes.","pos":[0,68]}]}],"pos":[49949,50018],"yaml":true},{"content":"The actual number of bytes written into <code>bytes</code>.","nodes":[{"pos":[0,59],"content":"The actual number of bytes written into <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The actual number of bytes written into <code>bytes</code>."}],"pos":[50074,50134],"yaml":true},{"content":"<code>chars</code> is `null`.  \n  \n -or-  \n  \n <code>bytes</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."},{"pos":[36,40],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[47,76],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[50298,50381],"yaml":true},{"content":"<code>charIndex</code> or <code>charCount</code> or <code>byteIndex</code> is less than zero.  \n  \n -or-  \n  \n <code>charIndex</code> and <code>charCount</code> do not denote a valid range in <code>chars</code>.  \n  \n -or-  \n  \n <code>byteIndex</code> is not a valid index in <code>bytes</code>.","nodes":[{"pos":[0,93],"content":"<ph id=\"ph1\">&lt;code&gt;charIndex&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;charCount&lt;/code&gt;</ph> or <ph id=\"ph3\">&lt;code&gt;byteIndex&lt;/code&gt;</ph> is less than zero.","source":"<code>charIndex</code> or <code>charCount</code> or <code>byteIndex</code> is less than zero."},{"pos":[100,104],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[111,211],"content":"<ph id=\"ph1\">&lt;code&gt;charIndex&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;charCount&lt;/code&gt;</ph> do not denote a valid range in <ph id=\"ph3\">&lt;code&gt;chars&lt;/code&gt;</ph>.","source":"<code>charIndex</code> and <code>charCount</code> do not denote a valid range in <code>chars</code>."},{"pos":[218,222],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[229,295],"content":"<ph id=\"ph1\">&lt;code&gt;byteIndex&lt;/code&gt;</ph> is not a valid index in <ph id=\"ph2\">&lt;code&gt;bytes&lt;/code&gt;</ph>.","source":"<code>byteIndex</code> is not a valid index in <code>bytes</code>."}],"pos":[50495,50801],"yaml":true},{"content":"Error detection is enabled, and <code>chars</code> contains an invalid sequence of characters.  \n  \n -or-  \n  \n <code>bytes</code> does not have enough capacity from <code>byteIndex</code> to the end of the array to accommodate the resulting bytes.","nodes":[{"pos":[0,94],"content":"Error detection is enabled, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">chars</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains an invalid sequence of characters.","source":"Error detection is enabled, and <code>chars</code> contains an invalid sequence of characters."},{"pos":[101,105],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[112,248],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> does not have enough capacity from <ph id=\"ph2\">&lt;code&gt;byteIndex&lt;/code&gt;</ph> to the end of the array to accommodate the resulting bytes.","source":"<code>bytes</code> does not have enough capacity from <code>byteIndex</code> to the end of the array to accommodate the resulting bytes."}],"pos":[50895,51150],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[51268,51567],"yaml":true},{"content":"Encodes a set of characters from the specified <xref href=\"System.String\"></xref> into the specified byte array.","nodes":[{"pos":[0,112],"content":"Encodes a set of characters from the specified <ph id=\"ph1\">&lt;xref href=\"System.String\"&gt;&lt;/xref&gt;</ph> into the specified byte array.","source":"Encodes a set of characters from the specified <xref href=\"System.String\"></xref> into the specified byte array."}],"pos":[53189,53302],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \n  \n Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.  \n  \n> [!NOTE]\n>  To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility. The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.","nodes":[{"pos":[0,489],"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,489],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,190],"source":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, you call the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> method.","pos":[191,300],"source":" To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[301,489],"source":" The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[496,684],"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[0,188],"nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[0,104],"source":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>."},{"content":"Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[105,188]}]}]},{"pos":[691,1123],"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","nodes":[{"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","pos":[0,432],"nodes":[{"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks.","pos":[0,100]},{"content":"In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.UTF32Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.UTF32Encoding.GetEncoder%2A&gt;</ph> method, respectively.","pos":[101,432],"source":" In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively."}]}]},{"pos":[1131,1594],"content":"[!NOTE]\n To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility. The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.","leadings":["","> "],"nodes":[{"content":" To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility. The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.","pos":[8,461],"nodes":[{"content":"To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble.","pos":[1,158]},{"content":"Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility.","pos":[159,320]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph> method does not prepend a preamble to the beginning of a sequence of encoded bytes.","pos":[321,453],"source":" The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes."}]}]}],"pos":[53313,54917],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.String\"></xref> containing the set of characters to encode.","nodes":[{"pos":[0,82],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.String\"&gt;&lt;/xref&gt;</ph> containing the set of characters to encode.","source":"The <xref href=\"System.String\"></xref> containing the set of characters to encode."}],"pos":[55807,55890],"yaml":true},{"content":"The index of the first character to encode.","nodes":[{"pos":[0,43],"content":"The index of the first character to encode.","nodes":[{"content":"The index of the first character to encode.","pos":[0,43]}]}],"pos":[55954,55998],"yaml":true},{"content":"The number of characters to encode.","nodes":[{"pos":[0,35],"content":"The number of characters to encode.","nodes":[{"content":"The number of characters to encode.","pos":[0,35]}]}],"pos":[56062,56098],"yaml":true},{"content":"The byte array to contain the resulting sequence of bytes.","nodes":[{"pos":[0,58],"content":"The byte array to contain the resulting sequence of bytes.","nodes":[{"content":"The byte array to contain the resulting sequence of bytes.","pos":[0,58]}]}],"pos":[56159,56218],"yaml":true},{"content":"The index at which to start writing the resulting sequence of bytes.","nodes":[{"pos":[0,68],"content":"The index at which to start writing the resulting sequence of bytes.","nodes":[{"content":"The index at which to start writing the resulting sequence of bytes.","pos":[0,68]}]}],"pos":[56282,56351],"yaml":true},{"content":"The actual number of bytes written into <code>bytes</code>.","nodes":[{"pos":[0,59],"content":"The actual number of bytes written into <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The actual number of bytes written into <code>bytes</code>."}],"pos":[56407,56467],"yaml":true},{"content":"<code>s</code> is `null`.  \n  \n -or-  \n  \n <code>bytes</code> is `null`.","nodes":[{"pos":[0,25],"content":"<ph id=\"ph1\">&lt;code&gt;s&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>s</code> is `null`."},{"pos":[32,36],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[43,72],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[56631,56710],"yaml":true},{"content":"<code>charIndex</code> or <code>charCount</code> or <code>byteIndex</code> is less than zero.  \n  \n -or-  \n  \n <code>charIndex</code> and <code>charCount</code> do not denote a valid range in <code>chars</code>.  \n  \n -or-  \n  \n <code>byteIndex</code> is not a valid index in <code>bytes</code>.","nodes":[{"pos":[0,93],"content":"<ph id=\"ph1\">&lt;code&gt;charIndex&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;charCount&lt;/code&gt;</ph> or <ph id=\"ph3\">&lt;code&gt;byteIndex&lt;/code&gt;</ph> is less than zero.","source":"<code>charIndex</code> or <code>charCount</code> or <code>byteIndex</code> is less than zero."},{"pos":[100,104],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[111,211],"content":"<ph id=\"ph1\">&lt;code&gt;charIndex&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;charCount&lt;/code&gt;</ph> do not denote a valid range in <ph id=\"ph3\">&lt;code&gt;chars&lt;/code&gt;</ph>.","source":"<code>charIndex</code> and <code>charCount</code> do not denote a valid range in <code>chars</code>."},{"pos":[218,222],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[229,295],"content":"<ph id=\"ph1\">&lt;code&gt;byteIndex&lt;/code&gt;</ph> is not a valid index in <ph id=\"ph2\">&lt;code&gt;bytes&lt;/code&gt;</ph>.","source":"<code>byteIndex</code> is not a valid index in <code>bytes</code>."}],"pos":[56824,57130],"yaml":true},{"content":"Error detection is enabled, and <code>s</code> contains an invalid sequence of characters.  \n  \n -or-  \n  \n <code>bytes</code> does not have enough capacity from <code>byteIndex</code> to the end of the array to accommodate the resulting bytes.","nodes":[{"pos":[0,90],"content":"Error detection is enabled, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">s</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains an invalid sequence of characters.","source":"Error detection is enabled, and <code>s</code> contains an invalid sequence of characters."},{"pos":[97,101],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[108,244],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> does not have enough capacity from <ph id=\"ph2\">&lt;code&gt;byteIndex&lt;/code&gt;</ph> to the end of the array to accommodate the resulting bytes.","source":"<code>bytes</code> does not have enough capacity from <code>byteIndex</code> to the end of the array to accommodate the resulting bytes."}],"pos":[57224,57475],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[57593,57892],"yaml":true},{"content":"Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.","nodes":[{"pos":[0,107],"content":"Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.","nodes":[{"content":"Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.","pos":[0,107]}]}],"pos":[59412,59520],"yaml":true},{"content":"The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method calculates the exact array size required by the <xref:System.Text.UTF32Encoding.GetChars%2A> method to store the resulting characters. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.  \n  \n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","nodes":[{"pos":[0,489],"content":"The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method calculates the exact array size required by the <xref:System.Text.UTF32Encoding.GetChars%2A> method to store the resulting characters. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.","nodes":[{"content":"The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method calculates the exact array size required by the <xref:System.Text.UTF32Encoding.GetChars%2A> method to store the resulting characters. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.","pos":[0,489],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetCharCount%2A&gt;</ph> method calculates the exact array size required by the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetChars%2A&gt;</ph> method to store the resulting characters.","pos":[0,194],"source":"The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method calculates the exact array size required by the <xref:System.Text.UTF32Encoding.GetChars%2A> method to store the resulting characters."},{"content":"To calculate the maximum array size, call the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxCharCount%2A&gt;</ph> method.","pos":[195,300],"source":" To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.","pos":[301,489],"source":" The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster."}]}]},{"pos":[496,684],"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[0,188],"nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[0,104],"source":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>."},{"content":"Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[105,188]}]}]}],"pos":[59531,60220],"yaml":true,"extradata":"MT"},{"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"pos":[0,58],"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"content":"The byte array containing the sequence of bytes to decode.","pos":[0,58]}]}],"pos":[61001,61060],"yaml":true},{"content":"The index of the first byte to decode.","nodes":[{"pos":[0,38],"content":"The index of the first byte to decode.","nodes":[{"content":"The index of the first byte to decode.","pos":[0,38]}]}],"pos":[61120,61159],"yaml":true},{"content":"The number of bytes to decode.","nodes":[{"pos":[0,30],"content":"The number of bytes to decode.","nodes":[{"content":"The number of bytes to decode.","pos":[0,30]}]}],"pos":[61219,61250],"yaml":true},{"content":"The number of characters produced by decoding the specified sequence of bytes.","nodes":[{"pos":[0,78],"content":"The number of characters produced by decoding the specified sequence of bytes.","nodes":[{"content":"The number of characters produced by decoding the specified sequence of bytes.","pos":[0,78]}]}],"pos":[61306,61385],"yaml":true},{"content":"<code>bytes</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[61553,61583],"yaml":true},{"content":"<code>index</code> or <code>count</code> is less than zero.  \n  \n -or-  \n  \n <code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>.  \n  \n -or-  \n  \n The resulting number of bytes is greater than the maximum number that can be returned as an integer.","nodes":[{"pos":[0,59],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.","source":"<code>index</code> or <code>count</code> is less than zero."},{"pos":[66,70],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[77,169],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range in <ph id=\"ph3\">&lt;code&gt;bytes&lt;/code&gt;</ph>.","source":"<code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>."},{"pos":[176,180],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[187,287],"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","nodes":[{"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","pos":[0,100]}]}],"pos":[61697,61995],"yaml":true},{"content":"Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes.","nodes":[{"pos":[0,89],"content":"Error detection is enabled, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains an invalid sequence of bytes.","source":"Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes."}],"pos":[62089,62179],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[62297,62596],"yaml":true},{"content":"Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.","nodes":[{"pos":[0,116],"content":"Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.","nodes":[{"content":"Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.","pos":[0,116]}]}],"pos":[64050,64167],"yaml":true},{"content":"<xref:System.Text.UTF32Encoding.GetCharCount%2A> calculates the exact array size required by the <xref:System.Text.UTF32Encoding.GetChars%2A> method to store the resulting characters. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.  \n  \n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","nodes":[{"pos":[0,478],"content":"<xref:System.Text.UTF32Encoding.GetCharCount%2A> calculates the exact array size required by the <xref:System.Text.UTF32Encoding.GetChars%2A> method to store the resulting characters. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.","nodes":[{"content":"<xref:System.Text.UTF32Encoding.GetCharCount%2A> calculates the exact array size required by the <xref:System.Text.UTF32Encoding.GetChars%2A> method to store the resulting characters. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.","pos":[0,478],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetCharCount%2A&gt;</ph> calculates the exact array size required by the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetChars%2A&gt;</ph> method to store the resulting characters.","pos":[0,183],"source":"<xref:System.Text.UTF32Encoding.GetCharCount%2A> calculates the exact array size required by the <xref:System.Text.UTF32Encoding.GetChars%2A> method to store the resulting characters."},{"content":"To calculate the maximum array size, call the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxCharCount%2A&gt;</ph> method.","pos":[184,289],"source":" To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.","pos":[290,478],"source":" The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster."}]}]},{"pos":[485,673],"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[0,188],"nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[0,104],"source":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>."},{"content":"Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[105,188]}]}]}],"pos":[64178,64856],"yaml":true,"extradata":"MT"},{"content":"A pointer to the first byte to decode.","nodes":[{"pos":[0,38],"content":"A pointer to the first byte to decode.","nodes":[{"content":"A pointer to the first byte to decode.","pos":[0,38]}]}],"pos":[65101,65140],"yaml":true},{"content":"The number of bytes to decode.","nodes":[{"pos":[0,30],"content":"The number of bytes to decode.","nodes":[{"content":"The number of bytes to decode.","pos":[0,30]}]}],"pos":[65200,65231],"yaml":true},{"content":"The number of characters produced by decoding the specified sequence of bytes.","nodes":[{"pos":[0,78],"content":"The number of characters produced by decoding the specified sequence of bytes.","nodes":[{"content":"The number of characters produced by decoding the specified sequence of bytes.","pos":[0,78]}]}],"pos":[65287,65366],"yaml":true},{"content":"<code>bytes</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[65534,65564],"yaml":true},{"content":"<code>count</code> is less than zero.  \n  \n -or-  \n  \n The resulting number of bytes is greater than the maximum number that can be returned as an integer.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.","source":"<code>count</code> is less than zero."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,155],"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","nodes":[{"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","pos":[0,100]}]}],"pos":[65678,65840],"yaml":true},{"content":"Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes.","nodes":[{"pos":[0,89],"content":"Error detection is enabled, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains an invalid sequence of bytes.","source":"Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes."}],"pos":[65934,66024],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[66142,66441],"yaml":true},{"content":"Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.","nodes":[{"pos":[0,152],"content":"Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.","nodes":[{"content":"Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.","pos":[0,152]}]}],"pos":[68079,68232],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.  \n  \n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \n  \n If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method. You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method.  \n  \n Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","nodes":[{"pos":[0,486],"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.","pos":[0,486],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetChars%2A&gt;</ph> to store the resulting characters, call the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetCharCount%2A&gt;</ph> method.","pos":[0,191],"source":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method."},{"content":"To calculate the maximum array size, call the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxCharCount%2A&gt;</ph> method.","pos":[192,297],"source":" To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.","pos":[298,486],"source":" The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster."}]}]},{"pos":[493,681],"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[0,188],"nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[0,104],"source":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>."},{"content":"Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[105,188]}]}]},{"pos":[688,1008],"content":"If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method. You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method.","nodes":[{"content":"If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method. You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method.","pos":[0,320],"nodes":[{"content":"If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.","pos":[0,220]},{"content":"You can remove it by calling the <ph id=\"ph1\">&lt;xref:System.String.TrimStart%2A?displayProperty=fullName&gt;</ph> method.","pos":[221,320],"source":" You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method."}]}]},{"pos":[1015,1447],"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","nodes":[{"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","pos":[0,432],"nodes":[{"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks.","pos":[0,100]},{"content":"In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.UTF32Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.UTF32Encoding.GetEncoder%2A&gt;</ph> method, respectively.","pos":[101,432],"source":" In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively."}]}]}],"pos":[68243,69699],"yaml":true,"extradata":"MT"},{"content":"A pointer to the first byte to decode.","nodes":[{"pos":[0,38],"content":"A pointer to the first byte to decode.","nodes":[{"content":"A pointer to the first byte to decode.","pos":[0,38]}]}],"pos":[69972,70011],"yaml":true},{"content":"The number of bytes to decode.","nodes":[{"pos":[0,30],"content":"The number of bytes to decode.","nodes":[{"content":"The number of bytes to decode.","pos":[0,30]}]}],"pos":[70075,70106],"yaml":true},{"content":"A pointer to the location at which to start writing the resulting set of characters.","nodes":[{"pos":[0,84],"content":"A pointer to the location at which to start writing the resulting set of characters.","nodes":[{"content":"A pointer to the location at which to start writing the resulting set of characters.","pos":[0,84]}]}],"pos":[70166,70251],"yaml":true},{"content":"The maximum number of characters to write.","nodes":[{"pos":[0,42],"content":"The maximum number of characters to write.","nodes":[{"content":"The maximum number of characters to write.","pos":[0,42]}]}],"pos":[70315,70358],"yaml":true},{"content":"The actual number of characters written at the location indicated by <code>chars</code>.","nodes":[{"pos":[0,88],"content":"The actual number of characters written at the location indicated by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">chars</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The actual number of characters written at the location indicated by <code>chars</code>."}],"pos":[70414,70503],"yaml":true},{"content":"<code>bytes</code> is `null`.  \n  \n -or-  \n  \n <code>chars</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."},{"pos":[36,40],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[47,76],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."}],"pos":[70667,70750],"yaml":true},{"content":"<code>byteCount</code> or <code>charCount</code> is less than zero.","nodes":[{"pos":[0,67],"content":"<ph id=\"ph1\">&lt;code&gt;byteCount&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;charCount&lt;/code&gt;</ph> is less than zero.","source":"<code>byteCount</code> or <code>charCount</code> is less than zero."}],"pos":[70864,70932],"yaml":true},{"content":"Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes.  \n  \n -or-  \n  \n <code>charCount</code> is less than the resulting number of characters.","nodes":[{"pos":[0,89],"content":"Error detection is enabled, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains an invalid sequence of bytes.","source":"Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes."},{"pos":[96,100],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[107,178],"content":"<ph id=\"ph1\">&lt;code&gt;charCount&lt;/code&gt;</ph> is less than the resulting number of characters.","source":"<code>charCount</code> is less than the resulting number of characters."}],"pos":[71026,71211],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[71329,71628],"yaml":true},{"content":"Decodes a sequence of bytes from the specified byte array into the specified character array.","nodes":[{"pos":[0,93],"content":"Decodes a sequence of bytes from the specified byte array into the specified character array.","nodes":[{"content":"Decodes a sequence of bytes from the specified byte array into the specified character array.","pos":[0,93]}]}],"pos":[73338,73432],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.  \n  \n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \n  \n If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method. You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method.  \n  \n Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","nodes":[{"pos":[0,486],"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.","pos":[0,486],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetChars%2A&gt;</ph> to store the resulting characters, call the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetCharCount%2A&gt;</ph> method.","pos":[0,191],"source":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method."},{"content":"To calculate the maximum array size, call the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxCharCount%2A&gt;</ph> method.","pos":[192,297],"source":" To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.","pos":[298,486],"source":" The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster."}]}]},{"pos":[493,681],"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[0,188],"nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[0,104],"source":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>."},{"content":"Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[105,188]}]}]},{"pos":[688,1008],"content":"If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method. You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method.","nodes":[{"content":"If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method. You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method.","pos":[0,320],"nodes":[{"content":"If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.","pos":[0,220]},{"content":"You can remove it by calling the <ph id=\"ph1\">&lt;xref:System.String.TrimStart%2A?displayProperty=fullName&gt;</ph> method.","pos":[221,320],"source":" You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method."}]}]},{"pos":[1015,1447],"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","nodes":[{"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","pos":[0,432],"nodes":[{"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks.","pos":[0,100]},{"content":"In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.UTF32Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.UTF32Encoding.GetEncoder%2A&gt;</ph> method, respectively.","pos":[101,432],"source":" In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively."}]}]}],"pos":[73443,74899],"yaml":true,"extradata":"MT"},{"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"pos":[0,58],"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"content":"The byte array containing the sequence of bytes to decode.","pos":[0,58]}]}],"pos":[75713,75772],"yaml":true},{"content":"The index of the first byte to decode.","nodes":[{"pos":[0,38],"content":"The index of the first byte to decode.","nodes":[{"content":"The index of the first byte to decode.","pos":[0,38]}]}],"pos":[75836,75875],"yaml":true},{"content":"The number of bytes to decode.","nodes":[{"pos":[0,30],"content":"The number of bytes to decode.","nodes":[{"content":"The number of bytes to decode.","pos":[0,30]}]}],"pos":[75939,75970],"yaml":true},{"content":"The character array to contain the resulting set of characters.","nodes":[{"pos":[0,63],"content":"The character array to contain the resulting set of characters.","nodes":[{"content":"The character array to contain the resulting set of characters.","pos":[0,63]}]}],"pos":[76031,76095],"yaml":true},{"content":"The index at which to start writing the resulting set of characters.","nodes":[{"pos":[0,68],"content":"The index at which to start writing the resulting set of characters.","nodes":[{"content":"The index at which to start writing the resulting set of characters.","pos":[0,68]}]}],"pos":[76159,76228],"yaml":true},{"content":"The actual number of characters written into <code>chars</code>.","nodes":[{"pos":[0,64],"content":"The actual number of characters written into <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">chars</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The actual number of characters written into <code>chars</code>."}],"pos":[76284,76349],"yaml":true},{"content":"<code>bytes</code> is `null`.  \n  \n -or-  \n  \n <code>chars</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."},{"pos":[36,40],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[47,76],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>chars</code> is `null`."}],"pos":[76513,76596],"yaml":true},{"content":"<code>byteIndex</code> or <code>byteCount</code> or <code>charIndex</code> is less than zero.  \n  \n -or-  \n  \n <code>byteindex</code> and <code>byteCount</code> do not denote a valid range in <code>bytes</code>.  \n  \n -or-  \n  \n <code>charIndex</code> is not a valid index in <code>chars</code>.","nodes":[{"pos":[0,93],"content":"<ph id=\"ph1\">&lt;code&gt;byteIndex&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;byteCount&lt;/code&gt;</ph> or <ph id=\"ph3\">&lt;code&gt;charIndex&lt;/code&gt;</ph> is less than zero.","source":"<code>byteIndex</code> or <code>byteCount</code> or <code>charIndex</code> is less than zero."},{"pos":[100,104],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[111,211],"content":"<ph id=\"ph1\">&lt;code&gt;byteindex&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;byteCount&lt;/code&gt;</ph> do not denote a valid range in <ph id=\"ph3\">&lt;code&gt;bytes&lt;/code&gt;</ph>.","source":"<code>byteindex</code> and <code>byteCount</code> do not denote a valid range in <code>bytes</code>."},{"pos":[218,222],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[229,295],"content":"<ph id=\"ph1\">&lt;code&gt;charIndex&lt;/code&gt;</ph> is not a valid index in <ph id=\"ph2\">&lt;code&gt;chars&lt;/code&gt;</ph>.","source":"<code>charIndex</code> is not a valid index in <code>chars</code>."}],"pos":[76710,77016],"yaml":true},{"content":"Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes.  \n  \n -or-  \n  \n <code>chars</code> does not have enough capacity from <code>charIndex</code> to the end of the array to accommodate the resulting characters.","nodes":[{"pos":[0,89],"content":"Error detection is enabled, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains an invalid sequence of bytes.","source":"Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes."},{"pos":[96,100],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[107,248],"content":"<ph id=\"ph1\">&lt;code&gt;chars&lt;/code&gt;</ph> does not have enough capacity from <ph id=\"ph2\">&lt;code&gt;charIndex&lt;/code&gt;</ph> to the end of the array to accommodate the resulting characters.","source":"<code>chars</code> does not have enough capacity from <code>charIndex</code> to the end of the array to accommodate the resulting characters."}],"pos":[77110,77365],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[77483,77782],"yaml":true},{"content":"Obtains a decoder that converts a UTF-32 encoded sequence of bytes into a sequence of Unicode characters.","nodes":[{"pos":[0,105],"content":"Obtains a decoder that converts a UTF-32 encoded sequence of bytes into a sequence of Unicode characters.","nodes":[{"content":"Obtains a decoder that converts a UTF-32 encoded sequence of bytes into a sequence of Unicode characters.","pos":[0,105]}]}],"pos":[79107,79213],"yaml":true},{"content":"The <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.UTF32Encoding.GetChars%2A> method. However, a <xref:System.Text.Decoder> maintains state information between calls so it can correctly decode byte sequences that span blocks. The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation. Therefore, <xref:System.Text.UTF32Encoding.GetDecoder%2A> and <xref:System.Text.UTF32Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.  \n  \n If error detection is enabled, that is, the `throwOnInvalidCharacters` parameter of the constructor was set to `true`, error detection is also enabled in the <xref:System.Text.Decoder> returned by this method. If error detection is enabled and an invalid sequence is encountered, the state of the decoder is undefined and processing must stop.","nodes":[{"pos":[0,772],"content":"The <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.UTF32Encoding.GetChars%2A> method. However, a <xref:System.Text.Decoder> maintains state information between calls so it can correctly decode byte sequences that span blocks. The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation. Therefore, <xref:System.Text.UTF32Encoding.GetDecoder%2A> and <xref:System.Text.UTF32Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.","nodes":[{"content":"The <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.UTF32Encoding.GetChars%2A> method. However, a <xref:System.Text.Decoder> maintains state information between calls so it can correctly decode byte sequences that span blocks. The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation. Therefore, <xref:System.Text.UTF32Encoding.GetDecoder%2A> and <xref:System.Text.UTF32Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.","pos":[0,772],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName&gt;</ph> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetChars%2A&gt;</ph> method.","pos":[0,228],"source":"The <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.UTF32Encoding.GetChars%2A> method."},{"content":"However, a <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> maintains state information between calls so it can correctly decode byte sequences that span blocks.","pos":[229,368],"source":" However, a <xref:System.Text.Decoder> maintains state information between calls so it can correctly decode byte sequences that span blocks."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation.","pos":[369,515],"source":" The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation."},{"content":"Therefore, <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetDecoder%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.","pos":[516,772],"source":" Therefore, <xref:System.Text.UTF32Encoding.GetDecoder%2A> and <xref:System.Text.UTF32Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream."}]}]},{"pos":[779,1122],"content":"If error detection is enabled, that is, the `throwOnInvalidCharacters` parameter of the constructor was set to `true`, error detection is also enabled in the <xref:System.Text.Decoder> returned by this method. If error detection is enabled and an invalid sequence is encountered, the state of the decoder is undefined and processing must stop.","nodes":[{"content":"If error detection is enabled, that is, the <ph id=\"ph1\">`throwOnInvalidCharacters`</ph> parameter of the constructor was set to <ph id=\"ph2\">`true`</ph>, error detection is also enabled in the <ph id=\"ph3\">&lt;xref:System.Text.Decoder&gt;</ph> returned by this method.","pos":[0,209],"source":"If error detection is enabled, that is, the `throwOnInvalidCharacters` parameter of the constructor was set to `true`, error detection is also enabled in the <xref:System.Text.Decoder> returned by this method."},{"content":"If error detection is enabled and an invalid sequence is encountered, the state of the decoder is undefined and processing must stop.","pos":[210,343]}]}],"pos":[79224,80351],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Text.Decoder\"></xref> that converts a UTF-32 encoded sequence of bytes into a sequence of Unicode characters.","nodes":[{"pos":[0,130],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Text.Decoder\"&gt;&lt;/xref&gt;</ph> that converts a UTF-32 encoded sequence of bytes into a sequence of Unicode characters.","source":"A <xref href=\"System.Text.Decoder\"></xref> that converts a UTF-32 encoded sequence of bytes into a sequence of Unicode characters."}],"pos":[81130,81261],"yaml":true},{"content":"Obtains an encoder that converts a sequence of Unicode characters into a UTF-32 encoded sequence of bytes.","nodes":[{"pos":[0,106],"content":"Obtains an encoder that converts a sequence of Unicode characters into a UTF-32 encoded sequence of bytes.","nodes":[{"content":"Obtains an encoder that converts a sequence of Unicode characters into a UTF-32 encoded sequence of bytes.","pos":[0,106]}]}],"pos":[82636,82743],"yaml":true},{"content":"The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.UTF32Encoding.GetBytes%2A> method. However, a <xref:System.Text.Encoder> maintains state information between calls so it can correctly encode character sequences that span blocks. The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation. For example, a data block might end with an unmatched high-surrogate, and the matching low-surrogate might be in the next data block. Therefore, <xref:System.Text.UTF32Encoding.GetDecoder%2A> and <xref:System.Text.UTF32Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.  \n  \n If error detection is enabled, that is, the `throwOnInvalidCharacters` parameter of the constructor was set to `true`, error detection is also enabled in the <xref:System.Text.Encoder> returned by this method. If error detection is enabled and an invalid sequence is encountered, the state of the encoder is undefined and processing must stop.","nodes":[{"pos":[0,921],"content":"The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.UTF32Encoding.GetBytes%2A> method. However, a <xref:System.Text.Encoder> maintains state information between calls so it can correctly encode character sequences that span blocks. The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation. For example, a data block might end with an unmatched high-surrogate, and the matching low-surrogate might be in the next data block. Therefore, <xref:System.Text.UTF32Encoding.GetDecoder%2A> and <xref:System.Text.UTF32Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.","nodes":[{"content":"The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.UTF32Encoding.GetBytes%2A> method. However, a <xref:System.Text.Encoder> maintains state information between calls so it can correctly encode character sequences that span blocks. The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation. For example, a data block might end with an unmatched high-surrogate, and the matching low-surrogate might be in the next data block. Therefore, <xref:System.Text.UTF32Encoding.GetDecoder%2A> and <xref:System.Text.UTF32Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.","pos":[0,921],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName&gt;</ph> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph> method.","pos":[0,228],"source":"The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.UTF32Encoding.GetBytes%2A> method."},{"content":"However, a <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> maintains state information between calls so it can correctly encode character sequences that span blocks.","pos":[229,373],"source":" However, a <xref:System.Text.Encoder> maintains state information between calls so it can correctly encode character sequences that span blocks."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.Encoder&gt;</ph> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation.","pos":[374,530],"source":" The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation."},{"content":"For example, a data block might end with an unmatched high-surrogate, and the matching low-surrogate might be in the next data block.","pos":[531,664]},{"content":"Therefore, <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetDecoder%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetEncoder%2A&gt;</ph> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.","pos":[665,921],"source":" Therefore, <xref:System.Text.UTF32Encoding.GetDecoder%2A> and <xref:System.Text.UTF32Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream."}]}]},{"pos":[928,1271],"content":"If error detection is enabled, that is, the `throwOnInvalidCharacters` parameter of the constructor was set to `true`, error detection is also enabled in the <xref:System.Text.Encoder> returned by this method. If error detection is enabled and an invalid sequence is encountered, the state of the encoder is undefined and processing must stop.","nodes":[{"content":"If error detection is enabled, that is, the <ph id=\"ph1\">`throwOnInvalidCharacters`</ph> parameter of the constructor was set to <ph id=\"ph2\">`true`</ph>, error detection is also enabled in the <ph id=\"ph3\">&lt;xref:System.Text.Encoder&gt;</ph> returned by this method.","pos":[0,209],"source":"If error detection is enabled, that is, the `throwOnInvalidCharacters` parameter of the constructor was set to `true`, error detection is also enabled in the <xref:System.Text.Encoder> returned by this method."},{"content":"If error detection is enabled and an invalid sequence is encountered, the state of the encoder is undefined and processing must stop.","pos":[210,343]}]}],"pos":[82754,84030],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Text.Encoder\"></xref> that converts a sequence of Unicode characters into a UTF-32 encoded sequence of bytes.","nodes":[{"pos":[0,130],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Text.Encoder\"&gt;&lt;/xref&gt;</ph> that converts a sequence of Unicode characters into a UTF-32 encoded sequence of bytes.","source":"A <xref href=\"System.Text.Encoder\"></xref> that converts a sequence of Unicode characters into a UTF-32 encoded sequence of bytes."}],"pos":[84809,84940],"yaml":true},{"content":"Returns the hash code for the current instance.","nodes":[{"pos":[0,47],"content":"Returns the hash code for the current instance.","nodes":[{"content":"Returns the hash code for the current instance.","pos":[0,47]}]}],"pos":[86321,86369],"yaml":true},{"content":"The hash code for the current <xref href=\"System.Text.UTF32Encoding\"></xref> object.","nodes":[{"pos":[0,84],"content":"The hash code for the current <ph id=\"ph1\">&lt;xref href=\"System.Text.UTF32Encoding\"&gt;&lt;/xref&gt;</ph> object.","source":"The hash code for the current <xref href=\"System.Text.UTF32Encoding\"></xref> object."}],"pos":[86503,86588],"yaml":true},{"content":"Calculates the maximum number of bytes produced by encoding the specified number of characters.","nodes":[{"pos":[0,95],"content":"Calculates the maximum number of bytes produced by encoding the specified number of characters.","nodes":[{"content":"Calculates the maximum number of bytes produced by encoding the specified number of characters.","pos":[0,95]}]}],"pos":[88051,88147],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.  \n  \n <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> is a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>. If a fallback is chosen with a potentially large string,  <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> can return large values.  \n  \n In most cases, this method returns reasonable numbers for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded. You might also want to consider a different approach and use <xref:System.Text.UTF32Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName>.  \n  \n <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> has no relationship to <xref:System.Text.UTF32Encoding.GetChars%2A>. If you need a similar function to use with <xref:System.Text.UTF32Encoding.GetChars%2A>, use <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>.  \n  \n> [!NOTE]\n>  `GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.","nodes":[{"pos":[0,489],"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.","pos":[0,489],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph> to store the resulting bytes, you call the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method.","pos":[0,190],"source":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method."},{"content":"To calculate the maximum array size, you call the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> method.","pos":[191,300],"source":" To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> method generally allocates less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> method generally executes faster.","pos":[301,489],"source":" The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster."}]}]},{"pos":[496,794],"content":"<xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> is a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>. If a fallback is chosen with a potentially large string,  <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> can return large values.","nodes":[{"content":"<xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> is a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>. If a fallback is chosen with a potentially large string,  <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> can return large values.","pos":[0,298],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> is a worst-case number, including the worst case for the currently selected <ph id=\"ph2\">&lt;xref:System.Text.EncoderFallback&gt;</ph>.","pos":[0,163],"source":"<xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> is a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>."},{"content":"If a fallback is chosen with a potentially large string,  <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> can return large values.","pos":[164,298],"source":" If a fallback is chosen with a potentially large string,  <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> can return large values."}]}]},{"pos":[801,1207],"content":"In most cases, this method returns reasonable numbers for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded. You might also want to consider a different approach and use <xref:System.Text.UTF32Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName>.","nodes":[{"content":"In most cases, this method returns reasonable numbers for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded. You might also want to consider a different approach and use <xref:System.Text.UTF32Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName>.","pos":[0,406],"nodes":[{"content":"In most cases, this method returns reasonable numbers for small strings.","pos":[0,72]},{"content":"For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.","pos":[73,229]},{"content":"You might also want to consider a different approach and use <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetByteCount%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Text.Encoder.Convert%2A?displayProperty=fullName&gt;</ph>.","pos":[230,406],"source":" You might also want to consider a different approach and use <xref:System.Text.UTF32Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName>."}]}]},{"pos":[1214,1480],"content":"<xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> has no relationship to <xref:System.Text.UTF32Encoding.GetChars%2A>. If you need a similar function to use with <xref:System.Text.UTF32Encoding.GetChars%2A>, use <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>.","nodes":[{"content":"<xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> has no relationship to <xref:System.Text.UTF32Encoding.GetChars%2A>. If you need a similar function to use with <xref:System.Text.UTF32Encoding.GetChars%2A>, use <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>.","pos":[0,266],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph> has no relationship to <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetChars%2A&gt;</ph>.","pos":[0,120],"source":"<xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> has no relationship to <xref:System.Text.UTF32Encoding.GetChars%2A>."},{"content":"If you need a similar function to use with <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetChars%2A&gt;</ph>, use <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetMaxCharCount%2A&gt;</ph>.","pos":[121,266],"source":" If you need a similar function to use with <xref:System.Text.UTF32Encoding.GetChars%2A>, use <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>."}]}]},{"pos":[1488,1581],"content":"[!NOTE]\n `GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> `GetMaxByteCount(N)`</ph> is not necessarily the same value as <ph id=\"ph2\">`N* GetMaxByteCount(1)`</ph>.","pos":[8,91],"source":" `GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`."}]}],"pos":[88158,89751],"yaml":true,"extradata":"MT"},{"content":"The number of characters to encode.","nodes":[{"pos":[0,35],"content":"The number of characters to encode.","nodes":[{"content":"The number of characters to encode.","pos":[0,35]}]}],"pos":[90601,90637],"yaml":true},{"content":"The maximum number of bytes produced by encoding the specified number of characters.","nodes":[{"pos":[0,84],"content":"The maximum number of bytes produced by encoding the specified number of characters.","nodes":[{"content":"The maximum number of bytes produced by encoding the specified number of characters.","pos":[0,84]}]}],"pos":[90693,90778],"yaml":true},{"content":"<code>charCount</code> is less than zero.  \n  \n -or-  \n  \n The resulting number of bytes is greater than the maximum number that can be returned as an integer.","nodes":[{"pos":[0,41],"content":"<ph id=\"ph1\">&lt;code&gt;charCount&lt;/code&gt;</ph> is less than zero.","source":"<code>charCount</code> is less than zero."},{"pos":[48,52],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[59,159],"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","nodes":[{"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","pos":[0,100]}]}],"pos":[90961,91127],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.EncoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.EncoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.EncoderFallback\"></xref> is set to <xref href=\"System.Text.EncoderExceptionFallback\"></xref>."}],"pos":[91245,91544],"yaml":true},{"content":"Calculates the maximum number of characters produced by decoding the specified number of bytes.","nodes":[{"pos":[0,95],"content":"Calculates the maximum number of characters produced by decoding the specified number of bytes.","nodes":[{"content":"Calculates the maximum number of characters produced by decoding the specified number of bytes.","pos":[0,95]}]}],"pos":[92939,93035],"yaml":true},{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, you call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.  \n  \n <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> is a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>. If a fallback is chosen with a potentially large string, <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> can return large values.  \n  \n In most cases, this method returns reasonable numbers for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded. You might also want to consider a different approach and use <xref:System.Text.UTF32Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A>.  \n  \n <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> has no relationship to <xref:System.Text.UTF32Encoding.GetBytes%2A>. If you need a similar function to use with <xref:System.Text.UTF32Encoding.GetBytes%2A>, use <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>.  \n  \n> [!NOTE]\n>  `GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.","nodes":[{"pos":[0,494],"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, you call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.","nodes":[{"content":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, you call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.","pos":[0,494],"nodes":[{"content":"To calculate the exact array size required by <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetChars%2A&gt;</ph> to store the resulting characters, you call the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetCharCount%2A&gt;</ph> method.","pos":[0,195],"source":"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, you call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method."},{"content":"To calculate the maximum array size, you call the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxCharCount%2A&gt;</ph> method.","pos":[196,305],"source":" To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetCharCount%2A&gt;</ph> method generally allocates less memory, while the <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetMaxCharCount%2A&gt;</ph> method generally executes faster.","pos":[306,494],"source":" The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster."}]}]},{"pos":[501,798],"content":"<xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> is a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>. If a fallback is chosen with a potentially large string, <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> can return large values.","nodes":[{"content":"<xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> is a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>. If a fallback is chosen with a potentially large string, <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> can return large values.","pos":[0,297],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxCharCount%2A&gt;</ph> is a worst-case number, including the worst case for the currently selected <ph id=\"ph2\">&lt;xref:System.Text.DecoderFallback&gt;</ph>.","pos":[0,163],"source":"<xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> is a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>."},{"content":"If a fallback is chosen with a potentially large string, <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxCharCount%2A&gt;</ph> can return large values.","pos":[164,297],"source":" If a fallback is chosen with a potentially large string, <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> can return large values."}]}]},{"pos":[805,1186],"content":"In most cases, this method returns reasonable numbers for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded. You might also want to consider a different approach and use <xref:System.Text.UTF32Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A>.","nodes":[{"content":"In most cases, this method returns reasonable numbers for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded. You might also want to consider a different approach and use <xref:System.Text.UTF32Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A>.","pos":[0,381],"nodes":[{"content":"In most cases, this method returns reasonable numbers for small strings.","pos":[0,72]},{"content":"For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded.","pos":[73,229]},{"content":"You might also want to consider a different approach and use <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetCharCount%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Text.Decoder.Convert%2A&gt;</ph>.","pos":[230,381],"source":" You might also want to consider a different approach and use <xref:System.Text.UTF32Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A>."}]}]},{"pos":[1193,1459],"content":"<xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> has no relationship to <xref:System.Text.UTF32Encoding.GetBytes%2A>. If you need a similar function to use with <xref:System.Text.UTF32Encoding.GetBytes%2A>, use <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>.","nodes":[{"content":"<xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> has no relationship to <xref:System.Text.UTF32Encoding.GetBytes%2A>. If you need a similar function to use with <xref:System.Text.UTF32Encoding.GetBytes%2A>, use <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>.","pos":[0,266],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetMaxCharCount%2A&gt;</ph> has no relationship to <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph>.","pos":[0,120],"source":"<xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> has no relationship to <xref:System.Text.UTF32Encoding.GetBytes%2A>."},{"content":"If you need a similar function to use with <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph>, use <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetMaxByteCount%2A&gt;</ph>.","pos":[121,266],"source":" If you need a similar function to use with <xref:System.Text.UTF32Encoding.GetBytes%2A>, use <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>."}]}]},{"pos":[1467,1560],"content":"[!NOTE]\n `GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.","leadings":["","> "],"nodes":[{"content":"<ph id=\"ph1\"> `GetMaxCharCount(N)`</ph> is not necessarily the same value as <ph id=\"ph2\">`N* GetMaxCharCount(1)`</ph>.","pos":[8,91],"source":" `GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`."}]}],"pos":[93046,94618],"yaml":true,"extradata":"MT"},{"content":"The number of bytes to decode.","nodes":[{"pos":[0,30],"content":"The number of bytes to decode.","nodes":[{"content":"The number of bytes to decode.","pos":[0,30]}]}],"pos":[95384,95415],"yaml":true},{"content":"The maximum number of characters produced by decoding the specified number of bytes.","nodes":[{"pos":[0,84],"content":"The maximum number of characters produced by decoding the specified number of bytes.","nodes":[{"content":"The maximum number of characters produced by decoding the specified number of bytes.","pos":[0,84]}]}],"pos":[95471,95556],"yaml":true},{"content":"<code>byteCount</code> is less than zero.  \n  \n -or-  \n  \n The resulting number of bytes is greater than the maximum number that can be returned as an integer.","nodes":[{"pos":[0,41],"content":"<ph id=\"ph1\">&lt;code&gt;byteCount&lt;/code&gt;</ph> is less than zero.","source":"<code>byteCount</code> is less than zero."},{"pos":[48,52],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[59,159],"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","nodes":[{"content":"The resulting number of bytes is greater than the maximum number that can be returned as an integer.","pos":[0,100]}]}],"pos":[95739,95905],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,143],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)"},{"pos":[150,155],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[162,288],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[96023,96322],"yaml":true},{"content":"Returns a Unicode byte order mark encoded in UTF-32 format, if the <xref href=\"System.Text.UTF32Encoding\"></xref> object is configured to supply one.","nodes":[{"pos":[0,149],"content":"Returns a Unicode byte order mark encoded in UTF-32 format, if the <ph id=\"ph1\">&lt;xref href=\"System.Text.UTF32Encoding\"&gt;&lt;/xref&gt;</ph> object is configured to supply one.","source":"Returns a Unicode byte order mark encoded in UTF-32 format, if the <xref href=\"System.Text.UTF32Encoding\"></xref> object is configured to supply one."}],"pos":[97636,97786],"yaml":true},{"content":"The <xref:System.Text.UTF32Encoding> object can provide a preamble, which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process. Prefacing a sequence of encoded bytes with a byte order mark (code points U+0000 U+FEFF) helps the decoder determine the byte order and the transformation format, or UTF. The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):  \n  \n-   Big endian byte order: 00 00 FE FF  \n  \n-   Little endian byte order: FF FE 00 00  \n  \n You can instantiate a <xref:System.Text.UTF32Encoding> object whose <xref:System.Text.UTF32Encoding.GetPreamble%2A> method returns a valid BOM in the following ways:  \n  \n-   By retrieving the <xref:System.Text.UTF32Encoding> object returned by the <xref:System.Text.Encoding.UTF32%2A?displayProperty=fullName> property.  \n  \n-   By calling the parameterless <xref:System.Text.UTF32Encoding.%23ctor> constructor to instantiate a <xref:System.Text.UTF32Encoding> object.  \n  \n-   By supplying `true` as the value of the `byteOrderMark` argument to the <xref:System.Text.UTF32Encoding.%23ctor%2A> and <xref:System.Text.UTF32Encoding.%23ctor%2A> constructors.  \n  \n We recommend that you use the BOM, since it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.UTF32Encoding> object, for example, untagged or improperly tagged web data, or random text files stored when a business did not have international concerns or other data. Often, user problems might be avoided if data is consistently and properly tagged.  \n  \n For standards that provide an encoding type, a BOM is somewhat redundant. However, it can be used to help a server send the correct encoding header. Alternatively, it can be used as a fallback in case the encoding is otherwise lost.  \n  \n There are some disadvantages to using a BOM. For example, knowing how to limit the database fields that use a BOM can be difficult. Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data. In spite of the few disadvantages, however, the use of a BOM is highly recommended.  \n  \n For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123).  \n  \n> [!CAUTION]\n>  To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble. Note that the <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.","nodes":[{"pos":[0,425],"content":"The <xref:System.Text.UTF32Encoding> object can provide a preamble, which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process. Prefacing a sequence of encoded bytes with a byte order mark (code points U+0000 U+FEFF) helps the decoder determine the byte order and the transformation format, or UTF. The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):","nodes":[{"content":"The <xref:System.Text.UTF32Encoding> object can provide a preamble, which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process. Prefacing a sequence of encoded bytes with a byte order mark (code points U+0000 U+FEFF) helps the decoder determine the byte order and the transformation format, or UTF. The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):","pos":[0,425],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object can provide a preamble, which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process.","pos":[0,177],"source":"The <xref:System.Text.UTF32Encoding> object can provide a preamble, which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process."},{"content":"Prefacing a sequence of encoded bytes with a byte order mark (code points U+0000 U+FEFF) helps the decoder determine the byte order and the transformation format, or UTF.","pos":[178,348]},{"content":"The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):","pos":[349,425]}]}]},{"pos":[435,469],"content":"Big endian byte order: 00 00 FE FF","nodes":[{"content":"Big endian byte order: 00 00 FE FF","pos":[0,34]}]},{"pos":[479,516],"content":"Little endian byte order: FF FE 00 00","nodes":[{"content":"Little endian byte order: FF FE 00 00","pos":[0,37]}]},{"pos":[523,688],"content":"You can instantiate a <xref:System.Text.UTF32Encoding> object whose <xref:System.Text.UTF32Encoding.GetPreamble%2A> method returns a valid BOM in the following ways:","nodes":[{"content":"You can instantiate a <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object whose <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding.GetPreamble%2A&gt;</ph> method returns a valid BOM in the following ways:","pos":[0,165],"source":"You can instantiate a <xref:System.Text.UTF32Encoding> object whose <xref:System.Text.UTF32Encoding.GetPreamble%2A> method returns a valid BOM in the following ways:"}]},{"pos":[698,843],"content":"By retrieving the <xref:System.Text.UTF32Encoding> object returned by the <xref:System.Text.Encoding.UTF32%2A?displayProperty=fullName> property.","nodes":[{"content":"By retrieving the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object returned by the <ph id=\"ph2\">&lt;xref:System.Text.Encoding.UTF32%2A?displayProperty=fullName&gt;</ph> property.","pos":[0,145],"source":"By retrieving the <xref:System.Text.UTF32Encoding> object returned by the <xref:System.Text.Encoding.UTF32%2A?displayProperty=fullName> property."}]},{"pos":[853,992],"content":"By calling the parameterless <xref:System.Text.UTF32Encoding.%23ctor> constructor to instantiate a <xref:System.Text.UTF32Encoding> object.","nodes":[{"content":"By calling the parameterless <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.%23ctor&gt;</ph> constructor to instantiate a <ph id=\"ph2\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object.","pos":[0,139],"source":"By calling the parameterless <xref:System.Text.UTF32Encoding.%23ctor> constructor to instantiate a <xref:System.Text.UTF32Encoding> object."}]},{"pos":[1002,1179],"content":"By supplying <ph id=\"ph1\">`true`</ph> as the value of the <ph id=\"ph2\">`byteOrderMark`</ph> argument to the <ph id=\"ph3\">&lt;xref:System.Text.UTF32Encoding.%23ctor%2A&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.Text.UTF32Encoding.%23ctor%2A&gt;</ph> constructors.","source":"By supplying `true` as the value of the `byteOrderMark` argument to the <xref:System.Text.UTF32Encoding.%23ctor%2A> and <xref:System.Text.UTF32Encoding.%23ctor%2A> constructors."},{"pos":[1186,1607],"content":"We recommend that you use the BOM, since it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.UTF32Encoding> object, for example, untagged or improperly tagged web data, or random text files stored when a business did not have international concerns or other data. Often, user problems might be avoided if data is consistently and properly tagged.","nodes":[{"content":"We recommend that you use the BOM, since it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.UTF32Encoding> object, for example, untagged or improperly tagged web data, or random text files stored when a business did not have international concerns or other data. Often, user problems might be avoided if data is consistently and properly tagged.","pos":[0,421],"nodes":[{"content":"We recommend that you use the BOM, since it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding&gt;</ph> object, for example, untagged or improperly tagged web data, or random text files stored when a business did not have international concerns or other data.","pos":[0,338],"source":"We recommend that you use the BOM, since it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.UTF32Encoding> object, for example, untagged or improperly tagged web data, or random text files stored when a business did not have international concerns or other data."},{"content":"Often, user problems might be avoided if data is consistently and properly tagged.","pos":[339,421]}]}]},{"pos":[1614,1846],"content":"For standards that provide an encoding type, a BOM is somewhat redundant. However, it can be used to help a server send the correct encoding header. Alternatively, it can be used as a fallback in case the encoding is otherwise lost.","nodes":[{"content":"For standards that provide an encoding type, a BOM is somewhat redundant. However, it can be used to help a server send the correct encoding header. Alternatively, it can be used as a fallback in case the encoding is otherwise lost.","pos":[0,232],"nodes":[{"content":"For standards that provide an encoding type, a BOM is somewhat redundant.","pos":[0,73]},{"content":"However, it can be used to help a server send the correct encoding header.","pos":[74,148]},{"content":"Alternatively, it can be used as a fallback in case the encoding is otherwise lost.","pos":[149,232]}]}]},{"pos":[1853,2227],"content":"There are some disadvantages to using a BOM. For example, knowing how to limit the database fields that use a BOM can be difficult. Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data. In spite of the few disadvantages, however, the use of a BOM is highly recommended.","nodes":[{"content":"There are some disadvantages to using a BOM. For example, knowing how to limit the database fields that use a BOM can be difficult. Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data. In spite of the few disadvantages, however, the use of a BOM is highly recommended.","pos":[0,374],"nodes":[{"content":"There are some disadvantages to using a BOM.","pos":[0,44]},{"content":"For example, knowing how to limit the database fields that use a BOM can be difficult.","pos":[45,131]},{"content":"Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data.","pos":[132,290]},{"content":"In spite of the few disadvantages, however, the use of a BOM is highly recommended.","pos":[291,374]}]}]},{"pos":[2234,2392],"content":"For more information on byte order and the byte order mark, see The Unicode Standard at the <bpt id=\"p1\">[</bpt>Unicode home page<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkId=37123)</ept>.","source":"For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123)."},{"pos":[2400,2736],"content":"[!CAUTION]\n To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble. Note that the <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.","leadings":["","> "],"nodes":[{"content":" To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble. Note that the <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.","pos":[11,334],"nodes":[{"content":"To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble.","pos":[1,104]},{"content":"Note that the <ph id=\"ph1\">&lt;xref:System.Text.UTF32Encoding.GetBytes%2A&gt;</ph> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.","pos":[105,323],"source":" Note that the <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility."}]}]}],"pos":[97797,100559],"yaml":true,"extradata":"MT"},{"content":"A byte array containing the Unicode byte order mark, if the <xref href=\"System.Text.UTF32Encoding\"></xref> object is configured to supply one. Otherwise, this method returns a zero-length byte array.","nodes":[{"pos":[0,199],"content":"A byte array containing the Unicode byte order mark, if the <xref href=\"System.Text.UTF32Encoding\"></xref> object is configured to supply one. Otherwise, this method returns a zero-length byte array.","nodes":[{"content":"A byte array containing the Unicode byte order mark, if the <ph id=\"ph1\">&lt;xref href=\"System.Text.UTF32Encoding\"&gt;&lt;/xref&gt;</ph> object is configured to supply one.","pos":[0,142],"source":"A byte array containing the Unicode byte order mark, if the <xref href=\"System.Text.UTF32Encoding\"></xref> object is configured to supply one."},{"content":"Otherwise, this method returns a zero-length byte array.","pos":[143,199]}]}],"pos":[102371,102571],"yaml":true},{"content":"Decodes a range of bytes from a byte array into a string.","nodes":[{"pos":[0,57],"content":"Decodes a range of bytes from a byte array into a string.","nodes":[{"content":"Decodes a range of bytes from a byte array into a string.","pos":[0,57]}]}],"pos":[104124,104182],"yaml":true},{"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \n  \n If the range of bytes to be decoded includes the byte order mark (BOM), and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method. You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method.  \n  \n Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","nodes":[{"pos":[0,188],"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[0,188],"nodes":[{"content":"With error detection, an invalid sequence causes this method to throw a <ph id=\"ph1\">&lt;xref:System.ArgumentException&gt;</ph>.","pos":[0,104],"source":"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>."},{"content":"Without error detection, invalid sequences are ignored, and no exception is thrown.","pos":[105,188]}]}]},{"pos":[195,516],"content":"If the range of bytes to be decoded includes the byte order mark (BOM), and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method. You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method.","nodes":[{"content":"If the range of bytes to be decoded includes the byte order mark (BOM), and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method. You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method.","pos":[0,321],"nodes":[{"content":"If the range of bytes to be decoded includes the byte order mark (BOM), and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method.","pos":[0,221]},{"content":"You can remove it by calling the <ph id=\"ph1\">&lt;xref:System.String.TrimStart%2A?displayProperty=fullName&gt;</ph> method.","pos":[222,321],"source":" You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method."}]}]},{"pos":[523,961],"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","nodes":[{"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.","pos":[0,438],"nodes":[{"content":"Data to be converted, such as data read from a stream, might be available only in sequential blocks.","pos":[0,100]},{"content":"In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <ph id=\"ph1\">&lt;xref:System.Text.Decoder&gt;</ph> or the <ph id=\"ph2\">&lt;xref:System.Text.Encoder&gt;</ph> provided by the <ph id=\"ph3\">&lt;xref:System.Text.UTF32Encoding.GetDecoder%2A&gt;</ph> method or the <ph id=\"ph4\">&lt;xref:System.Text.UTF32Encoding.GetEncoder%2A&gt;</ph> method, respectively.","pos":[101,438],"source":" In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively."}]}]}],"pos":[104193,105161],"yaml":true,"extradata":"MT"},{"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"pos":[0,58],"content":"The byte array containing the sequence of bytes to decode.","nodes":[{"content":"The byte array containing the sequence of bytes to decode.","pos":[0,58]}]}],"pos":[107057,107116],"yaml":true},{"content":"The index of the first byte to decode.","nodes":[{"pos":[0,38],"content":"The index of the first byte to decode.","nodes":[{"content":"The index of the first byte to decode.","pos":[0,38]}]}],"pos":[107176,107215],"yaml":true},{"content":"The number of bytes to decode.","nodes":[{"pos":[0,30],"content":"The number of bytes to decode.","nodes":[{"content":"The number of bytes to decode.","pos":[0,30]}]}],"pos":[107275,107306],"yaml":true},{"content":"A string that contains the results of decoding the specified sequence of bytes.","nodes":[{"pos":[0,79],"content":"A string that contains the results of decoding the specified sequence of bytes.","nodes":[{"content":"A string that contains the results of decoding the specified sequence of bytes.","pos":[0,79]}]}],"pos":[107363,107443],"yaml":true},{"content":"<code>bytes</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;bytes&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>bytes</code> is `null`."}],"pos":[107608,107638],"yaml":true},{"content":"<code>index</code> or <code>count</code> is less than zero.  \n  \n -or-  \n  \n <code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>.","nodes":[{"pos":[0,59],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> is less than zero.","source":"<code>index</code> or <code>count</code> is less than zero."},{"pos":[66,70],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[77,169],"content":"<ph id=\"ph1\">&lt;code&gt;index&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;count&lt;/code&gt;</ph> do not denote a valid range in <ph id=\"ph3\">&lt;code&gt;bytes&lt;/code&gt;</ph>.","source":"<code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>."}],"pos":[107752,107928],"yaml":true},{"content":"Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes.","nodes":[{"pos":[0,89],"content":"Error detection is enabled, and <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">bytes</ph><ept id=\"p1\">&lt;/code&gt;</ept> contains an invalid sequence of bytes.","source":"Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes."}],"pos":[108022,108112],"yaml":true},{"content":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for a complete explanation)  \n  \n -and-  \n  \n <xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>.","nodes":[{"pos":[0,145],"content":"A fallback occurred (see <bpt id=\"p1\">[</bpt>Character Encoding in the .NET Framework<ept id=\"p1\">](~/docs/standard/base-types/character-encoding.md)</ept> for a complete explanation)","source":"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for a complete explanation)"},{"pos":[152,157],"content":"-and-","nodes":[{"content":"-and-","pos":[0,5]}]},{"pos":[164,290],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Text.Encoding.DecoderFallback\"&gt;&lt;/xref&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Text.DecoderExceptionFallback\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Text.Encoding.DecoderFallback\"></xref> is set to <xref href=\"System.Text.DecoderExceptionFallback\"></xref>."}],"pos":[108230,108531],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Text.UTF32Encoding\n  commentId: T:System.Text.UTF32Encoding\n  id: UTF32Encoding\n  children:\n  - System.Text.UTF32Encoding.#ctor\n  - System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean)\n  - System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)\n  - System.Text.UTF32Encoding.Equals(System.Object)\n  - System.Text.UTF32Encoding.GetByteCount(System.String)\n  - System.Text.UTF32Encoding.GetByteCount(System.Char*,System.Int32)\n  - System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)\n  - System.Text.UTF32Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\n  - System.Text.UTF32Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\n  - System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)\n  - System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)\n  - System.Text.UTF32Encoding.GetCharCount(System.Byte*,System.Int32)\n  - System.Text.UTF32Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\n  - System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\n  - System.Text.UTF32Encoding.GetDecoder\n  - System.Text.UTF32Encoding.GetEncoder\n  - System.Text.UTF32Encoding.GetHashCode\n  - System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)\n  - System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)\n  - System.Text.UTF32Encoding.GetPreamble\n  - System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)\n  langs:\n  - csharp\n  name: UTF32Encoding\n  nameWithType: UTF32Encoding\n  fullName: System.Text.UTF32Encoding\n  type: Class\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Represents a UTF-32 encoding of Unicode characters.\n  remarks: \"Encoding is the process of transforming a set of Unicode characters into a sequence of bytes. Decoding is the process of transforming a sequence of encoded bytes into a set of Unicode characters.  \\n  \\n The [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) assigns a code point (a number) to each character in every supported script. A Unicode Transformation Format (UTF) is a way to encode that code point. The [Unicode Standard](http://go.microsoft.com/fwlink/?linkid=37123) uses the following UTFs:  \\n  \\n-   UTF-8, which represents each code point as a sequence of one to four bytes.  \\n  \\n-   UTF-16, which represents each code point as a sequence of one to two 16-bit integers.  \\n  \\n-   UTF-32, which represents each code point as a 32-bit integer.  \\n  \\n For more information about the UTFs and other encodings supported by <xref:System.Text>, see .  \\n  \\n The <xref:System.Text.UTF32Encoding> class represents a UTF-32 encoding. The encoder can use the big endian byte order (most significant byte first) or the little endian byte order (least significant byte first). For example, the Latin Capital Letter A (code point U+0041) is serialized as follows (in hexadecimal):  \\n  \\n-   Big endian byte order: 00 00 00 41  \\n  \\n-   Little endian byte order: 41 00 00 00  \\n  \\n It is generally more efficient to store Unicode characters using the native byte order. For example, it is better to use the little endian byte order on little endian platforms, such as Intel computers. <xref:System.Text.UTF32Encoding> corresponds to the Windows code pages 12000 (little endian byte order) and 12001 (big endian byte order). You can determine the \\\"endianness\\\" of a particular architecture by calling the <xref:System.BitConverter.IsLittleEndian?displayProperty=fullName> method.  \\n  \\n Optionally, the <xref:System.Text.UTF32Encoding> object provides a byte order mark (BOM), which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process. If the preamble contains a byte order mark (BOM), it helps the decoder determine the byte order and the transformation format or UTF of a byte array.  \\n  \\n If the <xref:System.Text.UTF32Encoding> instance is configured to provide a BOM, you can retrieve it by calling the <xref:System.Text.UTF32Encoding.GetPreamble%2A> method; otherwise, the method returns an empty array. Note that, even if a <xref:System.Text.UTF32Encoding> object is configured for BOM support, you must include the BOM at the beginning of the encoded byte stream as appropriate; the encoding methods of the <xref:System.Text.UTF32Encoding> class do not do this automatically.  \\n  \\n To enable error detection and to make the class instance more secure, you should instantiate a <xref:System.Text.UTF32Encoding> object by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidBytes` argument to `true`. With error detection, a method that detects an invalid sequence of characters or bytes throws an <xref:System.ArgumentException> exception. Without error detection, no exception is thrown, and the invalid sequence is generally ignored.  \\n  \\n You can instantiate a <xref:System.Text.UTF32Encoding> object in a number of ways, depending on whether you want to it to provide a byte order mark (BOM), whether you want big-endian or little-endian encoding, and whether you want to enable error detection. The following table lists the <xref:System.Text.UTF32Encoding> constructors and the <xref:System.Text.Encoding> properties that return a <xref:System.Text.UnicodeEncoding> object.  \\n  \\n|Member|Endianness|BOM|Error detection|  \\n|------------|----------------|---------|---------------------|  \\n|<xref:System.Text.Encoding.UTF32%2A?displayProperty=fullName>|Little-endian|Yes|No (Replacement fallback)|  \\n|<xref:System.Text.UTF32Encoding.%23ctor?displayProperty=fullName>|Little-endian|Yes|No (Replacement fallback)|  \\n|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%29?displayProperty=fullName>|Configurable|Configurable|No (Replacement fallback)|  \\n|<xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName>|Configurable|Configurable|Configurable|  \\n  \\n The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method determines how many bytes result in encoding a set of Unicode characters, and the <xref:System.Text.UTF32Encoding.GetBytes%2A> method performs the actual encoding.  \\n  \\n Likewise, the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method determines how many characters result in decoding a sequence of bytes, and the <xref:System.Text.UTF32Encoding.GetChars%2A> and <xref:System.Text.UTF32Encoding.GetString%2A> methods perform the actual decoding.  \\n  \\n For an encoder or decoder that is able to save state information when encoding or decoding data that spans multiple blocks (such as string of 1 million characters that is encoded in 100,000-character segments), use the <xref:System.Text.UTF32Encoding.GetEncoder%2A> and <xref:System.Text.UTF32Encoding.GetDecoder%2A> properties, respectively.\"\n  example:\n  - \"The following example demonstrates the behavior of <xref:System.Text.UTF32Encoding> objects with and without error detection enabled. It creates a byte array whose last four bytes represent an invalid surrogate pair; the high surrogate U+D8FF is followed by an U+01FF, which is outside the range of low surrogates (0xDC00 through 0xDFFF). Without error detection, the UTF32 decoder uses replacement fallback to replace the invalid surrogate pair with REPLACEMENT CHARACTER (U+FFFD).  \\n  \\n [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]\\n [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]  \\n  \\n The following example encodes a string of Unicode characters into a byte array by using a <xref:System.Text.UTF32Encoding> object. The byte array is then decoded into a string to demonstrate that there is no loss of data.  \\n  \\n [!code-csharp[System.Text.UTF32Encoding.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/snippet.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/snippet.vb#1)]  \\n  \\n The following example uses the same string as the previous one, except that it writes the encoded bytes to a file and prefixes the byte stream with a byte order mark (BOM). It then reads the file in two different ways: as a text file by using a <xref:System.IO.StreamReader> object; and as a binary file. As you would expect, in neither case is the BOM included in the newly read string.  \\n  \\n [!code-csharp[System.Text.UTF32Encoding.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.class/cs/bom1.cs#2)]\\n [!code-vb[System.Text.UTF32Encoding.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.class/vb/bom1.vb#2)]\"\n  syntax:\n    content: 'public sealed class UTF32Encoding : System.Text.Encoding'\n  inheritance:\n  - System.Object\n  - System.Text.Encoding\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  - System.Text.Encoding.ASCII\n  - System.Text.Encoding.BigEndianUnicode\n  - System.Text.Encoding.BodyName\n  - System.Text.Encoding.Clone\n  - System.Text.Encoding.CodePage\n  - System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])\n  - System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)\n  - System.Text.Encoding.DecoderFallback\n  - System.Text.Encoding.Default\n  - System.Text.Encoding.EncoderFallback\n  - System.Text.Encoding.EncodingName\n  - System.Text.Encoding.GetByteCount(System.Char[])\n  - System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)\n  - System.Text.Encoding.GetBytes(System.Char[])\n  - System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)\n  - System.Text.Encoding.GetBytes(System.String)\n  - System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)\n  - System.Text.Encoding.GetCharCount(System.Byte[])\n  - System.Text.Encoding.GetChars(System.Byte[])\n  - System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)\n  - System.Text.Encoding.GetEncoding(System.Int32)\n  - System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  - System.Text.Encoding.GetEncoding(System.String)\n  - System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  - System.Text.Encoding.GetEncodings\n  - System.Text.Encoding.GetString(System.Byte*,System.Int32)\n  - System.Text.Encoding.GetString(System.Byte[])\n  - System.Text.Encoding.HeaderName\n  - System.Text.Encoding.IsAlwaysNormalized\n  - System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)\n  - System.Text.Encoding.IsBrowserDisplay\n  - System.Text.Encoding.IsBrowserSave\n  - System.Text.Encoding.IsMailNewsDisplay\n  - System.Text.Encoding.IsMailNewsSave\n  - System.Text.Encoding.IsReadOnly\n  - System.Text.Encoding.IsSingleByte\n  - System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)\n  - System.Text.Encoding.Unicode\n  - System.Text.Encoding.UTF32\n  - System.Text.Encoding.UTF7\n  - System.Text.Encoding.UTF8\n  - System.Text.Encoding.WebName\n  - System.Text.Encoding.WindowsCodePage\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.#ctor\n  commentId: M:System.Text.UTF32Encoding.#ctor\n  id: '#ctor'\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: UTF32Encoding()\n  nameWithType: UTF32Encoding.UTF32Encoding()\n  fullName: UTF32Encoding.UTF32Encoding()\n  type: Constructor\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Initializes a new instance of the <xref href=\"System.Text.UTF32Encoding\"></xref> class.\n  remarks: \"This constructor creates an instance that uses the little endian byte order, provides a Unicode byte order mark, and does not throw an exception when an invalid encoding is detected.  \\n  \\n> [!NOTE]\\n>  For security reasons, you should enable error detection by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidCharacters` argument to `true`.\"\n  example:\n  - \"The following example retrieves and displays the byte order mark for different <xref:System.Text.UTF32Encoding> instances.  \\n  \\n [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]\\n [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]\"\n  syntax:\n    content: public UTF32Encoding ();\n    parameters: []\n  overload: System.Text.UTF32Encoding.#ctor*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean)\n  commentId: M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean)\n  id: '#ctor(System.Boolean,System.Boolean)'\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: UTF32Encoding(Boolean, Boolean)\n  nameWithType: UTF32Encoding.UTF32Encoding(Boolean, Boolean)\n  fullName: UTF32Encoding.UTF32Encoding(Boolean, Boolean)\n  type: Constructor\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Initializes a new instance of the <xref href=\"System.Text.UTF32Encoding\"></xref> class. Parameters specify whether to use the big endian byte order and whether the <xref href=\"System.Text.UTF32Encoding.GetPreamble\"></xref> method returns a Unicode Unicode byte order mark.\n  remarks: \"This constructor creates an instance that does not throw an exception when an invalid encoding is detected.  \\n  \\n> [!NOTE]\\n>  For security reasons, you should enable error detection by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidCharacters` argument to `true`.\"\n  example:\n  - \"The following example retrieves and displays the byte order mark for different <xref:System.Text.UTF32Encoding> instances.  \\n  \\n [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]\\n [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]\"\n  syntax:\n    content: public UTF32Encoding (bool bigEndian, bool byteOrderMark);\n    parameters:\n    - id: bigEndian\n      type: System.Boolean\n      description: '`true` to use the big endian byte order (most significant byte first), or `false` to use the little endian byte order (least significant byte first).'\n    - id: byteOrderMark\n      type: System.Boolean\n      description: '`true` to specify that a Unicode byte order mark is provided; otherwise, `false`.'\n  overload: System.Text.UTF32Encoding.#ctor*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)\n  commentId: M:System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)\n  id: '#ctor(System.Boolean,System.Boolean,System.Boolean)'\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: UTF32Encoding(Boolean, Boolean, Boolean)\n  nameWithType: UTF32Encoding.UTF32Encoding(Boolean, Boolean, Boolean)\n  fullName: UTF32Encoding.UTF32Encoding(Boolean, Boolean, Boolean)\n  type: Constructor\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Initializes a new instance of the <xref href=\"System.Text.UTF32Encoding\"></xref> class. Parameters specify whether to use the big endian byte order, whether to provide a Unicode byte order mark, and whether to throw an exception when an invalid encoding is detected.\n  remarks: \"If `throwOnInvalidCharacters` is `true`, a method that detects an invalid byte sequence throws <xref:System.ArgumentException?displayProperty=fullName>. Otherwise, the method does not throw an exception, and the invalid sequence is ignored.  \\n  \\n> [!NOTE]\\n>  For security reasons, you should enable error detection by calling the <xref:System.Text.UTF32Encoding.%23ctor%28System.Boolean%2CSystem.Boolean%2CSystem.Boolean%29> constructor and setting its `throwOnInvalidCharacters` argument to `true`.\"\n  example:\n  - \"The following example demonstrates the behavior of <xref:System.Text.UTF32Encoding>, both with error detection enabled and without.  \\n  \\n [!code-cpp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CPP/errordetection.cpp#1)]\\n [!code-csharp[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/CS/errordetection.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.ErrorDetection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.ErrorDetection/VB/ErrorDetection.vb#1)]\"\n  syntax:\n    content: public UTF32Encoding (bool bigEndian, bool byteOrderMark, bool throwOnInvalidCharacters);\n    parameters:\n    - id: bigEndian\n      type: System.Boolean\n      description: '`true` to use the big endian byte order (most significant byte first), or `false` to use the little endian byte order (least significant byte first).'\n    - id: byteOrderMark\n      type: System.Boolean\n      description: '`true` to specify that a Unicode byte order mark is provided; otherwise, `false`.'\n    - id: throwOnInvalidCharacters\n      type: System.Boolean\n      description: '`true` to specify that an exception should be thrown when an invalid encoding is detected; otherwise, `false`.'\n  overload: System.Text.UTF32Encoding.#ctor*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.Equals(System.Object)\n  commentId: M:System.Text.UTF32Encoding.Equals(System.Object)\n  id: Equals(System.Object)\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: Equals(Object)\n  nameWithType: UTF32Encoding.Equals(Object)\n  fullName: UTF32Encoding.Equals(Object)\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Determines whether the specified <xref href=\"System.Object\"></xref> is equal to the current <xref href=\"System.Text.UTF32Encoding\"></xref> object.\n  remarks: \"Two <xref:System.Text.UTF32Encoding> objects are considered equal if all of the following conditions are true:  \\n  \\n-   Both objects use the same byte order.  \\n  \\n-   Both objects provide the byte order mark, or both do not.  \\n  \\n-   Both objects use the same encoder fallback.  \\n  \\n-   Both objects use the same decoder fallback.\"\n  example:\n  - \"The following example creates <xref:System.Text.UTF32Encoding> objects using different parameter values and then checks them for equality.  \\n  \\n [!code-cpp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CPP/equals.cpp#1)]\\n [!code-csharp[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/CS/equals.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.Equals/VB/equals.vb#1)]\"\n  syntax:\n    content: public override bool Equals (object value);\n    parameters:\n    - id: value\n      type: System.Object\n      description: The <xref href=\"System.Object\"></xref> to compare with the current object.\n    return:\n      type: System.Boolean\n      description: '`true` if <code>value</code> is an instance of <xref href=\"System.Text.UTF32Encoding\"></xref> and is equal to the current object; otherwise, `false`.'\n  overload: System.Text.UTF32Encoding.Equals*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetByteCount(System.String)\n  commentId: M:System.Text.UTF32Encoding.GetByteCount(System.String)\n  id: GetByteCount(System.String)\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetByteCount(String)\n  nameWithType: UTF32Encoding.GetByteCount(String)\n  fullName: UTF32Encoding.GetByteCount(String)\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Calculates the number of bytes produced by encoding the characters in the specified <xref href=\"System.String\"></xref>.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \\n  \\n To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting the preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method.\"\n  example:\n  - \"The following example calls the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> and <xref:System.Text.UnicodeEncoding.GetByteCount%28System.String%29> methods to calculate the maximum and actual number of bytes required to encode a string. It also displays the actual number of bytes required to store a byte stream with a byte order mark.  \\n  \\n [!code-csharp[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount1.cs#1)]\\n [!code-vb[System.Text.Utf32Encoding.GetByteCount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount1.vb#1)]\"\n  syntax:\n    content: public override int GetByteCount (string s);\n    parameters:\n    - id: s\n      type: System.String\n      description: The <xref href=\"System.String\"></xref> containing the set of characters to encode.\n    return:\n      type: System.Int32\n      description: The number of bytes produced by encoding the specified characters.\n  overload: System.Text.UTF32Encoding.GetByteCount*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>s</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The resulting number of bytes is greater than the maximum number that can be returned as an integer.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: Error detection is enabled, and <code>s</code> contains an invalid sequence of characters.\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetByteCount(System.Char*,System.Int32)\n  commentId: M:System.Text.UTF32Encoding.GetByteCount(System.Char*,System.Int32)\n  id: GetByteCount(System.Char*,System.Int32)\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetByteCount(Char*, Int32)\n  nameWithType: UTF32Encoding.GetByteCount(Char*, Int32)\n  fullName: UTF32Encoding.GetByteCount(Char*, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Calculates the number of bytes produced by encoding a set of characters starting at the specified character pointer.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n With error detection, an invalid sequence causes this method to throw an <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \\n  \\n To ensure that the encoded bytes are decoded properly when they are saved as a file or a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      [System.Security.SecurityCritical]\n\n      public override int GetByteCount (char* chars, int count);\n    parameters:\n    - id: chars\n      type: System.Char*\n      description: A pointer to the first character to encode.\n    - id: count\n      type: System.Int32\n      description: The number of characters to encode.\n    return:\n      type: System.Int32\n      description: The number of bytes produced by encoding the specified characters.\n  overload: System.Text.UTF32Encoding.GetByteCount*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>chars</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>count</code> is less than zero.  \\n  \\n -or-  \\n  \\n The resulting number of bytes is greater than the maximum number that can be returned as an integer.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: Error detection is enabled, and <code>chars</code> contains an invalid sequence of characters.\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  attributes:\n  - type: System.CLSCompliantAttribute\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)\n  commentId: M:System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)\n  id: GetByteCount(System.Char[],System.Int32,System.Int32)\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetByteCount(Char[], Int32, Int32)\n  nameWithType: UTF32Encoding.GetByteCount(Char[], Int32, Int32)\n  fullName: UTF32Encoding.GetByteCount(Char[], Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Calculates the number of bytes produced by encoding a set of characters from the specified character array.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \\n  \\n To ensure that the encoded bytes are decoded properly when they are saved as a file or a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility, and the number of bytes in the preamble Is not reflected in the value returned by the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method.\"\n  example:\n  - \"The following example populates an array with a Latin uppercase and lowercase characters and calls the <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to determine the number of bytes needed to encode the Latin lowercase characters. It then displays this information along with the total number of bytes needed if a byte order mark is added. It compares this number with the value returned by the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method, which indicates maximum number of bytes needed to encode the Latin lowercase characters. The following example populates an array with a combination of Greek and Cyrillic characters and calls the <xref:System.Text.UnicodeEncoding.GetByteCount%28System.Char%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method to determine the number of bytes needed to encode the Cyrillic characters. It then displays this information along with the total number of bytes needed if a byte order mark is added. It compares this number with the value returned by the <xref:System.Text.UnicodeEncoding.GetMaxByteCount%2A> method, which indicates maximum number of bytes needed to encode the Cyrillic characters.  \\n  \\n [!code-csharp[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/cs/getbytecount2.cs#2)]\\n [!code-vb[System.Text.Utf32Encoding.GetByteCount#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getbytecount/vb/getbytecount2.vb#2)]\"\n  syntax:\n    content: public override int GetByteCount (char[] chars, int index, int count);\n    parameters:\n    - id: chars\n      type: System.Char[]\n      description: The character array containing the set of characters to encode.\n    - id: index\n      type: System.Int32\n      description: The index of the first character to encode.\n    - id: count\n      type: System.Int32\n      description: The number of characters to encode.\n    return:\n      type: System.Int32\n      description: The number of bytes produced by encoding the specified characters.\n  overload: System.Text.UTF32Encoding.GetByteCount*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>chars</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>index</code> or <code>count</code> is less than zero.  \\n  \\n -or-  \\n  \\n <code>index</code> and <code>count</code> do not denote a valid range in <code>chars</code>.  \\n  \\n -or-  \\n  \\n The resulting number of bytes is greater than the maximum number that can be returned as an integer.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: Error detection is enabled, and <code>chars</code> contains an invalid sequence of characters.\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\n  commentId: M:System.Text.UTF32Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\n  id: GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetBytes(Char*, Int32, Byte*, Int32)\n  nameWithType: UTF32Encoding.GetBytes(Char*, Int32, Byte*, Int32)\n  fullName: UTF32Encoding.GetBytes(Char*, Int32, Byte*, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Encodes a set of characters starting at the specified character pointer into a sequence of bytes that are stored starting at the specified byte pointer.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \\n  \\n Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.  \\n  \\n> [!NOTE]\\n>  To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility. The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      [System.Security.SecurityCritical]\n\n      public override int GetBytes (char* chars, int charCount, byte* bytes, int byteCount);\n    parameters:\n    - id: chars\n      type: System.Char*\n      description: A pointer to the first character to encode.\n    - id: charCount\n      type: System.Int32\n      description: The number of characters to encode.\n    - id: bytes\n      type: System.Byte*\n      description: A pointer to the location at which to start writing the resulting sequence of bytes.\n    - id: byteCount\n      type: System.Int32\n      description: The maximum number of bytes to write.\n    return:\n      type: System.Int32\n      description: The actual number of bytes written at the location indicated by the <code>bytes</code> parameter.\n  overload: System.Text.UTF32Encoding.GetBytes*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>chars</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>bytes</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>charCount</code> or <code>byteCount</code> is less than zero.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"Error detection is enabled, and <code>chars</code> contains an invalid sequence of characters.  \\n  \\n -or-  \\n  \\n <code>byteCount</code> is less than the resulting number of bytes.\"\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  attributes:\n  - type: System.CLSCompliantAttribute\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\n  commentId: M:System.Text.UTF32Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\n  id: GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetBytes(Char[], Int32, Int32, Byte[], Int32)\n  nameWithType: UTF32Encoding.GetBytes(Char[], Int32, Int32, Byte[], Int32)\n  fullName: UTF32Encoding.GetBytes(Char[], Int32, Int32, Byte[], Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Encodes a set of characters from the specified character array into the specified byte array.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \\n  \\n Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.  \\n  \\n> [!NOTE]\\n>  To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility. The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.\"\n  example:\n  - \"The following example determines the number of bytes required to encode three characters from a character array, then encodes the characters and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CPP/getbytes_chararr.cpp#1)]\\n [!code-csharp[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/CS/getbytes_chararr.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.GetBytes_CharArr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_CharArr/VB/GetBytes_CharArr.vb#1)]\"\n  syntax:\n    content: public override int GetBytes (char[] chars, int charIndex, int charCount, byte[] bytes, int byteIndex);\n    parameters:\n    - id: chars\n      type: System.Char[]\n      description: The character array containing the set of characters to encode.\n    - id: charIndex\n      type: System.Int32\n      description: The index of the first character to encode.\n    - id: charCount\n      type: System.Int32\n      description: The number of characters to encode.\n    - id: bytes\n      type: System.Byte[]\n      description: The byte array to contain the resulting sequence of bytes.\n    - id: byteIndex\n      type: System.Int32\n      description: The index at which to start writing the resulting sequence of bytes.\n    return:\n      type: System.Int32\n      description: The actual number of bytes written into <code>bytes</code>.\n  overload: System.Text.UTF32Encoding.GetBytes*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>chars</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>bytes</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>charIndex</code> or <code>charCount</code> or <code>byteIndex</code> is less than zero.  \\n  \\n -or-  \\n  \\n <code>charIndex</code> and <code>charCount</code> do not denote a valid range in <code>chars</code>.  \\n  \\n -or-  \\n  \\n <code>byteIndex</code> is not a valid index in <code>bytes</code>.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"Error detection is enabled, and <code>chars</code> contains an invalid sequence of characters.  \\n  \\n -or-  \\n  \\n <code>bytes</code> does not have enough capacity from <code>byteIndex</code> to the end of the array to accommodate the resulting bytes.\"\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)\n  commentId: M:System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)\n  id: GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetBytes(String, Int32, Int32, Byte[], Int32)\n  nameWithType: UTF32Encoding.GetBytes(String, Int32, Int32, Byte[], Int32)\n  fullName: UTF32Encoding.GetBytes(String, Int32, Int32, Byte[], Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Encodes a set of characters from the specified <xref href=\"System.String\"></xref> into the specified byte array.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \\n  \\n Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.  \\n  \\n> [!NOTE]\\n>  To ensure that the encoded bytes are decoded properly when they are saved as a file or as a stream, you can prefix a stream of encoded bytes with a preamble. Inserting a preamble at the beginning of a byte stream (such as at the beginning of a series of bytes to be written to a file) is the developer's responsibility. The <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a preamble to the beginning of a sequence of encoded bytes.\"\n  example:\n  - \"The following example determines the number of bytes required to encode a string, then encodes the string and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]\\n [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]\"\n  syntax:\n    content: public override int GetBytes (string s, int charIndex, int charCount, byte[] bytes, int byteIndex);\n    parameters:\n    - id: s\n      type: System.String\n      description: The <xref href=\"System.String\"></xref> containing the set of characters to encode.\n    - id: charIndex\n      type: System.Int32\n      description: The index of the first character to encode.\n    - id: charCount\n      type: System.Int32\n      description: The number of characters to encode.\n    - id: bytes\n      type: System.Byte[]\n      description: The byte array to contain the resulting sequence of bytes.\n    - id: byteIndex\n      type: System.Int32\n      description: The index at which to start writing the resulting sequence of bytes.\n    return:\n      type: System.Int32\n      description: The actual number of bytes written into <code>bytes</code>.\n  overload: System.Text.UTF32Encoding.GetBytes*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>s</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>bytes</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>charIndex</code> or <code>charCount</code> or <code>byteIndex</code> is less than zero.  \\n  \\n -or-  \\n  \\n <code>charIndex</code> and <code>charCount</code> do not denote a valid range in <code>chars</code>.  \\n  \\n -or-  \\n  \\n <code>byteIndex</code> is not a valid index in <code>bytes</code>.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"Error detection is enabled, and <code>s</code> contains an invalid sequence of characters.  \\n  \\n -or-  \\n  \\n <code>bytes</code> does not have enough capacity from <code>byteIndex</code> to the end of the array to accommodate the resulting bytes.\"\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)\n  commentId: M:System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)\n  id: GetCharCount(System.Byte[],System.Int32,System.Int32)\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetCharCount(Byte[], Int32, Int32)\n  nameWithType: UTF32Encoding.GetCharCount(Byte[], Int32, Int32)\n  fullName: UTF32Encoding.GetCharCount(Byte[], Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Calculates the number of characters produced by decoding a sequence of bytes from the specified byte array.\n  remarks: \"The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method calculates the exact array size required by the <xref:System.Text.UTF32Encoding.GetChars%2A> method to store the resulting characters. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.  \\n  \\n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.\"\n  example:\n  - \"The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.  \\n  \\n [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]\\n [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]\"\n  syntax:\n    content: public override int GetCharCount (byte[] bytes, int index, int count);\n    parameters:\n    - id: bytes\n      type: System.Byte[]\n      description: The byte array containing the sequence of bytes to decode.\n    - id: index\n      type: System.Int32\n      description: The index of the first byte to decode.\n    - id: count\n      type: System.Int32\n      description: The number of bytes to decode.\n    return:\n      type: System.Int32\n      description: The number of characters produced by decoding the specified sequence of bytes.\n  overload: System.Text.UTF32Encoding.GetCharCount*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>bytes</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>index</code> or <code>count</code> is less than zero.  \\n  \\n -or-  \\n  \\n <code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>.  \\n  \\n -or-  \\n  \\n The resulting number of bytes is greater than the maximum number that can be returned as an integer.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes.\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetCharCount(System.Byte*,System.Int32)\n  commentId: M:System.Text.UTF32Encoding.GetCharCount(System.Byte*,System.Int32)\n  id: GetCharCount(System.Byte*,System.Int32)\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetCharCount(Byte*, Int32)\n  nameWithType: UTF32Encoding.GetCharCount(Byte*, Int32)\n  fullName: UTF32Encoding.GetCharCount(Byte*, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Calculates the number of characters produced by decoding a sequence of bytes starting at the specified byte pointer.\n  remarks: \"<xref:System.Text.UTF32Encoding.GetCharCount%2A> calculates the exact array size required by the <xref:System.Text.UTF32Encoding.GetChars%2A> method to store the resulting characters. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.  \\n  \\n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      [System.Security.SecurityCritical]\n\n      public override int GetCharCount (byte* bytes, int count);\n    parameters:\n    - id: bytes\n      type: System.Byte*\n      description: A pointer to the first byte to decode.\n    - id: count\n      type: System.Int32\n      description: The number of bytes to decode.\n    return:\n      type: System.Int32\n      description: The number of characters produced by decoding the specified sequence of bytes.\n  overload: System.Text.UTF32Encoding.GetCharCount*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>bytes</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>count</code> is less than zero.  \\n  \\n -or-  \\n  \\n The resulting number of bytes is greater than the maximum number that can be returned as an integer.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes.\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  attributes:\n  - type: System.CLSCompliantAttribute\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\n  commentId: M:System.Text.UTF32Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\n  id: GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetChars(Byte*, Int32, Char*, Int32)\n  nameWithType: UTF32Encoding.GetChars(Byte*, Int32, Char*, Int32)\n  fullName: UTF32Encoding.GetChars(Byte*, Int32, Char*, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Decodes a sequence of bytes starting at the specified byte pointer into a set of characters that are stored starting at the specified character pointer.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.  \\n  \\n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \\n  \\n If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method. You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method.  \\n  \\n Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.\"\n  syntax:\n    content: >-\n      [System.CLSCompliant(false)]\n\n      [System.Security.SecurityCritical]\n\n      public override int GetChars (byte* bytes, int byteCount, char* chars, int charCount);\n    parameters:\n    - id: bytes\n      type: System.Byte*\n      description: A pointer to the first byte to decode.\n    - id: byteCount\n      type: System.Int32\n      description: The number of bytes to decode.\n    - id: chars\n      type: System.Char*\n      description: A pointer to the location at which to start writing the resulting set of characters.\n    - id: charCount\n      type: System.Int32\n      description: The maximum number of characters to write.\n    return:\n      type: System.Int32\n      description: The actual number of characters written at the location indicated by <code>chars</code>.\n  overload: System.Text.UTF32Encoding.GetChars*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>bytes</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>chars</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>byteCount</code> or <code>charCount</code> is less than zero.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes.  \\n  \\n -or-  \\n  \\n <code>charCount</code> is less than the resulting number of characters.\"\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  attributes:\n  - type: System.CLSCompliantAttribute\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\n  commentId: M:System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\n  id: GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetChars(Byte[], Int32, Int32, Char[], Int32)\n  nameWithType: UTF32Encoding.GetChars(Byte[], Int32, Int32, Char[], Int32)\n  fullName: UTF32Encoding.GetChars(Byte[], Int32, Int32, Char[], Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Decodes a sequence of bytes from the specified byte array into the specified character array.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method. To calculate the maximum array size, call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.  \\n  \\n With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \\n  \\n If the range of bytes to be decoded includes the byte order mark (BOM) and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method. You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method.  \\n  \\n Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application uses the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.\"\n  example:\n  - \"The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.  \\n  \\n [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]\\n [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]\"\n  syntax:\n    content: public override int GetChars (byte[] bytes, int byteIndex, int byteCount, char[] chars, int charIndex);\n    parameters:\n    - id: bytes\n      type: System.Byte[]\n      description: The byte array containing the sequence of bytes to decode.\n    - id: byteIndex\n      type: System.Int32\n      description: The index of the first byte to decode.\n    - id: byteCount\n      type: System.Int32\n      description: The number of bytes to decode.\n    - id: chars\n      type: System.Char[]\n      description: The character array to contain the resulting set of characters.\n    - id: charIndex\n      type: System.Int32\n      description: The index at which to start writing the resulting set of characters.\n    return:\n      type: System.Int32\n      description: The actual number of characters written into <code>chars</code>.\n  overload: System.Text.UTF32Encoding.GetChars*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>bytes</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>chars</code> is `null`.\"\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>byteIndex</code> or <code>byteCount</code> or <code>charIndex</code> is less than zero.  \\n  \\n -or-  \\n  \\n <code>byteindex</code> and <code>byteCount</code> do not denote a valid range in <code>bytes</code>.  \\n  \\n -or-  \\n  \\n <code>charIndex</code> is not a valid index in <code>chars</code>.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes.  \\n  \\n -or-  \\n  \\n <code>chars</code> does not have enough capacity from <code>charIndex</code> to the end of the array to accommodate the resulting characters.\"\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetDecoder\n  commentId: M:System.Text.UTF32Encoding.GetDecoder\n  id: GetDecoder\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetDecoder()\n  nameWithType: UTF32Encoding.GetDecoder()\n  fullName: UTF32Encoding.GetDecoder()\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Obtains a decoder that converts a UTF-32 encoded sequence of bytes into a sequence of Unicode characters.\n  remarks: \"The <xref:System.Text.Decoder.GetChars%2A?displayProperty=fullName> method converts sequential blocks of bytes into sequential blocks of characters, in a manner similar to the <xref:System.Text.UTF32Encoding.GetChars%2A> method. However, a <xref:System.Text.Decoder> maintains state information between calls so it can correctly decode byte sequences that span blocks. The <xref:System.Text.Decoder> also preserves trailing bytes at the end of data blocks and uses the trailing bytes in the next decoding operation. Therefore, <xref:System.Text.UTF32Encoding.GetDecoder%2A> and <xref:System.Text.UTF32Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.  \\n  \\n If error detection is enabled, that is, the `throwOnInvalidCharacters` parameter of the constructor was set to `true`, error detection is also enabled in the <xref:System.Text.Decoder> returned by this method. If error detection is enabled and an invalid sequence is encountered, the state of the decoder is undefined and processing must stop.\"\n  example:\n  - \"The following example uses an encoder and a decoder to encode a string into an array of bytes, and then decode the bytes into an array of characters.  \\n  \\n [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]\\n [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]\"\n  syntax:\n    content: public override System.Text.Decoder GetDecoder ();\n    parameters: []\n    return:\n      type: System.Text.Decoder\n      description: A <xref href=\"System.Text.Decoder\"></xref> that converts a UTF-32 encoded sequence of bytes into a sequence of Unicode characters.\n  overload: System.Text.UTF32Encoding.GetDecoder*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetEncoder\n  commentId: M:System.Text.UTF32Encoding.GetEncoder\n  id: GetEncoder\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetEncoder()\n  nameWithType: UTF32Encoding.GetEncoder()\n  fullName: UTF32Encoding.GetEncoder()\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Obtains an encoder that converts a sequence of Unicode characters into a UTF-32 encoded sequence of bytes.\n  remarks: \"The <xref:System.Text.Encoder.GetBytes%2A?displayProperty=fullName> method converts sequential blocks of characters into sequential blocks of bytes, in a manner similar to the <xref:System.Text.UTF32Encoding.GetBytes%2A> method. However, a <xref:System.Text.Encoder> maintains state information between calls so it can correctly encode character sequences that span blocks. The <xref:System.Text.Encoder> also preserves trailing characters at the end of data blocks and uses the trailing characters in the next encoding operation. For example, a data block might end with an unmatched high-surrogate, and the matching low-surrogate might be in the next data block. Therefore, <xref:System.Text.UTF32Encoding.GetDecoder%2A> and <xref:System.Text.UTF32Encoding.GetEncoder%2A> are useful for network transmission and file operations, because those operations often deal with blocks of data instead of a complete data stream.  \\n  \\n If error detection is enabled, that is, the `throwOnInvalidCharacters` parameter of the constructor was set to `true`, error detection is also enabled in the <xref:System.Text.Encoder> returned by this method. If error detection is enabled and an invalid sequence is encountered, the state of the encoder is undefined and processing must stop.\"\n  example:\n  - \"The following example uses an encoder and a decoder to encode a string into an array of bytes, and then decode the bytes into an array of characters.  \\n  \\n [!code-cpp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CPP/encdec.cpp#1)]\\n [!code-csharp[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/CS/encdec.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.EncDec#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.EncDec/VB/EncDec.vb#1)]\"\n  syntax:\n    content: public override System.Text.Encoder GetEncoder ();\n    parameters: []\n    return:\n      type: System.Text.Encoder\n      description: A <xref href=\"System.Text.Encoder\"></xref> that converts a sequence of Unicode characters into a UTF-32 encoded sequence of bytes.\n  overload: System.Text.UTF32Encoding.GetEncoder*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetHashCode\n  commentId: M:System.Text.UTF32Encoding.GetHashCode\n  id: GetHashCode\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetHashCode()\n  nameWithType: UTF32Encoding.GetHashCode()\n  fullName: UTF32Encoding.GetHashCode()\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Returns the hash code for the current instance.\n  syntax:\n    content: public override int GetHashCode ();\n    parameters: []\n    return:\n      type: System.Int32\n      description: The hash code for the current <xref href=\"System.Text.UTF32Encoding\"></xref> object.\n  overload: System.Text.UTF32Encoding.GetHashCode*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)\n  commentId: M:System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)\n  id: GetMaxByteCount(System.Int32)\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetMaxByteCount(Int32)\n  nameWithType: UTF32Encoding.GetMaxByteCount(Int32)\n  fullName: UTF32Encoding.GetMaxByteCount(Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Calculates the maximum number of bytes produced by encoding the specified number of characters.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetBytes%2A> to store the resulting bytes, you call the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method. The <xref:System.Text.UTF32Encoding.GetByteCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> method generally executes faster.  \\n  \\n <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> is a worst-case number, including the worst case for the currently selected <xref:System.Text.EncoderFallback>. If a fallback is chosen with a potentially large string,  <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> can return large values.  \\n  \\n In most cases, this method returns reasonable numbers for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded. You might also want to consider a different approach and use <xref:System.Text.UTF32Encoding.GetByteCount%2A> or <xref:System.Text.Encoder.Convert%2A?displayProperty=fullName>.  \\n  \\n <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A> has no relationship to <xref:System.Text.UTF32Encoding.GetChars%2A>. If you need a similar function to use with <xref:System.Text.UTF32Encoding.GetChars%2A>, use <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A>.  \\n  \\n> [!NOTE]\\n>  `GetMaxByteCount(N)` is not necessarily the same value as `N* GetMaxByteCount(1)`.\"\n  example:\n  - \"The following example determines the number of bytes required to encode a string, then encodes the string and displays the resulting bytes.  \\n  \\n [!code-cpp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CPP/getbytes_string.cpp#1)]\\n [!code-csharp[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/CS/getbytes_string.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.GetBytes_String#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetBytes_String/VB/GetBytes_String.vb#1)]\"\n  syntax:\n    content: public override int GetMaxByteCount (int charCount);\n    parameters:\n    - id: charCount\n      type: System.Int32\n      description: The number of characters to encode.\n    return:\n      type: System.Int32\n      description: The maximum number of bytes produced by encoding the specified number of characters.\n  overload: System.Text.UTF32Encoding.GetMaxByteCount*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>charCount</code> is less than zero.  \\n  \\n -or-  \\n  \\n The resulting number of bytes is greater than the maximum number that can be returned as an integer.\"\n  - type: System.Text.EncoderFallbackException\n    commentId: T:System.Text.EncoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.EncoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.EncoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)\n  commentId: M:System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)\n  id: GetMaxCharCount(System.Int32)\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetMaxCharCount(Int32)\n  nameWithType: UTF32Encoding.GetMaxCharCount(Int32)\n  fullName: UTF32Encoding.GetMaxCharCount(Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Calculates the maximum number of characters produced by decoding the specified number of bytes.\n  remarks: \"To calculate the exact array size required by <xref:System.Text.UTF32Encoding.GetChars%2A> to store the resulting characters, you call the <xref:System.Text.UTF32Encoding.GetCharCount%2A> method. To calculate the maximum array size, you call the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method. The <xref:System.Text.UTF32Encoding.GetCharCount%2A> method generally allocates less memory, while the <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> method generally executes faster.  \\n  \\n <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> is a worst-case number, including the worst case for the currently selected <xref:System.Text.DecoderFallback>. If a fallback is chosen with a potentially large string, <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> can return large values.  \\n  \\n In most cases, this method returns reasonable numbers for small strings. For large strings, you might have to choose between using very large buffers and catching errors in the rare case that a more reasonable buffer is exceeded. You might also want to consider a different approach and use <xref:System.Text.UTF32Encoding.GetCharCount%2A> or <xref:System.Text.Decoder.Convert%2A>.  \\n  \\n <xref:System.Text.UTF32Encoding.GetMaxCharCount%2A> has no relationship to <xref:System.Text.UTF32Encoding.GetBytes%2A>. If you need a similar function to use with <xref:System.Text.UTF32Encoding.GetBytes%2A>, use <xref:System.Text.UTF32Encoding.GetMaxByteCount%2A>.  \\n  \\n> [!NOTE]\\n>  `GetMaxCharCount(N)` is not necessarily the same value as `N* GetMaxCharCount(1)`.\"\n  example:\n  - \"The following example encodes a string into an array of bytes, and then decodes the bytes into an array of characters.  \\n  \\n [!code-cpp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CPP/getchars.cpp#1)]\\n [!code-csharp[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/CS/getchars.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.GetChars#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetChars/VB/GetChars.vb#1)]\"\n  syntax:\n    content: public override int GetMaxCharCount (int byteCount);\n    parameters:\n    - id: byteCount\n      type: System.Int32\n      description: The number of bytes to decode.\n    return:\n      type: System.Int32\n      description: The maximum number of characters produced by decoding the specified number of bytes.\n  overload: System.Text.UTF32Encoding.GetMaxCharCount*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>byteCount</code> is less than zero.  \\n  \\n -or-  \\n  \\n The resulting number of bytes is greater than the maximum number that can be returned as an integer.\"\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetPreamble\n  commentId: M:System.Text.UTF32Encoding.GetPreamble\n  id: GetPreamble\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetPreamble()\n  nameWithType: UTF32Encoding.GetPreamble()\n  fullName: UTF32Encoding.GetPreamble()\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Returns a Unicode byte order mark encoded in UTF-32 format, if the <xref href=\"System.Text.UTF32Encoding\"></xref> object is configured to supply one.\n  remarks: \"The <xref:System.Text.UTF32Encoding> object can provide a preamble, which is an array of bytes that can be prefixed to the sequence of bytes resulting from the encoding process. Prefacing a sequence of encoded bytes with a byte order mark (code points U+0000 U+FEFF) helps the decoder determine the byte order and the transformation format, or UTF. The Unicode byte order mark (BOM) is serialized as follows (in hexadecimal):  \\n  \\n-   Big endian byte order: 00 00 FE FF  \\n  \\n-   Little endian byte order: FF FE 00 00  \\n  \\n You can instantiate a <xref:System.Text.UTF32Encoding> object whose <xref:System.Text.UTF32Encoding.GetPreamble%2A> method returns a valid BOM in the following ways:  \\n  \\n-   By retrieving the <xref:System.Text.UTF32Encoding> object returned by the <xref:System.Text.Encoding.UTF32%2A?displayProperty=fullName> property.  \\n  \\n-   By calling the parameterless <xref:System.Text.UTF32Encoding.%23ctor> constructor to instantiate a <xref:System.Text.UTF32Encoding> object.  \\n  \\n-   By supplying `true` as the value of the `byteOrderMark` argument to the <xref:System.Text.UTF32Encoding.%23ctor%2A> and <xref:System.Text.UTF32Encoding.%23ctor%2A> constructors.  \\n  \\n We recommend that you use the BOM, since it provides nearly certain identification of an encoding for files that otherwise have lost reference to the <xref:System.Text.UTF32Encoding> object, for example, untagged or improperly tagged web data, or random text files stored when a business did not have international concerns or other data. Often, user problems might be avoided if data is consistently and properly tagged.  \\n  \\n For standards that provide an encoding type, a BOM is somewhat redundant. However, it can be used to help a server send the correct encoding header. Alternatively, it can be used as a fallback in case the encoding is otherwise lost.  \\n  \\n There are some disadvantages to using a BOM. For example, knowing how to limit the database fields that use a BOM can be difficult. Concatenation of files can be a problem also, for example, when files are merged in such a way that an unnecessary character can end up in the middle of data. In spite of the few disadvantages, however, the use of a BOM is highly recommended.  \\n  \\n For more information on byte order and the byte order mark, see The Unicode Standard at the [Unicode home page](http://go.microsoft.com/fwlink/?LinkId=37123).  \\n  \\n> [!CAUTION]\\n>  To ensure that the encoded bytes are decoded properly, you should prefix encoded bytes with a preamble. Note that the <xref:System.Text.UTF32Encoding.GetBytes%2A> method does not prepend a BOM to a sequence of encoded bytes; supplying a BOM at the beginning of an appropriate byte stream is the developer's responsibility.\"\n  example:\n  - \"The following code example retrieves and displays the byte order mark for different <xref:System.Text.UTF32Encoding> instances.  \\n  \\n [!code-cpp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CPP/getpreamble.cpp#1)]\\n [!code-csharp[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.GetPreamble#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/GetPreamble.vb#1)]  \\n  \\n The following example instantiates two <xref:System.Text.UTF32Encoding> objects, the first of which does not provide a BOM and the second of which does. It then calls the <xref:System.Text.UTF32Encoding.GetPreamble%2A> method to write the BOM to a file before writing a UTF-32-encoded string. As the output from the example shows, the file that saves the bytes from the second encoder has four more bytes that the first.  \\n  \\n [!code-csharp[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/CS/getpreamble1.cs#2)]\\n [!code-vb[System.Text.UTF32Encoding.GetPreamble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Text.UTF32Encoding.GetPreamble/VB/getpreamble1.vb#2)]  \\n  \\n You can also compare the files by using the `fc` command in a console window, or you can inspect the files in a text editor that includes a Hex View mode. Note that when the file is opened in an editor that supports UTF-32, the BOM is not displayed.\"\n  syntax:\n    content: public override byte[] GetPreamble ();\n    parameters: []\n    return:\n      type: System.Byte[]\n      description: A byte array containing the Unicode byte order mark, if the <xref href=\"System.Text.UTF32Encoding\"></xref> object is configured to supply one. Otherwise, this method returns a zero-length byte array.\n  overload: System.Text.UTF32Encoding.GetPreamble*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)\n  commentId: M:System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)\n  id: GetString(System.Byte[],System.Int32,System.Int32)\n  parent: System.Text.UTF32Encoding\n  langs:\n  - csharp\n  name: GetString(Byte[], Int32, Int32)\n  nameWithType: UTF32Encoding.GetString(Byte[], Int32, Int32)\n  fullName: UTF32Encoding.GetString(Byte[], Int32, Int32)\n  type: Method\n  assemblies:\n  - System.Text.Encoding.Extensions\n  - mscorlib\n  - netstandard\n  namespace: System.Text\n  summary: Decodes a range of bytes from a byte array into a string.\n  remarks: \"With error detection, an invalid sequence causes this method to throw a <xref:System.ArgumentException>. Without error detection, invalid sequences are ignored, and no exception is thrown.  \\n  \\n If the range of bytes to be decoded includes the byte order mark (BOM), and the byte array was returned by a method of a non-BOM aware type, the character U+FFFE is included in the character array returned by this method. You can remove it by calling the <xref:System.String.TrimStart%2A?displayProperty=fullName> method.  \\n  \\n Data to be converted, such as data read from a stream, might be available only in sequential blocks. In this case, or if the amount of data is so large that it needs to be divided into smaller blocks, the application should use the <xref:System.Text.Decoder> or the <xref:System.Text.Encoder> provided by the <xref:System.Text.UTF32Encoding.GetDecoder%2A> method or the <xref:System.Text.UTF32Encoding.GetEncoder%2A> method, respectively.\"\n  example:\n  - \"The following example encodes a string into two arrays arrays of bytes, one in little-endian order and the other in big-endian order. It then decodes the bytes back into a string.  \\n  \\n [!code-csharp[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/getstring.cs#1)]\\n [!code-vb[System.Text.UTF32Encoding.GetString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString.vb#1)]  \\n  \\n The following example initializes an array by calling the <xref:System.Text.UTF32Encoding.GetByteCount%2A> method to determine exactly how many bytes are required for an encoded string and then adding the size of the byte order mark (BOM). The example then calls the <xref:System.Text.UTF32Encoding.GetPreamble%2A> method to store the BOM to the array before calling the <xref:System.Text.UTF32Encoding.GetBytes%2A> method to store the encoded bytes to the array. The example then calls the <xref:System.Text.UTF32Encoding.GetString%2A> method to decode the string.  \\n  \\n [!code-csharp[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/CS/GetString1.cs#2)]\\n [!code-vb[System.Text.UTF32Encoding.GetString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.text.utf32encoding.getstring/VB/GetString1.vb#2)]  \\n  \\n Note that in this case the decoded string differs from the original string, since it begins with a 32-bit byte order mark U+FFFE U+0000. This means that the two strings will compare as unequal, and that if the string is output, the BOM will be displayed as the replacement character \\\"?\\\".\"\n  syntax:\n    content: public override string GetString (byte[] bytes, int index, int count);\n    parameters:\n    - id: bytes\n      type: System.Byte[]\n      description: The byte array containing the sequence of bytes to decode.\n    - id: index\n      type: System.Int32\n      description: The index of the first byte to decode.\n    - id: count\n      type: System.Int32\n      description: The number of bytes to decode.\n    return:\n      type: System.String\n      description: A string that contains the results of decoding the specified sequence of bytes.\n  overload: System.Text.UTF32Encoding.GetString*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>bytes</code> is `null`.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"<code>index</code> or <code>count</code> is less than zero.  \\n  \\n -or-  \\n  \\n <code>index</code> and <code>count</code> do not denote a valid range in <code>bytes</code>.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: Error detection is enabled, and <code>bytes</code> contains an invalid sequence of bytes.\n  - type: System.Text.DecoderFallbackException\n    commentId: T:System.Text.DecoderFallbackException\n    description: \"A fallback occurred (see [Character Encoding in the .NET Framework](~/docs/standard/base-types/character-encoding.md) for a complete explanation)  \\n  \\n -and-  \\n  \\n <xref href=\\\"System.Text.Encoding.DecoderFallback\\\"></xref> is set to <xref href=\\\"System.Text.DecoderExceptionFallback\\\"></xref>.\"\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Text.Encoding\n  parent: System.Text\n  isExternal: false\n  name: Encoding\n  nameWithType: Encoding\n  fullName: System.Text.Encoding\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.ArgumentException\n  parent: System\n  isExternal: false\n  name: ArgumentException\n  nameWithType: ArgumentException\n  fullName: System.ArgumentException\n- uid: System.Text.EncoderFallbackException\n  parent: System.Text\n  isExternal: false\n  name: EncoderFallbackException\n  nameWithType: EncoderFallbackException\n  fullName: System.Text.EncoderFallbackException\n- uid: System.Text.DecoderFallbackException\n  parent: System.Text\n  isExternal: false\n  name: DecoderFallbackException\n  nameWithType: DecoderFallbackException\n  fullName: System.Text.DecoderFallbackException\n- uid: System.Text.UTF32Encoding.#ctor\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: UTF32Encoding()\n  nameWithType: UTF32Encoding.UTF32Encoding()\n  fullName: UTF32Encoding.UTF32Encoding()\n- uid: System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: UTF32Encoding(Boolean, Boolean)\n  nameWithType: UTF32Encoding.UTF32Encoding(Boolean, Boolean)\n  fullName: UTF32Encoding.UTF32Encoding(Boolean, Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Text.UTF32Encoding.#ctor(System.Boolean,System.Boolean,System.Boolean)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: UTF32Encoding(Boolean, Boolean, Boolean)\n  nameWithType: UTF32Encoding.UTF32Encoding(Boolean, Boolean, Boolean)\n  fullName: UTF32Encoding.UTF32Encoding(Boolean, Boolean, Boolean)\n- uid: System.Text.UTF32Encoding.Equals(System.Object)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: UTF32Encoding.Equals(Object)\n  fullName: UTF32Encoding.Equals(Object)\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.Text.UTF32Encoding.GetByteCount(System.String)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetByteCount(String)\n  nameWithType: UTF32Encoding.GetByteCount(String)\n  fullName: UTF32Encoding.GetByteCount(String)\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.String\n  parent: System\n  isExternal: false\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.Text.UTF32Encoding.GetByteCount(System.Char*,System.Int32)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetByteCount(Char*, Int32)\n  nameWithType: UTF32Encoding.GetByteCount(Char*, Int32)\n  fullName: UTF32Encoding.GetByteCount(Char*, Int32)\n- uid: System.Char\n  name: Char\n  nameWithType: Char\n  fullName: System.Char\n- uid: System.Char*\n  parent: System\n  isExternal: false\n  name: Char*\n  nameWithType: Char*\n  fullName: System.Char*\n  spec.csharp:\n  - uid: System.Char\n    name: Char\n    nameWithType: Char\n    fullName: System.Char\n  - name: '*'\n    nameWithType: '*'\n    fullName: '*'\n- uid: System.Text.UTF32Encoding.GetByteCount(System.Char[],System.Int32,System.Int32)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetByteCount(Char[], Int32, Int32)\n  nameWithType: UTF32Encoding.GetByteCount(Char[], Int32, Int32)\n  fullName: UTF32Encoding.GetByteCount(Char[], Int32, Int32)\n- uid: System.Char[]\n  parent: System\n  isExternal: false\n  name: Char[]\n  nameWithType: Char[]\n  fullName: System.Char[]\n  spec.csharp:\n  - uid: System.Char\n    name: Char\n    nameWithType: Char\n    fullName: System.Char\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Text.UTF32Encoding.GetBytes(System.Char*,System.Int32,System.Byte*,System.Int32)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetBytes(Char*, Int32, Byte*, Int32)\n  nameWithType: UTF32Encoding.GetBytes(Char*, Int32, Byte*, Int32)\n  fullName: UTF32Encoding.GetBytes(Char*, Int32, Byte*, Int32)\n- uid: System.Byte\n  name: Byte\n  nameWithType: Byte\n  fullName: System.Byte\n- uid: System.Byte*\n  parent: System\n  isExternal: false\n  name: Byte*\n  nameWithType: Byte*\n  fullName: System.Byte*\n  spec.csharp:\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: System.Byte\n  - name: '*'\n    nameWithType: '*'\n    fullName: '*'\n- uid: System.Text.UTF32Encoding.GetBytes(System.Char[],System.Int32,System.Int32,System.Byte[],System.Int32)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetBytes(Char[], Int32, Int32, Byte[], Int32)\n  nameWithType: UTF32Encoding.GetBytes(Char[], Int32, Int32, Byte[], Int32)\n  fullName: UTF32Encoding.GetBytes(Char[], Int32, Int32, Byte[], Int32)\n- uid: System.Byte[]\n  parent: System\n  isExternal: false\n  name: Byte[]\n  nameWithType: Byte[]\n  fullName: System.Byte[]\n  spec.csharp:\n  - uid: System.Byte\n    name: Byte\n    nameWithType: Byte\n    fullName: System.Byte\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Text.UTF32Encoding.GetBytes(System.String,System.Int32,System.Int32,System.Byte[],System.Int32)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetBytes(String, Int32, Int32, Byte[], Int32)\n  nameWithType: UTF32Encoding.GetBytes(String, Int32, Int32, Byte[], Int32)\n  fullName: UTF32Encoding.GetBytes(String, Int32, Int32, Byte[], Int32)\n- uid: System.Text.UTF32Encoding.GetCharCount(System.Byte[],System.Int32,System.Int32)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetCharCount(Byte[], Int32, Int32)\n  nameWithType: UTF32Encoding.GetCharCount(Byte[], Int32, Int32)\n  fullName: UTF32Encoding.GetCharCount(Byte[], Int32, Int32)\n- uid: System.Text.UTF32Encoding.GetCharCount(System.Byte*,System.Int32)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetCharCount(Byte*, Int32)\n  nameWithType: UTF32Encoding.GetCharCount(Byte*, Int32)\n  fullName: UTF32Encoding.GetCharCount(Byte*, Int32)\n- uid: System.Text.UTF32Encoding.GetChars(System.Byte*,System.Int32,System.Char*,System.Int32)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetChars(Byte*, Int32, Char*, Int32)\n  nameWithType: UTF32Encoding.GetChars(Byte*, Int32, Char*, Int32)\n  fullName: UTF32Encoding.GetChars(Byte*, Int32, Char*, Int32)\n- uid: System.Text.UTF32Encoding.GetChars(System.Byte[],System.Int32,System.Int32,System.Char[],System.Int32)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetChars(Byte[], Int32, Int32, Char[], Int32)\n  nameWithType: UTF32Encoding.GetChars(Byte[], Int32, Int32, Char[], Int32)\n  fullName: UTF32Encoding.GetChars(Byte[], Int32, Int32, Char[], Int32)\n- uid: System.Text.UTF32Encoding.GetDecoder\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetDecoder()\n  nameWithType: UTF32Encoding.GetDecoder()\n  fullName: UTF32Encoding.GetDecoder()\n- uid: System.Text.Decoder\n  parent: System.Text\n  isExternal: false\n  name: Decoder\n  nameWithType: Decoder\n  fullName: System.Text.Decoder\n- uid: System.Text.UTF32Encoding.GetEncoder\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetEncoder()\n  nameWithType: UTF32Encoding.GetEncoder()\n  fullName: UTF32Encoding.GetEncoder()\n- uid: System.Text.Encoder\n  parent: System.Text\n  isExternal: false\n  name: Encoder\n  nameWithType: Encoder\n  fullName: System.Text.Encoder\n- uid: System.Text.UTF32Encoding.GetHashCode\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: UTF32Encoding.GetHashCode()\n  fullName: UTF32Encoding.GetHashCode()\n- uid: System.Text.UTF32Encoding.GetMaxByteCount(System.Int32)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetMaxByteCount(Int32)\n  nameWithType: UTF32Encoding.GetMaxByteCount(Int32)\n  fullName: UTF32Encoding.GetMaxByteCount(Int32)\n- uid: System.Text.UTF32Encoding.GetMaxCharCount(System.Int32)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetMaxCharCount(Int32)\n  nameWithType: UTF32Encoding.GetMaxCharCount(Int32)\n  fullName: UTF32Encoding.GetMaxCharCount(Int32)\n- uid: System.Text.UTF32Encoding.GetPreamble\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetPreamble()\n  nameWithType: UTF32Encoding.GetPreamble()\n  fullName: UTF32Encoding.GetPreamble()\n- uid: System.Text.UTF32Encoding.GetString(System.Byte[],System.Int32,System.Int32)\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetString(Byte[], Int32, Int32)\n  nameWithType: UTF32Encoding.GetString(Byte[], Int32, Int32)\n  fullName: UTF32Encoding.GetString(Byte[], Int32, Int32)\n- uid: System.Text.UTF32Encoding.#ctor*\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: UTF32Encoding\n  nameWithType: UTF32Encoding.UTF32Encoding\n  fullName: UTF32Encoding.UTF32Encoding\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n- uid: System.Text.UTF32Encoding.Equals*\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: Equals\n  nameWithType: UTF32Encoding.Equals\n  fullName: UTF32Encoding.Equals\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n- uid: System.Text.UTF32Encoding.GetByteCount*\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetByteCount\n  nameWithType: UTF32Encoding.GetByteCount\n  fullName: UTF32Encoding.GetByteCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n- uid: System.Text.UTF32Encoding.GetBytes*\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetBytes\n  nameWithType: UTF32Encoding.GetBytes\n  fullName: UTF32Encoding.GetBytes\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n- uid: System.Text.UTF32Encoding.GetCharCount*\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetCharCount\n  nameWithType: UTF32Encoding.GetCharCount\n  fullName: UTF32Encoding.GetCharCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n- uid: System.Text.UTF32Encoding.GetChars*\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetChars\n  nameWithType: UTF32Encoding.GetChars\n  fullName: UTF32Encoding.GetChars\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n- uid: System.Text.UTF32Encoding.GetDecoder*\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetDecoder\n  nameWithType: UTF32Encoding.GetDecoder\n  fullName: UTF32Encoding.GetDecoder\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n- uid: System.Text.UTF32Encoding.GetEncoder*\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetEncoder\n  nameWithType: UTF32Encoding.GetEncoder\n  fullName: UTF32Encoding.GetEncoder\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n- uid: System.Text.UTF32Encoding.GetHashCode*\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetHashCode\n  nameWithType: UTF32Encoding.GetHashCode\n  fullName: UTF32Encoding.GetHashCode\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n- uid: System.Text.UTF32Encoding.GetMaxByteCount*\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetMaxByteCount\n  nameWithType: UTF32Encoding.GetMaxByteCount\n  fullName: UTF32Encoding.GetMaxByteCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n- uid: System.Text.UTF32Encoding.GetMaxCharCount*\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetMaxCharCount\n  nameWithType: UTF32Encoding.GetMaxCharCount\n  fullName: UTF32Encoding.GetMaxCharCount\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n- uid: System.Text.UTF32Encoding.GetPreamble*\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetPreamble\n  nameWithType: UTF32Encoding.GetPreamble\n  fullName: UTF32Encoding.GetPreamble\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n- uid: System.Text.UTF32Encoding.GetString*\n  parent: System.Text.UTF32Encoding\n  isExternal: false\n  name: GetString\n  nameWithType: UTF32Encoding.GetString\n  fullName: UTF32Encoding.GetString\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Text/UTF32Encoding.xml\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.Text.Encoding.ASCII\n  parent: System.Text.Encoding\n  isExternal: false\n  name: ASCII\n  nameWithType: Encoding.ASCII\n  fullName: Encoding.ASCII\n- uid: System.Text.Encoding.BigEndianUnicode\n  parent: System.Text.Encoding\n  isExternal: false\n  name: BigEndianUnicode\n  nameWithType: Encoding.BigEndianUnicode\n  fullName: Encoding.BigEndianUnicode\n- uid: System.Text.Encoding.BodyName\n  parent: System.Text.Encoding\n  isExternal: false\n  name: BodyName\n  nameWithType: Encoding.BodyName\n  fullName: Encoding.BodyName\n- uid: System.Text.Encoding.Clone\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Clone()\n  nameWithType: Encoding.Clone()\n  fullName: Encoding.Clone()\n- uid: System.Text.Encoding.CodePage\n  parent: System.Text.Encoding\n  isExternal: false\n  name: CodePage\n  nameWithType: Encoding.CodePage\n  fullName: Encoding.CodePage\n- uid: System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Convert(Encoding, Encoding, Byte[], Int32, Int32)\n  nameWithType: Encoding.Convert(Encoding, Encoding, Byte[], Int32, Int32)\n  fullName: Encoding.Convert(Encoding, Encoding, Byte[], Int32, Int32)\n- uid: System.Text.Encoding.Convert(System.Text.Encoding,System.Text.Encoding,System.Byte[])\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Convert(Encoding, Encoding, Byte[])\n  nameWithType: Encoding.Convert(Encoding, Encoding, Byte[])\n  fullName: Encoding.Convert(Encoding, Encoding, Byte[])\n- uid: System.Text.Encoding.DecoderFallback\n  parent: System.Text.Encoding\n  isExternal: false\n  name: DecoderFallback\n  nameWithType: Encoding.DecoderFallback\n  fullName: Encoding.DecoderFallback\n- uid: System.Text.Encoding.Default\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Default\n  nameWithType: Encoding.Default\n  fullName: Encoding.Default\n- uid: System.Text.Encoding.EncoderFallback\n  parent: System.Text.Encoding\n  isExternal: false\n  name: EncoderFallback\n  nameWithType: Encoding.EncoderFallback\n  fullName: Encoding.EncoderFallback\n- uid: System.Text.Encoding.EncodingName\n  parent: System.Text.Encoding\n  isExternal: false\n  name: EncodingName\n  nameWithType: Encoding.EncodingName\n  fullName: Encoding.EncodingName\n- uid: System.Text.Encoding.GetByteCount(System.String,System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetByteCount(String, Int32, Int32)\n  nameWithType: Encoding.GetByteCount(String, Int32, Int32)\n  fullName: Encoding.GetByteCount(String, Int32, Int32)\n- uid: System.Text.Encoding.GetByteCount(System.Char[])\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetByteCount(Char[])\n  nameWithType: Encoding.GetByteCount(Char[])\n  fullName: Encoding.GetByteCount(Char[])\n- uid: System.Text.Encoding.GetBytes(System.Char[])\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetBytes(Char[])\n  nameWithType: Encoding.GetBytes(Char[])\n  fullName: Encoding.GetBytes(Char[])\n- uid: System.Text.Encoding.GetBytes(System.String)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetBytes(String)\n  nameWithType: Encoding.GetBytes(String)\n  fullName: Encoding.GetBytes(String)\n- uid: System.Text.Encoding.GetBytes(System.Char[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetBytes(Char[], Int32, Int32)\n  nameWithType: Encoding.GetBytes(Char[], Int32, Int32)\n  fullName: Encoding.GetBytes(Char[], Int32, Int32)\n- uid: System.Text.Encoding.GetBytes(System.String,System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetBytes(String, Int32, Int32)\n  nameWithType: Encoding.GetBytes(String, Int32, Int32)\n  fullName: Encoding.GetBytes(String, Int32, Int32)\n- uid: System.Text.Encoding.GetCharCount(System.Byte[])\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetCharCount(Byte[])\n  nameWithType: Encoding.GetCharCount(Byte[])\n  fullName: Encoding.GetCharCount(Byte[])\n- uid: System.Text.Encoding.GetChars(System.Byte[],System.Int32,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetChars(Byte[], Int32, Int32)\n  nameWithType: Encoding.GetChars(Byte[], Int32, Int32)\n  fullName: Encoding.GetChars(Byte[], Int32, Int32)\n- uid: System.Text.Encoding.GetChars(System.Byte[])\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetChars(Byte[])\n  nameWithType: Encoding.GetChars(Byte[])\n  fullName: Encoding.GetChars(Byte[])\n- uid: System.Text.Encoding.GetEncoding(System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetEncoding(Int32)\n  nameWithType: Encoding.GetEncoding(Int32)\n  fullName: Encoding.GetEncoding(Int32)\n- uid: System.Text.Encoding.GetEncoding(System.String)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetEncoding(String)\n  nameWithType: Encoding.GetEncoding(String)\n  fullName: Encoding.GetEncoding(String)\n- uid: System.Text.Encoding.GetEncoding(System.Int32,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetEncoding(Int32, EncoderFallback, DecoderFallback)\n  nameWithType: Encoding.GetEncoding(Int32, EncoderFallback, DecoderFallback)\n  fullName: Encoding.GetEncoding(Int32, EncoderFallback, DecoderFallback)\n- uid: System.Text.Encoding.GetEncoding(System.String,System.Text.EncoderFallback,System.Text.DecoderFallback)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetEncoding(String, EncoderFallback, DecoderFallback)\n  nameWithType: Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)\n  fullName: Encoding.GetEncoding(String, EncoderFallback, DecoderFallback)\n- uid: System.Text.Encoding.GetEncodings\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetEncodings()\n  nameWithType: Encoding.GetEncodings()\n  fullName: Encoding.GetEncodings()\n- uid: System.Text.Encoding.GetString(System.Byte[])\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetString(Byte[])\n  nameWithType: Encoding.GetString(Byte[])\n  fullName: Encoding.GetString(Byte[])\n- uid: System.Text.Encoding.GetString(System.Byte*,System.Int32)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: GetString(Byte*, Int32)\n  nameWithType: Encoding.GetString(Byte*, Int32)\n  fullName: Encoding.GetString(Byte*, Int32)\n- uid: System.Text.Encoding.HeaderName\n  parent: System.Text.Encoding\n  isExternal: false\n  name: HeaderName\n  nameWithType: Encoding.HeaderName\n  fullName: Encoding.HeaderName\n- uid: System.Text.Encoding.IsAlwaysNormalized\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsAlwaysNormalized()\n  nameWithType: Encoding.IsAlwaysNormalized()\n  fullName: Encoding.IsAlwaysNormalized()\n- uid: System.Text.Encoding.IsAlwaysNormalized(System.Text.NormalizationForm)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsAlwaysNormalized(NormalizationForm)\n  nameWithType: Encoding.IsAlwaysNormalized(NormalizationForm)\n  fullName: Encoding.IsAlwaysNormalized(NormalizationForm)\n- uid: System.Text.Encoding.IsBrowserDisplay\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsBrowserDisplay\n  nameWithType: Encoding.IsBrowserDisplay\n  fullName: Encoding.IsBrowserDisplay\n- uid: System.Text.Encoding.IsBrowserSave\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsBrowserSave\n  nameWithType: Encoding.IsBrowserSave\n  fullName: Encoding.IsBrowserSave\n- uid: System.Text.Encoding.IsMailNewsDisplay\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsMailNewsDisplay\n  nameWithType: Encoding.IsMailNewsDisplay\n  fullName: Encoding.IsMailNewsDisplay\n- uid: System.Text.Encoding.IsMailNewsSave\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsMailNewsSave\n  nameWithType: Encoding.IsMailNewsSave\n  fullName: Encoding.IsMailNewsSave\n- uid: System.Text.Encoding.IsReadOnly\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsReadOnly\n  nameWithType: Encoding.IsReadOnly\n  fullName: Encoding.IsReadOnly\n- uid: System.Text.Encoding.IsSingleByte\n  parent: System.Text.Encoding\n  isExternal: false\n  name: IsSingleByte\n  nameWithType: Encoding.IsSingleByte\n  fullName: Encoding.IsSingleByte\n- uid: System.Text.Encoding.RegisterProvider(System.Text.EncodingProvider)\n  parent: System.Text.Encoding\n  isExternal: false\n  name: RegisterProvider(EncodingProvider)\n  nameWithType: Encoding.RegisterProvider(EncodingProvider)\n  fullName: Encoding.RegisterProvider(EncodingProvider)\n- uid: System.Text.Encoding.Unicode\n  parent: System.Text.Encoding\n  isExternal: false\n  name: Unicode\n  nameWithType: Encoding.Unicode\n  fullName: Encoding.Unicode\n- uid: System.Text.Encoding.UTF32\n  parent: System.Text.Encoding\n  isExternal: false\n  name: UTF32\n  nameWithType: Encoding.UTF32\n  fullName: Encoding.UTF32\n- uid: System.Text.Encoding.UTF7\n  parent: System.Text.Encoding\n  isExternal: false\n  name: UTF7\n  nameWithType: Encoding.UTF7\n  fullName: Encoding.UTF7\n- uid: System.Text.Encoding.UTF8\n  parent: System.Text.Encoding\n  isExternal: false\n  name: UTF8\n  nameWithType: Encoding.UTF8\n  fullName: Encoding.UTF8\n- uid: System.Text.Encoding.WebName\n  parent: System.Text.Encoding\n  isExternal: false\n  name: WebName\n  nameWithType: Encoding.WebName\n  fullName: Encoding.WebName\n- uid: System.Text.Encoding.WindowsCodePage\n  parent: System.Text.Encoding\n  isExternal: false\n  name: WindowsCodePage\n  nameWithType: Encoding.WindowsCodePage\n  fullName: Encoding.WindowsCodePage\n"}