{"nodes":[{"content":"Provides a <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref> that can be written to and updated.","nodes":[{"pos":[0,109],"content":"Provides a <ph id=\"ph1\">&lt;xref href=\"System.Windows.Media.Imaging.BitmapSource\"&gt;&lt;/xref&gt;</ph> that can be written to and updated.","source":"Provides a <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref> that can be written to and updated."}],"pos":[2294,2404],"yaml":true},{"content":"Use the <xref:System.Windows.Media.Imaging.WriteableBitmap> class to update and render a bitmap on a per-frame basis. This is useful for generating algorithmic content, such as a fractal image, and for data visualization, such as a music visualizer.  \n  \n The <xref:System.Windows.Media.Imaging.WriteableBitmap> class uses two buffers. The *back buffer* is allocated in system memory and accumulates content that is not currently displayed. The *front buffer* is allocated in system memory and contains the content that is currently displayed. The rendering system copies the front buffer to video memory for display.  \n  \n Two threads use these buffers. The *user interface (UI) thread* generates the UI but does not present it to the screen. The UI thread responds to user input, timers, and other events. An application can have multiple UI threads. The *render thread* composes and renders changes from the UI thread. There is only one render thread per application.  \n  \n The UI thread writes content to the back buffer. The render thread reads content from the front buffer and copies it to video memory. Changes to the back buffer are tracked with changed rectangular regions.  \n  \n Call one of the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> overloads to update and display content in the back buffer automatically.  \n  \n For greater control over updates, and for multi-threaded access to the back buffer, use the following workflow.  \n  \n1.  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method to reserve the back buffer for updates.  \n  \n2.  Obtain a pointer to the back buffer by accessing the <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> property.  \n  \n3.  Write changes to the back buffer. Other threads may write changes to the back buffer when the <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked.  \n  \n4.  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method to indicate areas that have changed.  \n  \n5.  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method to release the back buffer and allow presentation to the screen.  \n  \n When updates are sent to the rendering thread, the rendering thread copies the changed rectangles from the back buffer to the front buffer. The rendering system controls this exchange to avoid deadlocks and redraw artifacts, such as \"tearing\".","nodes":[{"pos":[0,249],"content":"Use the <xref:System.Windows.Media.Imaging.WriteableBitmap> class to update and render a bitmap on a per-frame basis. This is useful for generating algorithmic content, such as a fractal image, and for data visualization, such as a music visualizer.","nodes":[{"content":"Use the <xref:System.Windows.Media.Imaging.WriteableBitmap> class to update and render a bitmap on a per-frame basis. This is useful for generating algorithmic content, such as a fractal image, and for data visualization, such as a music visualizer.","pos":[0,249],"nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt;</ph> class to update and render a bitmap on a per-frame basis.","pos":[0,117],"source":"Use the <xref:System.Windows.Media.Imaging.WriteableBitmap> class to update and render a bitmap on a per-frame basis."},{"content":"This is useful for generating algorithmic content, such as a fractal image, and for data visualization, such as a music visualizer.","pos":[118,249]}]}]},{"pos":[256,617],"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap> class uses two buffers. The *back buffer* is allocated in system memory and accumulates content that is not currently displayed. The *front buffer* is allocated in system memory and contains the content that is currently displayed. The rendering system copies the front buffer to video memory for display.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt;</ph> class uses two buffers.","pos":[0,79],"source":"The <xref:System.Windows.Media.Imaging.WriteableBitmap> class uses two buffers."},{"content":"The <bpt id=\"p1\">*</bpt>back buffer<ept id=\"p1\">*</ept> is allocated in system memory and accumulates content that is not currently displayed.","pos":[80,184],"source":" The *back buffer* is allocated in system memory and accumulates content that is not currently displayed."},{"content":"The <bpt id=\"p1\">*</bpt>front buffer<ept id=\"p1\">*</ept> is allocated in system memory and contains the content that is currently displayed.","pos":[185,287],"source":" The *front buffer* is allocated in system memory and contains the content that is currently displayed."},{"content":"The rendering system copies the front buffer to video memory for display.","pos":[288,361]}]},{"pos":[624,970],"content":"Two threads use these buffers. The *user interface (UI) thread* generates the UI but does not present it to the screen. The UI thread responds to user input, timers, and other events. An application can have multiple UI threads. The *render thread* composes and renders changes from the UI thread. There is only one render thread per application.","nodes":[{"content":"Two threads use these buffers.","pos":[0,30]},{"content":"The <bpt id=\"p1\">*</bpt>user interface (UI) thread<ept id=\"p1\">*</ept> generates the UI but does not present it to the screen.","pos":[31,119],"source":" The *user interface (UI) thread* generates the UI but does not present it to the screen."},{"content":"The UI thread responds to user input, timers, and other events.","pos":[120,183]},{"content":"An application can have multiple UI threads.","pos":[184,228]},{"content":"The <bpt id=\"p1\">*</bpt>render thread<ept id=\"p1\">*</ept> composes and renders changes from the UI thread.","pos":[229,297],"source":" The *render thread* composes and renders changes from the UI thread."},{"content":"There is only one render thread per application.","pos":[298,346]}]},{"pos":[977,1183],"content":"The UI thread writes content to the back buffer. The render thread reads content from the front buffer and copies it to video memory. Changes to the back buffer are tracked with changed rectangular regions.","nodes":[{"content":"The UI thread writes content to the back buffer. The render thread reads content from the front buffer and copies it to video memory. Changes to the back buffer are tracked with changed rectangular regions.","pos":[0,206],"nodes":[{"content":"The UI thread writes content to the back buffer.","pos":[0,48]},{"content":"The render thread reads content from the front buffer and copies it to video memory.","pos":[49,133]},{"content":"Changes to the back buffer are tracked with changed rectangular regions.","pos":[134,206]}]}]},{"pos":[1190,1346],"content":"Call one of the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> overloads to update and display content in the back buffer automatically.","nodes":[{"content":"Call one of the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A&gt;</ph> overloads to update and display content in the back buffer automatically.","pos":[0,156],"source":"Call one of the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> overloads to update and display content in the back buffer automatically."}]},{"pos":[1353,1464],"content":"For greater control over updates, and for multi-threaded access to the back buffer, use the following workflow.","nodes":[{"content":"For greater control over updates, and for multi-threaded access to the back buffer, use the following workflow.","pos":[0,111]}]},{"pos":[1474,1589],"content":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method to reserve the back buffer for updates.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A&gt;</ph> method to reserve the back buffer for updates.","pos":[0,115],"source":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method to reserve the back buffer for updates."}]},{"pos":[1599,1727],"content":"Obtain a pointer to the back buffer by accessing the <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> property.","nodes":[{"content":"Obtain a pointer to the back buffer by accessing the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A&gt;</ph> property.","pos":[0,128],"source":"Obtain a pointer to the back buffer by accessing the <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> property."}]},{"pos":[1737,1893],"content":"Write changes to the back buffer. Other threads may write changes to the back buffer when the <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked.","nodes":[{"content":"Write changes to the back buffer. Other threads may write changes to the back buffer when the <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked.","pos":[0,156],"nodes":[{"content":"Write changes to the back buffer.","pos":[0,33]},{"content":"Other threads may write changes to the back buffer when the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt;</ph> is locked.","pos":[34,156],"source":" Other threads may write changes to the back buffer when the <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked."}]}]},{"pos":[1903,2023],"content":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method to indicate areas that have changed.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A&gt;</ph> method to indicate areas that have changed.","pos":[0,120],"source":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method to indicate areas that have changed."}]},{"pos":[2033,2175],"content":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method to release the back buffer and allow presentation to the screen.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt;</ph> method to release the back buffer and allow presentation to the screen.","pos":[0,142],"source":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method to release the back buffer and allow presentation to the screen."}]},{"pos":[2182,2425],"content":"When updates are sent to the rendering thread, the rendering thread copies the changed rectangles from the back buffer to the front buffer. The rendering system controls this exchange to avoid deadlocks and redraw artifacts, such as \"tearing\".","nodes":[{"content":"When updates are sent to the rendering thread, the rendering thread copies the changed rectangles from the back buffer to the front buffer. The rendering system controls this exchange to avoid deadlocks and redraw artifacts, such as \"tearing\".","pos":[0,243],"nodes":[{"content":"When updates are sent to the rendering thread, the rendering thread copies the changed rectangles from the back buffer to the front buffer.","pos":[0,139]},{"content":"The rendering system controls this exchange to avoid deadlocks and redraw artifacts, such as \"tearing\".","pos":[140,243]}]}]}],"pos":[2415,4867],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> class using the given <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref>.","nodes":[{"pos":[0,185],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;&lt;/xref&gt;</ph> class using the given <ph id=\"ph2\">&lt;xref href=\"System.Windows.Media.Imaging.BitmapSource\"&gt;&lt;/xref&gt;</ph>.","source":"Initializes a new instance of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> class using the given <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref>."}],"pos":[12122,12308],"yaml":true},{"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29> constructor is preferred over using this constructor.  \n  \n If `source` does not use a natively supported bitmap format, format conversions are applied for each frame update, which reduces performance.","nodes":[{"pos":[0,262],"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29> constructor is preferred over using this constructor.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29&gt;</ph> constructor is preferred over using this constructor.","pos":[0,262],"source":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29> constructor is preferred over using this constructor."}]},{"pos":[269,410],"content":"If <ph id=\"ph1\">`source`</ph> does not use a natively supported bitmap format, format conversions are applied for each frame update, which reduces performance.","source":"If `source` does not use a natively supported bitmap format, format conversions are applied for each frame update, which reduces performance."}],"pos":[12319,12734],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref> to use for initialization.","nodes":[{"pos":[0,93],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Windows.Media.Imaging.BitmapSource\"&gt;&lt;/xref&gt;</ph> to use for initialization.","source":"The <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref> to use for initialization."}],"pos":[12989,13083],"yaml":true},{"content":"Initializes a new instance of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> class with the specified parameters.","nodes":[{"pos":[0,136],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;&lt;/xref&gt;</ph> class with the specified parameters.","source":"Initializes a new instance of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> class with the specified parameters."}],"pos":[14773,14910],"yaml":true},{"content":"The preferred values for `pixelFormat` are <xref:System.Windows.Media.PixelFormats.Bgr32%2A> and <xref:System.Windows.Media.PixelFormats.Pbgra32%2A>. These formats are natively supported and do not require a format conversion. Other `pixelFormat` values require a format conversion for each frame update, which reduces performance.","nodes":[{"pos":[0,331],"content":"The preferred values for `pixelFormat` are <xref:System.Windows.Media.PixelFormats.Bgr32%2A> and <xref:System.Windows.Media.PixelFormats.Pbgra32%2A>. These formats are natively supported and do not require a format conversion. Other `pixelFormat` values require a format conversion for each frame update, which reduces performance.","nodes":[{"content":"The preferred values for <ph id=\"ph1\">`pixelFormat`</ph> are <ph id=\"ph2\">&lt;xref:System.Windows.Media.PixelFormats.Bgr32%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Windows.Media.PixelFormats.Pbgra32%2A&gt;</ph>.","pos":[0,149],"source":"The preferred values for `pixelFormat` are <xref:System.Windows.Media.PixelFormats.Bgr32%2A> and <xref:System.Windows.Media.PixelFormats.Pbgra32%2A>."},{"content":"These formats are natively supported and do not require a format conversion.","pos":[150,226]},{"content":"Other <ph id=\"ph1\">`pixelFormat`</ph> values require a format conversion for each frame update, which reduces performance.","pos":[227,331],"source":" Other `pixelFormat` values require a format conversion for each frame update, which reduces performance."}]}],"pos":[14921,15253],"yaml":true,"extradata":"MT"},{"content":"The desired width of the bitmap.","nodes":[{"pos":[0,32],"content":"The desired width of the bitmap.","nodes":[{"content":"The desired width of the bitmap.","pos":[0,32]}]}],"pos":[15590,15623],"yaml":true},{"content":"The desired height of the bitmap.","nodes":[{"pos":[0,33],"content":"The desired height of the bitmap.","nodes":[{"content":"The desired height of the bitmap.","pos":[0,33]}]}],"pos":[15689,15723],"yaml":true},{"content":"The horizontal [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] of the bitmap.","nodes":[{"pos":[0,87],"content":"The horizontal <ph id=\"ph1\">[!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)]</ph> of the bitmap.","source":"The horizontal [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] of the bitmap."}],"pos":[15783,15871],"yaml":true},{"content":"The vertical [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] of the bitmap.","nodes":[{"pos":[0,85],"content":"The vertical <ph id=\"ph1\">[!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)]</ph> of the bitmap.","source":"The vertical [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] of the bitmap."}],"pos":[15931,16017],"yaml":true},{"content":"The <xref href=\"System.Windows.Media.PixelFormat\"></xref> of the bitmap.","nodes":[{"pos":[0,72],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Windows.Media.PixelFormat\"&gt;&lt;/xref&gt;</ph> of the bitmap.","source":"The <xref href=\"System.Windows.Media.PixelFormat\"></xref> of the bitmap."}],"pos":[16103,16176],"yaml":true},{"content":"The <xref href=\"System.Windows.Media.Imaging.BitmapPalette\"></xref> of the bitmap.","nodes":[{"pos":[0,82],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Windows.Media.Imaging.BitmapPalette\"&gt;&lt;/xref&gt;</ph> of the bitmap.","source":"The <xref href=\"System.Windows.Media.Imaging.BitmapPalette\"></xref> of the bitmap."}],"pos":[16268,16351],"yaml":true},{"content":"Specifies the area of the bitmap that changed.","nodes":[{"pos":[0,46],"content":"Specifies the area of the bitmap that changed.","nodes":[{"content":"Specifies the area of the bitmap that changed.","pos":[0,46]}]}],"pos":[17590,17637],"yaml":true},{"content":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method to indicate changes your code has made to the back buffer.  \n  \n When you call this method multiple times, the changed areas are accumulated in a sufficient, but not necessarily minimal, representation. For efficiency, only the areas that are marked as dirty are guaranteed to be copied forward to the front buffer. However, any portion of the bitmap may be copied forward, so you must ensure that the entire back buffer is always valid.  \n  \n Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods, as described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.","nodes":[{"pos":[0,142],"content":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method to indicate changes your code has made to the back buffer.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A&gt;</ph> method to indicate changes your code has made to the back buffer.","pos":[0,142],"source":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method to indicate changes your code has made to the back buffer."}]},{"pos":[149,521],"content":"When you call this method multiple times, the changed areas are accumulated in a sufficient, but not necessarily minimal, representation. For efficiency, only the areas that are marked as dirty are guaranteed to be copied forward to the front buffer. However, any portion of the bitmap may be copied forward, so you must ensure that the entire back buffer is always valid.","nodes":[{"content":"When you call this method multiple times, the changed areas are accumulated in a sufficient, but not necessarily minimal, representation. For efficiency, only the areas that are marked as dirty are guaranteed to be copied forward to the front buffer. However, any portion of the bitmap may be copied forward, so you must ensure that the entire back buffer is always valid.","pos":[0,372],"nodes":[{"content":"When you call this method multiple times, the changed areas are accumulated in a sufficient, but not necessarily minimal, representation.","pos":[0,137]},{"content":"For efficiency, only the areas that are marked as dirty are guaranteed to be copied forward to the front buffer.","pos":[138,250]},{"content":"However, any portion of the bitmap may be copied forward, so you must ensure that the entire back buffer is always valid.","pos":[251,372]}]}]},{"pos":[528,859],"content":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods, as described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A&gt;</ph> method only between calls to the <ph id=\"ph2\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt;</ph> methods, as described in the <ph id=\"ph4\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt;</ph> class remarks.","pos":[0,331],"source":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods, as described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks."}]}],"pos":[17648,18514],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Windows.Int32Rect\"></xref> representing the area that changed. Dimensions are in pixels.","nodes":[{"pos":[0,110],"content":"An <xref href=\"System.Windows.Int32Rect\"></xref> representing the area that changed. Dimensions are in pixels.","nodes":[{"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Windows.Int32Rect\"&gt;&lt;/xref&gt;</ph> representing the area that changed.","pos":[0,84],"source":"An <xref href=\"System.Windows.Int32Rect\"></xref> representing the area that changed."},{"content":"Dimensions are in pixels.","pos":[85,110]}]}],"pos":[19057,19168],"yaml":true},{"content":"The bitmap has not been locked by a call to the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap.Lock\"></xref> or <xref href=\"System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\"></xref> methods.","nodes":[{"pos":[0,229],"content":"The bitmap has not been locked by a call to the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap.Lock\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\"&gt;&lt;/xref&gt;</ph> methods.","source":"The bitmap has not been locked by a call to the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap.Lock\"></xref> or <xref href=\"System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\"></xref> methods."}],"pos":[19363,19593],"yaml":true},{"content":"<code>dirtyRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.","nodes":[{"pos":[0,121],"content":"<ph id=\"ph1\">&lt;code&gt;dirtyRect&lt;/code&gt;</ph> falls outside the bounds of the <ph id=\"ph2\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;&lt;/xref&gt;</ph>.","source":"<code>dirtyRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>."}],"pos":[19707,19829],"yaml":true},{"content":"Gets a pointer to the back buffer.","nodes":[{"pos":[0,34],"content":"Gets a pointer to the back buffer.","nodes":[{"content":"Gets a pointer to the back buffer.","pos":[0,34]}]}],"pos":[20866,20901],"yaml":true},{"content":"The back buffer contains the bitmap contents in the pixel format requested by the user.  \n  \n Update the back buffer only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods. If you do not follow the Lock/Unlock workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks, undefined behaviors, such as tearing, can occur.  \n  \n The address of the back buffer does not change.  \n  \n## Thread Safety  \n You can pass the <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> pointer to external components and other threads for processing, but if you do, you must provide you own thread coordination. In particular, you must ensure that the UI thread specifies changed areas by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method, and that the UI thread unlocks the buffer by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.","nodes":[{"pos":[0,87],"content":"The back buffer contains the bitmap contents in the pixel format requested by the user.","nodes":[{"content":"The back buffer contains the bitmap contents in the pixel format requested by the user.","pos":[0,87]}]},{"pos":[94,456],"content":"Update the back buffer only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods. If you do not follow the Lock/Unlock workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks, undefined behaviors, such as tearing, can occur.","nodes":[{"content":"Update the back buffer only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods. If you do not follow the Lock/Unlock workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks, undefined behaviors, such as tearing, can occur.","pos":[0,362],"nodes":[{"content":"Update the back buffer only between calls to the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt;</ph> methods.","pos":[0,183],"source":"Update the back buffer only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods."},{"content":"If you do not follow the Lock/Unlock workflow described in the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt;</ph> class remarks, undefined behaviors, such as tearing, can occur.","pos":[184,362],"source":" If you do not follow the Lock/Unlock workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks, undefined behaviors, such as tearing, can occur."}]}]},{"pos":[463,510],"content":"The address of the back buffer does not change.","nodes":[{"content":"The address of the back buffer does not change.","pos":[0,47]}]},{"pos":[519,532],"content":"Thread Safety","linkify":"Thread Safety","nodes":[{"content":"Thread Safety","pos":[0,13]}]},{"pos":[536,1036],"content":"You can pass the <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> pointer to external components and other threads for processing, but if you do, you must provide you own thread coordination. In particular, you must ensure that the UI thread specifies changed areas by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method, and that the UI thread unlocks the buffer by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.","nodes":[{"content":"You can pass the <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> pointer to external components and other threads for processing, but if you do, you must provide you own thread coordination. In particular, you must ensure that the UI thread specifies changed areas by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method, and that the UI thread unlocks the buffer by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.","pos":[0,500],"nodes":[{"content":"You can pass the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A&gt;</ph> pointer to external components and other threads for processing, but if you do, you must provide you own thread coordination.","pos":[0,208],"source":"You can pass the <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> pointer to external components and other threads for processing, but if you do, you must provide you own thread coordination."},{"content":"In particular, you must ensure that the UI thread specifies changed areas by calling the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A&gt;</ph> method, and that the UI thread unlocks the buffer by calling the <ph id=\"ph2\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt;</ph> method.","pos":[209,500],"source":" In particular, you must ensure that the UI thread specifies changed areas by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method, and that the UI thread unlocks the buffer by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method."}]}]}],"pos":[20912,21958],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.IntPtr\"></xref> that points to the base address of the back buffer.","nodes":[{"pos":[0,89],"content":"An <ph id=\"ph1\">&lt;xref href=\"System.IntPtr\"&gt;&lt;/xref&gt;</ph> that points to the base address of the back buffer.","source":"An <xref href=\"System.IntPtr\"></xref> that points to the base address of the back buffer."}],"pos":[22175,22265],"yaml":true},{"content":"Gets a value indicating the number of bytes in a single row of pixel data.","nodes":[{"pos":[0,74],"content":"Gets a value indicating the number of bytes in a single row of pixel data.","nodes":[{"content":"Gets a value indicating the number of bytes in a single row of pixel data.","pos":[0,74]}]}],"pos":[23472,23547],"yaml":true},{"content":"An integer indicating the number of bytes in a single row of pixel data.","nodes":[{"pos":[0,72],"content":"An integer indicating the number of bytes in a single row of pixel data.","nodes":[{"content":"An integer indicating the number of bytes in a single row of pixel data.","pos":[0,72]}]}],"pos":[23663,23736],"yaml":true},{"content":"Creates a modifiable clone of this <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>, making deep copies of this object's values. When copying dependency properties, this method copies resource references and data bindings (but they might no longer resolve) but not animations or their current values.","nodes":[{"pos":[0,317],"content":"Creates a modifiable clone of this <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>, making deep copies of this object's values. When copying dependency properties, this method copies resource references and data bindings (but they might no longer resolve) but not animations or their current values.","nodes":[{"content":"Creates a modifiable clone of this <ph id=\"ph1\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;&lt;/xref&gt;</ph>, making deep copies of this object's values.","pos":[0,145],"source":"Creates a modifiable clone of this <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>, making deep copies of this object's values."},{"content":"When copying dependency properties, this method copies resource references and data bindings (but they might no longer resolve) but not animations or their current values.","pos":[146,317]}]}],"pos":[24773,25091],"yaml":true},{"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.  \n  \n For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>.","nodes":[{"pos":[0,244],"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.","nodes":[{"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.","pos":[0,244],"nodes":[{"content":"This method is used to produce modifiable copies of frozen <ph id=\"ph1\">&lt;xref:System.Windows.Freezable&gt;</ph> objects (or any <ph id=\"ph2\">&lt;xref:System.Windows.Freezable&gt;</ph> object).","pos":[0,147],"source":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object)."},{"content":"For convenience, this method shadows the inherited version with a strongly typed implementation.","pos":[148,244]}]}]},{"pos":[251,343],"content":"For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>.","nodes":[{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName&gt;</ph>.","pos":[0,92],"source":"For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>."}]}],"pos":[25102,25450],"yaml":true,"extradata":"MT"},{"content":"A modifiable clone of the current object. The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true.`","nodes":[{"pos":[0,238],"content":"A modifiable clone of the current object. The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true.`","nodes":[{"content":"A modifiable clone of the current object.","pos":[0,41]},{"content":"The cloned object's <ph id=\"ph1\">&lt;xref href=\"System.Windows.Freezable.IsFrozen\"&gt;&lt;/xref&gt;</ph> property will be <ph id=\"ph2\">`false`</ph> even if the source's <ph id=\"ph3\">&lt;xref href=\"System.Windows.Freezable.IsFrozen\"&gt;&lt;/xref&gt;</ph> property was <ph id=\"ph4\">`true.`</ph>","pos":[42,238],"source":" The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true.`"}]}],"pos":[25642,25881],"yaml":true},{"content":"Creates a modifiable clone of this <xref href=\"System.Windows.Media.Animation.ByteAnimationUsingKeyFrames\"></xref> object, making deep copies of this object's current values. Resource references, data bindings, and animations are not copied, but their current values are.","nodes":[{"pos":[0,271],"content":"Creates a modifiable clone of this <xref href=\"System.Windows.Media.Animation.ByteAnimationUsingKeyFrames\"></xref> object, making deep copies of this object's current values. Resource references, data bindings, and animations are not copied, but their current values are.","nodes":[{"content":"Creates a modifiable clone of this <ph id=\"ph1\">&lt;xref href=\"System.Windows.Media.Animation.ByteAnimationUsingKeyFrames\"&gt;&lt;/xref&gt;</ph> object, making deep copies of this object's current values.","pos":[0,174],"source":"Creates a modifiable clone of this <xref href=\"System.Windows.Media.Animation.ByteAnimationUsingKeyFrames\"></xref> object, making deep copies of this object's current values."},{"content":"Resource references, data bindings, and animations are not copied, but their current values are.","pos":[175,271]}]}],"pos":[28455,28727],"yaml":true},{"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.  \n  \n For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>.","nodes":[{"pos":[0,244],"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.","nodes":[{"content":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.","pos":[0,244],"nodes":[{"content":"This method is used to produce modifiable copies of frozen <ph id=\"ph1\">&lt;xref:System.Windows.Freezable&gt;</ph> objects (or any <ph id=\"ph2\">&lt;xref:System.Windows.Freezable&gt;</ph> object).","pos":[0,147],"source":"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object)."},{"content":"For convenience, this method shadows the inherited version with a strongly typed implementation.","pos":[148,244]}]}]},{"pos":[251,355],"content":"For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>.","nodes":[{"content":"For more information, see <ph id=\"ph1\">&lt;xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName&gt;</ph>.","pos":[0,104],"source":"For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>."}]}],"pos":[28738,29098],"yaml":true,"extradata":"MT"},{"content":"A modifiable clone of the current object. The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true`.","nodes":[{"pos":[0,238],"content":"A modifiable clone of the current object. The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true`.","nodes":[{"content":"A modifiable clone of the current object.","pos":[0,41]},{"content":"The cloned object's <ph id=\"ph1\">&lt;xref href=\"System.Windows.Freezable.IsFrozen\"&gt;&lt;/xref&gt;</ph> property will be <ph id=\"ph2\">`false`</ph> even if the source's <ph id=\"ph3\">&lt;xref href=\"System.Windows.Freezable.IsFrozen\"&gt;&lt;/xref&gt;</ph> property was <ph id=\"ph4\">`true`</ph>.","pos":[42,238],"source":" The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true`."}]}],"pos":[29302,29541],"yaml":true},{"content":"Reserves the back buffer for updates.","nodes":[{"pos":[0,37],"content":"Reserves the back buffer for updates.","nodes":[{"content":"Reserves the back buffer for updates.","pos":[0,37]}]}],"pos":[37953,37991],"yaml":true},{"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method increments the lock count. When a <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked, the rendering system does not send updates until the <xref:System.Windows.Media.Imaging.WriteableBitmap> is fully unlocked by calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.  \n  \n You can use the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method to support multi-threaded implementations. In these scenarios, the UI thread locks the bitmap and exposes the back buffer to other threads. When the worker thread has finished a frame, the UI thread adds changed rectangles and unlocks the buffer.  \n  \n The UI thread can block when the render thread acquires a lock on the back buffer to copy it forward to the front buffer. If the latency from this block is too long, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method to wait for a short time and then unblock the UI thread to perform other tasks while the back buffer is locked.","nodes":[{"pos":[0,376],"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method increments the lock count. When a <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked, the rendering system does not send updates until the <xref:System.Windows.Media.Imaging.WriteableBitmap> is fully unlocked by calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.","nodes":[{"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method increments the lock count. When a <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked, the rendering system does not send updates until the <xref:System.Windows.Media.Imaging.WriteableBitmap> is fully unlocked by calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.","pos":[0,376],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A&gt;</ph> method increments the lock count.","pos":[0,97],"source":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method increments the lock count."},{"content":"When a <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt;</ph> is locked, the rendering system does not send updates until the <ph id=\"ph2\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt;</ph> is fully unlocked by calls to the <ph id=\"ph3\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt;</ph> method.","pos":[98,376],"source":" When a <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked, the rendering system does not send updates until the <xref:System.Windows.Media.Imaging.WriteableBitmap> is fully unlocked by calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method."}]}]},{"pos":[383,712],"content":"You can use the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method to support multi-threaded implementations. In these scenarios, the UI thread locks the bitmap and exposes the back buffer to other threads. When the worker thread has finished a frame, the UI thread adds changed rectangles and unlocks the buffer.","nodes":[{"content":"You can use the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method to support multi-threaded implementations. In these scenarios, the UI thread locks the bitmap and exposes the back buffer to other threads. When the worker thread has finished a frame, the UI thread adds changed rectangles and unlocks the buffer.","pos":[0,329],"nodes":[{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A&gt;</ph> method to support multi-threaded implementations.","pos":[0,125],"source":"You can use the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method to support multi-threaded implementations."},{"content":"In these scenarios, the UI thread locks the bitmap and exposes the back buffer to other threads.","pos":[126,222]},{"content":"When the worker thread has finished a frame, the UI thread adds changed rectangles and unlocks the buffer.","pos":[223,329]}]}]},{"pos":[719,1074],"content":"The UI thread can block when the render thread acquires a lock on the back buffer to copy it forward to the front buffer. If the latency from this block is too long, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method to wait for a short time and then unblock the UI thread to perform other tasks while the back buffer is locked.","nodes":[{"content":"The UI thread can block when the render thread acquires a lock on the back buffer to copy it forward to the front buffer. If the latency from this block is too long, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method to wait for a short time and then unblock the UI thread to perform other tasks while the back buffer is locked.","pos":[0,355],"nodes":[{"content":"The UI thread can block when the render thread acquires a lock on the back buffer to copy it forward to the front buffer.","pos":[0,121]},{"content":"If the latency from this block is too long, use the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A&gt;</ph> method to wait for a short time and then unblock the UI thread to perform other tasks while the back buffer is locked.","pos":[122,355],"source":" If the latency from this block is too long, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method to wait for a short time and then unblock the UI thread to perform other tasks while the back buffer is locked."}]}]}],"pos":[38002,39083],"yaml":true,"extradata":"MT"},{"content":"Attempts to lock the bitmap, waiting for no longer than the specified length of time.","nodes":[{"pos":[0,85],"content":"Attempts to lock the bitmap, waiting for no longer than the specified length of time.","nodes":[{"content":"Attempts to lock the bitmap, waiting for no longer than the specified length of time.","pos":[0,85]}]}],"pos":[40563,40649],"yaml":true},{"content":"When a lock is acquired, the behavior of the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method is the same as the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method.","nodes":[{"pos":[0,201],"content":"When a lock is acquired, the behavior of the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method is the same as the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method.","nodes":[{"content":"When a lock is acquired, the behavior of the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A&gt;</ph> method is the same as the <ph id=\"ph2\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A&gt;</ph> method.","pos":[0,201],"source":"When a lock is acquired, the behavior of the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method is the same as the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method."}]}],"pos":[40660,40862],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Windows.Duration\"></xref> that represents the length of time to wait. A value of 0 returns immediately. A value of <xref href=\"System.Windows.Duration.Forever\"></xref> blocks indefinitely.","nodes":[{"pos":[0,209],"content":"A <xref href=\"System.Windows.Duration\"></xref> that represents the length of time to wait. A value of 0 returns immediately. A value of <xref href=\"System.Windows.Duration.Forever\"></xref> blocks indefinitely.","nodes":[{"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Windows.Duration\"&gt;&lt;/xref&gt;</ph> that represents the length of time to wait.","pos":[0,90],"source":"A <xref href=\"System.Windows.Duration\"></xref> that represents the length of time to wait."},{"content":"A value of 0 returns immediately.","pos":[91,124]},{"content":"A value of <ph id=\"ph1\">&lt;xref href=\"System.Windows.Duration.Forever\"&gt;&lt;/xref&gt;</ph> blocks indefinitely.","pos":[125,209],"source":" A value of <xref href=\"System.Windows.Duration.Forever\"></xref> blocks indefinitely."}]}],"pos":[41080,41290],"yaml":true},{"content":"`true` if the lock was acquired; otherwise, `false`.","nodes":[{"pos":[0,52],"content":"<ph id=\"ph1\">`true`</ph> if the lock was acquired; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the lock was acquired; otherwise, `false`."}],"pos":[41348,41403],"yaml":true},{"content":"<code>timeout</code> is set to <xref href=\"System.Windows.Duration.Automatic\"></xref>.","nodes":[{"pos":[0,86],"content":"<ph id=\"ph1\">&lt;code&gt;timeout&lt;/code&gt;</ph> is set to <ph id=\"ph2\">&lt;xref href=\"System.Windows.Duration.Automatic\"&gt;&lt;/xref&gt;</ph>.","source":"<code>timeout</code> is set to <xref href=\"System.Windows.Duration.Automatic\"></xref>."}],"pos":[41597,41684],"yaml":true},{"content":"Releases the back buffer to make it available for display.","nodes":[{"pos":[0,58],"content":"Releases the back buffer to make it available for display.","nodes":[{"content":"Releases the back buffer to make it available for display.","pos":[0,58]}]}],"pos":[42701,42760],"yaml":true},{"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method decrements the lock count. When the lock count reaches 0, a render pass is requested if the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method has been called.","nodes":[{"pos":[0,256],"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method decrements the lock count. When the lock count reaches 0, a render pass is requested if the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method has been called.","nodes":[{"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method decrements the lock count. When the lock count reaches 0, a render pass is requested if the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method has been called.","pos":[0,256],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt;</ph> method decrements the lock count.","pos":[0,99],"source":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method decrements the lock count."},{"content":"When the lock count reaches 0, a render pass is requested if the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A&gt;</ph> method has been called.","pos":[100,256],"source":" When the lock count reaches 0, a render pass is requested if the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method has been called."}]}]}],"pos":[42771,43028],"yaml":true,"extradata":"MT"},{"content":"The bitmap has not been locked by a call to the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap.Lock\"></xref> or <xref href=\"System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\"></xref> methods.","nodes":[{"pos":[0,229],"content":"The bitmap has not been locked by a call to the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap.Lock\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\"&gt;&lt;/xref&gt;</ph> methods.","source":"The bitmap has not been locked by a call to the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap.Lock\"></xref> or <xref href=\"System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\"></xref> methods."}],"pos":[43616,43846],"yaml":true},{"content":"Updates the pixels in the specified region of the bitmap.","nodes":[{"pos":[0,57],"content":"Updates the pixels in the specified region of the bitmap.","nodes":[{"content":"Updates the pixels in the specified region of the bitmap.","pos":[0,57]}]}],"pos":[45178,45236],"yaml":true},{"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method.  \n  \n> [!NOTE]\n>  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.","nodes":[{"pos":[0,379],"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overloads are preferred over using this method.","pos":[0,379],"source":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method."}]},{"pos":[387,587],"content":"[!NOTE]\n In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.","leadings":["","> "],"nodes":[{"content":"In partial trust, use the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload.","pos":[9,198],"source":" In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload."}]}],"pos":[45247,45840],"yaml":true,"extradata":"MT"},{"content":"The rectangle of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> to update.","nodes":[{"pos":[0,97],"content":"The rectangle of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;&lt;/xref&gt;</ph> to update.","source":"The rectangle of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> to update."}],"pos":[46406,46504],"yaml":true},{"content":"The pixel array used to update the bitmap.","nodes":[{"pos":[0,42],"content":"The pixel array used to update the bitmap.","nodes":[{"content":"The pixel array used to update the bitmap.","pos":[0,42]}]}],"pos":[46565,46608],"yaml":true},{"content":"The stride of the update region in <code>pixels</code>.","nodes":[{"pos":[0,55],"content":"The stride of the update region in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">pixels</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The stride of the update region in <code>pixels</code>."}],"pos":[46669,46725],"yaml":true},{"content":"The input buffer offset.","nodes":[{"pos":[0,24],"content":"The input buffer offset.","nodes":[{"content":"The input buffer offset.","pos":[0,24]}]}],"pos":[46786,46811],"yaml":true},{"content":"One or more of the following conditions is true.  \n  \n <code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.  \n  \n <code>stride</code> < 1  \n  \n <code>offset</code> < 0","nodes":[{"pos":[0,48],"content":"One or more of the following conditions is true.","nodes":[{"content":"One or more of the following conditions is true.","pos":[0,48]}]},{"pos":[55,238],"content":"<code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.  \n  \n <code>stride</code> < 1  \n  \n <code>offset</code> < 0","nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;sourceRect&lt;/code&gt;</ph> falls outside the bounds of the <ph id=\"ph2\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;&lt;/xref&gt;</ph>.","pos":[0,122],"source":"<code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>."},{"content":"<ph id=\"ph1\">&lt;code&gt;stride&lt;/code&gt;</ph> &lt; 1  <ph id=\"ph2\">&lt;code&gt;offset&lt;/code&gt;</ph> &lt; 0","pos":[129,182],"source":"<code>stride</code> < 1  \n  \n <code>offset</code> < 0"}]}],"pos":[47009,47257],"yaml":true},{"content":"<code>pixels</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;pixels&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>pixels</code> is `null`."}],"pos":[47359,47390],"yaml":true},{"content":"<code>pixels</code> has a rank other than 1 or 2, or its length is less than or equal to 0.","nodes":[{"pos":[0,91],"content":"<ph id=\"ph1\">&lt;code&gt;pixels&lt;/code&gt;</ph> has a rank other than 1 or 2, or its length is less than or equal to 0.","source":"<code>pixels</code> has a rank other than 1 or 2, or its length is less than or equal to 0."}],"pos":[47484,47576],"yaml":true},{"content":"Updates the pixels in the specified region of the bitmap.","nodes":[{"pos":[0,57],"content":"Updates the pixels in the specified region of the bitmap.","nodes":[{"content":"Updates the pixels in the specified region of the bitmap.","pos":[0,57]}]}],"pos":[48914,48972],"yaml":true},{"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method.  \n  \n> [!NOTE]\n>  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.","nodes":[{"pos":[0,379],"content":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overloads are preferred over using this method.","pos":[0,379],"source":"The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method."}]},{"pos":[387,587],"content":"[!NOTE]\n In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.","leadings":["","> "],"nodes":[{"content":"In partial trust, use the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload.","pos":[9,198],"source":" In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload."}]}],"pos":[48983,49576],"yaml":true,"extradata":"MT"},{"content":"The rectangle of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> to update.","nodes":[{"pos":[0,97],"content":"The rectangle of the <ph id=\"ph1\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;&lt;/xref&gt;</ph> to update.","source":"The rectangle of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> to update."}],"pos":[49849,49947],"yaml":true},{"content":"The input buffer used to update the bitmap.","nodes":[{"pos":[0,43],"content":"The input buffer used to update the bitmap.","nodes":[{"content":"The input buffer used to update the bitmap.","pos":[0,43]}]}],"pos":[50009,50053],"yaml":true},{"content":"The size of the input buffer.","nodes":[{"pos":[0,29],"content":"The size of the input buffer.","nodes":[{"content":"The size of the input buffer.","pos":[0,29]}]}],"pos":[50118,50148],"yaml":true},{"content":"The stride of the update region in <code>buffer</code>.","nodes":[{"pos":[0,55],"content":"The stride of the update region in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">buffer</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The stride of the update region in <code>buffer</code>."}],"pos":[50209,50265],"yaml":true},{"content":"One or more of the following conditions is true.  \n  \n <code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.  \n  \n <code>bufferSize</code> < 1  \n  \n <code>stride</code> < 1","nodes":[{"pos":[0,48],"content":"One or more of the following conditions is true.","nodes":[{"content":"One or more of the following conditions is true.","pos":[0,48]}]},{"pos":[55,242],"content":"<code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.  \n  \n <code>bufferSize</code> < 1  \n  \n <code>stride</code> < 1","nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;sourceRect&lt;/code&gt;</ph> falls outside the bounds of the <ph id=\"ph2\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;&lt;/xref&gt;</ph>.","pos":[0,122],"source":"<code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>."},{"content":"<ph id=\"ph1\">&lt;code&gt;bufferSize&lt;/code&gt;</ph> &lt; 1  <ph id=\"ph2\">&lt;code&gt;stride&lt;/code&gt;</ph> &lt; 1","pos":[129,186],"source":"<code>bufferSize</code> < 1  \n  \n <code>stride</code> < 1"}]}],"pos":[50463,50715],"yaml":true},{"content":"<code>buffer</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;buffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>buffer</code> is `null`."}],"pos":[50817,50848],"yaml":true},{"content":"Updates the pixels in the specified region of the bitmap.","nodes":[{"pos":[0,57],"content":"Updates the pixels in the specified region of the bitmap.","nodes":[{"content":"Updates the pixels in the specified region of the bitmap.","pos":[0,57]}]}],"pos":[52240,52298],"yaml":true},{"content":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`. Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.  \n  \n> [!NOTE]\n>  Use this overload in partial trust.","nodes":[{"pos":[0,469],"content":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`. Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A&gt;</ph> method to update the <ph id=\"ph2\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt;</ph> automatically with the contents of <ph id=\"ph3\">`sourceBuffer`</ph>.","pos":[0,199],"source":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`."},{"content":"Calling this method is the equivalent of using the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt;</ph> workflow described in the <ph id=\"ph3\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt;</ph> class remarks.","pos":[200,469],"source":" Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks."}]},{"pos":[477,523],"content":"[!NOTE]\n Use this overload in partial trust.","leadings":["","> "],"nodes":[{"content":"Use this overload in partial trust.","pos":[9,44]}]}],"pos":[52309,52838],"yaml":true,"extradata":"MT"},{"content":"The rectangle in <code>sourceBuffer</code> to copy.","nodes":[{"pos":[0,51],"content":"The rectangle in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">sourceBuffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> to copy.","source":"The rectangle in <code>sourceBuffer</code> to copy."}],"pos":[53148,53200],"yaml":true},{"content":"The input buffer used to update the bitmap.","nodes":[{"pos":[0,43],"content":"The input buffer used to update the bitmap.","nodes":[{"content":"The input buffer used to update the bitmap.","pos":[0,43]}]}],"pos":[53267,53311],"yaml":true},{"content":"The stride of the input buffer, in bytes.","nodes":[{"pos":[0,41],"content":"The stride of the input buffer, in bytes.","nodes":[{"content":"The stride of the input buffer, in bytes.","pos":[0,41]}]}],"pos":[53384,53426],"yaml":true},{"content":"The destination x-coordinate of the left-most pixel in the back buffer.","nodes":[{"pos":[0,71],"content":"The destination x-coordinate of the left-most pixel in the back buffer.","nodes":[{"content":"The destination x-coordinate of the left-most pixel in the back buffer.","pos":[0,71]}]}],"pos":[53493,53565],"yaml":true},{"content":"The destination y-coordinate of the top-most pixel in the back buffer.","nodes":[{"pos":[0,70],"content":"The destination y-coordinate of the top-most pixel in the back buffer.","nodes":[{"content":"The destination y-coordinate of the top-most pixel in the back buffer.","pos":[0,70]}]}],"pos":[53632,53703],"yaml":true},{"content":"One or more of the following conditions is true.  \n  \n <code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.  \n  \n <code>destinationX</code> or <code>destinationY</code> is outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.  \n  \n <code>sourceBufferStride</code> < 1","nodes":[{"pos":[0,48],"content":"One or more of the following conditions is true.","nodes":[{"content":"One or more of the following conditions is true.","pos":[0,48]}]},{"pos":[55,377],"content":"<code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.  \n  \n <code>destinationX</code> or <code>destinationY</code> is outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.  \n  \n <code>sourceBufferStride</code> < 1","nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;sourceRect&lt;/code&gt;</ph> falls outside the bounds of the <ph id=\"ph2\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;&lt;/xref&gt;</ph>.","pos":[0,122],"source":"<code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>."},{"content":"<ph id=\"ph1\">&lt;code&gt;destinationX&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;destinationY&lt;/code&gt;</ph> is outside the bounds of the <ph id=\"ph3\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;&lt;/xref&gt;</ph>.","pos":[129,279],"source":"<code>destinationX</code> or <code>destinationY</code> is outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>."},{"content":"<ph id=\"ph1\">&lt;code&gt;sourceBufferStride&lt;/code&gt;</ph> &lt; 1","pos":[286,321],"source":"<code>sourceBufferStride</code> < 1"}]}],"pos":[53901,54290],"yaml":true},{"content":"<code>sourceBuffer</code> is `null`.","nodes":[{"pos":[0,36],"content":"<ph id=\"ph1\">&lt;code&gt;sourceBuffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>sourceBuffer</code> is `null`."}],"pos":[54392,54429],"yaml":true},{"content":"<code>sourceBuffer</code> has a rank other than 1 or 2, or its length is less than or equal to 0.","nodes":[{"pos":[0,97],"content":"<ph id=\"ph1\">&lt;code&gt;sourceBuffer&lt;/code&gt;</ph> has a rank other than 1 or 2, or its length is less than or equal to 0.","source":"<code>sourceBuffer</code> has a rank other than 1 or 2, or its length is less than or equal to 0."}],"pos":[54523,54621],"yaml":true},{"content":"Updates the pixels in the specified region of the bitmap.","nodes":[{"pos":[0,57],"content":"Updates the pixels in the specified region of the bitmap.","nodes":[{"content":"Updates the pixels in the specified region of the bitmap.","pos":[0,57]}]}],"pos":[56057,56115],"yaml":true},{"content":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`. Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.  \n  \n> [!NOTE]\n>  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.","nodes":[{"pos":[0,469],"content":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`. Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A&gt;</ph> method to update the <ph id=\"ph2\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt;</ph> automatically with the contents of <ph id=\"ph3\">`sourceBuffer`</ph>.","pos":[0,199],"source":"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`."},{"content":"Calling this method is the equivalent of using the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A&gt;</ph> workflow described in the <ph id=\"ph3\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap&gt;</ph> class remarks.","pos":[200,469],"source":" Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks."}]},{"pos":[477,677],"content":"[!NOTE]\n In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.","leadings":["","> "],"nodes":[{"content":"In partial trust, use the <ph id=\"ph1\">&lt;xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29&gt;</ph> overload.","pos":[9,198],"source":" In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload."}]}],"pos":[56126,56809],"yaml":true,"extradata":"MT"},{"content":"The rectangle in <code>sourceBuffer</code> to copy.","nodes":[{"pos":[0,51],"content":"The rectangle in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">sourceBuffer</ph><ept id=\"p1\">&lt;/code&gt;</ept> to copy.","source":"The rectangle in <code>sourceBuffer</code> to copy."}],"pos":[57142,57194],"yaml":true},{"content":"The input buffer used to update the bitmap.","nodes":[{"pos":[0,43],"content":"The input buffer used to update the bitmap.","nodes":[{"content":"The input buffer used to update the bitmap.","pos":[0,43]}]}],"pos":[57262,57306],"yaml":true},{"content":"The size of the input buffer.","nodes":[{"pos":[0,29],"content":"The size of the input buffer.","nodes":[{"content":"The size of the input buffer.","pos":[0,29]}]}],"pos":[57377,57407],"yaml":true},{"content":"The stride of the input buffer, in bytes.","nodes":[{"pos":[0,41],"content":"The stride of the input buffer, in bytes.","nodes":[{"content":"The stride of the input buffer, in bytes.","pos":[0,41]}]}],"pos":[57480,57522],"yaml":true},{"content":"The destination x-coordinate of the left-most pixel in the back buffer.","nodes":[{"pos":[0,71],"content":"The destination x-coordinate of the left-most pixel in the back buffer.","nodes":[{"content":"The destination x-coordinate of the left-most pixel in the back buffer.","pos":[0,71]}]}],"pos":[57589,57661],"yaml":true},{"content":"The destination y-coordinate of the top-most pixel in the back buffer.","nodes":[{"pos":[0,70],"content":"The destination y-coordinate of the top-most pixel in the back buffer.","nodes":[{"content":"The destination y-coordinate of the top-most pixel in the back buffer.","pos":[0,70]}]}],"pos":[57728,57799],"yaml":true},{"content":"One or more of the following conditions is true.  \n  \n <code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.  \n  \n <code>destinationX</code> or <code>destinationY</code> is outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.  \n  \n <code>sourceBufferSize</code> < 1  \n  \n <code>sourceBufferStride</code> < 1","nodes":[{"pos":[0,48],"content":"One or more of the following conditions is true.","nodes":[{"content":"One or more of the following conditions is true.","pos":[0,48]}]},{"pos":[55,417],"content":"<code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.  \n  \n <code>destinationX</code> or <code>destinationY</code> is outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.  \n  \n <code>sourceBufferSize</code> < 1  \n  \n <code>sourceBufferStride</code> < 1","nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;sourceRect&lt;/code&gt;</ph> falls outside the bounds of the <ph id=\"ph2\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;&lt;/xref&gt;</ph>.","pos":[0,122],"source":"<code>sourceRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>."},{"content":"<ph id=\"ph1\">&lt;code&gt;destinationX&lt;/code&gt;</ph> or <ph id=\"ph2\">&lt;code&gt;destinationY&lt;/code&gt;</ph> is outside the bounds of the <ph id=\"ph3\">&lt;xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"&gt;&lt;/xref&gt;</ph>.","pos":[129,279],"source":"<code>destinationX</code> or <code>destinationY</code> is outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>."},{"content":"<ph id=\"ph1\">&lt;code&gt;sourceBufferSize&lt;/code&gt;</ph> &lt; 1  <ph id=\"ph2\">&lt;code&gt;sourceBufferStride&lt;/code&gt;</ph> &lt; 1","pos":[286,361],"source":"<code>sourceBufferSize</code> < 1  \n  \n <code>sourceBufferStride</code> < 1"}]}],"pos":[57997,58428],"yaml":true},{"content":"<code>sourceBuffer</code> is `null`.","nodes":[{"pos":[0,36],"content":"<ph id=\"ph1\">&lt;code&gt;sourceBuffer&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>sourceBuffer</code> is `null`."}],"pos":[58530,58567],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Windows.Media.Imaging.WriteableBitmap\n  commentId: T:System.Windows.Media.Imaging.WriteableBitmap\n  id: WriteableBitmap\n  children:\n  - System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Windows.Media.Imaging.BitmapSource)\n  - System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette)\n  - System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)\n  - System.Windows.Media.Imaging.WriteableBitmap.BackBuffer\n  - System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride\n  - System.Windows.Media.Imaging.WriteableBitmap.Clone\n  - System.Windows.Media.Imaging.WriteableBitmap.CloneCore(System.Windows.Freezable)\n  - System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue\n  - System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore(System.Windows.Freezable)\n  - System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore\n  - System.Windows.Media.Imaging.WriteableBitmap.FreezeCore(System.Boolean)\n  - System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore(System.Windows.Freezable)\n  - System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore(System.Windows.Freezable)\n  - System.Windows.Media.Imaging.WriteableBitmap.Lock\n  - System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\n  - System.Windows.Media.Imaging.WriteableBitmap.Unlock\n  - System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)\n  - System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)\n  - System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)\n  - System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)\n  langs:\n  - csharp\n  name: WriteableBitmap\n  nameWithType: WriteableBitmap\n  fullName: System.Windows.Media.Imaging.WriteableBitmap\n  type: Class\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Provides a <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref> that can be written to and updated.\n  remarks: \"Use the <xref:System.Windows.Media.Imaging.WriteableBitmap> class to update and render a bitmap on a per-frame basis. This is useful for generating algorithmic content, such as a fractal image, and for data visualization, such as a music visualizer.  \\n  \\n The <xref:System.Windows.Media.Imaging.WriteableBitmap> class uses two buffers. The *back buffer* is allocated in system memory and accumulates content that is not currently displayed. The *front buffer* is allocated in system memory and contains the content that is currently displayed. The rendering system copies the front buffer to video memory for display.  \\n  \\n Two threads use these buffers. The *user interface (UI) thread* generates the UI but does not present it to the screen. The UI thread responds to user input, timers, and other events. An application can have multiple UI threads. The *render thread* composes and renders changes from the UI thread. There is only one render thread per application.  \\n  \\n The UI thread writes content to the back buffer. The render thread reads content from the front buffer and copies it to video memory. Changes to the back buffer are tracked with changed rectangular regions.  \\n  \\n Call one of the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> overloads to update and display content in the back buffer automatically.  \\n  \\n For greater control over updates, and for multi-threaded access to the back buffer, use the following workflow.  \\n  \\n1.  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method to reserve the back buffer for updates.  \\n  \\n2.  Obtain a pointer to the back buffer by accessing the <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> property.  \\n  \\n3.  Write changes to the back buffer. Other threads may write changes to the back buffer when the <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked.  \\n  \\n4.  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method to indicate areas that have changed.  \\n  \\n5.  Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method to release the back buffer and allow presentation to the screen.  \\n  \\n When updates are sent to the rendering thread, the rendering thread copies the changed rectangles from the back buffer to the front buffer. The rendering system controls this exchange to avoid deadlocks and redraw artifacts, such as \\\"tearing\\\".\"\n  example:\n  - \"The following example demonstrates how a <xref:System.Windows.Media.Imaging.WriteableBitmap> can be used as the source of an <xref:System.Windows.Controls.Image> to draw pixels when the mouse moves.  \\n  \\n [!code-csharp[WriteableBitmap2#WriteableBitmapFullPage](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#writeablebitmapfullpage)]\"\n  syntax:\n    content: 'public sealed class WriteableBitmap : System.Windows.Media.Imaging.BitmapSource'\n  inheritance:\n  - System.Object\n  - System.Windows.Threading.DispatcherObject\n  - System.Windows.DependencyObject\n  - System.Windows.Freezable\n  - System.Windows.Media.Animation.Animatable\n  - System.Windows.Media.ImageSource\n  - System.Windows.Media.Imaging.BitmapSource\n  implements: []\n  inheritedMembers:\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)\n  - System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.DependencyObjectType\n  - System.Windows.DependencyObject.Equals(System.Object)\n  - System.Windows.DependencyObject.GetHashCode\n  - System.Windows.DependencyObject.GetLocalValueEnumerator\n  - System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.IsSealed\n  - System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)\n  - System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)\n  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)\n  - System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)\n  - System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)\n  - System.Windows.Freezable.CanFreeze\n  - System.Windows.Freezable.Changed\n  - System.Windows.Freezable.CreateInstance\n  - System.Windows.Freezable.Freeze\n  - System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)\n  - System.Windows.Freezable.GetAsFrozen\n  - System.Windows.Freezable.GetCurrentValueAsFrozen\n  - System.Windows.Freezable.IsFrozen\n  - System.Windows.Freezable.OnChanged\n  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)\n  - System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)\n  - System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)\n  - System.Windows.Freezable.ReadPreamble\n  - System.Windows.Freezable.WritePostscript\n  - System.Windows.Freezable.WritePreamble\n  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)\n  - System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)\n  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)\n  - System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)\n  - System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)\n  - System.Windows.Media.Animation.Animatable.HasAnimatedProperties\n  - System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)\n  - System.Windows.Media.ImageSource.PixelsToDIPs(System.Double,System.Int32)\n  - System.Windows.Media.ImageSource.System#IFormattable#ToString(System.String,System.IFormatProvider)\n  - System.Windows.Media.ImageSource.ToString\n  - System.Windows.Media.ImageSource.ToString(System.IFormatProvider)\n  - System.Windows.Media.Imaging.BitmapSource.CheckIfSiteOfOrigin\n  - System.Windows.Media.Imaging.BitmapSource.CopyPixels(System.Array,System.Int32,System.Int32)\n  - System.Windows.Media.Imaging.BitmapSource.CopyPixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)\n  - System.Windows.Media.Imaging.BitmapSource.CopyPixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)\n  - System.Windows.Media.Imaging.BitmapSource.Create(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette,System.Array,System.Int32)\n  - System.Windows.Media.Imaging.BitmapSource.Create(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette,System.IntPtr,System.Int32,System.Int32)\n  - System.Windows.Media.Imaging.BitmapSource.DecodeFailed\n  - System.Windows.Media.Imaging.BitmapSource.DownloadCompleted\n  - System.Windows.Media.Imaging.BitmapSource.DownloadFailed\n  - System.Windows.Media.Imaging.BitmapSource.DownloadProgress\n  - System.Windows.Media.Imaging.BitmapSource.DpiX\n  - System.Windows.Media.Imaging.BitmapSource.DpiY\n  - System.Windows.Media.Imaging.BitmapSource.Format\n  - System.Windows.Media.Imaging.BitmapSource.Height\n  - System.Windows.Media.Imaging.BitmapSource.IsDownloading\n  - System.Windows.Media.Imaging.BitmapSource.Metadata\n  - System.Windows.Media.Imaging.BitmapSource.Palette\n  - System.Windows.Media.Imaging.BitmapSource.PixelHeight\n  - System.Windows.Media.Imaging.BitmapSource.PixelWidth\n  - System.Windows.Media.Imaging.BitmapSource.Width\n  - System.Windows.Threading.DispatcherObject.CheckAccess\n  - System.Windows.Threading.DispatcherObject.Dispatcher\n  - System.Windows.Threading.DispatcherObject.VerifyAccess\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Windows.Media.Imaging.BitmapSource)\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Windows.Media.Imaging.BitmapSource)\n  id: '#ctor(System.Windows.Media.Imaging.BitmapSource)'\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: WriteableBitmap(BitmapSource)\n  nameWithType: WriteableBitmap.WriteableBitmap(BitmapSource)\n  fullName: WriteableBitmap.WriteableBitmap(BitmapSource)\n  type: Constructor\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Initializes a new instance of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> class using the given <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref>.\n  remarks: \"The <xref:System.Windows.Media.Imaging.WriteableBitmap.%23ctor%28System.Int32%2CSystem.Int32%2CSystem.Double%2CSystem.Double%2CSystem.Windows.Media.PixelFormat%2CSystem.Windows.Media.Imaging.BitmapPalette%29> constructor is preferred over using this constructor.  \\n  \\n If `source` does not use a natively supported bitmap format, format conversions are applied for each frame update, which reduces performance.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public WriteableBitmap (System.Windows.Media.Imaging.BitmapSource source);\n    parameters:\n    - id: source\n      type: System.Windows.Media.Imaging.BitmapSource\n      description: The <xref href=\"System.Windows.Media.Imaging.BitmapSource\"></xref> to use for initialization.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.#ctor*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette)\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette)\n  id: '#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette)'\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: WriteableBitmap(Int32, Int32, Double, Double, PixelFormat, BitmapPalette)\n  nameWithType: WriteableBitmap.WriteableBitmap(Int32, Int32, Double, Double, PixelFormat, BitmapPalette)\n  fullName: WriteableBitmap.WriteableBitmap(Int32, Int32, Double, Double, PixelFormat, BitmapPalette)\n  type: Constructor\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Initializes a new instance of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> class with the specified parameters.\n  remarks: The preferred values for `pixelFormat` are <xref:System.Windows.Media.PixelFormats.Bgr32%2A> and <xref:System.Windows.Media.PixelFormats.Pbgra32%2A>. These formats are natively supported and do not require a format conversion. Other `pixelFormat` values require a format conversion for each frame update, which reduces performance.\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public WriteableBitmap (int pixelWidth, int pixelHeight, double dpiX, double dpiY, System.Windows.Media.PixelFormat pixelFormat, System.Windows.Media.Imaging.BitmapPalette palette);\n    parameters:\n    - id: pixelWidth\n      type: System.Int32\n      description: The desired width of the bitmap.\n    - id: pixelHeight\n      type: System.Int32\n      description: The desired height of the bitmap.\n    - id: dpiX\n      type: System.Double\n      description: The horizontal [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] of the bitmap.\n    - id: dpiY\n      type: System.Double\n      description: The vertical [!INCLUDE[TLA#tla_dpi](~/includes/tlasharptla-dpi-md.md)] of the bitmap.\n    - id: pixelFormat\n      type: System.Windows.Media.PixelFormat\n      description: The <xref href=\"System.Windows.Media.PixelFormat\"></xref> of the bitmap.\n    - id: palette\n      type: System.Windows.Media.Imaging.BitmapPalette\n      description: The <xref href=\"System.Windows.Media.Imaging.BitmapPalette\"></xref> of the bitmap.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.#ctor*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)\n  id: AddDirtyRect(System.Windows.Int32Rect)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: AddDirtyRect(Int32Rect)\n  nameWithType: WriteableBitmap.AddDirtyRect(Int32Rect)\n  fullName: WriteableBitmap.AddDirtyRect(Int32Rect)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Specifies the area of the bitmap that changed.\n  remarks: \"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method to indicate changes your code has made to the back buffer.  \\n  \\n When you call this method multiple times, the changed areas are accumulated in a sufficient, but not necessarily minimal, representation. For efficiency, only the areas that are marked as dirty are guaranteed to be copied forward to the front buffer. However, any portion of the bitmap may be copied forward, so you must ensure that the entire back buffer is always valid.  \\n  \\n Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods, as described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.\"\n  example:\n  - \"The following code example shows how to specify the area of the back buffer that changed by using the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method.  \\n  \\n [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public void AddDirtyRect (System.Windows.Int32Rect dirtyRect);\n    parameters:\n    - id: dirtyRect\n      type: System.Windows.Int32Rect\n      description: An <xref href=\"System.Windows.Int32Rect\"></xref> representing the area that changed. Dimensions are in pixels.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The bitmap has not been locked by a call to the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap.Lock\"></xref> or <xref href=\"System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\"></xref> methods.\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>dirtyRect</code> falls outside the bounds of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Media.Imaging.WriteableBitmap.BackBuffer\n  commentId: P:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer\n  id: BackBuffer\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: BackBuffer\n  nameWithType: WriteableBitmap.BackBuffer\n  fullName: WriteableBitmap.BackBuffer\n  type: Property\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Gets a pointer to the back buffer.\n  remarks: \"The back buffer contains the bitmap contents in the pixel format requested by the user.  \\n  \\n Update the back buffer only between calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> methods. If you do not follow the Lock/Unlock workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks, undefined behaviors, such as tearing, can occur.  \\n  \\n The address of the back buffer does not change.  \\n  \\n## Thread Safety  \\n You can pass the <xref:System.Windows.Media.Imaging.WriteableBitmap.BackBuffer%2A> pointer to external components and other threads for processing, but if you do, you must provide you own thread coordination. In particular, you must ensure that the UI thread specifies changed areas by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method, and that the UI thread unlocks the buffer by calling the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.\"\n  syntax:\n    content: >-\n      [get: System.Security.SecurityCritical]\n\n      [set: System.Security.SecurityCritical]\n\n      public IntPtr BackBuffer { get; }\n    return:\n      type: System.IntPtr\n      description: An <xref href=\"System.IntPtr\"></xref> that points to the base address of the back buffer.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.BackBuffer*\n  exceptions: []\n  attributes:\n  - type: 'get: System.Security.SecurityCritical'\n  - type: 'set: System.Security.SecurityCritical'\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride\n  commentId: P:System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride\n  id: BackBufferStride\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: BackBufferStride\n  nameWithType: WriteableBitmap.BackBufferStride\n  fullName: WriteableBitmap.BackBufferStride\n  type: Property\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Gets a value indicating the number of bytes in a single row of pixel data.\n  syntax:\n    content: public int BackBufferStride { get; }\n    return:\n      type: System.Int32\n      description: An integer indicating the number of bytes in a single row of pixel data.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Clone\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.Clone\n  id: Clone\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: Clone()\n  nameWithType: WriteableBitmap.Clone()\n  fullName: WriteableBitmap.Clone()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Creates a modifiable clone of this <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref>, making deep copies of this object's values. When copying dependency properties, this method copies resource references and data bindings (but they might no longer resolve) but not animations or their current values.\n  remarks: \"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.  \\n  \\n For more information, see <xref:System.Windows.Freezable.Clone%2A?displayProperty=fullName>.\"\n  syntax:\n    content: public System.Windows.Media.Imaging.WriteableBitmap Clone ();\n    parameters: []\n    return:\n      type: System.Windows.Media.Imaging.WriteableBitmap\n      description: A modifiable clone of the current object. The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true.`\n  overload: System.Windows.Media.Imaging.WriteableBitmap.Clone*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCore(System.Windows.Freezable)\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.CloneCore(System.Windows.Freezable)\n  id: CloneCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: CloneCore(Freezable)\n  nameWithType: WriteableBitmap.CloneCore(Freezable)\n  fullName: WriteableBitmap.CloneCore(Freezable)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      [System.Security.SecurityTreatAsSafe]\n\n      protected override void CloneCore (System.Windows.Freezable sourceFreezable);\n    parameters:\n    - id: sourceFreezable\n      type: System.Windows.Freezable\n      description: ''\n  overload: System.Windows.Media.Imaging.WriteableBitmap.CloneCore*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  - type: System.Security.SecurityTreatAsSafeAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue\n  id: CloneCurrentValue\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: CloneCurrentValue()\n  nameWithType: WriteableBitmap.CloneCurrentValue()\n  fullName: WriteableBitmap.CloneCurrentValue()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Creates a modifiable clone of this <xref href=\"System.Windows.Media.Animation.ByteAnimationUsingKeyFrames\"></xref> object, making deep copies of this object's current values. Resource references, data bindings, and animations are not copied, but their current values are.\n  remarks: \"This method is used to produce modifiable copies of frozen <xref:System.Windows.Freezable> objects (or any <xref:System.Windows.Freezable> object). For convenience, this method shadows the inherited version with a strongly typed implementation.  \\n  \\n For more information, see <xref:System.Windows.Freezable.CloneCurrentValue%2A?displayProperty=fullName>.\"\n  syntax:\n    content: public System.Windows.Media.Imaging.WriteableBitmap CloneCurrentValue ();\n    parameters: []\n    return:\n      type: System.Windows.Media.Imaging.WriteableBitmap\n      description: A modifiable clone of the current object. The cloned object's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property will be `false` even if the source's <xref href=\"System.Windows.Freezable.IsFrozen\"></xref> property was `true`.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore(System.Windows.Freezable)\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore(System.Windows.Freezable)\n  id: CloneCurrentValueCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: CloneCurrentValueCore(Freezable)\n  nameWithType: WriteableBitmap.CloneCurrentValueCore(Freezable)\n  fullName: WriteableBitmap.CloneCurrentValueCore(Freezable)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      [System.Security.SecurityTreatAsSafe]\n\n      protected override void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);\n    parameters:\n    - id: sourceFreezable\n      type: System.Windows.Freezable\n      description: ''\n  overload: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  - type: System.Security.SecurityTreatAsSafeAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore\n  id: CreateInstanceCore\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: CreateInstanceCore()\n  nameWithType: WriteableBitmap.CreateInstanceCore()\n  fullName: WriteableBitmap.CreateInstanceCore()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  syntax:\n    content: protected override System.Windows.Freezable CreateInstanceCore ();\n    parameters: []\n    return:\n      type: System.Windows.Freezable\n      description: ''\n  overload: System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.FreezeCore(System.Boolean)\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.FreezeCore(System.Boolean)\n  id: FreezeCore(System.Boolean)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: FreezeCore(Boolean)\n  nameWithType: WriteableBitmap.FreezeCore(Boolean)\n  fullName: WriteableBitmap.FreezeCore(Boolean)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      [System.Security.SecurityTreatAsSafe]\n\n      protected override bool FreezeCore (bool isChecking);\n    parameters:\n    - id: isChecking\n      type: System.Boolean\n      description: ''\n    return:\n      type: System.Boolean\n      description: ''\n  overload: System.Windows.Media.Imaging.WriteableBitmap.FreezeCore*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  - type: System.Security.SecurityTreatAsSafeAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore(System.Windows.Freezable)\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore(System.Windows.Freezable)\n  id: GetAsFrozenCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: GetAsFrozenCore(Freezable)\n  nameWithType: WriteableBitmap.GetAsFrozenCore(Freezable)\n  fullName: WriteableBitmap.GetAsFrozenCore(Freezable)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      [System.Security.SecurityTreatAsSafe]\n\n      protected override void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);\n    parameters:\n    - id: sourceFreezable\n      type: System.Windows.Freezable\n      description: ''\n  overload: System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  - type: System.Security.SecurityTreatAsSafeAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore(System.Windows.Freezable)\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore(System.Windows.Freezable)\n  id: GetCurrentValueAsFrozenCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: GetCurrentValueAsFrozenCore(Freezable)\n  nameWithType: WriteableBitmap.GetCurrentValueAsFrozenCore(Freezable)\n  fullName: WriteableBitmap.GetCurrentValueAsFrozenCore(Freezable)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      [System.Security.SecurityTreatAsSafe]\n\n      protected override void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);\n    parameters:\n    - id: sourceFreezable\n      type: System.Windows.Freezable\n      description: ''\n  overload: System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  - type: System.Security.SecurityTreatAsSafeAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Lock\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.Lock\n  id: Lock\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: Lock()\n  nameWithType: WriteableBitmap.Lock()\n  fullName: WriteableBitmap.Lock()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Reserves the back buffer for updates.\n  remarks: \"The <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method increments the lock count. When a <xref:System.Windows.Media.Imaging.WriteableBitmap> is locked, the rendering system does not send updates until the <xref:System.Windows.Media.Imaging.WriteableBitmap> is fully unlocked by calls to the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.  \\n  \\n You can use the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method to support multi-threaded implementations. In these scenarios, the UI thread locks the bitmap and exposes the back buffer to other threads. When the worker thread has finished a frame, the UI thread adds changed rectangles and unlocks the buffer.  \\n  \\n The UI thread can block when the render thread acquires a lock on the back buffer to copy it forward to the front buffer. If the latency from this block is too long, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method to wait for a short time and then unblock the UI thread to perform other tasks while the back buffer is locked.\"\n  example:\n  - \"The following code example shows how to reserve the back buffer by using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method.  \\n  \\n [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]\"\n  syntax:\n    content: public void Lock ();\n    parameters: []\n  overload: System.Windows.Media.Imaging.WriteableBitmap.Lock*\n  exceptions: []\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\n  id: TryLock(System.Windows.Duration)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: TryLock(Duration)\n  nameWithType: WriteableBitmap.TryLock(Duration)\n  fullName: WriteableBitmap.TryLock(Duration)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Attempts to lock the bitmap, waiting for no longer than the specified length of time.\n  remarks: When a lock is acquired, the behavior of the <xref:System.Windows.Media.Imaging.WriteableBitmap.TryLock%2A> method is the same as the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> method.\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public bool TryLock (System.Windows.Duration timeout);\n    parameters:\n    - id: timeout\n      type: System.Windows.Duration\n      description: A <xref href=\"System.Windows.Duration\"></xref> that represents the length of time to wait. A value of 0 returns immediately. A value of <xref href=\"System.Windows.Duration.Forever\"></xref> blocks indefinitely.\n    return:\n      type: System.Boolean\n      description: '`true` if the lock was acquired; otherwise, `false`.'\n  overload: System.Windows.Media.Imaging.WriteableBitmap.TryLock*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: <code>timeout</code> is set to <xref href=\"System.Windows.Duration.Automatic\"></xref>.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Unlock\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.Unlock\n  id: Unlock\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: Unlock()\n  nameWithType: WriteableBitmap.Unlock()\n  fullName: WriteableBitmap.Unlock()\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Releases the back buffer to make it available for display.\n  remarks: The <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method decrements the lock count. When the lock count reaches 0, a render pass is requested if the <xref:System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect%2A> method has been called.\n  example:\n  - \"The following code example shows how to release the back buffer by using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> method.  \\n  \\n [!code-csharp[WriteableBitmap2#2](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#2)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public void Unlock ();\n    parameters: []\n  overload: System.Windows.Media.Imaging.WriteableBitmap.Unlock*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The bitmap has not been locked by a call to the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap.Lock\"></xref> or <xref href=\"System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\"></xref> methods.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)\n  id: WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: WritePixels(Int32Rect, Array, Int32, Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect, Array, Int32, Int32)\n  fullName: WriteableBitmap.WritePixels(Int32Rect, Array, Int32, Int32)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Updates the pixels in the specified region of the bitmap.\n  remarks: \"The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method.  \\n  \\n> [!NOTE]\\n>  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.\"\n  example:\n  - \"The following code example shows how to update a pixel in the back buffer by using the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method.  \\n  \\n [!code-csharp[WriteableBitmap2#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WriteableBitmap2/CS/Program.cs#3)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public void WritePixels (System.Windows.Int32Rect sourceRect, Array pixels, int stride, int offset);\n    parameters:\n    - id: sourceRect\n      type: System.Windows.Int32Rect\n      description: The rectangle of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> to update.\n    - id: pixels\n      type: System.Array\n      description: The pixel array used to update the bitmap.\n    - id: stride\n      type: System.Int32\n      description: The stride of the update region in <code>pixels</code>.\n    - id: offset\n      type: System.Int32\n      description: The input buffer offset.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.WritePixels*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"One or more of the following conditions is true.  \\n  \\n <code>sourceRect</code> falls outside the bounds of the <xref href=\\\"System.Windows.Media.Imaging.WriteableBitmap\\\"></xref>.  \\n  \\n <code>stride</code> < 1  \\n  \\n <code>offset</code> < 0\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>pixels</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>pixels</code> has a rank other than 1 or 2, or its length is less than or equal to 0.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)\n  id: WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: WritePixels(Int32Rect, IntPtr, Int32, Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect, IntPtr, Int32, Int32)\n  fullName: WriteableBitmap.WritePixels(Int32Rect, IntPtr, Int32, Int32)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Updates the pixels in the specified region of the bitmap.\n  remarks: \"The <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> and <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.IntPtr%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overloads are preferred over using this method.  \\n  \\n> [!NOTE]\\n>  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public void WritePixels (System.Windows.Int32Rect sourceRect, IntPtr buffer, int bufferSize, int stride);\n    parameters:\n    - id: sourceRect\n      type: System.Windows.Int32Rect\n      description: The rectangle of the <xref href=\"System.Windows.Media.Imaging.WriteableBitmap\"></xref> to update.\n    - id: buffer\n      type: System.IntPtr\n      description: The input buffer used to update the bitmap.\n    - id: bufferSize\n      type: System.Int32\n      description: The size of the input buffer.\n    - id: stride\n      type: System.Int32\n      description: The stride of the update region in <code>buffer</code>.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.WritePixels*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"One or more of the following conditions is true.  \\n  \\n <code>sourceRect</code> falls outside the bounds of the <xref href=\\\"System.Windows.Media.Imaging.WriteableBitmap\\\"></xref>.  \\n  \\n <code>bufferSize</code> < 1  \\n  \\n <code>stride</code> < 1\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>buffer</code> is `null`.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  author: stevehoag\n  ms.author: shoag\n  manager: wpickett\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)\n  id: WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: WritePixels(Int32Rect, Array, Int32, Int32, Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect, Array, Int32, Int32, Int32)\n  fullName: WriteableBitmap.WritePixels(Int32Rect, Array, Int32, Int32, Int32)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Updates the pixels in the specified region of the bitmap.\n  remarks: \"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`. Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.  \\n  \\n> [!NOTE]\\n>  Use this overload in partial trust.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public void WritePixels (System.Windows.Int32Rect sourceRect, Array sourceBuffer, int sourceBufferStride, int destinationX, int destinationY);\n    parameters:\n    - id: sourceRect\n      type: System.Windows.Int32Rect\n      description: The rectangle in <code>sourceBuffer</code> to copy.\n    - id: sourceBuffer\n      type: System.Array\n      description: The input buffer used to update the bitmap.\n    - id: sourceBufferStride\n      type: System.Int32\n      description: The stride of the input buffer, in bytes.\n    - id: destinationX\n      type: System.Int32\n      description: The destination x-coordinate of the left-most pixel in the back buffer.\n    - id: destinationY\n      type: System.Int32\n      description: The destination y-coordinate of the top-most pixel in the back buffer.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.WritePixels*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"One or more of the following conditions is true.  \\n  \\n <code>sourceRect</code> falls outside the bounds of the <xref href=\\\"System.Windows.Media.Imaging.WriteableBitmap\\\"></xref>.  \\n  \\n <code>destinationX</code> or <code>destinationY</code> is outside the bounds of the <xref href=\\\"System.Windows.Media.Imaging.WriteableBitmap\\\"></xref>.  \\n  \\n <code>sourceBufferStride</code> < 1\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>sourceBuffer</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>sourceBuffer</code> has a rank other than 1 or 2, or its length is less than or equal to 0.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  ms.author: kempb\n  manager: ghogen\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)\n  commentId: M:System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)\n  id: WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  langs:\n  - csharp\n  name: WritePixels(Int32Rect, IntPtr, Int32, Int32, Int32, Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect, IntPtr, Int32, Int32, Int32, Int32)\n  fullName: WriteableBitmap.WritePixels(Int32Rect, IntPtr, Int32, Int32, Int32, Int32)\n  type: Method\n  assemblies:\n  - PresentationCore\n  namespace: System.Windows.Media.Imaging\n  summary: Updates the pixels in the specified region of the bitmap.\n  remarks: \"Call the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%2A> method to update the <xref:System.Windows.Media.Imaging.WriteableBitmap> automatically with the contents of `sourceBuffer`. Calling this method is the equivalent of using the <xref:System.Windows.Media.Imaging.WriteableBitmap.Lock%2A> and <xref:System.Windows.Media.Imaging.WriteableBitmap.Unlock%2A> workflow described in the <xref:System.Windows.Media.Imaging.WriteableBitmap> class remarks.  \\n  \\n> [!NOTE]\\n>  In partial trust, use the <xref:System.Windows.Media.Imaging.WriteableBitmap.WritePixels%28System.Windows.Int32Rect%2CSystem.Array%2CSystem.Int32%2CSystem.Int32%2CSystem.Int32%29> overload.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public void WritePixels (System.Windows.Int32Rect sourceRect, IntPtr sourceBuffer, int sourceBufferSize, int sourceBufferStride, int destinationX, int destinationY);\n    parameters:\n    - id: sourceRect\n      type: System.Windows.Int32Rect\n      description: The rectangle in <code>sourceBuffer</code> to copy.\n    - id: sourceBuffer\n      type: System.IntPtr\n      description: The input buffer used to update the bitmap.\n    - id: sourceBufferSize\n      type: System.Int32\n      description: The size of the input buffer.\n    - id: sourceBufferStride\n      type: System.Int32\n      description: The stride of the input buffer, in bytes.\n    - id: destinationX\n      type: System.Int32\n      description: The destination x-coordinate of the left-most pixel in the back buffer.\n    - id: destinationY\n      type: System.Int32\n      description: The destination y-coordinate of the top-most pixel in the back buffer.\n  overload: System.Windows.Media.Imaging.WriteableBitmap.WritePixels*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: \"One or more of the following conditions is true.  \\n  \\n <code>sourceRect</code> falls outside the bounds of the <xref href=\\\"System.Windows.Media.Imaging.WriteableBitmap\\\"></xref>.  \\n  \\n <code>destinationX</code> or <code>destinationY</code> is outside the bounds of the <xref href=\\\"System.Windows.Media.Imaging.WriteableBitmap\\\"></xref>.  \\n  \\n <code>sourceBufferSize</code> < 1  \\n  \\n <code>sourceBufferStride</code> < 1\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>sourceBuffer</code> is `null`.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n  ms.technology:\n  - dotnet-wpf\n  ms.author: kempb\n  manager: ghogen\nreferences:\n- uid: System.Windows.Media.Imaging.BitmapSource\n  parent: System.Windows.Media.Imaging\n  isExternal: false\n  name: BitmapSource\n  nameWithType: BitmapSource\n  fullName: System.Windows.Media.Imaging.BitmapSource\n- uid: System.InvalidOperationException\n  parent: System\n  isExternal: false\n  name: InvalidOperationException\n  nameWithType: InvalidOperationException\n  fullName: System.InvalidOperationException\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.ArgumentException\n  parent: System\n  isExternal: false\n  name: ArgumentException\n  nameWithType: ArgumentException\n  fullName: System.ArgumentException\n- uid: System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Windows.Media.Imaging.BitmapSource)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WriteableBitmap(BitmapSource)\n  nameWithType: WriteableBitmap.WriteableBitmap(BitmapSource)\n  fullName: WriteableBitmap.WriteableBitmap(BitmapSource)\n- uid: System.Windows.Media.Imaging.WriteableBitmap.#ctor(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WriteableBitmap(Int32, Int32, Double, Double, PixelFormat, BitmapPalette)\n  nameWithType: WriteableBitmap.WriteableBitmap(Int32, Int32, Double, Double, PixelFormat, BitmapPalette)\n  fullName: WriteableBitmap.WriteableBitmap(Int32, Int32, Double, Double, PixelFormat, BitmapPalette)\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Double\n  parent: System\n  isExternal: false\n  name: Double\n  nameWithType: Double\n  fullName: System.Double\n- uid: System.Windows.Media.PixelFormat\n  parent: System.Windows.Media\n  isExternal: false\n  name: PixelFormat\n  nameWithType: PixelFormat\n  fullName: System.Windows.Media.PixelFormat\n- uid: System.Windows.Media.Imaging.BitmapPalette\n  parent: System.Windows.Media.Imaging\n  isExternal: false\n  name: BitmapPalette\n  nameWithType: BitmapPalette\n  fullName: System.Windows.Media.Imaging.BitmapPalette\n- uid: System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect(System.Windows.Int32Rect)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: AddDirtyRect(Int32Rect)\n  nameWithType: WriteableBitmap.AddDirtyRect(Int32Rect)\n  fullName: WriteableBitmap.AddDirtyRect(Int32Rect)\n- uid: System.Windows.Int32Rect\n  parent: System.Windows\n  isExternal: false\n  name: Int32Rect\n  nameWithType: Int32Rect\n  fullName: System.Windows.Int32Rect\n- uid: System.Windows.Media.Imaging.WriteableBitmap.BackBuffer\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: BackBuffer\n  nameWithType: WriteableBitmap.BackBuffer\n  fullName: WriteableBitmap.BackBuffer\n- uid: System.IntPtr\n  parent: System\n  isExternal: false\n  name: IntPtr\n  nameWithType: IntPtr\n  fullName: System.IntPtr\n- uid: System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: BackBufferStride\n  nameWithType: WriteableBitmap.BackBufferStride\n  fullName: WriteableBitmap.BackBufferStride\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Clone\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: Clone()\n  nameWithType: WriteableBitmap.Clone()\n  fullName: WriteableBitmap.Clone()\n- uid: System.Windows.Media.Imaging.WriteableBitmap\n  parent: System.Windows.Media.Imaging\n  isExternal: false\n  name: WriteableBitmap\n  nameWithType: WriteableBitmap\n  fullName: System.Windows.Media.Imaging.WriteableBitmap\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CloneCore(Freezable)\n  nameWithType: WriteableBitmap.CloneCore(Freezable)\n  fullName: WriteableBitmap.CloneCore(Freezable)\n- uid: System.Windows.Freezable\n  parent: System.Windows\n  isExternal: false\n  name: Freezable\n  nameWithType: Freezable\n  fullName: System.Windows.Freezable\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CloneCurrentValue()\n  nameWithType: WriteableBitmap.CloneCurrentValue()\n  fullName: WriteableBitmap.CloneCurrentValue()\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CloneCurrentValueCore(Freezable)\n  nameWithType: WriteableBitmap.CloneCurrentValueCore(Freezable)\n  fullName: WriteableBitmap.CloneCurrentValueCore(Freezable)\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CreateInstanceCore()\n  nameWithType: WriteableBitmap.CreateInstanceCore()\n  fullName: WriteableBitmap.CreateInstanceCore()\n- uid: System.Windows.Media.Imaging.WriteableBitmap.FreezeCore(System.Boolean)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: FreezeCore(Boolean)\n  nameWithType: WriteableBitmap.FreezeCore(Boolean)\n  fullName: WriteableBitmap.FreezeCore(Boolean)\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: GetAsFrozenCore(Freezable)\n  nameWithType: WriteableBitmap.GetAsFrozenCore(Freezable)\n  fullName: WriteableBitmap.GetAsFrozenCore(Freezable)\n- uid: System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore(System.Windows.Freezable)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: GetCurrentValueAsFrozenCore(Freezable)\n  nameWithType: WriteableBitmap.GetCurrentValueAsFrozenCore(Freezable)\n  fullName: WriteableBitmap.GetCurrentValueAsFrozenCore(Freezable)\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Lock\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: Lock()\n  nameWithType: WriteableBitmap.Lock()\n  fullName: WriteableBitmap.Lock()\n- uid: System.Windows.Media.Imaging.WriteableBitmap.TryLock(System.Windows.Duration)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: TryLock(Duration)\n  nameWithType: WriteableBitmap.TryLock(Duration)\n  fullName: WriteableBitmap.TryLock(Duration)\n- uid: System.Windows.Duration\n  parent: System.Windows\n  isExternal: false\n  name: Duration\n  nameWithType: Duration\n  fullName: System.Windows.Duration\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Unlock\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: Unlock()\n  nameWithType: WriteableBitmap.Unlock()\n  fullName: WriteableBitmap.Unlock()\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WritePixels(Int32Rect, Array, Int32, Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect, Array, Int32, Int32)\n  fullName: WriteableBitmap.WritePixels(Int32Rect, Array, Int32, Int32)\n- uid: System.Array\n  parent: System\n  isExternal: false\n  name: Array\n  nameWithType: Array\n  fullName: System.Array\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WritePixels(Int32Rect, IntPtr, Int32, Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect, IntPtr, Int32, Int32)\n  fullName: WriteableBitmap.WritePixels(Int32Rect, IntPtr, Int32, Int32)\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WritePixels(Int32Rect, Array, Int32, Int32, Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect, Array, Int32, Int32, Int32)\n  fullName: WriteableBitmap.WritePixels(Int32Rect, Array, Int32, Int32, Int32)\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WritePixels(Int32Rect, IntPtr, Int32, Int32, Int32, Int32)\n  nameWithType: WriteableBitmap.WritePixels(Int32Rect, IntPtr, Int32, Int32, Int32, Int32)\n  fullName: WriteableBitmap.WritePixels(Int32Rect, IntPtr, Int32, Int32, Int32, Int32)\n- uid: System.Windows.Media.Imaging.WriteableBitmap.#ctor*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WriteableBitmap\n  nameWithType: WriteableBitmap.WriteableBitmap\n  fullName: WriteableBitmap.WriteableBitmap\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.AddDirtyRect*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: AddDirtyRect\n  nameWithType: WriteableBitmap.AddDirtyRect\n  fullName: WriteableBitmap.AddDirtyRect\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.BackBuffer*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: BackBuffer\n  nameWithType: WriteableBitmap.BackBuffer\n  fullName: WriteableBitmap.BackBuffer\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.BackBufferStride*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: BackBufferStride\n  nameWithType: WriteableBitmap.BackBufferStride\n  fullName: WriteableBitmap.BackBufferStride\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Clone*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: Clone\n  nameWithType: WriteableBitmap.Clone\n  fullName: WriteableBitmap.Clone\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCore*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CloneCore\n  nameWithType: WriteableBitmap.CloneCore\n  fullName: WriteableBitmap.CloneCore\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValue*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CloneCurrentValue\n  nameWithType: WriteableBitmap.CloneCurrentValue\n  fullName: WriteableBitmap.CloneCurrentValue\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CloneCurrentValueCore*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CloneCurrentValueCore\n  nameWithType: WriteableBitmap.CloneCurrentValueCore\n  fullName: WriteableBitmap.CloneCurrentValueCore\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.CreateInstanceCore*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: CreateInstanceCore\n  nameWithType: WriteableBitmap.CreateInstanceCore\n  fullName: WriteableBitmap.CreateInstanceCore\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.FreezeCore*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: FreezeCore\n  nameWithType: WriteableBitmap.FreezeCore\n  fullName: WriteableBitmap.FreezeCore\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.GetAsFrozenCore*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: GetAsFrozenCore\n  nameWithType: WriteableBitmap.GetAsFrozenCore\n  fullName: WriteableBitmap.GetAsFrozenCore\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.GetCurrentValueAsFrozenCore*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: GetCurrentValueAsFrozenCore\n  nameWithType: WriteableBitmap.GetCurrentValueAsFrozenCore\n  fullName: WriteableBitmap.GetCurrentValueAsFrozenCore\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Lock*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: Lock\n  nameWithType: WriteableBitmap.Lock\n  fullName: WriteableBitmap.Lock\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.TryLock*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: TryLock\n  nameWithType: WriteableBitmap.TryLock\n  fullName: WriteableBitmap.TryLock\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.Unlock*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: Unlock\n  nameWithType: WriteableBitmap.Unlock\n  fullName: WriteableBitmap.Unlock\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.Media.Imaging.WriteableBitmap.WritePixels*\n  parent: System.Windows.Media.Imaging.WriteableBitmap\n  isExternal: false\n  name: WritePixels\n  nameWithType: WriteableBitmap.WritePixels\n  fullName: WriteableBitmap.WritePixels\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Windows.Media.Imaging/WriteableBitmap.xml\n- uid: System.Windows.DependencyObject.Equals(System.Object)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: DependencyObject.Equals(Object)\n  fullName: DependencyObject.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Windows.DependencyObject.GetHashCode\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: DependencyObject.GetHashCode()\n  fullName: DependencyObject.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Windows.Media.ImageSource.ToString\n  parent: System.Windows.Media.ImageSource\n  isExternal: false\n  name: ToString()\n  nameWithType: ImageSource.ToString()\n  fullName: ImageSource.ToString()\n- uid: System.Windows.Threading.DispatcherObject.CheckAccess\n  parent: System.Windows.Threading.DispatcherObject\n  isExternal: false\n  name: CheckAccess()\n  nameWithType: DispatcherObject.CheckAccess()\n  fullName: DispatcherObject.CheckAccess()\n- uid: System.Windows.Threading.DispatcherObject.Dispatcher\n  parent: System.Windows.Threading.DispatcherObject\n  isExternal: false\n  name: Dispatcher\n  nameWithType: DispatcherObject.Dispatcher\n  fullName: DispatcherObject.Dispatcher\n- uid: System.Windows.Threading.DispatcherObject.VerifyAccess\n  parent: System.Windows.Threading.DispatcherObject\n  isExternal: false\n  name: VerifyAccess()\n  nameWithType: DispatcherObject.VerifyAccess()\n  fullName: DispatcherObject.VerifyAccess()\n- uid: System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: ClearValue(DependencyProperty)\n  nameWithType: DependencyObject.ClearValue(DependencyProperty)\n  fullName: DependencyObject.ClearValue(DependencyProperty)\n- uid: System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: ClearValue(DependencyPropertyKey)\n  nameWithType: DependencyObject.ClearValue(DependencyPropertyKey)\n  fullName: DependencyObject.ClearValue(DependencyPropertyKey)\n- uid: System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: CoerceValue(DependencyProperty)\n  nameWithType: DependencyObject.CoerceValue(DependencyProperty)\n  fullName: DependencyObject.CoerceValue(DependencyProperty)\n- uid: System.Windows.DependencyObject.DependencyObjectType\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: DependencyObjectType\n  nameWithType: DependencyObject.DependencyObjectType\n  fullName: DependencyObject.DependencyObjectType\n- uid: System.Windows.DependencyObject.GetLocalValueEnumerator\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: GetLocalValueEnumerator()\n  nameWithType: DependencyObject.GetLocalValueEnumerator()\n  fullName: DependencyObject.GetLocalValueEnumerator()\n- uid: System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: GetValue(DependencyProperty)\n  nameWithType: DependencyObject.GetValue(DependencyProperty)\n  fullName: DependencyObject.GetValue(DependencyProperty)\n- uid: System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: InvalidateProperty(DependencyProperty)\n  nameWithType: DependencyObject.InvalidateProperty(DependencyProperty)\n  fullName: DependencyObject.InvalidateProperty(DependencyProperty)\n- uid: System.Windows.DependencyObject.IsSealed\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: IsSealed\n  nameWithType: DependencyObject.IsSealed\n  fullName: DependencyObject.IsSealed\n- uid: System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: OnPropertyChanged(DependencyPropertyChangedEventArgs)\n  nameWithType: Freezable.OnPropertyChanged(DependencyPropertyChangedEventArgs)\n  fullName: Freezable.OnPropertyChanged(DependencyPropertyChangedEventArgs)\n- uid: System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: ReadLocalValue(DependencyProperty)\n  nameWithType: DependencyObject.ReadLocalValue(DependencyProperty)\n  fullName: DependencyObject.ReadLocalValue(DependencyProperty)\n- uid: System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: SetCurrentValue(DependencyProperty, Object)\n  nameWithType: DependencyObject.SetCurrentValue(DependencyProperty, Object)\n  fullName: DependencyObject.SetCurrentValue(DependencyProperty, Object)\n- uid: System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: SetValue(DependencyProperty, Object)\n  nameWithType: DependencyObject.SetValue(DependencyProperty, Object)\n  fullName: DependencyObject.SetValue(DependencyProperty, Object)\n- uid: System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: SetValue(DependencyPropertyKey, Object)\n  nameWithType: DependencyObject.SetValue(DependencyPropertyKey, Object)\n  fullName: DependencyObject.SetValue(DependencyPropertyKey, Object)\n- uid: System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)\n  parent: System.Windows.DependencyObject\n  isExternal: false\n  name: ShouldSerializeProperty(DependencyProperty)\n  nameWithType: DependencyObject.ShouldSerializeProperty(DependencyProperty)\n  fullName: DependencyObject.ShouldSerializeProperty(DependencyProperty)\n- uid: System.Windows.Freezable.CanFreeze\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: CanFreeze\n  nameWithType: Freezable.CanFreeze\n  fullName: Freezable.CanFreeze\n- uid: System.Windows.Freezable.Changed\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: Changed\n  nameWithType: Freezable.Changed\n  fullName: Freezable.Changed\n- uid: System.Windows.Freezable.CreateInstance\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: CreateInstance()\n  nameWithType: Freezable.CreateInstance()\n  fullName: Freezable.CreateInstance()\n- uid: System.Windows.Freezable.Freeze\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: Freeze()\n  nameWithType: Freezable.Freeze()\n  fullName: Freezable.Freeze()\n- uid: System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: Freeze(Freezable, Boolean)\n  nameWithType: Freezable.Freeze(Freezable, Boolean)\n  fullName: Freezable.Freeze(Freezable, Boolean)\n- uid: System.Windows.Freezable.GetAsFrozen\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: GetAsFrozen()\n  nameWithType: Freezable.GetAsFrozen()\n  fullName: Freezable.GetAsFrozen()\n- uid: System.Windows.Freezable.GetCurrentValueAsFrozen\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: GetCurrentValueAsFrozen()\n  nameWithType: Freezable.GetCurrentValueAsFrozen()\n  fullName: Freezable.GetCurrentValueAsFrozen()\n- uid: System.Windows.Freezable.IsFrozen\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: IsFrozen\n  nameWithType: Freezable.IsFrozen\n  fullName: Freezable.IsFrozen\n- uid: System.Windows.Freezable.OnChanged\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: OnChanged()\n  nameWithType: Freezable.OnChanged()\n  fullName: Freezable.OnChanged()\n- uid: System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: OnFreezablePropertyChanged(DependencyObject, DependencyObject)\n  nameWithType: Freezable.OnFreezablePropertyChanged(DependencyObject, DependencyObject)\n  fullName: Freezable.OnFreezablePropertyChanged(DependencyObject, DependencyObject)\n- uid: System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: OnFreezablePropertyChanged(DependencyObject, DependencyObject, DependencyProperty)\n  nameWithType: Freezable.OnFreezablePropertyChanged(DependencyObject, DependencyObject, DependencyProperty)\n  fullName: Freezable.OnFreezablePropertyChanged(DependencyObject, DependencyObject, DependencyProperty)\n- uid: System.Windows.Freezable.ReadPreamble\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: ReadPreamble()\n  nameWithType: Freezable.ReadPreamble()\n  fullName: Freezable.ReadPreamble()\n- uid: System.Windows.Freezable.WritePostscript\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: WritePostscript()\n  nameWithType: Freezable.WritePostscript()\n  fullName: Freezable.WritePostscript()\n- uid: System.Windows.Freezable.WritePreamble\n  parent: System.Windows.Freezable\n  isExternal: false\n  name: WritePreamble()\n  nameWithType: Freezable.WritePreamble()\n  fullName: Freezable.WritePreamble()\n- uid: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)\n  parent: System.Windows.Media.Animation.Animatable\n  isExternal: false\n  name: ApplyAnimationClock(DependencyProperty, AnimationClock)\n  nameWithType: Animatable.ApplyAnimationClock(DependencyProperty, AnimationClock)\n  fullName: Animatable.ApplyAnimationClock(DependencyProperty, AnimationClock)\n- uid: System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)\n  parent: System.Windows.Media.Animation.Animatable\n  isExternal: false\n  name: ApplyAnimationClock(DependencyProperty, AnimationClock, HandoffBehavior)\n  nameWithType: Animatable.ApplyAnimationClock(DependencyProperty, AnimationClock, HandoffBehavior)\n  fullName: Animatable.ApplyAnimationClock(DependencyProperty, AnimationClock, HandoffBehavior)\n- uid: System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)\n  parent: System.Windows.Media.Animation.Animatable\n  isExternal: false\n  name: BeginAnimation(DependencyProperty, AnimationTimeline)\n  nameWithType: Animatable.BeginAnimation(DependencyProperty, AnimationTimeline)\n  fullName: Animatable.BeginAnimation(DependencyProperty, AnimationTimeline)\n- uid: System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)\n  parent: System.Windows.Media.Animation.Animatable\n  isExternal: false\n  name: BeginAnimation(DependencyProperty, AnimationTimeline, HandoffBehavior)\n  nameWithType: Animatable.BeginAnimation(DependencyProperty, AnimationTimeline, HandoffBehavior)\n  fullName: Animatable.BeginAnimation(DependencyProperty, AnimationTimeline, HandoffBehavior)\n- uid: System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)\n  parent: System.Windows.Media.Animation.Animatable\n  isExternal: false\n  name: GetAnimationBaseValue(DependencyProperty)\n  nameWithType: Animatable.GetAnimationBaseValue(DependencyProperty)\n  fullName: Animatable.GetAnimationBaseValue(DependencyProperty)\n- uid: System.Windows.Media.Animation.Animatable.HasAnimatedProperties\n  parent: System.Windows.Media.Animation.Animatable\n  isExternal: false\n  name: HasAnimatedProperties\n  nameWithType: Animatable.HasAnimatedProperties\n  fullName: Animatable.HasAnimatedProperties\n- uid: System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)\n  parent: System.Windows.Media.Animation.Animatable\n  isExternal: false\n  name: ShouldSerializeStoredWeakReference(DependencyObject)\n  nameWithType: Animatable.ShouldSerializeStoredWeakReference(DependencyObject)\n  fullName: Animatable.ShouldSerializeStoredWeakReference(DependencyObject)\n- uid: System.Windows.Media.Imaging.BitmapSource.Height\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: Height\n  nameWithType: BitmapSource.Height\n  fullName: BitmapSource.Height\n- uid: System.Windows.Media.Imaging.BitmapSource.Metadata\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: Metadata\n  nameWithType: BitmapSource.Metadata\n  fullName: BitmapSource.Metadata\n- uid: System.Windows.Media.ImageSource.PixelsToDIPs(System.Double,System.Int32)\n  parent: System.Windows.Media.ImageSource\n  isExternal: false\n  name: PixelsToDIPs(Double, Int32)\n  nameWithType: ImageSource.PixelsToDIPs(Double, Int32)\n  fullName: ImageSource.PixelsToDIPs(Double, Int32)\n- uid: System.Windows.Media.ImageSource.ToString(System.IFormatProvider)\n  parent: System.Windows.Media.ImageSource\n  isExternal: false\n  name: ToString(IFormatProvider)\n  nameWithType: ImageSource.ToString(IFormatProvider)\n  fullName: ImageSource.ToString(IFormatProvider)\n- uid: System.Windows.Media.Imaging.BitmapSource.Width\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: Width\n  nameWithType: BitmapSource.Width\n  fullName: BitmapSource.Width\n- uid: System.Windows.Media.ImageSource.System#IFormattable#ToString(System.String,System.IFormatProvider)\n  parent: System.Windows.Media.ImageSource\n  isExternal: false\n  name: IFormattable.ToString(String, IFormatProvider)\n  nameWithType: ImageSource.IFormattable.ToString(String, IFormatProvider)\n  fullName: ImageSource.IFormattable.ToString(String, IFormatProvider)\n- uid: System.Windows.Media.Imaging.BitmapSource.CheckIfSiteOfOrigin\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: CheckIfSiteOfOrigin()\n  nameWithType: BitmapSource.CheckIfSiteOfOrigin()\n  fullName: BitmapSource.CheckIfSiteOfOrigin()\n- uid: System.Windows.Media.Imaging.BitmapSource.CopyPixels(System.Array,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: CopyPixels(Array, Int32, Int32)\n  nameWithType: BitmapSource.CopyPixels(Array, Int32, Int32)\n  fullName: BitmapSource.CopyPixels(Array, Int32, Int32)\n- uid: System.Windows.Media.Imaging.BitmapSource.CopyPixels(System.Windows.Int32Rect,System.Array,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: CopyPixels(Int32Rect, Array, Int32, Int32)\n  nameWithType: BitmapSource.CopyPixels(Int32Rect, Array, Int32, Int32)\n  fullName: BitmapSource.CopyPixels(Int32Rect, Array, Int32, Int32)\n- uid: System.Windows.Media.Imaging.BitmapSource.CopyPixels(System.Windows.Int32Rect,System.IntPtr,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: CopyPixels(Int32Rect, IntPtr, Int32, Int32)\n  nameWithType: BitmapSource.CopyPixels(Int32Rect, IntPtr, Int32, Int32)\n  fullName: BitmapSource.CopyPixels(Int32Rect, IntPtr, Int32, Int32)\n- uid: System.Windows.Media.Imaging.BitmapSource.Create(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette,System.Array,System.Int32)\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: Create(Int32, Int32, Double, Double, PixelFormat, BitmapPalette, Array, Int32)\n  nameWithType: BitmapSource.Create(Int32, Int32, Double, Double, PixelFormat, BitmapPalette, Array, Int32)\n  fullName: BitmapSource.Create(Int32, Int32, Double, Double, PixelFormat, BitmapPalette, Array, Int32)\n- uid: System.Windows.Media.Imaging.BitmapSource.Create(System.Int32,System.Int32,System.Double,System.Double,System.Windows.Media.PixelFormat,System.Windows.Media.Imaging.BitmapPalette,System.IntPtr,System.Int32,System.Int32)\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: Create(Int32, Int32, Double, Double, PixelFormat, BitmapPalette, IntPtr, Int32, Int32)\n  nameWithType: BitmapSource.Create(Int32, Int32, Double, Double, PixelFormat, BitmapPalette, IntPtr, Int32, Int32)\n  fullName: BitmapSource.Create(Int32, Int32, Double, Double, PixelFormat, BitmapPalette, IntPtr, Int32, Int32)\n- uid: System.Windows.Media.Imaging.BitmapSource.DecodeFailed\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: DecodeFailed\n  nameWithType: BitmapSource.DecodeFailed\n  fullName: BitmapSource.DecodeFailed\n- uid: System.Windows.Media.Imaging.BitmapSource.DownloadCompleted\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: DownloadCompleted\n  nameWithType: BitmapSource.DownloadCompleted\n  fullName: BitmapSource.DownloadCompleted\n- uid: System.Windows.Media.Imaging.BitmapSource.DownloadFailed\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: DownloadFailed\n  nameWithType: BitmapSource.DownloadFailed\n  fullName: BitmapSource.DownloadFailed\n- uid: System.Windows.Media.Imaging.BitmapSource.DownloadProgress\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: DownloadProgress\n  nameWithType: BitmapSource.DownloadProgress\n  fullName: BitmapSource.DownloadProgress\n- uid: System.Windows.Media.Imaging.BitmapSource.DpiX\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: DpiX\n  nameWithType: BitmapSource.DpiX\n  fullName: BitmapSource.DpiX\n- uid: System.Windows.Media.Imaging.BitmapSource.DpiY\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: DpiY\n  nameWithType: BitmapSource.DpiY\n  fullName: BitmapSource.DpiY\n- uid: System.Windows.Media.Imaging.BitmapSource.Format\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: Format\n  nameWithType: BitmapSource.Format\n  fullName: BitmapSource.Format\n- uid: System.Windows.Media.Imaging.BitmapSource.IsDownloading\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: IsDownloading\n  nameWithType: BitmapSource.IsDownloading\n  fullName: BitmapSource.IsDownloading\n- uid: System.Windows.Media.Imaging.BitmapSource.Palette\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: Palette\n  nameWithType: BitmapSource.Palette\n  fullName: BitmapSource.Palette\n- uid: System.Windows.Media.Imaging.BitmapSource.PixelHeight\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: PixelHeight\n  nameWithType: BitmapSource.PixelHeight\n  fullName: BitmapSource.PixelHeight\n- uid: System.Windows.Media.Imaging.BitmapSource.PixelWidth\n  parent: System.Windows.Media.Imaging.BitmapSource\n  isExternal: false\n  name: PixelWidth\n  nameWithType: BitmapSource.PixelWidth\n  fullName: BitmapSource.PixelWidth\n"}