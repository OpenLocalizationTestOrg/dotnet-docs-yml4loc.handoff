{"nodes":[{"content":"Checks for sufficient memory resources before executing an operation. This class cannot be inherited.","nodes":[{"pos":[0,101],"content":"Checks for sufficient memory resources before executing an operation. This class cannot be inherited.","nodes":[{"content":"Checks for sufficient memory resources before executing an operation. This class cannot be inherited.","pos":[0,101],"nodes":[{"content":"Checks for sufficient memory resources before executing an operation.","pos":[0,69]},{"content":"This class cannot be inherited.","pos":[70,101]}]}]}],"pos":[530,632],"yaml":true},{"content":"> [!NOTE]\n>  This class is intended for use in advanced development.  \n  \n Creating an instance of the <xref:System.Runtime.MemoryFailPoint> class creates a memory gate. A memory gate checks for sufficient resources before initiating an activity that requires a large amount of memory. Failing the check results in an <xref:System.InsufficientMemoryException> exception being thrown. This exception prevents an operation from being started and reduces the possibility of failure due to lack of resources. This enables you decrease performance to avoid an <xref:System.OutOfMemoryException> exception and any state corruption that may result from improper handling of the exception in arbitrary locations in your code.  \n  \n> [!IMPORTANT]\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.  \n  \n By throwing an <xref:System.InsufficientMemoryException> exception, an application can distinguish between an estimate that an operation will not be able to complete and  a partially completed operation that may have corrupted the application state. This allows an application to reduce the frequency of a pessimistic escalation policy, which may require unloading the current <xref:System.AppDomain> or recycling the process.  \n  \n <xref:System.Runtime.MemoryFailPoint> checks to see whether sufficient memory and consecutive virtual address space are available in all garbage collection heaps, and may increase the size of the swap file.  <xref:System.Runtime.MemoryFailPoint> makes no guarantees regarding the long-term availability of the memory during the lifetime of the gate, but callers should always use the <xref:System.Runtime.MemoryFailPoint.Dispose%2A> method to ensure that resources associated with <xref:System.Runtime.MemoryFailPoint> are released.  \n  \n To use a memory gate, you must create a <xref:System.Runtime.MemoryFailPoint> object and specify the number of megabytes (MB) of memory that the next operation is expected to use. If enough memory is not available, an <xref:System.InsufficientMemoryException> exception is thrown.  \n  \n The parameter of the constructor must be a positive integer. A negative value raises an <xref:System.ArgumentOutOfRangeException> exception.  \n  \n <xref:System.Runtime.MemoryFailPoint> operates at a granularity of 16 MB. Any values smaller than 16 MB are treated as 16 MB, and other values are treated as the next largest multiple of 16 MB.","nodes":[{"pos":[2,68],"content":"[!NOTE]\n This class is intended for use in advanced development.","leadings":["","> "],"nodes":[{"content":"This class is intended for use in advanced development.","pos":[9,64]}]},{"pos":[75,717],"content":"Creating an instance of the <xref:System.Runtime.MemoryFailPoint> class creates a memory gate. A memory gate checks for sufficient resources before initiating an activity that requires a large amount of memory. Failing the check results in an <xref:System.InsufficientMemoryException> exception being thrown. This exception prevents an operation from being started and reduces the possibility of failure due to lack of resources. This enables you decrease performance to avoid an <xref:System.OutOfMemoryException> exception and any state corruption that may result from improper handling of the exception in arbitrary locations in your code.","nodes":[{"content":"Creating an instance of the <xref:System.Runtime.MemoryFailPoint> class creates a memory gate. A memory gate checks for sufficient resources before initiating an activity that requires a large amount of memory. Failing the check results in an <xref:System.InsufficientMemoryException> exception being thrown. This exception prevents an operation from being started and reduces the possibility of failure due to lack of resources. This enables you decrease performance to avoid an <xref:System.OutOfMemoryException> exception and any state corruption that may result from improper handling of the exception in arbitrary locations in your code.","pos":[0,642],"nodes":[{"content":"Creating an instance of the <ph id=\"ph1\">&lt;xref:System.Runtime.MemoryFailPoint&gt;</ph> class creates a memory gate.","pos":[0,94],"source":"Creating an instance of the <xref:System.Runtime.MemoryFailPoint> class creates a memory gate."},{"content":"A memory gate checks for sufficient resources before initiating an activity that requires a large amount of memory.","pos":[95,210]},{"content":"Failing the check results in an <ph id=\"ph1\">&lt;xref:System.InsufficientMemoryException&gt;</ph> exception being thrown.","pos":[211,308],"source":" Failing the check results in an <xref:System.InsufficientMemoryException> exception being thrown."},{"content":"This exception prevents an operation from being started and reduces the possibility of failure due to lack of resources.","pos":[309,429]},{"content":"This enables you decrease performance to avoid an <ph id=\"ph1\">&lt;xref:System.OutOfMemoryException&gt;</ph> exception and any state corruption that may result from improper handling of the exception in arbitrary locations in your code.","pos":[430,642],"source":" This enables you decrease performance to avoid an <xref:System.OutOfMemoryException> exception and any state corruption that may result from improper handling of the exception in arbitrary locations in your code."}]}]},{"pos":[725,1251],"content":"[!IMPORTANT]\n This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.","leadings":["","> "],"nodes":[{"content":" This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic.","pos":[13,524],"nodes":[{"content":"This type implements the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface.","pos":[1,62],"source":" This type implements the <xref:System.IDisposable> interface."},{"content":"When you have finished using the type, you should dispose of it either directly or indirectly.","pos":[63,157]},{"content":"To dispose of the type directly, call its <ph id=\"ph1\">&lt;xref:System.IDisposable.Dispose%2A&gt;</ph> method in a <ph id=\"ph2\">`try`</ph><ph id=\"ph3\">/</ph><ph id=\"ph4\">`catch`</ph> block.","pos":[158,269],"source":" To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block."},{"content":"To dispose of it indirectly, use a language construct such as <ph id=\"ph1\">`using`</ph> (in C#) or <ph id=\"ph2\">`Using`</ph> (in Visual Basic).","pos":[270,377],"source":" To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic)."},{"content":"For more information, see the \"Using an Object that Implements IDisposable\" section in the <ph id=\"ph1\">&lt;xref:System.IDisposable&gt;</ph> interface topic.","pos":[378,511],"source":" For more information, see the \"Using an Object that Implements IDisposable\" section in the <xref:System.IDisposable> interface topic."}]}]},{"pos":[1258,1684],"content":"By throwing an <xref:System.InsufficientMemoryException> exception, an application can distinguish between an estimate that an operation will not be able to complete and  a partially completed operation that may have corrupted the application state. This allows an application to reduce the frequency of a pessimistic escalation policy, which may require unloading the current <xref:System.AppDomain> or recycling the process.","nodes":[{"content":"By throwing an <xref:System.InsufficientMemoryException> exception, an application can distinguish between an estimate that an operation will not be able to complete and  a partially completed operation that may have corrupted the application state. This allows an application to reduce the frequency of a pessimistic escalation policy, which may require unloading the current <xref:System.AppDomain> or recycling the process.","pos":[0,426],"nodes":[{"content":"By throwing an <ph id=\"ph1\">&lt;xref:System.InsufficientMemoryException&gt;</ph> exception, an application can distinguish between an estimate that an operation will not be able to complete and  a partially completed operation that may have corrupted the application state.","pos":[0,249],"source":"By throwing an <xref:System.InsufficientMemoryException> exception, an application can distinguish between an estimate that an operation will not be able to complete and  a partially completed operation that may have corrupted the application state."},{"content":"This allows an application to reduce the frequency of a pessimistic escalation policy, which may require unloading the current <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> or recycling the process.","pos":[250,426],"source":" This allows an application to reduce the frequency of a pessimistic escalation policy, which may require unloading the current <xref:System.AppDomain> or recycling the process."}]}]},{"pos":[1691,2223],"content":"<xref:System.Runtime.MemoryFailPoint> checks to see whether sufficient memory and consecutive virtual address space are available in all garbage collection heaps, and may increase the size of the swap file.  <xref:System.Runtime.MemoryFailPoint> makes no guarantees regarding the long-term availability of the memory during the lifetime of the gate, but callers should always use the <xref:System.Runtime.MemoryFailPoint.Dispose%2A> method to ensure that resources associated with <xref:System.Runtime.MemoryFailPoint> are released.","nodes":[{"content":"<xref:System.Runtime.MemoryFailPoint> checks to see whether sufficient memory and consecutive virtual address space are available in all garbage collection heaps, and may increase the size of the swap file.  <xref:System.Runtime.MemoryFailPoint> makes no guarantees regarding the long-term availability of the memory during the lifetime of the gate, but callers should always use the <xref:System.Runtime.MemoryFailPoint.Dispose%2A> method to ensure that resources associated with <xref:System.Runtime.MemoryFailPoint> are released.","pos":[0,532],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.MemoryFailPoint&gt;</ph> checks to see whether sufficient memory and consecutive virtual address space are available in all garbage collection heaps, and may increase the size of the swap file.","pos":[0,206],"source":"<xref:System.Runtime.MemoryFailPoint> checks to see whether sufficient memory and consecutive virtual address space are available in all garbage collection heaps, and may increase the size of the swap file."},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.MemoryFailPoint&gt;</ph> makes no guarantees regarding the long-term availability of the memory during the lifetime of the gate, but callers should always use the <ph id=\"ph2\">&lt;xref:System.Runtime.MemoryFailPoint.Dispose%2A&gt;</ph> method to ensure that resources associated with <ph id=\"ph3\">&lt;xref:System.Runtime.MemoryFailPoint&gt;</ph> are released.","pos":[208,532],"source":"  <xref:System.Runtime.MemoryFailPoint> makes no guarantees regarding the long-term availability of the memory during the lifetime of the gate, but callers should always use the <xref:System.Runtime.MemoryFailPoint.Dispose%2A> method to ensure that resources associated with <xref:System.Runtime.MemoryFailPoint> are released."}]}]},{"pos":[2230,2510],"content":"To use a memory gate, you must create a <xref:System.Runtime.MemoryFailPoint> object and specify the number of megabytes (MB) of memory that the next operation is expected to use. If enough memory is not available, an <xref:System.InsufficientMemoryException> exception is thrown.","nodes":[{"content":"To use a memory gate, you must create a <xref:System.Runtime.MemoryFailPoint> object and specify the number of megabytes (MB) of memory that the next operation is expected to use. If enough memory is not available, an <xref:System.InsufficientMemoryException> exception is thrown.","pos":[0,280],"nodes":[{"content":"To use a memory gate, you must create a <ph id=\"ph1\">&lt;xref:System.Runtime.MemoryFailPoint&gt;</ph> object and specify the number of megabytes (MB) of memory that the next operation is expected to use.","pos":[0,179],"source":"To use a memory gate, you must create a <xref:System.Runtime.MemoryFailPoint> object and specify the number of megabytes (MB) of memory that the next operation is expected to use."},{"content":"If enough memory is not available, an <ph id=\"ph1\">&lt;xref:System.InsufficientMemoryException&gt;</ph> exception is thrown.","pos":[180,280],"source":" If enough memory is not available, an <xref:System.InsufficientMemoryException> exception is thrown."}]}]},{"pos":[2517,2657],"content":"The parameter of the constructor must be a positive integer. A negative value raises an <xref:System.ArgumentOutOfRangeException> exception.","nodes":[{"content":"The parameter of the constructor must be a positive integer. A negative value raises an <xref:System.ArgumentOutOfRangeException> exception.","pos":[0,140],"nodes":[{"content":"The parameter of the constructor must be a positive integer.","pos":[0,60]},{"content":"A negative value raises an <ph id=\"ph1\">&lt;xref:System.ArgumentOutOfRangeException&gt;</ph> exception.","pos":[61,140],"source":" A negative value raises an <xref:System.ArgumentOutOfRangeException> exception."}]}]},{"pos":[2664,2857],"content":"<xref:System.Runtime.MemoryFailPoint> operates at a granularity of 16 MB. Any values smaller than 16 MB are treated as 16 MB, and other values are treated as the next largest multiple of 16 MB.","nodes":[{"content":"<xref:System.Runtime.MemoryFailPoint> operates at a granularity of 16 MB. Any values smaller than 16 MB are treated as 16 MB, and other values are treated as the next largest multiple of 16 MB.","pos":[0,193],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.MemoryFailPoint&gt;</ph> operates at a granularity of 16 MB.","pos":[0,73],"source":"<xref:System.Runtime.MemoryFailPoint> operates at a granularity of 16 MB."},{"content":"Any values smaller than 16 MB are treated as 16 MB, and other values are treated as the next largest multiple of 16 MB.","pos":[74,193]}]}]}],"pos":[643,3521],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Runtime.MemoryFailPoint\"></xref> class, specifying the amount of memory required for successful execution.","nodes":[{"pos":[0,159],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.MemoryFailPoint\"&gt;&lt;/xref&gt;</ph> class, specifying the amount of memory required for successful execution.","source":"Initializes a new instance of the <xref href=\"System.Runtime.MemoryFailPoint\"></xref> class, specifying the amount of memory required for successful execution."}],"pos":[5896,6056],"yaml":true},{"content":"The amount of memory used by your application to process a work item can be determined empirically.  To estimate the amount of memory your application needs to process a request, consider using the <xref:System.GC.GetTotalMemory%2A?displayProperty=fullName> method to determine the amount of memory available before and after calling the method that processes the work item. See the <xref:System.Runtime.MemoryFailPoint> class for a code example that dynamically determines the value for the `sizeInMegabytes` parameter.","nodes":[{"pos":[0,520],"content":"The amount of memory used by your application to process a work item can be determined empirically.  To estimate the amount of memory your application needs to process a request, consider using the <xref:System.GC.GetTotalMemory%2A?displayProperty=fullName> method to determine the amount of memory available before and after calling the method that processes the work item. See the <xref:System.Runtime.MemoryFailPoint> class for a code example that dynamically determines the value for the `sizeInMegabytes` parameter.","nodes":[{"content":"The amount of memory used by your application to process a work item can be determined empirically.","pos":[0,99]},{"content":"To estimate the amount of memory your application needs to process a request, consider using the <ph id=\"ph1\">&lt;xref:System.GC.GetTotalMemory%2A?displayProperty=fullName&gt;</ph> method to determine the amount of memory available before and after calling the method that processes the work item.","pos":[101,374],"source":"  To estimate the amount of memory your application needs to process a request, consider using the <xref:System.GC.GetTotalMemory%2A?displayProperty=fullName> method to determine the amount of memory available before and after calling the method that processes the work item."},{"content":"See the <ph id=\"ph1\">&lt;xref:System.Runtime.MemoryFailPoint&gt;</ph> class for a code example that dynamically determines the value for the <ph id=\"ph2\">`sizeInMegabytes`</ph> parameter.","pos":[375,520],"source":" See the <xref:System.Runtime.MemoryFailPoint> class for a code example that dynamically determines the value for the `sizeInMegabytes` parameter."}]}],"pos":[6067,6588],"yaml":true,"extradata":"MT"},{"content":"The required memory size, in megabytes. This must be a positive value.","nodes":[{"pos":[0,70],"content":"The required memory size, in megabytes. This must be a positive value.","nodes":[{"content":"The required memory size, in megabytes. This must be a positive value.","pos":[0,70],"nodes":[{"content":"The required memory size, in megabytes.","pos":[0,39]},{"content":"This must be a positive value.","pos":[40,70]}]}]}],"pos":[7092,7163],"yaml":true},{"content":"The specified memory size is negative.","nodes":[{"pos":[0,38],"content":"The specified memory size is negative.","nodes":[{"content":"The specified memory size is negative.","pos":[0,38]}]}],"pos":[7341,7380],"yaml":true},{"content":"There is insufficient memory to begin execution of the code protected by the gate.","nodes":[{"pos":[0,82],"content":"There is insufficient memory to begin execution of the code protected by the gate.","nodes":[{"content":"There is insufficient memory to begin execution of the code protected by the gate.","pos":[0,82]}]}],"pos":[7494,7577],"yaml":true},{"content":"Releases all resources used by the <xref href=\"System.Runtime.MemoryFailPoint\"></xref>.","nodes":[{"pos":[0,87],"content":"Releases all resources used by the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.MemoryFailPoint\"&gt;&lt;/xref&gt;</ph>.","source":"Releases all resources used by the <xref href=\"System.Runtime.MemoryFailPoint\"></xref>."}],"pos":[8693,8781],"yaml":true},{"content":"Call <xref:System.Runtime.MemoryFailPoint.Dispose%2A> when you are finished using the <xref:System.Runtime.MemoryFailPoint>. The <xref:System.Runtime.MemoryFailPoint.Dispose%2A> method leaves the <xref:System.Runtime.MemoryFailPoint> in an unusable state. After calling <xref:System.Runtime.MemoryFailPoint>, you must release all references to the <xref:System.Runtime.MemoryFailPoint> so the garbage collector can reclaim the memory that the <xref:System.Runtime.MemoryFailPoint> was occupying. For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  \n  \n> [!NOTE]\n>  Always call <xref:System.Runtime.MemoryFailPoint.Dispose%2A> before you release your last reference to the <xref:System.Runtime.MemoryFailPoint>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.MemoryFailPoint> object's `Finalize` method.","nodes":[{"pos":[0,701],"content":"Call <xref:System.Runtime.MemoryFailPoint.Dispose%2A> when you are finished using the <xref:System.Runtime.MemoryFailPoint>. The <xref:System.Runtime.MemoryFailPoint.Dispose%2A> method leaves the <xref:System.Runtime.MemoryFailPoint> in an unusable state. After calling <xref:System.Runtime.MemoryFailPoint>, you must release all references to the <xref:System.Runtime.MemoryFailPoint> so the garbage collector can reclaim the memory that the <xref:System.Runtime.MemoryFailPoint> was occupying. For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).","nodes":[{"content":"Call <ph id=\"ph1\">&lt;xref:System.Runtime.MemoryFailPoint.Dispose%2A&gt;</ph> when you are finished using the <ph id=\"ph2\">&lt;xref:System.Runtime.MemoryFailPoint&gt;</ph>.","pos":[0,124],"source":"Call <xref:System.Runtime.MemoryFailPoint.Dispose%2A> when you are finished using the <xref:System.Runtime.MemoryFailPoint>."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.MemoryFailPoint.Dispose%2A&gt;</ph> method leaves the <ph id=\"ph2\">&lt;xref:System.Runtime.MemoryFailPoint&gt;</ph> in an unusable state.","pos":[125,255],"source":" The <xref:System.Runtime.MemoryFailPoint.Dispose%2A> method leaves the <xref:System.Runtime.MemoryFailPoint> in an unusable state."},{"content":"After calling <ph id=\"ph1\">&lt;xref:System.Runtime.MemoryFailPoint&gt;</ph>, you must release all references to the <ph id=\"ph2\">&lt;xref:System.Runtime.MemoryFailPoint&gt;</ph> so the garbage collector can reclaim the memory that the <ph id=\"ph3\">&lt;xref:System.Runtime.MemoryFailPoint&gt;</ph> was occupying.","pos":[256,495],"source":" After calling <xref:System.Runtime.MemoryFailPoint>, you must release all references to the <xref:System.Runtime.MemoryFailPoint> so the garbage collector can reclaim the memory that the <xref:System.Runtime.MemoryFailPoint> was occupying."},{"content":"For more information, see <bpt id=\"p1\">[</bpt>Cleaning Up Unmanaged Resources<ept id=\"p1\">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id=\"p2\">[</bpt>Implementing a Dispose Method<ept id=\"p2\">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.","pos":[496,701],"source":" For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md)."}]},{"pos":[709,1024],"content":"[!NOTE]\n Always call <xref:System.Runtime.MemoryFailPoint.Dispose%2A> before you release your last reference to the <xref:System.Runtime.MemoryFailPoint>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.MemoryFailPoint> object's `Finalize` method.","leadings":["","> "],"nodes":[{"content":" Always call <xref:System.Runtime.MemoryFailPoint.Dispose%2A> before you release your last reference to the <xref:System.Runtime.MemoryFailPoint>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.MemoryFailPoint> object's `Finalize` method.","pos":[8,313],"nodes":[{"content":"Always call <ph id=\"ph1\">&lt;xref:System.Runtime.MemoryFailPoint.Dispose%2A&gt;</ph> before you release your last reference to the <ph id=\"ph2\">&lt;xref:System.Runtime.MemoryFailPoint&gt;</ph>.","pos":[1,146],"source":" Always call <xref:System.Runtime.MemoryFailPoint.Dispose%2A> before you release your last reference to the <xref:System.Runtime.MemoryFailPoint>."},{"content":"Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id=\"ph1\">&lt;xref:System.Runtime.MemoryFailPoint&gt;</ph> object's <ph id=\"ph2\">`Finalize`</ph> method.","pos":[147,305],"source":" Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.MemoryFailPoint> object's `Finalize` method."}]}]}],"pos":[8792,9822],"yaml":true,"extradata":"MT"},{"content":"Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <xref href=\"System.Runtime.MemoryFailPoint\"></xref> object.","nodes":[{"pos":[0,175],"content":"Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.MemoryFailPoint\"&gt;&lt;/xref&gt;</ph> object.","source":"Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <xref href=\"System.Runtime.MemoryFailPoint\"></xref> object."}],"pos":[11063,11239],"yaml":true},{"content":"The garbage collector calls the <xref:System.Runtime.MemoryFailPoint.Finalize%2A> method when the current object is ready to be finalized.","nodes":[{"pos":[0,138],"content":"The garbage collector calls the <xref:System.Runtime.MemoryFailPoint.Finalize%2A> method when the current object is ready to be finalized.","nodes":[{"content":"The garbage collector calls the <ph id=\"ph1\">&lt;xref:System.Runtime.MemoryFailPoint.Finalize%2A&gt;</ph> method when the current object is ready to be finalized.","pos":[0,138],"source":"The garbage collector calls the <xref:System.Runtime.MemoryFailPoint.Finalize%2A> method when the current object is ready to be finalized."}]}],"pos":[11250,11389],"yaml":true,"extradata":"MT"}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Runtime.MemoryFailPoint\n  commentId: T:System.Runtime.MemoryFailPoint\n  id: MemoryFailPoint\n  children:\n  - System.Runtime.MemoryFailPoint.#ctor(System.Int32)\n  - System.Runtime.MemoryFailPoint.Dispose\n  - System.Runtime.MemoryFailPoint.Finalize\n  langs:\n  - csharp\n  name: MemoryFailPoint\n  nameWithType: MemoryFailPoint\n  fullName: System.Runtime.MemoryFailPoint\n  type: Class\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime\n  summary: Checks for sufficient memory resources before executing an operation. This class cannot be inherited.\n  remarks: \"> [!NOTE]\\n>  This class is intended for use in advanced development.  \\n  \\n Creating an instance of the <xref:System.Runtime.MemoryFailPoint> class creates a memory gate. A memory gate checks for sufficient resources before initiating an activity that requires a large amount of memory. Failing the check results in an <xref:System.InsufficientMemoryException> exception being thrown. This exception prevents an operation from being started and reduces the possibility of failure due to lack of resources. This enables you decrease performance to avoid an <xref:System.OutOfMemoryException> exception and any state corruption that may result from improper handling of the exception in arbitrary locations in your code.  \\n  \\n> [!IMPORTANT]\\n>  This type implements the <xref:System.IDisposable> interface. When you have finished using the type, you should dispose of it either directly or indirectly. To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block. To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic). For more information, see the \\\"Using an Object that Implements IDisposable\\\" section in the <xref:System.IDisposable> interface topic.  \\n  \\n By throwing an <xref:System.InsufficientMemoryException> exception, an application can distinguish between an estimate that an operation will not be able to complete and  a partially completed operation that may have corrupted the application state. This allows an application to reduce the frequency of a pessimistic escalation policy, which may require unloading the current <xref:System.AppDomain> or recycling the process.  \\n  \\n <xref:System.Runtime.MemoryFailPoint> checks to see whether sufficient memory and consecutive virtual address space are available in all garbage collection heaps, and may increase the size of the swap file.  <xref:System.Runtime.MemoryFailPoint> makes no guarantees regarding the long-term availability of the memory during the lifetime of the gate, but callers should always use the <xref:System.Runtime.MemoryFailPoint.Dispose%2A> method to ensure that resources associated with <xref:System.Runtime.MemoryFailPoint> are released.  \\n  \\n To use a memory gate, you must create a <xref:System.Runtime.MemoryFailPoint> object and specify the number of megabytes (MB) of memory that the next operation is expected to use. If enough memory is not available, an <xref:System.InsufficientMemoryException> exception is thrown.  \\n  \\n The parameter of the constructor must be a positive integer. A negative value raises an <xref:System.ArgumentOutOfRangeException> exception.  \\n  \\n <xref:System.Runtime.MemoryFailPoint> operates at a granularity of 16 MB. Any values smaller than 16 MB are treated as 16 MB, and other values are treated as the next largest multiple of 16 MB.\"\n  example:\n  - \"<xref:System.Runtime.MemoryFailPoint> enables an application to slow itself to avoid running out of memory in a corrupting manner.  It should be used within a lexical scope.  The following example launches threads to process items in a work queue.  Before each thread is launched, the available memory resources are checked using <xref:System.Runtime.MemoryFailPoint>.  If an exception is thrown, the main method waits until memory is available before launching the next thread.  \\n  \\n [!code-csharp[MemoryFailPoint#1](~/samples/snippets/csharp/VS_Snippets_CLR/MemoryFailPoint/CS/program.cs#1)]\"\n  syntax:\n    content: 'public sealed class MemoryFailPoint : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable'\n  inheritance:\n  - System.Object\n  - System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  implements:\n  - System.IDisposable\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime/MemoryFailPoint.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.MemoryFailPoint.#ctor(System.Int32)\n  commentId: M:System.Runtime.MemoryFailPoint.#ctor(System.Int32)\n  id: '#ctor(System.Int32)'\n  parent: System.Runtime.MemoryFailPoint\n  langs:\n  - csharp\n  name: MemoryFailPoint(Int32)\n  nameWithType: MemoryFailPoint.MemoryFailPoint(Int32)\n  fullName: MemoryFailPoint.MemoryFailPoint(Int32)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime\n  summary: Initializes a new instance of the <xref href=\"System.Runtime.MemoryFailPoint\"></xref> class, specifying the amount of memory required for successful execution.\n  remarks: The amount of memory used by your application to process a work item can be determined empirically.  To estimate the amount of memory your application needs to process a request, consider using the <xref:System.GC.GetTotalMemory%2A?displayProperty=fullName> method to determine the amount of memory available before and after calling the method that processes the work item. See the <xref:System.Runtime.MemoryFailPoint> class for a code example that dynamically determines the value for the `sizeInMegabytes` parameter.\n  example:\n  - \"The following example demonstrates how to determine the amount of memory a method requires when executing. This code example is part of a larger example provided for the <xref:System.Runtime.MemoryFailPoint> class.  \\n  \\n [!code-csharp[MemoryFailPoint#2](~/samples/snippets/csharp/VS_Snippets_CLR/MemoryFailPoint/CS/program.cs#2)]\"\n  syntax:\n    content: public MemoryFailPoint (int sizeInMegabytes);\n    parameters:\n    - id: sizeInMegabytes\n      type: System.Int32\n      description: The required memory size, in megabytes. This must be a positive value.\n  overload: System.Runtime.MemoryFailPoint.#ctor*\n  exceptions:\n  - type: System.ArgumentOutOfRangeException\n    commentId: T:System.ArgumentOutOfRangeException\n    description: The specified memory size is negative.\n  - type: System.InsufficientMemoryException\n    commentId: T:System.InsufficientMemoryException\n    description: There is insufficient memory to begin execution of the code protected by the gate.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime/MemoryFailPoint.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.MemoryFailPoint.Dispose\n  commentId: M:System.Runtime.MemoryFailPoint.Dispose\n  id: Dispose\n  parent: System.Runtime.MemoryFailPoint\n  langs:\n  - csharp\n  name: Dispose()\n  nameWithType: MemoryFailPoint.Dispose()\n  fullName: MemoryFailPoint.Dispose()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime\n  summary: Releases all resources used by the <xref href=\"System.Runtime.MemoryFailPoint\"></xref>.\n  remarks: \"Call <xref:System.Runtime.MemoryFailPoint.Dispose%2A> when you are finished using the <xref:System.Runtime.MemoryFailPoint>. The <xref:System.Runtime.MemoryFailPoint.Dispose%2A> method leaves the <xref:System.Runtime.MemoryFailPoint> in an unusable state. After calling <xref:System.Runtime.MemoryFailPoint>, you must release all references to the <xref:System.Runtime.MemoryFailPoint> so the garbage collector can reclaim the memory that the <xref:System.Runtime.MemoryFailPoint> was occupying. For more information, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).  \\n  \\n> [!NOTE]\\n>  Always call <xref:System.Runtime.MemoryFailPoint.Dispose%2A> before you release your last reference to the <xref:System.Runtime.MemoryFailPoint>. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.MemoryFailPoint> object's `Finalize` method.\"\n  syntax:\n    content: public void Dispose ();\n    parameters: []\n  overload: System.Runtime.MemoryFailPoint.Dispose*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime/MemoryFailPoint.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.MemoryFailPoint.Finalize\n  commentId: M:System.Runtime.MemoryFailPoint.Finalize\n  id: Finalize\n  parent: System.Runtime.MemoryFailPoint\n  langs:\n  - csharp\n  name: Finalize()\n  nameWithType: MemoryFailPoint.Finalize()\n  fullName: MemoryFailPoint.Finalize()\n  type: Method\n  assemblies:\n  - mscorlib\n  - System.Runtime\n  namespace: System.Runtime\n  summary: Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <xref href=\"System.Runtime.MemoryFailPoint\"></xref> object.\n  remarks: The garbage collector calls the <xref:System.Runtime.MemoryFailPoint.Finalize%2A> method when the current object is ready to be finalized.\n  syntax:\n    content: ~MemoryFailPoint ();\n    parameters: []\n  overload: System.Runtime.MemoryFailPoint.Finalize*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime/MemoryFailPoint.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n  parent: System.Runtime.ConstrainedExecution\n  isExternal: false\n  name: CriticalFinalizerObject\n  nameWithType: CriticalFinalizerObject\n  fullName: System.Runtime.ConstrainedExecution.CriticalFinalizerObject\n- uid: System.ArgumentOutOfRangeException\n  parent: System\n  isExternal: false\n  name: ArgumentOutOfRangeException\n  nameWithType: ArgumentOutOfRangeException\n  fullName: System.ArgumentOutOfRangeException\n- uid: System.InsufficientMemoryException\n  parent: System\n  isExternal: false\n  name: InsufficientMemoryException\n  nameWithType: InsufficientMemoryException\n  fullName: System.InsufficientMemoryException\n- uid: System.Runtime.MemoryFailPoint.#ctor(System.Int32)\n  parent: System.Runtime.MemoryFailPoint\n  isExternal: false\n  name: MemoryFailPoint(Int32)\n  nameWithType: MemoryFailPoint.MemoryFailPoint(Int32)\n  fullName: MemoryFailPoint.MemoryFailPoint(Int32)\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Runtime.MemoryFailPoint.Dispose\n  parent: System.Runtime.MemoryFailPoint\n  isExternal: false\n  name: Dispose()\n  nameWithType: MemoryFailPoint.Dispose()\n  fullName: MemoryFailPoint.Dispose()\n- uid: System.Runtime.MemoryFailPoint.Finalize\n  parent: System.Runtime.MemoryFailPoint\n  isExternal: false\n  name: Finalize()\n  nameWithType: MemoryFailPoint.Finalize()\n  fullName: MemoryFailPoint.Finalize()\n- uid: System.Runtime.MemoryFailPoint.#ctor*\n  parent: System.Runtime.MemoryFailPoint\n  isExternal: false\n  name: MemoryFailPoint\n  nameWithType: MemoryFailPoint.MemoryFailPoint\n  fullName: MemoryFailPoint.MemoryFailPoint\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime/MemoryFailPoint.xml\n- uid: System.Runtime.MemoryFailPoint.Dispose*\n  parent: System.Runtime.MemoryFailPoint\n  isExternal: false\n  name: Dispose\n  nameWithType: MemoryFailPoint.Dispose\n  fullName: MemoryFailPoint.Dispose\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime/MemoryFailPoint.xml\n- uid: System.Runtime.MemoryFailPoint.Finalize*\n  parent: System.Runtime.MemoryFailPoint\n  isExternal: false\n  name: Finalize\n  nameWithType: MemoryFailPoint.Finalize\n  fullName: MemoryFailPoint.Finalize\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime/MemoryFailPoint.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.IDisposable\n  parent: System\n  isExternal: false\n  name: IDisposable\n  nameWithType: IDisposable\n  fullName: System.IDisposable\n"}