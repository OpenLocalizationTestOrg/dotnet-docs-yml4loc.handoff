<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">5af25979e8a1f185bff6493d5ec189b4046e793d</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Runtime.CompilerServices.RuntimeHelpers.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">8b6403a2e466851a436cbe5624a0cca7e275683f</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">70c8c7f57f74dff221649bf4088f253b63e2afb9</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Provides a set of static methods and properties that provide support for compilers.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve">
          <source>This class cannot be inherited.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Ensures that the remaining stack space is large enough to execute the average .NET Framework function.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.EnsureSufficientExecutionStack%2A&gt;</ph> provides information about an artificially limited stack that preserves enough space for an exception to be raised and recovery action to be taken.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>The artificial stack limit is chosen by the common language runtime to ensure that enough space remains to throw an exception safely.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is useful in situations where stack overflow might occur as a result of unbounded recursion.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>It is intended for use in compiler services scenarios, although it can also be used safely in other development scenarios.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the stack space is sufficient, the exception is not thrown, and most .NET Framework types and members can still be called.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is not part of the constrained execution region (CER) support, and should not be confused with the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>The available stack space is insufficient to execute the average .NET Framework function.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Determines whether the specified <ph id="ph1">&lt;xref href="System.Object"&gt;&lt;/xref&gt;</ph> instances are considered equal.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used by compilers.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>The first object to compare.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>The second object to compare.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">o1</ph><ept id="p1">&lt;/code&gt;</ept> parameter is the same instance as the <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">o2</ph><ept id="p2">&lt;/code&gt;</ept> parameter, or if both are <ph id="ph4">`null`</ph>, or if <bpt id="p3">&lt;code&gt;</bpt><ph id="ph5">o1.Equals(o2)</ph><ept id="p3">&lt;/code&gt;</ept> returns <ph id="ph6">`true`</ph>; otherwise, <ph id="ph7">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Executes code using a <ph id="ph1">&lt;xref href="System.Delegate"&gt;&lt;/xref&gt;</ph> while using another <ph id="ph2">&lt;xref href="System.Delegate"&gt;&lt;/xref&gt;</ph> to execute additional code in case of an exception.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used by compilers.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>A delegate to the code to try.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>A delegate to the code to run if an exception occurs.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>The data to pass to <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">code</ph><ept id="p1">&lt;/code&gt;</ept> and <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">backoutCode</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source>Serves as a hash function for a particular object, and is suitable for use in algorithms and data structures that use hash codes, such as a hash table.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph> method always calls the <ph id="ph2">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> method non-virtually, even if the object's type has overridden the <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, using <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph> might differ from calling <ph id="ph2">`GetHashCode`</ph> directly on the object with the <ph id="ph3">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT">
          <source>Although the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph> method returns identical hash codes for identical object references, you should not use this method to test for object identity, because this hash code does not uniquely identify an object reference.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT">
          <source>To test for object identify (that is, to test that two objects reference the same object in memory), call the <ph id="ph1">&lt;xref:System.Object.ReferenceEquals%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT">
          <source>Nor should you use <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> to test whether two strings represent equal object references, because the string is interned.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT">
          <source>To test for string interning, call the <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph> methods differ as follows:</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph> returns a hash code that is based on the object's definition of equality.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, two strings with identical contents will return the same value for <ph id="ph1">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph> returns a hash code that indicates object identity.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, two string variables whose contents are identical and that represent a string that is interned (see the <bpt id="p1">[</bpt>String Interning<ept id="p1">](#interning)</ept> section) or that represent a single string in memory return identical hash codes.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A&gt;</ph> always returns identical hash codes for equal object references.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, the reverse is not true: equal hash codes do not indicate equal object references.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT">
          <source>A particular hash code value is not unique to a particular object reference; different object references can generate identical hash codes.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used by compilers.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>String Interning</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime (CLR) maintains an internal pool of strings and stores literals in the pool.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>If two strings (for example, <ph id="ph1">`str1`</ph> and <ph id="ph2">`str2`</ph>) are formed from an identical string literal, the CLR will set <ph id="ph3">`str1`</ph> and <ph id="ph4">`str2`</ph> to point to the same location on the managed heap to conserve memory.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>Calling <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph> on these two string objects will produce the same hash code, contrary to the second bulleted item in the previous section.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>The CLR adds only literals to the pool.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>Results of string operations such as concatenation are not added to the pool, unless the compiler resolves the string concatenation as a single string literal.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, if <ph id="ph1">`str2`</ph> was created as the result of a concatenation operation, and <ph id="ph2">`str2`</ph> is identical to <ph id="ph3">`str1`</ph>, using <ph id="ph4">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=fullName&gt;</ph> on these two string objects will not produce the same hash code.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you want to add a concatenated string to the pool explicitly, use the <ph id="ph1">&lt;xref:System.String.Intern%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can also use the <ph id="ph1">&lt;xref:System.String.IsInterned%2A?displayProperty=fullName&gt;</ph> method to check whether a string has an interned reference.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve">
          <source>An object to retrieve the hash code for.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>A hash code for the object identified by the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">o</ph><ept id="p1">&lt;/code&gt;</ept> parameter.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Boxes a value type.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT">
          <source>Boxing a value type creates an object and performs a shallow copy of the fields of the specified value type into the new object.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method allows a value class to be manipulated as an object while it retains the aliasing behavior of a value class.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value depends on whether the value class is mutable or immutable:</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value being assigned is a mutable value class, the method returns a shallow copy of the class, because value classes have copy semantics.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the value being assigned is an immutable value class, the method returns the object itself, instead of a copy of the class.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compilers of dynamically typed languages can use this method to make sure that boxed value types work identically to unboxed value types.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, boxed value types get cloned when you pass them around, and they are always passed by value.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>The compiler can call <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.GetObjectValue%2A&gt;</ph> to assign a value type to an object or to pass a value type as a parameter of a type object.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used by compilers.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>The value type to be boxed.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>A boxed copy of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">obj</ph><ept id="p1">&lt;/code&gt;</ept> if it is a value class; otherwise, <bpt id="p2">&lt;code&gt;</bpt><ph id="ph2">obj</ph><ept id="p2">&lt;/code&gt;</ept> itself.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Provides a fast way to initialize an array from data that is stored in a module.</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used by compilers.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The array to be initialized.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A field handle that specifies the location of the data used to initialize the array.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source>Gets the offset, in bytes, to the data in the given string.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compilers use this property for unsafe, but efficient, pointer operations on the characters in a managed string.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compilers should pin the string against movement by the garbage collector before use.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that common language runtime strings are immutable; that is, their contents can be read but not changed.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve">
          <source>The byte offset, from the start of the <ph id="ph1">&lt;xref href="System.String"&gt;&lt;/xref&gt;</ph> object to the first character in the string.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>Designates a body of code as a constrained execution region (CER).</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compilers use this method to mark <ph id="ph1">`catch`</ph>, <ph id="ph2">`finally`</ph>, and <ph id="ph3">`fault`</ph> blocks as constrained execution regions (CERs).</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT">
          <source>Code that is marked as a constrained region must only call other code with strong reliability contracts.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT">
          <source>It should not allocate or make virtual calls to unprepared or unreliable methods unless it is prepared to handle failures.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note that no intermediate language opcodes, except <ph id="ph1">`NOP`</ph>, are allowed between a call to the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method and the <ph id="ph3">`try`</ph> block.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about CERs, see the classes in the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution&gt;</ph> namespace.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT">
          <source>CERs that are marked using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method do not work perfectly when a <ph id="ph2">&lt;xref:System.StackOverflowException&gt;</ph> is generated from the <ph id="ph3">`try`</ph> block.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A&gt;</ph> method calls the <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve">
          <source>Designates a body of code as a constrained execution region (CER) without performing any probing.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compilers should not call this method directly.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead, define a CER by calling the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve">
          <source>Provides a way for applications to dynamically prepare <ph id="ph1">&lt;xref href="System.AppDomain"&gt;&lt;/xref&gt;</ph> event delegates.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.AppDomain&gt;</ph> event delegates such as <ph id="ph2">&lt;xref:System.AppDomain.DomainUnload&gt;</ph>, <ph id="ph3">&lt;xref:System.AppDomain.ProcessExit&gt;</ph>, and <ph id="ph4">&lt;xref:System.AppDomain.UnhandledException&gt;</ph> are not automatically prepared at startup.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use the following methods to prepare them:</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attribute the method by using the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>Attribute the method by using the <ph id="ph1">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>Call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareContractedDelegate%2A&gt;</ph> method to dynamically prepare the delegate.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information, see the article <bpt id="p1">[</bpt>Keep Your Code Running with the Reliability Features of the .NET Framework<ept id="p1">](http://go.microsoft.com/fwlink/?LinkId=145491)</ept> in the MSDN Magazine.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve">
          <source>The event delegate to prepare.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve">
          <source>Indicates that the specified delegate should be prepared for inclusion in a constrained execution region (CER).</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compilers use this method to prepare a delegate's invocation method and to prepare the target of that invocation (and the delegate's statically determinable call graph) as a constrained execution region (CER).</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve">
          <source>The delegate type to prepare.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve">
          <source>Prepares a method for inclusion in a constrained execution region (CER).</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>Compilers use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> method to handle virtual calls that are made inside a constrained execution region (CER).</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>At JIT compilation time, the common language runtime does not usually have enough information about the target of a virtual call.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, the runtime does not initially prepare that segment of the call graph.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the code that is using the CER has enough knowledge to determine the target at any point in time before the CER is actually entered, it can call <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%29&gt;</ph> to perform the same runtime preparation normally done for a CER rooted at the method specified as an argument.</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve">
          <source>A handle to the method to prepare.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve">
          <source>Prepares a method for inclusion in a constrained execution region (CER) with the specified instantiation.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can provide generics support for compilers by using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime cannot prepare constrained execution regions (CERs) rooted in a method that has generic type parameters (either a type parameter on the class containing the method or one on the method itself) when those type parameters are instantiated as reference types.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can use this overload to pass a specific instantiation (such as an array of types), specifying class type parameters first (if any), followed by method type parameters (if any).</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>The runtime prepares that instantiation of the method.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>(This is necessary only if the instantiations you use contain at least one reference type parameter.) Thus, you can use a CER-style <ph id="ph1">`try`</ph> clause in a generic method (or a nongeneric method on a generic class) and it will work reliably with instantiations of <ph id="ph2">&lt;xref:System.Int32&gt;</ph> or other value types.</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>To instantiate reference types such as <ph id="ph1">&lt;xref:System.String&gt;</ph>, you must use an explicit <ph id="ph2">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareMethod%28System.RuntimeMethodHandle%2CSystem.RuntimeTypeHandle%5B%5D%29&gt;</ph> method on the CER root method first.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>A handle to the method to prepare.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>The instantiation to pass to the method.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>Probes for a certain amount of stack space to ensure that a stack overflow cannot happen within a subsequent block of code (assuming that your code uses only a finite and moderate amount of stack space).</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>We recommend that you use a constrained execution region (CER) instead of this method.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used by the constrained execution region (CER) infrastructure when running in hosts that are resilient to stack overflow such as Microsoft SQL Server and Microsoft Exchange Server.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method currently probes for 48 KB of stack space on the x86 platform, but the exact amount may change over time and may vary on other platforms.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is also used by compilers.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT">
          <source>Instead of using the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ProbeForSufficientStack%2A&gt;</ph> method, you should use a standard CER.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, if you are planning to use a moderate amount of stack space, call the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.PrepareConstrainedRegions%2A?displayProperty=fullName&gt;</ph> method immediately before your <ph id="ph2">`try`</ph><ph id="ph3">/</ph><ph id="ph4">`finally`</ph> or <ph id="ph5">`try`</ph><ph id="ph6">/</ph><ph id="ph7">`catch`</ph> block.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you are calling a recursive method or plan to use a lot of stack space, you must use the <ph id="ph1">&lt;xref:System.Runtime.CompilerServices.RuntimeHelpers.ExecuteCodeWithGuaranteedCleanup%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>Runs a specified class constructor method.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used by compilers.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>A type handle that specifies the class constructor method to run.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>The class initializer throws an exception.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>Runs a specified module constructor method.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is used by compilers.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>A handle that specifies the module constructor method to run.</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>The module constructor throws an exception.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>