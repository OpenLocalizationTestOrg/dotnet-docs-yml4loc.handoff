<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">0e8a2a741501cbad34c391af933bc359d02eaab2</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Net.Sockets.SocketType.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">22842386276c1552337b1edfc8346c2fc6a227c2</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">49494c00f4ee9297ed5ba4640801befd68122c3b</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Specifies the type of socket that an instance of the <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> class represents.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source>Before a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> can send and receive data, it must first be created using an <ph id="ph2">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and a <ph id="ph4">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType&gt;</ph> enumeration provides several options for defining the type of <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you intend to open.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketType&gt;</ph> will sometimes implicitly indicate which <ph id="ph2">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> will be used within an <ph id="ph3">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example when the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType&gt;</ph> is Dgram, the <ph id="ph2">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> is always <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph>.When the <ph id="ph4">&lt;xref:System.Net.Sockets.SocketType&gt;</ph> is Stream, the <ph id="ph5">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> is always <ph id="ph6">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>If you try to create a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> with an incompatible combination, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve">
          <source>Supports datagrams, which are connectionless, unreliable messages of a fixed (typically small) maximum length.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve">
          <source>Messages might be lost or duplicated and might arrive out of order.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Net.Sockets.Socket"&gt;&lt;/xref&gt;</ph> of type <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketType.Dgram"&gt;&lt;/xref&gt;</ph> requires no connection prior to sending and receiving data, and can communicate with multiple peers.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.SocketType.Dgram"&gt;&lt;/xref&gt;</ph> uses the Datagram Protocol (<ph id="ph2">&lt;xref href="System.Net.Sockets.ProtocolType.Udp"&gt;&lt;/xref&gt;</ph>) and the <ph id="ph3">&lt;xref href="System.Net.Sockets.AddressFamily.InterNetwork"&gt;&lt;/xref&gt;</ph><ph id="ph4">&lt;xref href="System.Net.Sockets.AddressFamily"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>Supports access to the underlying transport protocol.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Using the <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketType"&gt;&lt;/xref&gt;</ph><ph id="ph2">&lt;xref href="System.Net.Sockets.SocketType.Raw"&gt;&lt;/xref&gt;</ph>, you can communicate using protocols like Internet Control Message Protocol (<ph id="ph3">&lt;xref href="System.Net.Sockets.ProtocolType.Icmp"&gt;&lt;/xref&gt;</ph>) and Internet Group Management Protocol (<ph id="ph4">&lt;xref href="System.Net.Sockets.ProtocolType.Igmp"&gt;&lt;/xref&gt;</ph>).</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve">
          <source>Your application must provide a complete IP header when sending.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve">
          <source>Received datagrams return with the IP header and options intact.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve">
          <source>Supports connectionless, message-oriented, reliably delivered messages, and preserves message boundaries in data.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve">
          <source>Rdm (Reliably Delivered Messages) messages arrive unduplicated and in order.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve">
          <source>Furthermore, the sender is notified if messages are lost.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve">
          <source>If you initialize a <ph id="ph1">`Socket`</ph> using <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketType.Rdm"&gt;&lt;/xref&gt;</ph>, you do not require a remote host connection before sending and receiving data.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve">
          <source>With <ph id="ph1">&lt;xref href="System.Net.Sockets.SocketType.Rdm"&gt;&lt;/xref&gt;</ph>, you can communicate with multiple peers.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve">
          <source>Provides connection-oriented and reliable two-way transfer of ordered byte streams across a network.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.SocketType.Seqpacket"&gt;&lt;/xref&gt;</ph> does not duplicate data, and it preserves boundaries within the data stream.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Socket`</ph> of type <ph id="ph2">&lt;xref href="System.Net.Sockets.SocketType.Seqpacket"&gt;&lt;/xref&gt;</ph> communicates with a single peer and requires a remote host connection before communication can begin.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source>Supports reliable, two-way, connection-based byte streams without the duplication of data and without preservation of boundaries.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`Socket`</ph> of this type communicates with a single peer and requires a remote host connection before communication can begin.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Net.Sockets.SocketType.Stream"&gt;&lt;/xref&gt;</ph> uses the Transmission Control Protocol (<ph id="ph2">&lt;xref href="System.Net.Sockets.ProtocolType.Tcp"&gt;&lt;/xref&gt;</ph>) <ph id="ph3">&lt;xref href="System.Net.Sockets.ProtocolType"&gt;&lt;/xref&gt;</ph> and the <ph id="ph4">`InterNetwork`</ph><ph id="ph5">&lt;xref href="System.Net.Sockets.AddressFamily"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source>Specifies an unknown <ph id="ph1">`Socket`</ph> type.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>