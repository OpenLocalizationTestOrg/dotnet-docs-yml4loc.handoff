{"nodes":[{"content":"Lets you control the physical layout of the data fields of a class or structure in memory.","nodes":[{"pos":[0,90],"content":"Lets you control the physical layout of the data fields of a class or structure in memory.","nodes":[{"content":"Lets you control the physical layout of the data fields of a class or structure in memory.","pos":[0,90]}]}],"pos":[923,1014],"yaml":true},{"content":"You can apply this attribute to classes or structures.  \n  \n The common language runtime controls the physical layout of the data fields of a class or structure in managed memory. However, if you want to pass the type to unmanaged code, you can use the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute to control the unmanaged layout of the type. Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> to force the members to be laid out sequentially in the order they appear. For , <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> controls both the layout in managed memory and the layout in unmanaged memory. For non-blittable types, it controls the layout when the class or structure is marshaled to unmanaged code, but does not control the layout in managed memory. Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> to control the precise position of each data member. This affects both managed and unmanaged layout, for both blittable and non-blittable types. Using <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> requires that you use the <xref:System.Runtime.InteropServices.FieldOffsetAttribute> attribute to indicate the position of each field within the type.  \n  \n C#, Visual Basic, and C++ compilers apply the <xref:System.Runtime.InteropServices.LayoutKind.Sequential> layout value to structures by default. For classes, you must apply the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> value explicitly. The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) also applies the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute; it always applies the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> value when it imports a type library.","nodes":[{"pos":[0,54],"content":"You can apply this attribute to classes or structures.","nodes":[{"content":"You can apply this attribute to classes or structures.","pos":[0,54]}]},{"pos":[61,1330],"content":"The common language runtime controls the physical layout of the data fields of a class or structure in managed memory. However, if you want to pass the type to unmanaged code, you can use the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute to control the unmanaged layout of the type. Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> to force the members to be laid out sequentially in the order they appear. For , <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> controls both the layout in managed memory and the layout in unmanaged memory. For non-blittable types, it controls the layout when the class or structure is marshaled to unmanaged code, but does not control the layout in managed memory. Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> to control the precise position of each data member. This affects both managed and unmanaged layout, for both blittable and non-blittable types. Using <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> requires that you use the <xref:System.Runtime.InteropServices.FieldOffsetAttribute> attribute to indicate the position of each field within the type.","nodes":[{"content":"The common language runtime controls the physical layout of the data fields of a class or structure in managed memory. However, if you want to pass the type to unmanaged code, you can use the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute to control the unmanaged layout of the type. Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> to force the members to be laid out sequentially in the order they appear. For , <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> controls both the layout in managed memory and the layout in unmanaged memory. For non-blittable types, it controls the layout when the class or structure is marshaled to unmanaged code, but does not control the layout in managed memory. Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> to control the precise position of each data member. This affects both managed and unmanaged layout, for both blittable and non-blittable types. Using <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> requires that you use the <xref:System.Runtime.InteropServices.FieldOffsetAttribute> attribute to indicate the position of each field within the type.","pos":[0,1269],"nodes":[{"content":"The common language runtime controls the physical layout of the data fields of a class or structure in managed memory.","pos":[0,118]},{"content":"However, if you want to pass the type to unmanaged code, you can use the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute to control the unmanaged layout of the type.","pos":[119,306],"source":" However, if you want to pass the type to unmanaged code, you can use the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute to control the unmanaged layout of the type."},{"content":"Use the attribute with <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> to force the members to be laid out sequentially in the order they appear.","pos":[307,478],"source":" Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> to force the members to be laid out sequentially in the order they appear."},{"content":"For , <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> controls both the layout in managed memory and the layout in unmanaged memory.","pos":[479,637],"source":" For , <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> controls both the layout in managed memory and the layout in unmanaged memory."},{"content":"For non-blittable types, it controls the layout when the class or structure is marshaled to unmanaged code, but does not control the layout in managed memory.","pos":[638,796]},{"content":"Use the attribute with <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> to control the precise position of each data member.","pos":[797,946],"source":" Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> to control the precise position of each data member."},{"content":"This affects both managed and unmanaged layout, for both blittable and non-blittable types.","pos":[947,1038]},{"content":"Using <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> requires that you use the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.FieldOffsetAttribute&gt;</ph> attribute to indicate the position of each field within the type.","pos":[1039,1269],"source":" Using <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> requires that you use the <xref:System.Runtime.InteropServices.FieldOffsetAttribute> attribute to indicate the position of each field within the type."}]}]},{"pos":[1337,1928],"content":"C#, Visual Basic, and C++ compilers apply the <xref:System.Runtime.InteropServices.LayoutKind.Sequential> layout value to structures by default. For classes, you must apply the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> value explicitly. The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) also applies the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute; it always applies the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> value when it imports a type library.","nodes":[{"content":"C#, Visual Basic, and C++ compilers apply the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.LayoutKind.Sequential&gt;</ph> layout value to structures by default.","pos":[0,144],"source":"C#, Visual Basic, and C++ compilers apply the <xref:System.Runtime.InteropServices.LayoutKind.Sequential> layout value to structures by default."},{"content":"For classes, you must apply the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> value explicitly.","pos":[145,268],"source":" For classes, you must apply the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> value explicitly."},{"content":"The <bpt id=\"p1\">[</bpt>Tlbimp.exe (Type Library Importer)<ept id=\"p1\">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> also applies the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute; it always applies the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> value when it imports a type library.","pos":[269,591],"source":" The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) also applies the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute; it always applies the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> value when it imports a type library."}]}],"pos":[1025,2960],"yaml":true,"extradata":"MT"},{"content":"Initalizes a new instance of the <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"></xref> class with the specified <xref href=\"System.Runtime.InteropServices.LayoutKind\"></xref> enumeration member.","nodes":[{"pos":[0,214],"content":"Initalizes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"&gt;&lt;/xref&gt;</ph> class with the specified <ph id=\"ph2\">&lt;xref href=\"System.Runtime.InteropServices.LayoutKind\"&gt;&lt;/xref&gt;</ph> enumeration member.","source":"Initalizes a new instance of the <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"></xref> class with the specified <xref href=\"System.Runtime.InteropServices.LayoutKind\"></xref> enumeration member."}],"pos":[9422,9637],"yaml":true},{"content":"This constructor takes an underlying 16-bit integer that represents each <xref:System.Runtime.InteropServices.LayoutKind> enumeration member. The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) uses this constructor.","nodes":[{"pos":[0,265],"content":"This constructor takes an underlying 16-bit integer that represents each <xref:System.Runtime.InteropServices.LayoutKind> enumeration member. The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) uses this constructor.","nodes":[{"content":"This constructor takes an underlying 16-bit integer that represents each <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.LayoutKind&gt;</ph> enumeration member.","pos":[0,141],"source":"This constructor takes an underlying 16-bit integer that represents each <xref:System.Runtime.InteropServices.LayoutKind> enumeration member."},{"content":"The <bpt id=\"p1\">[</bpt>Tlbimp.exe (Type Library Importer)<ept id=\"p1\">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> uses this constructor.","pos":[142,265],"source":" The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) uses this constructor."}]}],"pos":[9648,9914],"yaml":true,"extradata":"MT"},{"content":"A 16-bit integer that represents one of the <xref href=\"System.Runtime.InteropServices.LayoutKind\"></xref> values that specifes how the class or structure should be arranged.","nodes":[{"pos":[0,174],"content":"A 16-bit integer that represents one of the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.LayoutKind\"&gt;&lt;/xref&gt;</ph> values that specifes how the class or structure should be arranged.","source":"A 16-bit integer that represents one of the <xref href=\"System.Runtime.InteropServices.LayoutKind\"></xref> values that specifes how the class or structure should be arranged."}],"pos":[10067,10242],"yaml":true},{"content":"Initalizes a new instance of the <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"></xref> class with the specified <xref href=\"System.Runtime.InteropServices.LayoutKind\"></xref> enumeration member.","nodes":[{"pos":[0,214],"content":"Initalizes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"&gt;&lt;/xref&gt;</ph> class with the specified <ph id=\"ph2\">&lt;xref href=\"System.Runtime.InteropServices.LayoutKind\"&gt;&lt;/xref&gt;</ph> enumeration member.","source":"Initalizes a new instance of the <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"></xref> class with the specified <xref href=\"System.Runtime.InteropServices.LayoutKind\"></xref> enumeration member."}],"pos":[11765,11980],"yaml":true},{"content":"For readable code that is less prone to error, always use this constructor.","nodes":[{"pos":[0,75],"content":"For readable code that is less prone to error, always use this constructor.","nodes":[{"content":"For readable code that is less prone to error, always use this constructor.","pos":[0,75]}]}],"pos":[11991,12067],"yaml":true,"extradata":"MT"},{"content":"One of the enumeration values that specifes how the class or structure should be arranged.","nodes":[{"pos":[0,90],"content":"One of the enumeration values that specifes how the class or structure should be arranged.","nodes":[{"content":"One of the enumeration values that specifes how the class or structure should be arranged.","pos":[0,90]}]}],"pos":[12285,12376],"yaml":true},{"content":"Indicates whether string data fields within the class should be marshaled as `LPWSTR` or `LPSTR` by default.","nodes":[{"pos":[0,108],"content":"Indicates whether string data fields within the class should be marshaled as <ph id=\"ph1\">`LPWSTR`</ph> or <ph id=\"ph2\">`LPSTR`</ph> by default.","source":"Indicates whether string data fields within the class should be marshaled as `LPWSTR` or `LPSTR` by default."}],"pos":[14034,14143],"yaml":true},{"content":"If the `CharSet` field is set to <xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName>, all string arguments are converted to Unicode characters (`LPWSTR`) before they are passed to the unmanaged implementation. If the field is set to <xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName>, the strings are converted to ANSI strings (`LPSTR`). If the `CharSet` field is set to <xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName>, the conversion is platform-dependent (ANSI on Windows 98 and Windows Me, and Unicode on later versions).","nodes":[{"pos":[0,586],"content":"If the `CharSet` field is set to <xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName>, all string arguments are converted to Unicode characters (`LPWSTR`) before they are passed to the unmanaged implementation. If the field is set to <xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName>, the strings are converted to ANSI strings (`LPSTR`). If the `CharSet` field is set to <xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName>, the conversion is platform-dependent (ANSI on Windows 98 and Windows Me, and Unicode on later versions).","nodes":[{"content":"If the <ph id=\"ph1\">`CharSet`</ph> field is set to <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName&gt;</ph>, all string arguments are converted to Unicode characters (<ph id=\"ph3\">`LPWSTR`</ph>) before they are passed to the unmanaged implementation.","pos":[0,228],"source":"If the `CharSet` field is set to <xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName>, all string arguments are converted to Unicode characters (`LPWSTR`) before they are passed to the unmanaged implementation."},{"content":"If the field is set to <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName&gt;</ph>, the strings are converted to ANSI strings (<ph id=\"ph2\">`LPSTR`</ph>).","pos":[229,376],"source":" If the field is set to <xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName>, the strings are converted to ANSI strings (`LPSTR`)."},{"content":"If the <ph id=\"ph1\">`CharSet`</ph> field is set to <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName&gt;</ph>, the conversion is platform-dependent (ANSI on Windows 98 and Windows Me, and Unicode on later versions).","pos":[377,586],"source":" If the `CharSet` field is set to <xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName>, the conversion is platform-dependent (ANSI on Windows 98 and Windows Me, and Unicode on later versions)."}]}],"pos":[14154,14741],"yaml":true,"extradata":"MT"},{"content":"Controls the alignment of data fields of a class or structure in memory.","nodes":[{"pos":[0,72],"content":"Controls the alignment of data fields of a class or structure in memory.","nodes":[{"content":"Controls the alignment of data fields of a class or structure in memory.","pos":[0,72]}]}],"pos":[16472,16545],"yaml":true},{"content":"The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field controls the alignment of a type's fields in memory.  It affects both <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> and <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName>. By default, the value is 0, indicating the default packing size for the current platform. The value of <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> must be 0, 1, 2, 4, 8, 16, 32, 64, or 128:  \n  \n The fields of a type instance are aligned by using the following rules:  \n  \n-   The alignment of the type is the size of its largest element (1, 2, 4, 8, etc., bytes) or the specified packing size, whichever is smaller.  \n  \n-   Each field must align with fields of its own size (1, 2, 4, 8, etc., bytes) or the alignment of the type, whichever is smaller.  Because the default alignment of the type is the size of its largest element, which is greater than or equal to all other field lengths, this usually means that fields are aligned by their size. For example, even if the largest field in a type is a 64-bit (8-byte) integer or the Pack field is set to 8, <xref:System.Byte> fields align on 1-byte boundaries, <xref:System.Int16> fields align on 2-byte boundaries, and <xref:System.Int32> fields align on 4-byte boundaries.  \n  \n-   Padding is added between fields to satisfy the alignment requirements.  \n  \n For example, consider the following structure, which consists of two <xref:System.Byte> fields and one <xref:System.Int32> field, when it is used with various values for the <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field.  \n  \n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex0.cs#1)]  \n  \n> [!IMPORTANT]\n>  To successfully compile the C# examples, you must specify the `/unsafe` compiler switch.  \n  \n If you specify the default packing size, the size of the structure is 8 bytes. The two bytes occupy the first two bytes of memory, because bytes must align on one-byte boundaries. Because the default alignment of the type is 4 bytes, which is the size of its largest fields, `i3`, there are two bytes of padding followed by the integer field.  \n  \n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex1.cs#2)]  \n  \n If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 6 bytes. As before, the two bytes occupy the first two bytes of memory. Because fields now align on 2-byte boundaries, there is no padding between the second byte and the integer.  \n  \n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex2.cs#3)]  \n  \n If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 4, the size of the structure is the same as in the default case, where the type's alignment was defined by the size of its largest field, `i3`, which is 4.  \n  \n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex3.cs#4)]  \n  \n If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 8, the size of the structure is the still same as in the default case, because the `i3` field aligns on a 4-byte boundary, which is smaller than the 8-byte boundary specified by the Pack field.  \n  \n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex4.cs#5)]  \n  \n To take another example, consider the following structure, which consists of two byte fields, one 32-bit signed integer field, one single-element byte array, and a decimal value. With the default packing size, the size of the structure is 28 bytes. The two bytes occupy the first two bytes of memory, followed by two bytes of padding, followed by the integer. Next is the one-byte array, followed by three bytes of padding. Finally, the <xref:System.Decimal> field, d5, aligns on a 4-byte boundary because a decimal value consists of four <xref:System.Int32> fields, so its alignment is based on the size of the largest of its fields rather than on the size of the <xref:System.Decimal> structure as a whole.  \n  \n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex5.cs#6)]  \n  \n If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 24 bytes. In comparison with the default alignment, the two bytes of padding between the two bytes and the integer have been removed because the type's alignment is now 4 rather than 2. And the three bytes of padding after `a4` have been replaced by one byte of padding, since `d5` now aligns on a 2-byte boundary rather than a 4-byte boundary.  \n  \n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex6.cs#7)]  \n  \n If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 8, the size of the structure is the same as in the default case, because all the alignment requirements in this structure are less than 8.  \n  \n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex7.cs#8)]  \n  \n The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field is frequently used when structures are exported during disk and network write operations. The field is also frequently used during platform invoke and interop operations.  \n  \n Occasionally, the field is used to reduce memory requirements by producing a tighter packing size. However, this usage requires careful consideration of actual hardware constraints, and may actually degrade performance.","nodes":[{"pos":[0,508],"content":"The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field controls the alignment of a type's fields in memory.  It affects both <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> and <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName>. By default, the value is 0, indicating the default packing size for the current platform. The value of <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> must be 0, 1, 2, 4, 8, 16, 32, 64, or 128:","nodes":[{"content":"The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field controls the alignment of a type's fields in memory.  It affects both <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> and <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName>. By default, the value is 0, indicating the default packing size for the current platform. The value of <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> must be 0, 1, 2, 4, 8, 16, 32, 64, or 128:","pos":[0,508],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field controls the alignment of a type's fields in memory.","pos":[0,127],"source":"The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field controls the alignment of a type's fields in memory."},{"content":"It affects both <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph>.","pos":[129,297],"source":"  It affects both <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> and <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName>."},{"content":"By default, the value is 0, indicating the default packing size for the current platform.","pos":[298,387]},{"content":"The value of <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> must be 0, 1, 2, 4, 8, 16, 32, 64, or 128:","pos":[388,508],"source":" The value of <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> must be 0, 1, 2, 4, 8, 16, 32, 64, or 128:"}]}]},{"pos":[515,586],"content":"The fields of a type instance are aligned by using the following rules:","nodes":[{"content":"The fields of a type instance are aligned by using the following rules:","pos":[0,71]}]},{"pos":[596,735],"content":"The alignment of the type is the size of its largest element (1, 2, 4, 8, etc., bytes) or the specified packing size, whichever is smaller.","nodes":[{"content":"The alignment of the type is the size of its largest element (1, 2, 4, 8, etc., bytes) or the specified packing size, whichever is smaller.","pos":[0,139]}]},{"pos":[745,1345],"content":"Each field must align with fields of its own size (1, 2, 4, 8, etc., bytes) or the alignment of the type, whichever is smaller.  Because the default alignment of the type is the size of its largest element, which is greater than or equal to all other field lengths, this usually means that fields are aligned by their size. For example, even if the largest field in a type is a 64-bit (8-byte) integer or the Pack field is set to 8, <xref:System.Byte> fields align on 1-byte boundaries, <xref:System.Int16> fields align on 2-byte boundaries, and <xref:System.Int32> fields align on 4-byte boundaries.","nodes":[{"content":"Each field must align with fields of its own size (1, 2, 4, 8, etc., bytes) or the alignment of the type, whichever is smaller.  Because the default alignment of the type is the size of its largest element, which is greater than or equal to all other field lengths, this usually means that fields are aligned by their size. For example, even if the largest field in a type is a 64-bit (8-byte) integer or the Pack field is set to 8, <xref:System.Byte> fields align on 1-byte boundaries, <xref:System.Int16> fields align on 2-byte boundaries, and <xref:System.Int32> fields align on 4-byte boundaries.","pos":[0,600],"nodes":[{"content":"Each field must align with fields of its own size (1, 2, 4, 8, etc., bytes) or the alignment of the type, whichever is smaller.","pos":[0,127]},{"content":"Because the default alignment of the type is the size of its largest element, which is greater than or equal to all other field lengths, this usually means that fields are aligned by their size.","pos":[129,323]},{"content":"For example, even if the largest field in a type is a 64-bit (8-byte) integer or the Pack field is set to 8, <ph id=\"ph1\">&lt;xref:System.Byte&gt;</ph> fields align on 1-byte boundaries, <ph id=\"ph2\">&lt;xref:System.Int16&gt;</ph> fields align on 2-byte boundaries, and <ph id=\"ph3\">&lt;xref:System.Int32&gt;</ph> fields align on 4-byte boundaries.","pos":[324,600],"source":" For example, even if the largest field in a type is a 64-bit (8-byte) integer or the Pack field is set to 8, <xref:System.Byte> fields align on 1-byte boundaries, <xref:System.Int16> fields align on 2-byte boundaries, and <xref:System.Int32> fields align on 4-byte boundaries."}]}]},{"pos":[1355,1425],"content":"Padding is added between fields to satisfy the alignment requirements.","nodes":[{"content":"Padding is added between fields to satisfy the alignment requirements.","pos":[0,70]}]},{"pos":[1432,1677],"content":"For example, consider the following structure, which consists of two <xref:System.Byte> fields and one <xref:System.Int32> field, when it is used with various values for the <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field.","nodes":[{"content":"For example, consider the following structure, which consists of two <ph id=\"ph1\">&lt;xref:System.Byte&gt;</ph> fields and one <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph> field, when it is used with various values for the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field.","pos":[0,245],"source":"For example, consider the following structure, which consists of two <xref:System.Byte> fields and one <xref:System.Int32> field, when it is used with various values for the <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field."}]},{"pos":[1684,1883],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Runtime.InteropServices.StructLayoutAttribute.Pack#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex0.cs#1)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex0.cs#1)]"},{"pos":[1891,1995],"content":"[!IMPORTANT]\n To successfully compile the C# examples, you must specify the `/unsafe` compiler switch.","leadings":["","> "],"nodes":[{"content":"To successfully compile the C# examples, you must specify the <ph id=\"ph1\">`/unsafe`</ph> compiler switch.","pos":[14,102],"source":" To successfully compile the C# examples, you must specify the `/unsafe` compiler switch."}]},{"pos":[2002,2344],"content":"If you specify the default packing size, the size of the structure is 8 bytes. The two bytes occupy the first two bytes of memory, because bytes must align on one-byte boundaries. Because the default alignment of the type is 4 bytes, which is the size of its largest fields, `i3`, there are two bytes of padding followed by the integer field.","nodes":[{"content":"If you specify the default packing size, the size of the structure is 8 bytes.","pos":[0,78]},{"content":"The two bytes occupy the first two bytes of memory, because bytes must align on one-byte boundaries.","pos":[79,179]},{"content":"Because the default alignment of the type is 4 bytes, which is the size of its largest fields, <ph id=\"ph1\">`i3`</ph>, there are two bytes of padding followed by the integer field.","pos":[180,342],"source":" Because the default alignment of the type is 4 bytes, which is the size of its largest fields, `i3`, there are two bytes of padding followed by the integer field."}]},{"pos":[2351,2550],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Runtime.InteropServices.StructLayoutAttribute.Pack#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex1.cs#2)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex1.cs#2)]"},{"pos":[2557,2846],"content":"If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 6 bytes. As before, the two bytes occupy the first two bytes of memory. Because fields now align on 2-byte boundaries, there is no padding between the second byte and the integer.","nodes":[{"content":"If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 6 bytes. As before, the two bytes occupy the first two bytes of memory. Because fields now align on 2-byte boundaries, there is no padding between the second byte and the integer.","pos":[0,289],"nodes":[{"content":"If <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 2, the size of the structure is 6 bytes.","pos":[0,118],"source":"If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 6 bytes."},{"content":"As before, the two bytes occupy the first two bytes of memory.","pos":[119,181]},{"content":"Because fields now align on 2-byte boundaries, there is no padding between the second byte and the integer.","pos":[182,289]}]}]},{"pos":[2853,3052],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Runtime.InteropServices.StructLayoutAttribute.Pack#3<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex2.cs#3)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex2.cs#3)]"},{"pos":[3059,3292],"content":"If <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 4, the size of the structure is the same as in the default case, where the type's alignment was defined by the size of its largest field, <ph id=\"ph2\">`i3`</ph>, which is 4.","source":"If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 4, the size of the structure is the same as in the default case, where the type's alignment was defined by the size of its largest field, `i3`, which is 4."},{"pos":[3299,3498],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Runtime.InteropServices.StructLayoutAttribute.Pack#4<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex3.cs#4)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex3.cs#4)]"},{"pos":[3505,3776],"content":"If <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 8, the size of the structure is the still same as in the default case, because the <ph id=\"ph2\">`i3`</ph> field aligns on a 4-byte boundary, which is smaller than the 8-byte boundary specified by the Pack field.","source":"If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 8, the size of the structure is the still same as in the default case, because the `i3` field aligns on a 4-byte boundary, which is smaller than the 8-byte boundary specified by the Pack field."},{"pos":[3783,3982],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Runtime.InteropServices.StructLayoutAttribute.Pack#5<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex4.cs#5)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex4.cs#5)]"},{"pos":[3989,4697],"content":"To take another example, consider the following structure, which consists of two byte fields, one 32-bit signed integer field, one single-element byte array, and a decimal value. With the default packing size, the size of the structure is 28 bytes. The two bytes occupy the first two bytes of memory, followed by two bytes of padding, followed by the integer. Next is the one-byte array, followed by three bytes of padding. Finally, the <xref:System.Decimal> field, d5, aligns on a 4-byte boundary because a decimal value consists of four <xref:System.Int32> fields, so its alignment is based on the size of the largest of its fields rather than on the size of the <xref:System.Decimal> structure as a whole.","nodes":[{"content":"To take another example, consider the following structure, which consists of two byte fields, one 32-bit signed integer field, one single-element byte array, and a decimal value. With the default packing size, the size of the structure is 28 bytes. The two bytes occupy the first two bytes of memory, followed by two bytes of padding, followed by the integer. Next is the one-byte array, followed by three bytes of padding. Finally, the <xref:System.Decimal> field, d5, aligns on a 4-byte boundary because a decimal value consists of four <xref:System.Int32> fields, so its alignment is based on the size of the largest of its fields rather than on the size of the <xref:System.Decimal> structure as a whole.","pos":[0,708],"nodes":[{"content":"To take another example, consider the following structure, which consists of two byte fields, one 32-bit signed integer field, one single-element byte array, and a decimal value.","pos":[0,178]},{"content":"With the default packing size, the size of the structure is 28 bytes.","pos":[179,248]},{"content":"The two bytes occupy the first two bytes of memory, followed by two bytes of padding, followed by the integer.","pos":[249,359]},{"content":"Next is the one-byte array, followed by three bytes of padding.","pos":[360,423]},{"content":"Finally, the <ph id=\"ph1\">&lt;xref:System.Decimal&gt;</ph> field, d5, aligns on a 4-byte boundary because a decimal value consists of four <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph> fields, so its alignment is based on the size of the largest of its fields rather than on the size of the <ph id=\"ph3\">&lt;xref:System.Decimal&gt;</ph> structure as a whole.","pos":[424,708],"source":" Finally, the <xref:System.Decimal> field, d5, aligns on a 4-byte boundary because a decimal value consists of four <xref:System.Int32> fields, so its alignment is based on the size of the largest of its fields rather than on the size of the <xref:System.Decimal> structure as a whole."}]}]},{"pos":[4704,4903],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Runtime.InteropServices.StructLayoutAttribute.Pack#6<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex5.cs#6)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex5.cs#6)]"},{"pos":[4910,5364],"content":"If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 24 bytes. In comparison with the default alignment, the two bytes of padding between the two bytes and the integer have been removed because the type's alignment is now 4 rather than 2. And the three bytes of padding after `a4` have been replaced by one byte of padding, since `d5` now aligns on a 2-byte boundary rather than a 4-byte boundary.","nodes":[{"content":"If <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 2, the size of the structure is 24 bytes.","pos":[0,119],"source":"If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 24 bytes."},{"content":"In comparison with the default alignment, the two bytes of padding between the two bytes and the integer have been removed because the type's alignment is now 4 rather than 2.","pos":[120,295]},{"content":"And the three bytes of padding after <ph id=\"ph1\">`a4`</ph> have been replaced by one byte of padding, since <ph id=\"ph2\">`d5`</ph> now aligns on a 2-byte boundary rather than a 4-byte boundary.","pos":[296,454],"source":" And the three bytes of padding after `a4` have been replaced by one byte of padding, since `d5` now aligns on a 2-byte boundary rather than a 4-byte boundary."}]},{"pos":[5371,5570],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Runtime.InteropServices.StructLayoutAttribute.Pack#7<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex6.cs#7)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex6.cs#7)]"},{"pos":[5577,5793],"content":"If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 8, the size of the structure is the same as in the default case, because all the alignment requirements in this structure are less than 8.","nodes":[{"content":"If <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> is set to 8, the size of the structure is the same as in the default case, because all the alignment requirements in this structure are less than 8.","pos":[0,216],"source":"If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 8, the size of the structure is the same as in the default case, because all the alignment requirements in this structure are less than 8."}]},{"pos":[5800,5999],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Runtime.InteropServices.StructLayoutAttribute.Pack#8<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex7.cs#8)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex7.cs#8)]"},{"pos":[6006,6251],"content":"The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field is frequently used when structures are exported during disk and network write operations. The field is also frequently used during platform invoke and interop operations.","nodes":[{"content":"The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field is frequently used when structures are exported during disk and network write operations. The field is also frequently used during platform invoke and interop operations.","pos":[0,245],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack&gt;</ph> field is frequently used when structures are exported during disk and network write operations.","pos":[0,164],"source":"The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field is frequently used when structures are exported during disk and network write operations."},{"content":"The field is also frequently used during platform invoke and interop operations.","pos":[165,245]}]}]},{"pos":[6258,6477],"content":"Occasionally, the field is used to reduce memory requirements by producing a tighter packing size. However, this usage requires careful consideration of actual hardware constraints, and may actually degrade performance.","nodes":[{"content":"Occasionally, the field is used to reduce memory requirements by producing a tighter packing size. However, this usage requires careful consideration of actual hardware constraints, and may actually degrade performance.","pos":[0,219],"nodes":[{"content":"Occasionally, the field is used to reduce memory requirements by producing a tighter packing size.","pos":[0,98]},{"content":"However, this usage requires careful consideration of actual hardware constraints, and may actually degrade performance.","pos":[99,219]}]}]}],"pos":[16556,23083],"yaml":true,"extradata":"MT"},{"content":"Indicates the absolute size of the class or structure.","nodes":[{"pos":[0,54],"content":"Indicates the absolute size of the class or structure.","nodes":[{"content":"Indicates the absolute size of the class or structure.","pos":[0,54]}]}],"pos":[24750,24805],"yaml":true},{"content":"This field must be equal or greater than the total size, in bytes, of the members of the class or structure. This field is primarily for compiler writers who want to extend the memory occupied by a structure for direct, unmanaged access. For example, you can use this field when working with unions that are not represented in metadata directly.","nodes":[{"pos":[0,345],"content":"This field must be equal or greater than the total size, in bytes, of the members of the class or structure. This field is primarily for compiler writers who want to extend the memory occupied by a structure for direct, unmanaged access. For example, you can use this field when working with unions that are not represented in metadata directly.","nodes":[{"content":"This field must be equal or greater than the total size, in bytes, of the members of the class or structure. This field is primarily for compiler writers who want to extend the memory occupied by a structure for direct, unmanaged access. For example, you can use this field when working with unions that are not represented in metadata directly.","pos":[0,345],"nodes":[{"content":"This field must be equal or greater than the total size, in bytes, of the members of the class or structure.","pos":[0,108]},{"content":"This field is primarily for compiler writers who want to extend the memory occupied by a structure for direct, unmanaged access.","pos":[109,237]},{"content":"For example, you can use this field when working with unions that are not represented in metadata directly.","pos":[238,345]}]}]}],"pos":[24816,25162],"yaml":true,"extradata":"MT"},{"content":"Gets the <xref href=\"System.Runtime.InteropServices.LayoutKind\"></xref> value that specifies how the class or structure is arranged.","nodes":[{"pos":[0,132],"content":"Gets the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.LayoutKind\"&gt;&lt;/xref&gt;</ph> value that specifies how the class or structure is arranged.","source":"Gets the <xref href=\"System.Runtime.InteropServices.LayoutKind\"></xref> value that specifies how the class or structure is arranged."}],"pos":[26838,26971],"yaml":true},{"content":"One of the enumeration values that specifies how the class or structure is arranged.","nodes":[{"pos":[0,84],"content":"One of the enumeration values that specifies how the class or structure is arranged.","nodes":[{"content":"One of the enumeration values that specifies how the class or structure is arranged.","pos":[0,84]}]}],"pos":[27143,27228],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Runtime.InteropServices.StructLayoutAttribute\n  commentId: T:System.Runtime.InteropServices.StructLayoutAttribute\n  id: StructLayoutAttribute\n  children:\n  - System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)\n  - System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)\n  - System.Runtime.InteropServices.StructLayoutAttribute.CharSet\n  - System.Runtime.InteropServices.StructLayoutAttribute.Pack\n  - System.Runtime.InteropServices.StructLayoutAttribute.Size\n  - System.Runtime.InteropServices.StructLayoutAttribute.Value\n  langs:\n  - csharp\n  name: StructLayoutAttribute\n  nameWithType: StructLayoutAttribute\n  fullName: System.Runtime.InteropServices.StructLayoutAttribute\n  type: Class\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Runtime.InteropServices\n  summary: Lets you control the physical layout of the data fields of a class or structure in memory.\n  remarks: \"You can apply this attribute to classes or structures.  \\n  \\n The common language runtime controls the physical layout of the data fields of a class or structure in managed memory. However, if you want to pass the type to unmanaged code, you can use the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute to control the unmanaged layout of the type. Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> to force the members to be laid out sequentially in the order they appear. For , <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> controls both the layout in managed memory and the layout in unmanaged memory. For non-blittable types, it controls the layout when the class or structure is marshaled to unmanaged code, but does not control the layout in managed memory. Use the attribute with <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> to control the precise position of each data member. This affects both managed and unmanaged layout, for both blittable and non-blittable types. Using <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> requires that you use the <xref:System.Runtime.InteropServices.FieldOffsetAttribute> attribute to indicate the position of each field within the type.  \\n  \\n C#, Visual Basic, and C++ compilers apply the <xref:System.Runtime.InteropServices.LayoutKind.Sequential> layout value to structures by default. For classes, you must apply the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> value explicitly. The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) also applies the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute; it always applies the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> value when it imports a type library.\"\n  example:\n  - \"The following example demonstrates a managed declaration of the `GetSystemTime` function and defines `MySystemTime` class with <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> layout. `GetSystemTime` gets the system time and prints to the console.  \\n  \\n [!code-cpp[StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/StructLayoutAttribute/CPP/structlayoutattribute.cpp#1)]\\n [!code-csharp[StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/StructLayoutAttribute/CS/structlayoutattribute.cs#1)]\\n [!code-vb[StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/StructLayoutAttribute/VB/structlayoutattribute.vb#1)]\"\n  syntax:\n    content: >-\n      [System.AttributeUsage(System.AttributeTargets.Class | System.AttributeTargets.Struct, Inherited=false)]\n\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public sealed class StructLayoutAttribute : Attribute\n  inheritance:\n  - System.Object\n  - System.Attribute\n  implements: []\n  inheritedMembers:\n  - System.Attribute.Equals(System.Object)\n  - System.Attribute.GetCustomAttribute(System.Reflection.Assembly,System.Type)\n  - System.Attribute.GetCustomAttribute(System.Reflection.Assembly,System.Type,System.Boolean)\n  - System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo,System.Type)\n  - System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo,System.Type,System.Boolean)\n  - System.Attribute.GetCustomAttribute(System.Reflection.Module,System.Type)\n  - System.Attribute.GetCustomAttribute(System.Reflection.Module,System.Type,System.Boolean)\n  - System.Attribute.GetCustomAttribute(System.Reflection.ParameterInfo,System.Type)\n  - System.Attribute.GetCustomAttribute(System.Reflection.ParameterInfo,System.Type,System.Boolean)\n  - System.Attribute.GetCustomAttributes(System.Reflection.Assembly)\n  - System.Attribute.GetCustomAttributes(System.Reflection.Assembly,System.Boolean)\n  - System.Attribute.GetCustomAttributes(System.Reflection.Assembly,System.Type)\n  - System.Attribute.GetCustomAttributes(System.Reflection.Assembly,System.Type,System.Boolean)\n  - System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo)\n  - System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo,System.Boolean)\n  - System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo,System.Type)\n  - System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo,System.Type,System.Boolean)\n  - System.Attribute.GetCustomAttributes(System.Reflection.Module)\n  - System.Attribute.GetCustomAttributes(System.Reflection.Module,System.Boolean)\n  - System.Attribute.GetCustomAttributes(System.Reflection.Module,System.Type)\n  - System.Attribute.GetCustomAttributes(System.Reflection.Module,System.Type,System.Boolean)\n  - System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo)\n  - System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo,System.Boolean)\n  - System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo,System.Type)\n  - System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo,System.Type,System.Boolean)\n  - System.Attribute.GetHashCode\n  - System.Attribute.IsDefaultAttribute\n  - System.Attribute.IsDefined(System.Reflection.Assembly,System.Type)\n  - System.Attribute.IsDefined(System.Reflection.Assembly,System.Type,System.Boolean)\n  - System.Attribute.IsDefined(System.Reflection.MemberInfo,System.Type)\n  - System.Attribute.IsDefined(System.Reflection.MemberInfo,System.Type,System.Boolean)\n  - System.Attribute.IsDefined(System.Reflection.Module,System.Type)\n  - System.Attribute.IsDefined(System.Reflection.Module,System.Type,System.Boolean)\n  - System.Attribute.IsDefined(System.Reflection.ParameterInfo,System.Type)\n  - System.Attribute.IsDefined(System.Reflection.ParameterInfo,System.Type,System.Boolean)\n  - System.Attribute.Match(System.Object)\n  - System.Attribute.System#Runtime#InteropServices#_Attribute#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)\n  - System.Attribute.System#Runtime#InteropServices#_Attribute#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)\n  - System.Attribute.System#Runtime#InteropServices#_Attribute#GetTypeInfoCount(System.UInt32@)\n  - System.Attribute.System#Runtime#InteropServices#_Attribute#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)\n  - System.Attribute.TypeId\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  attributes:\n  - type: System.AttributeUsageAttribute\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/StructLayoutAttribute.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)\n  commentId: M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)\n  id: '#ctor(System.Int16)'\n  parent: System.Runtime.InteropServices.StructLayoutAttribute\n  langs:\n  - csharp\n  name: StructLayoutAttribute(Int16)\n  nameWithType: StructLayoutAttribute.StructLayoutAttribute(Int16)\n  fullName: StructLayoutAttribute.StructLayoutAttribute(Int16)\n  type: Constructor\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Initalizes a new instance of the <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"></xref> class with the specified <xref href=\"System.Runtime.InteropServices.LayoutKind\"></xref> enumeration member.\n  remarks: This constructor takes an underlying 16-bit integer that represents each <xref:System.Runtime.InteropServices.LayoutKind> enumeration member. The [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) uses this constructor.\n  syntax:\n    content: public StructLayoutAttribute (short layoutKind);\n    parameters:\n    - id: layoutKind\n      type: System.Int16\n      description: A 16-bit integer that represents one of the <xref href=\"System.Runtime.InteropServices.LayoutKind\"></xref> values that specifes how the class or structure should be arranged.\n  overload: System.Runtime.InteropServices.StructLayoutAttribute.#ctor*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/StructLayoutAttribute.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)\n  commentId: M:System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)\n  id: '#ctor(System.Runtime.InteropServices.LayoutKind)'\n  parent: System.Runtime.InteropServices.StructLayoutAttribute\n  langs:\n  - csharp\n  name: StructLayoutAttribute(LayoutKind)\n  nameWithType: StructLayoutAttribute.StructLayoutAttribute(LayoutKind)\n  fullName: StructLayoutAttribute.StructLayoutAttribute(LayoutKind)\n  type: Constructor\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Runtime.InteropServices\n  summary: Initalizes a new instance of the <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"></xref> class with the specified <xref href=\"System.Runtime.InteropServices.LayoutKind\"></xref> enumeration member.\n  remarks: For readable code that is less prone to error, always use this constructor.\n  syntax:\n    content: public StructLayoutAttribute (System.Runtime.InteropServices.LayoutKind layoutKind);\n    parameters:\n    - id: layoutKind\n      type: System.Runtime.InteropServices.LayoutKind\n      description: One of the enumeration values that specifes how the class or structure should be arranged.\n  overload: System.Runtime.InteropServices.StructLayoutAttribute.#ctor*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/StructLayoutAttribute.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.StructLayoutAttribute.CharSet\n  commentId: F:System.Runtime.InteropServices.StructLayoutAttribute.CharSet\n  id: CharSet\n  parent: System.Runtime.InteropServices.StructLayoutAttribute\n  langs:\n  - csharp\n  name: CharSet\n  nameWithType: StructLayoutAttribute.CharSet\n  fullName: StructLayoutAttribute.CharSet\n  type: Field\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Runtime.InteropServices\n  summary: Indicates whether string data fields within the class should be marshaled as `LPWSTR` or `LPSTR` by default.\n  remarks: If the `CharSet` field is set to <xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName>, all string arguments are converted to Unicode characters (`LPWSTR`) before they are passed to the unmanaged implementation. If the field is set to <xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName>, the strings are converted to ANSI strings (`LPSTR`). If the `CharSet` field is set to <xref:System.Runtime.InteropServices.CharSet?displayProperty=fullName>, the conversion is platform-dependent (ANSI on Windows 98 and Windows Me, and Unicode on later versions).\n  syntax:\n    content: public System.Runtime.InteropServices.CharSet CharSet;\n    return:\n      type: System.Runtime.InteropServices.CharSet\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/StructLayoutAttribute.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.StructLayoutAttribute.Pack\n  commentId: F:System.Runtime.InteropServices.StructLayoutAttribute.Pack\n  id: Pack\n  parent: System.Runtime.InteropServices.StructLayoutAttribute\n  langs:\n  - csharp\n  name: Pack\n  nameWithType: StructLayoutAttribute.Pack\n  fullName: StructLayoutAttribute.Pack\n  type: Field\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Runtime.InteropServices\n  summary: Controls the alignment of data fields of a class or structure in memory.\n  remarks: \"The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field controls the alignment of a type's fields in memory.  It affects both <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> and <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName>. By default, the value is 0, indicating the default packing size for the current platform. The value of <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> must be 0, 1, 2, 4, 8, 16, 32, 64, or 128:  \\n  \\n The fields of a type instance are aligned by using the following rules:  \\n  \\n-   The alignment of the type is the size of its largest element (1, 2, 4, 8, etc., bytes) or the specified packing size, whichever is smaller.  \\n  \\n-   Each field must align with fields of its own size (1, 2, 4, 8, etc., bytes) or the alignment of the type, whichever is smaller.  Because the default alignment of the type is the size of its largest element, which is greater than or equal to all other field lengths, this usually means that fields are aligned by their size. For example, even if the largest field in a type is a 64-bit (8-byte) integer or the Pack field is set to 8, <xref:System.Byte> fields align on 1-byte boundaries, <xref:System.Int16> fields align on 2-byte boundaries, and <xref:System.Int32> fields align on 4-byte boundaries.  \\n  \\n-   Padding is added between fields to satisfy the alignment requirements.  \\n  \\n For example, consider the following structure, which consists of two <xref:System.Byte> fields and one <xref:System.Int32> field, when it is used with various values for the <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field.  \\n  \\n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex0.cs#1)]  \\n  \\n> [!IMPORTANT]\\n>  To successfully compile the C# examples, you must specify the `/unsafe` compiler switch.  \\n  \\n If you specify the default packing size, the size of the structure is 8 bytes. The two bytes occupy the first two bytes of memory, because bytes must align on one-byte boundaries. Because the default alignment of the type is 4 bytes, which is the size of its largest fields, `i3`, there are two bytes of padding followed by the integer field.  \\n  \\n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex1.cs#2)]  \\n  \\n If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 6 bytes. As before, the two bytes occupy the first two bytes of memory. Because fields now align on 2-byte boundaries, there is no padding between the second byte and the integer.  \\n  \\n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex2.cs#3)]  \\n  \\n If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 4, the size of the structure is the same as in the default case, where the type's alignment was defined by the size of its largest field, `i3`, which is 4.  \\n  \\n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex3.cs#4)]  \\n  \\n If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 8, the size of the structure is the still same as in the default case, because the `i3` field aligns on a 4-byte boundary, which is smaller than the 8-byte boundary specified by the Pack field.  \\n  \\n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex4.cs#5)]  \\n  \\n To take another example, consider the following structure, which consists of two byte fields, one 32-bit signed integer field, one single-element byte array, and a decimal value. With the default packing size, the size of the structure is 28 bytes. The two bytes occupy the first two bytes of memory, followed by two bytes of padding, followed by the integer. Next is the one-byte array, followed by three bytes of padding. Finally, the <xref:System.Decimal> field, d5, aligns on a 4-byte boundary because a decimal value consists of four <xref:System.Int32> fields, so its alignment is based on the size of the largest of its fields rather than on the size of the <xref:System.Decimal> structure as a whole.  \\n  \\n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex5.cs#6)]  \\n  \\n If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 2, the size of the structure is 24 bytes. In comparison with the default alignment, the two bytes of padding between the two bytes and the integer have been removed because the type's alignment is now 4 rather than 2. And the three bytes of padding after `a4` have been replaced by one byte of padding, since `d5` now aligns on a 2-byte boundary rather than a 4-byte boundary.  \\n  \\n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex6.cs#7)]  \\n  \\n If <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> is set to 8, the size of the structure is the same as in the default case, because all the alignment requirements in this structure are less than 8.  \\n  \\n [!code-csharp[System.Runtime.InteropServices.StructLayoutAttribute.Pack#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.interopservices.structlayoutattribute.pack/cs/packex7.cs#8)]  \\n  \\n The <xref:System.Runtime.InteropServices.StructLayoutAttribute.Pack> field is frequently used when structures are exported during disk and network write operations. The field is also frequently used during platform invoke and interop operations.  \\n  \\n Occasionally, the field is used to reduce memory requirements by producing a tighter packing size. However, this usage requires careful consideration of actual hardware constraints, and may actually degrade performance.\"\n  syntax:\n    content: public int Pack;\n    return:\n      type: System.Int32\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/StructLayoutAttribute.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.StructLayoutAttribute.Size\n  commentId: F:System.Runtime.InteropServices.StructLayoutAttribute.Size\n  id: Size\n  parent: System.Runtime.InteropServices.StructLayoutAttribute\n  langs:\n  - csharp\n  name: Size\n  nameWithType: StructLayoutAttribute.Size\n  fullName: StructLayoutAttribute.Size\n  type: Field\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Runtime.InteropServices\n  summary: Indicates the absolute size of the class or structure.\n  remarks: This field must be equal or greater than the total size, in bytes, of the members of the class or structure. This field is primarily for compiler writers who want to extend the memory occupied by a structure for direct, unmanaged access. For example, you can use this field when working with unions that are not represented in metadata directly.\n  syntax:\n    content: public int Size;\n    return:\n      type: System.Int32\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/StructLayoutAttribute.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.StructLayoutAttribute.Value\n  commentId: P:System.Runtime.InteropServices.StructLayoutAttribute.Value\n  id: Value\n  parent: System.Runtime.InteropServices.StructLayoutAttribute\n  langs:\n  - csharp\n  name: Value\n  nameWithType: StructLayoutAttribute.Value\n  fullName: StructLayoutAttribute.Value\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System.Runtime.InteropServices\n  summary: Gets the <xref href=\"System.Runtime.InteropServices.LayoutKind\"></xref> value that specifies how the class or structure is arranged.\n  syntax:\n    content: public System.Runtime.InteropServices.LayoutKind Value { get; }\n    return:\n      type: System.Runtime.InteropServices.LayoutKind\n      description: One of the enumeration values that specifies how the class or structure is arranged.\n  overload: System.Runtime.InteropServices.StructLayoutAttribute.Value*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/StructLayoutAttribute.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Attribute\n  parent: System\n  isExternal: false\n  name: Attribute\n  nameWithType: Attribute\n  fullName: System.Attribute\n- uid: System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Int16)\n  parent: System.Runtime.InteropServices.StructLayoutAttribute\n  isExternal: false\n  name: StructLayoutAttribute(Int16)\n  nameWithType: StructLayoutAttribute.StructLayoutAttribute(Int16)\n  fullName: StructLayoutAttribute.StructLayoutAttribute(Int16)\n- uid: System.Int16\n  parent: System\n  isExternal: false\n  name: Int16\n  nameWithType: Int16\n  fullName: System.Int16\n- uid: System.Runtime.InteropServices.StructLayoutAttribute.#ctor(System.Runtime.InteropServices.LayoutKind)\n  parent: System.Runtime.InteropServices.StructLayoutAttribute\n  isExternal: false\n  name: StructLayoutAttribute(LayoutKind)\n  nameWithType: StructLayoutAttribute.StructLayoutAttribute(LayoutKind)\n  fullName: StructLayoutAttribute.StructLayoutAttribute(LayoutKind)\n- uid: System.Runtime.InteropServices.LayoutKind\n  parent: System.Runtime.InteropServices\n  isExternal: false\n  name: LayoutKind\n  nameWithType: LayoutKind\n  fullName: System.Runtime.InteropServices.LayoutKind\n- uid: System.Runtime.InteropServices.StructLayoutAttribute.CharSet\n  parent: System.Runtime.InteropServices.StructLayoutAttribute\n  isExternal: false\n  name: CharSet\n  nameWithType: StructLayoutAttribute.CharSet\n  fullName: StructLayoutAttribute.CharSet\n- uid: System.Runtime.InteropServices.CharSet\n  parent: System.Runtime.InteropServices\n  isExternal: false\n  name: CharSet\n  nameWithType: CharSet\n  fullName: System.Runtime.InteropServices.CharSet\n- uid: System.Runtime.InteropServices.StructLayoutAttribute.Pack\n  parent: System.Runtime.InteropServices.StructLayoutAttribute\n  isExternal: false\n  name: Pack\n  nameWithType: StructLayoutAttribute.Pack\n  fullName: StructLayoutAttribute.Pack\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Runtime.InteropServices.StructLayoutAttribute.Size\n  parent: System.Runtime.InteropServices.StructLayoutAttribute\n  isExternal: false\n  name: Size\n  nameWithType: StructLayoutAttribute.Size\n  fullName: StructLayoutAttribute.Size\n- uid: System.Runtime.InteropServices.StructLayoutAttribute.Value\n  parent: System.Runtime.InteropServices.StructLayoutAttribute\n  isExternal: false\n  name: Value\n  nameWithType: StructLayoutAttribute.Value\n  fullName: StructLayoutAttribute.Value\n- uid: System.Runtime.InteropServices.StructLayoutAttribute.#ctor*\n  parent: System.Runtime.InteropServices.StructLayoutAttribute\n  isExternal: false\n  name: StructLayoutAttribute\n  nameWithType: StructLayoutAttribute.StructLayoutAttribute\n  fullName: StructLayoutAttribute.StructLayoutAttribute\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  - netcore-1.0\n  - netcore-1.1\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/StructLayoutAttribute.xml\n- uid: System.Runtime.InteropServices.StructLayoutAttribute.Value*\n  parent: System.Runtime.InteropServices.StructLayoutAttribute\n  isExternal: false\n  name: Value\n  nameWithType: StructLayoutAttribute.Value\n  fullName: StructLayoutAttribute.Value\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/StructLayoutAttribute.xml\n- uid: System.Attribute.Equals(System.Object)\n  parent: System.Attribute\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Attribute.Equals(Object)\n  fullName: Attribute.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Attribute.GetHashCode\n  parent: System.Attribute\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Attribute.GetHashCode()\n  fullName: Attribute.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.Attribute.GetCustomAttribute(System.Reflection.ParameterInfo,System.Type,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttribute(ParameterInfo, Type, Boolean)\n  nameWithType: Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean)\n  fullName: Attribute.GetCustomAttribute(ParameterInfo, Type, Boolean)\n- uid: System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo,System.Type,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttribute(MemberInfo, Type, Boolean)\n  nameWithType: Attribute.GetCustomAttribute(MemberInfo, Type, Boolean)\n  fullName: Attribute.GetCustomAttribute(MemberInfo, Type, Boolean)\n- uid: System.Attribute.GetCustomAttribute(System.Reflection.Assembly,System.Type,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttribute(Assembly, Type, Boolean)\n  nameWithType: Attribute.GetCustomAttribute(Assembly, Type, Boolean)\n  fullName: Attribute.GetCustomAttribute(Assembly, Type, Boolean)\n- uid: System.Attribute.GetCustomAttribute(System.Reflection.Module,System.Type,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttribute(Module, Type, Boolean)\n  nameWithType: Attribute.GetCustomAttribute(Module, Type, Boolean)\n  fullName: Attribute.GetCustomAttribute(Module, Type, Boolean)\n- uid: System.Attribute.GetCustomAttribute(System.Reflection.Module,System.Type)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttribute(Module, Type)\n  nameWithType: Attribute.GetCustomAttribute(Module, Type)\n  fullName: Attribute.GetCustomAttribute(Module, Type)\n- uid: System.Attribute.GetCustomAttribute(System.Reflection.MemberInfo,System.Type)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttribute(MemberInfo, Type)\n  nameWithType: Attribute.GetCustomAttribute(MemberInfo, Type)\n  fullName: Attribute.GetCustomAttribute(MemberInfo, Type)\n- uid: System.Attribute.GetCustomAttribute(System.Reflection.Assembly,System.Type)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttribute(Assembly, Type)\n  nameWithType: Attribute.GetCustomAttribute(Assembly, Type)\n  fullName: Attribute.GetCustomAttribute(Assembly, Type)\n- uid: System.Attribute.GetCustomAttribute(System.Reflection.ParameterInfo,System.Type)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttribute(ParameterInfo, Type)\n  nameWithType: Attribute.GetCustomAttribute(ParameterInfo, Type)\n  fullName: Attribute.GetCustomAttribute(ParameterInfo, Type)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.Module,System.Type)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(Module, Type)\n  nameWithType: Attribute.GetCustomAttributes(Module, Type)\n  fullName: Attribute.GetCustomAttributes(Module, Type)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo,System.Type,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(ParameterInfo, Type, Boolean)\n  nameWithType: Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean)\n  fullName: Attribute.GetCustomAttributes(ParameterInfo, Type, Boolean)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.Module,System.Type,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(Module, Type, Boolean)\n  nameWithType: Attribute.GetCustomAttributes(Module, Type, Boolean)\n  fullName: Attribute.GetCustomAttributes(Module, Type, Boolean)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo,System.Type,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(MemberInfo, Type, Boolean)\n  nameWithType: Attribute.GetCustomAttributes(MemberInfo, Type, Boolean)\n  fullName: Attribute.GetCustomAttributes(MemberInfo, Type, Boolean)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.Assembly,System.Type,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(Assembly, Type, Boolean)\n  nameWithType: Attribute.GetCustomAttributes(Assembly, Type, Boolean)\n  fullName: Attribute.GetCustomAttributes(Assembly, Type, Boolean)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo,System.Type)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(ParameterInfo, Type)\n  nameWithType: Attribute.GetCustomAttributes(ParameterInfo, Type)\n  fullName: Attribute.GetCustomAttributes(ParameterInfo, Type)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.Module,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(Module, Boolean)\n  nameWithType: Attribute.GetCustomAttributes(Module, Boolean)\n  fullName: Attribute.GetCustomAttributes(Module, Boolean)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(ParameterInfo, Boolean)\n  nameWithType: Attribute.GetCustomAttributes(ParameterInfo, Boolean)\n  fullName: Attribute.GetCustomAttributes(ParameterInfo, Boolean)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(MemberInfo, Boolean)\n  nameWithType: Attribute.GetCustomAttributes(MemberInfo, Boolean)\n  fullName: Attribute.GetCustomAttributes(MemberInfo, Boolean)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.Assembly,System.Type)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(Assembly, Type)\n  nameWithType: Attribute.GetCustomAttributes(Assembly, Type)\n  fullName: Attribute.GetCustomAttributes(Assembly, Type)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.Assembly,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(Assembly, Boolean)\n  nameWithType: Attribute.GetCustomAttributes(Assembly, Boolean)\n  fullName: Attribute.GetCustomAttributes(Assembly, Boolean)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.ParameterInfo)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(ParameterInfo)\n  nameWithType: Attribute.GetCustomAttributes(ParameterInfo)\n  fullName: Attribute.GetCustomAttributes(ParameterInfo)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.Module)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(Module)\n  nameWithType: Attribute.GetCustomAttributes(Module)\n  fullName: Attribute.GetCustomAttributes(Module)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(MemberInfo)\n  nameWithType: Attribute.GetCustomAttributes(MemberInfo)\n  fullName: Attribute.GetCustomAttributes(MemberInfo)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.Assembly)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(Assembly)\n  nameWithType: Attribute.GetCustomAttributes(Assembly)\n  fullName: Attribute.GetCustomAttributes(Assembly)\n- uid: System.Attribute.GetCustomAttributes(System.Reflection.MemberInfo,System.Type)\n  parent: System.Attribute\n  isExternal: false\n  name: GetCustomAttributes(MemberInfo, Type)\n  nameWithType: Attribute.GetCustomAttributes(MemberInfo, Type)\n  fullName: Attribute.GetCustomAttributes(MemberInfo, Type)\n- uid: System.Attribute.IsDefaultAttribute\n  parent: System.Attribute\n  isExternal: false\n  name: IsDefaultAttribute()\n  nameWithType: Attribute.IsDefaultAttribute()\n  fullName: Attribute.IsDefaultAttribute()\n- uid: System.Attribute.IsDefined(System.Reflection.ParameterInfo,System.Type,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: IsDefined(ParameterInfo, Type, Boolean)\n  nameWithType: Attribute.IsDefined(ParameterInfo, Type, Boolean)\n  fullName: Attribute.IsDefined(ParameterInfo, Type, Boolean)\n- uid: System.Attribute.IsDefined(System.Reflection.Module,System.Type,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: IsDefined(Module, Type, Boolean)\n  nameWithType: Attribute.IsDefined(Module, Type, Boolean)\n  fullName: Attribute.IsDefined(Module, Type, Boolean)\n- uid: System.Attribute.IsDefined(System.Reflection.MemberInfo,System.Type,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: IsDefined(MemberInfo, Type, Boolean)\n  nameWithType: Attribute.IsDefined(MemberInfo, Type, Boolean)\n  fullName: Attribute.IsDefined(MemberInfo, Type, Boolean)\n- uid: System.Attribute.IsDefined(System.Reflection.Assembly,System.Type,System.Boolean)\n  parent: System.Attribute\n  isExternal: false\n  name: IsDefined(Assembly, Type, Boolean)\n  nameWithType: Attribute.IsDefined(Assembly, Type, Boolean)\n  fullName: Attribute.IsDefined(Assembly, Type, Boolean)\n- uid: System.Attribute.IsDefined(System.Reflection.MemberInfo,System.Type)\n  parent: System.Attribute\n  isExternal: false\n  name: IsDefined(MemberInfo, Type)\n  nameWithType: Attribute.IsDefined(MemberInfo, Type)\n  fullName: Attribute.IsDefined(MemberInfo, Type)\n- uid: System.Attribute.IsDefined(System.Reflection.Module,System.Type)\n  parent: System.Attribute\n  isExternal: false\n  name: IsDefined(Module, Type)\n  nameWithType: Attribute.IsDefined(Module, Type)\n  fullName: Attribute.IsDefined(Module, Type)\n- uid: System.Attribute.IsDefined(System.Reflection.Assembly,System.Type)\n  parent: System.Attribute\n  isExternal: false\n  name: IsDefined(Assembly, Type)\n  nameWithType: Attribute.IsDefined(Assembly, Type)\n  fullName: Attribute.IsDefined(Assembly, Type)\n- uid: System.Attribute.IsDefined(System.Reflection.ParameterInfo,System.Type)\n  parent: System.Attribute\n  isExternal: false\n  name: IsDefined(ParameterInfo, Type)\n  nameWithType: Attribute.IsDefined(ParameterInfo, Type)\n  fullName: Attribute.IsDefined(ParameterInfo, Type)\n- uid: System.Attribute.Match(System.Object)\n  parent: System.Attribute\n  isExternal: false\n  name: Match(Object)\n  nameWithType: Attribute.Match(Object)\n  fullName: Attribute.Match(Object)\n- uid: System.Attribute.TypeId\n  parent: System.Attribute\n  isExternal: false\n  name: TypeId\n  nameWithType: Attribute.TypeId\n  fullName: Attribute.TypeId\n- uid: System.Attribute.System#Runtime#InteropServices#_Attribute#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)\n  parent: System.Attribute\n  isExternal: false\n  name: _Attribute.GetIDsOfNames(Guid, IntPtr, UInt32, UInt32, IntPtr)\n  nameWithType: Attribute._Attribute.GetIDsOfNames(Guid, IntPtr, UInt32, UInt32, IntPtr)\n  fullName: Attribute._Attribute.GetIDsOfNames(Guid, IntPtr, UInt32, UInt32, IntPtr)\n- uid: System.Attribute.System#Runtime#InteropServices#_Attribute#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)\n  parent: System.Attribute\n  isExternal: false\n  name: _Attribute.GetTypeInfo(UInt32, UInt32, IntPtr)\n  nameWithType: Attribute._Attribute.GetTypeInfo(UInt32, UInt32, IntPtr)\n  fullName: Attribute._Attribute.GetTypeInfo(UInt32, UInt32, IntPtr)\n- uid: System.Attribute.System#Runtime#InteropServices#_Attribute#GetTypeInfoCount(System.UInt32@)\n  parent: System.Attribute\n  isExternal: false\n  name: _Attribute.GetTypeInfoCount(UInt32)\n  nameWithType: Attribute._Attribute.GetTypeInfoCount(UInt32)\n  fullName: Attribute._Attribute.GetTypeInfoCount(UInt32)\n- uid: System.Attribute.System#Runtime#InteropServices#_Attribute#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)\n  parent: System.Attribute\n  isExternal: false\n  name: _Attribute.Invoke(UInt32, Guid, UInt32, Int16, IntPtr, IntPtr, IntPtr, IntPtr)\n  nameWithType: Attribute._Attribute.Invoke(UInt32, Guid, UInt32, Int16, IntPtr, IntPtr, IntPtr, IntPtr)\n  fullName: Attribute._Attribute.Invoke(UInt32, Guid, UInt32, Int16, IntPtr, IntPtr, IntPtr, IntPtr)\n"}