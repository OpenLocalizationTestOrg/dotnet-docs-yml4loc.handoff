<?xml version="1.0"?>
<xliff version="1.2" xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="markdown" source-language="en-US" target-language="ja-jp">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-fdd610b" tool-company="Microsoft" />
      <xliffext:olfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">3d22bc139aef680aad63f349bcec45c3b75f808a</xliffext:olfilehash>
      <xliffext:olfilepath xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">System.Reflection.MethodBase.yml</xliffext:olfilepath>
      <xliffext:oltranslationpriority xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">net47</xliffext:oltranslationpriority>
      <xliffext:oltranslationtype xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">Human Translation</xliffext:oltranslationtype>
      <xliffext:olskeletonhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">7fb99b91160aa4c36a54e1704e8aaa48fcb42f36</xliffext:olskeletonhash>
      <xliffext:olxliffhash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">53830c9f2cf75407f13eb9fcbff2ed8c8f049ebf</xliffext:olxliffhash>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve">
          <source>Provides information about methods and constructors.</source>
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT">
          <source><ph id="ph1">`MethodBase`</ph> is the base class of <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve">
          <source>Initializes a new instance of the <ph id="ph1">&lt;xref href="System.Reflection.MethodBase"&gt;&lt;/xref&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve">
          <source>Gets the attributes associated with this method.</source>
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT">
          <source>All members have a set of attributes, which are defined in relation to the specific type of member.</source>
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, first get the type.</source>
        </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT">
          <source>From the type, get the method.</source>
        </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT">
          <source>From the method, get the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve">
          <source>One of the <ph id="ph1">&lt;xref href="System.Reflection.MethodAttributes"&gt;&lt;/xref&gt;</ph> values.</source>
        </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve">
          <source>Gets a value indicating the calling conventions for this method.</source>
        </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">&lt;xref href="System.Reflection.CallingConventions"&gt;&lt;/xref&gt;</ph> for this method.</source>
        </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the generic method contains unassigned generic type parameters.</source>
        </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT">
          <source>A generic method can be invoked only if there are no generic type definitions or open constructed types in the type arguments of the method itself or in any enclosing types.</source>
        </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT">
          <source>Because types can be arbitrarily complex, making this recursive determination is difficult.</source>
        </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT">
          <source>For convenience, and to reduce the chance of error, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</source>
        </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>, the method cannot be invoked.</source>
        </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property searches recursively for type parameters.</source>
        </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, it returns <ph id="ph1">`true`</ph> for any method in an open type <ph id="ph2">`A&lt;T&gt;`</ph> (<ph id="ph3">`A(Of T)`</ph> in Visual Basic), even though the method itself is not generic.</source>
        </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT">
          <source>Contrast this with the behavior of the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property, which returns <ph id="ph2">`false`</ph> for such a method.</source>
        </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT">
          <source>Similarly, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property parameter returns <ph id="ph2">`true`</ph> for any constructor in an open type, even though constructors cannot have type parameters of their own.</source>
        </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">&lt;xref href="System.Reflection.MethodBase"&gt;&lt;/xref&gt;</ph> object represents a generic method that contains unassigned generic type parameters; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve">
          <source>Returns a value that indicates whether this instance is equal to a specified object.</source>
        </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve">
          <source>An object to compare with this instance, or <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">obj</ph><ept id="p1">&lt;/code&gt;</ept> equals the type and value of this instance; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve">
          <source>Returns a <ph id="ph1">`MethodBase`</ph> object representing the currently executing method.</source>
        </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the currently executing method is defined on a generic type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> that is returned by <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> is obtained from the generic type definition (that is, <ph id="ph3">&lt;xref:System.Reflection.MethodInfo.ContainsGenericParameters%2A?displayProperty=fullName&gt;</ph> returns <ph id="ph4">`true`</ph>).</source>
        </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT">
          <source>Therefore, it does not reflect the type arguments that were used when the method was called.</source>
        </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if a method <ph id="ph1">`M()`</ph> is defined on a generic type <ph id="ph2">`C&lt;T&gt;`</ph> (<ph id="ph3">`C(Of T)`</ph> in Visual Basic), and <ph id="ph4">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> is called from <ph id="ph5">`C&lt;string&gt;.M()`</ph>, then <ph id="ph6">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> returns <ph id="ph7">`C&lt;T&gt;.M()`</ph> (<ph id="ph8">`C(Of T).M()`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the currently executing method is a generic method, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetCurrentMethod%2A&gt;</ph> returns the generic method definition.</source>
        </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the generic method is defined on a generic type, the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> is obtained from the generic type definition.</source>
        </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;xref href="System.Reflection.MethodBase.GetCurrentMethod"&gt;&lt;/xref&gt;</ph> is a static method that is called from within an executing method and that returns information about that method.</source>
        </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`MethodBase`</ph> object representing the currently executing method.</source>
        </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve">
          <source>This member was invoked with a late-binding mechanism.</source>
        </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve">
          <source>Returns an array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
        </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT">
          <source>The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</source>
        </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current method is a closed constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`false`</ph>), the array returned by the <ph id="ph3">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic method definition.</source>
        </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current method is a generic method definition, the array contains the type parameters.</source>
        </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current method is an open constructed method (that is, the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property returns <ph id="ph2">`true`</ph>) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</source>
        </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.</source>
        </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a demonstration of this scenario, see the code example provided for the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT">
          <source>Generic constructors are not supported in the .NET Framework version 2.0.</source>
        </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property throws <ph id="ph1">&lt;xref:System.NotSupportedException&gt;</ph> if not overridden in a derived class, so an exception is thrown if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve">
          <source>An array of <ph id="ph1">&lt;xref href="System.Type"&gt;&lt;/xref&gt;</ph> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</source>
        </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve">
          <source>Returns an empty array if the current method is not a generic method.</source>
        </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve">
          <source>The current object is a <ph id="ph1">&lt;xref href="System.Reflection.ConstructorInfo"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve">
          <source>Generic constructors are not supported in the .NET Framework version 2.0.</source>
        </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve">
          <source>This exception is the default behavior if this method is not overridden in a derived class.</source>
        </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve">
          <source>Returns the hash code for this instance.</source>
        </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve">
          <source>A 32-bit signed integer hash code.</source>
        </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets a <ph id="ph1">&lt;xref href="System.Reflection.MethodBody"&gt;&lt;/xref&gt;</ph> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</source>
        </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT">
          <source>You do not have to override the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> in order to use it.</source>
        </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can call the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodBody%2A&gt;</ph> method on <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects, because the method is overridden in the runtime versions of these classes.</source>
        </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, the runtime version of the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class derives from the <ph id="ph2">&lt;xref:System.Reflection.MethodInfo&gt;</ph> class, which in turn derives from the <ph id="ph3">&lt;xref:System.Reflection.MethodBase&gt;</ph> class.</source>
        </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.MethodBody"&gt;&lt;/xref&gt;</ph> object that provides access to the MSIL stream, local variables, and exceptions for the current method.</source>
        </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve">
          <source>This method is invalid unless overridden in a derived class.</source>
        </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve">
          <source>Gets method information by using the method's internal metadata representation (handle).</source>
        </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT">
          <source>Handles are valid only in the application domain in which they were obtained.</source>
        </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve">
          <source>The method's handle.</source>
        </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">`MethodBase`</ph> containing information about the method.</source>
        </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;handle&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve">
          <source>Gets a <ph id="ph1">&lt;xref href="System.Reflection.MethodBase"&gt;&lt;/xref&gt;</ph> object for the constructor or method represented by the specified handle, for the specified generic type.</source>
        </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT">
          <source>Handles are valid only in the application domain in which they were obtained.</source>
        </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT">
          <source>A <ph id="ph1">&lt;xref:System.RuntimeMethodHandle&gt;</ph> structure for a constructor or method of a generic type can represent different <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> objects, depending on the types specified for the type parameters of the generic type.</source>
        </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if <ph id="ph1">`class G&lt;T&gt;`</ph> (<ph id="ph2">`class G(Of T)`</ph> in Visual Basic, <ph id="ph3">`generic &lt;T&gt; ref class G`</ph> in C++) has a method that returns type <ph id="ph4">`T`</ph>, the <ph id="ph5">&lt;xref:System.Reflection.MethodBase&gt;</ph> object for that method in a constructed class such as <ph id="ph6">`G&lt;int&gt;`</ph> is different from the <ph id="ph7">&lt;xref:System.Reflection.MethodBase&gt;</ph> object for that method in the generic type definition.</source>
        </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve">
          <source>A handle to the internal metadata representation of a constructor or method.</source>
        </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve">
          <source>A handle to the generic type that defines the constructor or method.</source>
        </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.Reflection.MethodBase"&gt;&lt;/xref&gt;</ph> object representing the method or constructor specified by <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">handle</ph><ept id="p1">&lt;/code&gt;</ept>, in the generic type specified by <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">declaringType</ph><ept id="p2">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve">
          <source><ph id="ph1">&lt;code&gt;handle&lt;/code&gt;</ph> is invalid.</source>
        </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, returns the <ph id="ph1">&lt;xref href="System.Reflection.MethodImplAttributes"&gt;&lt;/xref&gt;</ph> flags.</source>
        </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve">
          <source>The <ph id="ph1">`MethodImplAttributes`</ph> flags.</source>
        </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, gets the parameters of the specified method or constructor.</source>
        </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve">
          <source>An array of type <ph id="ph1">`ParameterInfo`</ph> containing information that matches the signature of the method (or constructor) reflected by this <ph id="ph2">`MethodBase`</ph> instance.</source>
        </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve">
          <source>When overridden in a derived class, invokes the reflected method or constructor with the given parameters.</source>
        </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT">
          <source>Dynamically invokes the method reflected by this instance on <ph id="ph1">`obj`</ph>, and passes along the specified parameters.</source>
        </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method is static, the <ph id="ph1">`obj`</ph> parameter is ignored.</source>
        </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT">
          <source>For non-static methods, <ph id="ph1">`obj`</ph> should be an instance of a class that inherits or declares the method and must be the same type as this class.</source>
        </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the method has no parameters, the value of <ph id="ph1">`parameters`</ph> should be <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT">
          <source>Otherwise, the number, type, and order of elements in <ph id="ph1">`parameters`</ph> should be identical to the number, type, and order of parameters for the method reflected by this instance.</source>
        </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT">
          <source>You may not omit optional parameters in calls to <ph id="ph1">`Invoke`</ph>.</source>
        </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT">
          <source>To invoke a method omitting optional parameters, you should call <ph id="ph1">`Type.InvokeMember`</ph> instead.</source>
        </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method overload is used to invoke an instance constructor, the object supplied for <ph id="ph1">`obj`</ph> is reinitialized; that is, all instance initializers are executed.</source>
        </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</source>
        </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT">
          <source>For pass-by-value primitive parameters, normal widening is performed (Int16 -&gt; Int32, for example).</source>
        </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT">
          <source>For pass-by-value reference parameters, normal reference widening is allowed (derived class to base class, and base class to interface type).</source>
        </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT">
          <source>However, for pass-by-reference primitive parameters, the types must match exactly.</source>
        </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT">
          <source>For pass-by-reference reference parameters, the normal widening still applies.</source>
        </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, if the method reflected by this instance is declared as <ph id="ph1">`public boolean Compare(String a, String b)`</ph>, then <ph id="ph2">`parameters`</ph> should be an array of <ph id="ph3">`Objects`</ph> with length 2 such that <ph id="ph4">`parameters[0] = new Object("SomeString1") and parameters[1] = new Object("SomeString2")`</ph>.</source>
        </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a parameter of the current method is a value type, and the corresponding argument in <ph id="ph1">`parameters`</ph> is <ph id="ph2">`null`</ph>, the runtime passes a zero-initialized instance of the value type.</source>
        </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT">
          <source>Reflection uses dynamic method lookup when invoking virtual methods.</source>
        </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, suppose that class B inherits from class A and both implement a virtual method named M. Now suppose that you have a <ph id="ph1">`MethodInfo`</ph> object that represents M on class A. If you use the <ph id="ph2">`Invoke`</ph> method to invoke M on an object of type B, then reflection will use the implementation given by class B. Even if the object of type B is cast to A, the implementation given by class B is used (see code sample below).</source>
        </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT">
          <source>On the other hand, if the method is non-virtual, then reflection will use the implementation given by the type from which the <ph id="ph1">`MethodInfo`</ph> was obtained, regardless of the type of the object passed as the target.</source>
        </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT">
          <source>Access restrictions are ignored for fully trusted code.</source>
        </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, private constructors, methods, fields, and properties can be accessed and invoked via reflection whenever the code is fully trusted.</source>
        </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the invoked method throws an exception, <ph id="ph1">`TargetInvocationException.GetException`</ph> returns the exception.</source>
        </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT">
          <source>This implementation throws a <ph id="ph1">`NotSupportedException`</ph>.</source>
        </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve">
          <source>The object on which to invoke the method or constructor.</source>
        </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve">
          <source>If a method is static, this argument is ignored.</source>
        </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve">
          <source>If a constructor is static, this argument must be <ph id="ph1">`null`</ph> or an instance of the class that defines the constructor.</source>
        </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve">
          <source>A bitmask that is a combination of 0 or more bit flags from <ph id="ph1">&lt;xref href="System.Reflection.BindingFlags"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">binder</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>, this parameter is assigned the value <ph id="ph3">&lt;xref href="System.Reflection.BindingFlags.Default"&gt;&lt;/xref&gt;</ph>; thus, whatever you pass in is ignored.</source>
        </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve">
          <source>An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <ph id="ph1">`MemberInfo`</ph> objects via reflection.</source>
        </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve">
          <source>If <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">binder</ph><ept id="p1">&lt;/code&gt;</ept> is <ph id="ph2">`null`</ph>, the default binder is used.</source>
        </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve">
          <source>An argument list for the invoked method or constructor.</source>
        </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve">
          <source>This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</source>
        </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve">
          <source>If there are no parameters, this should be <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve">
          <source>If the method or constructor represented by this instance takes a ByRef parameter, there is no special attribute required for that parameter in order to invoke the method or constructor using this function.</source>
        </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve">
          <source>Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</source>
        </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve">
          <source>For reference-type elements, this value is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve">
          <source>For value-type elements, this value is 0, 0.0, or <ph id="ph1">`false`</ph>, depending on the specific element type.</source>
        </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve">
          <source>An instance of <ph id="ph1">`CultureInfo`</ph> used to govern the coercion of types.</source>
        </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve">
          <source>If this is <ph id="ph1">`null`</ph>, the <ph id="ph2">`CultureInfo`</ph> for the current thread is used.</source>
        </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve">
          <source>(This is necessary to convert a <ph id="ph1">`String`</ph> that represents 1000 to a <ph id="ph2">`Double`</ph> value, for example, since 1000 is represented differently by different cultures.)</source>
        </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve">
          <source>An <ph id="ph1">`Object`</ph> containing the return value of the invoked method, or <ph id="ph2">`null`</ph> in the case of a constructor, or <ph id="ph3">`null`</ph> if the method's return type is <ph id="ph4">`void`</ph>.</source>
        </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve">
          <source>Before calling the method or constructor, <ph id="ph1">`Invoke`</ph> checks to see if the user has access permission and verifies that the parameters are valid.</source>
        </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">obj</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <ph id="ph2">`null`</ph> and the method is not static.</source>
        </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve">
          <source>The method is not declared or inherited by the class of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">obj</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve">
          <source>A static constructor is invoked, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">obj</ph><ept id="p1">&lt;/code&gt;</ept> is neither <ph id="ph2">`null`</ph> nor an instance of the class that declared the constructor.</source>
        </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve">
          <source>The type of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">parameters</ph><ept id="p1">&lt;/code&gt;</ept> parameter does not match the signature of the method or constructor reflected by this instance.</source>
        </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">parameters</ph><ept id="p1">&lt;/code&gt;</ept> array does not have the correct number of arguments.</source>
        </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve">
          <source>The invoked method or constructor throws an exception.</source>
        </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve">
          <source>The caller does not have permission to execute the method or constructor that is represented by the current instance.</source>
        </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve">
          <source>The type that declares the method is an open generic type.</source>
        </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve">
          <source>That is, the <ph id="ph1">&lt;xref href="System.Type.ContainsGenericParameters"&gt;&lt;/xref&gt;</ph> property returns <ph id="ph2">`true`</ph> for the declaring type.</source>
        </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve">
          <source>Invokes the method or constructor represented by the current instance, using the specified parameters.</source>
        </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT">
          <source>This is a convenience method that calls the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.Invoke%28System.Object%2CSystem.Reflection.BindingFlags%2CSystem.Reflection.Binder%2CSystem.Object%5B%5D%2CSystem.Globalization.CultureInfo%29&gt;</ph> method overload, passing <ph id="ph2">&lt;xref:System.Reflection.BindingFlags.Default&gt;</ph> for <ph id="ph3">`invokeAttr`</ph> and <ph id="ph4">`null`</ph> for <ph id="ph5">`binder`</ph> and <ph id="ph6">`culture`</ph>.</source>
        </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the invoked method throws an exception, the <ph id="ph1">&lt;xref:System.Exception.GetBaseException%2A?displayProperty=fullName&gt;</ph> method returns the exception.</source>
        </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT">
          <source>To invoke a static method using its <ph id="ph1">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object, pass <ph id="ph2">`null`</ph> for <ph id="ph3">`obj`</ph>.</source>
        </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this method overload is used to invoke an instance constructor, the object supplied for <ph id="ph1">`obj`</ph> is reinitialized; that is, all instance initializers are executed.</source>
        </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a class constructor is invoked, the class is reinitialized; that is, all class initializers are executed.</source>
        </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT">
          <source>The return value is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT">
          <source>Starting with the <ph id="ph1">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id="ph2">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id="ph3">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public members is restricted to the caller’s grant set, or a subset thereof.</source>
        </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT">
          <source>(See <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)</source>
        </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT">
          <source>To use this functionality, your application should target the <ph id="ph1">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.</source>
        </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a parameter of the current method is a value type, and the corresponding argument in <ph id="ph1">`parameters`</ph> is <ph id="ph2">`null`</ph>, the runtime passes a zero-initialized instance of the value type.</source>
        </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve">
          <source>The object on which to invoke the method or constructor.</source>
        </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve">
          <source>If a method is static, this argument is ignored.</source>
        </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve">
          <source>If a constructor is static, this argument must be <ph id="ph1">`null`</ph> or an instance of the class that defines the constructor.</source>
        </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve">
          <source>An argument list for the invoked method or constructor.</source>
        </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve">
          <source>This is an array of objects with the same number, order, and type as the parameters of the method or constructor to be invoked.</source>
        </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve">
          <source>If there are no parameters, <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">parameters</ph><ept id="p1">&lt;/code&gt;</ept> should be <ph id="ph2">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve">
          <source>If the method or constructor represented by this instance takes a <ph id="ph1">`ref`</ph> parameter (<ph id="ph2">`ByRef`</ph> in Visual Basic), no special attribute is required for that parameter in order to invoke the method or constructor using this function.</source>
        </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve">
          <source>Any object in this array that is not explicitly initialized with a value will contain the default value for that object type.</source>
        </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve">
          <source>For reference-type elements, this value is <ph id="ph1">`null`</ph>.</source>
        </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve">
          <source>For value-type elements, this value is 0, 0.0, or <ph id="ph1">`false`</ph>, depending on the specific element type.</source>
        </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve">
          <source>An object containing the return value of the invoked method, or <ph id="ph1">`null`</ph> in the case of a constructor.</source>
        </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch <ph id="ph1">&lt;xref href="System.Exception"&gt;&lt;/xref&gt;</ph> instead.</source>
        </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">obj</ph><ept id="p1">&lt;/code&gt;</ept> parameter is <ph id="ph2">`null`</ph> and the method is not static.</source>
        </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve">
          <source>The method is not declared or inherited by the class of <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">obj</ph><ept id="p1">&lt;/code&gt;</ept>.</source>
        </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve">
          <source>A static constructor is invoked, and <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">obj</ph><ept id="p1">&lt;/code&gt;</ept> is neither <ph id="ph2">`null`</ph> nor an instance of the class that declared the constructor.</source>
        </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve">
          <source>The elements of the <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">parameters</ph><ept id="p1">&lt;/code&gt;</ept> array do not match the signature of the method or constructor reflected by this instance.</source>
        </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve">
          <source>The invoked method or constructor throws an exception.</source>
        </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve">
          <source>-or-</source>
        </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve">
          <source>The current instance is a <ph id="ph1">&lt;xref href="System.Reflection.Emit.DynamicMethod"&gt;&lt;/xref&gt;</ph> that contains unverifiable code.</source>
        </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve">
          <source>See the "Verification" section in Remarks for <ph id="ph1">&lt;xref href="System.Reflection.Emit.DynamicMethod"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve">
          <source>The <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">parameters</ph><ept id="p1">&lt;/code&gt;</ept> array does not have the correct number of arguments.</source>
        </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve">
          <source>In the <bpt id="p1">[</bpt>.NET for Windows Store apps<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id="p2">[</bpt>Portable Class Library<ept id="p2">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id="ph1">&lt;xref href="System.MemberAccessException"&gt;&lt;/xref&gt;</ph>, instead.</source>
        </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve">
          <source>The caller does not have permission to execute the method or constructor that is represented by the current instance.</source>
        </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve">
          <source>The type that declares the method is an open generic type.</source>
        </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve">
          <source>That is, the <ph id="ph1">&lt;xref href="System.Type.ContainsGenericParameters"&gt;&lt;/xref&gt;</ph> property returns <ph id="ph2">`true`</ph> for the declaring type.</source>
        </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve">
          <source>The current instance is a <ph id="ph1">&lt;xref href="System.Reflection.Emit.MethodBuilder"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the method is abstract.</source>
        </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT">
          <source>An abstract member is declared on a base class and has no implementation supplied.</source>
        </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, first get the type.</source>
        </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT">
          <source>From the type, get the method.</source>
        </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT">
          <source>From the method, get the <ph id="ph1">`MethodBase`</ph>.</source>
        </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`MethodBase`</ph> or constructor is other than public, it is protected and cannot be readily accessed.</source>
        </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT">
          <source>To access a non-public method, set the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> mask to <ph id="ph2">`NonPublic`</ph> in <ph id="ph3">`GetMethod`</ph>.</source>
        </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the method is abstract; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the potential visibility of this method or constructor is described by <ph id="ph1">&lt;xref href="System.Reflection.MethodAttributes.Assembly"&gt;&lt;/xref&gt;</ph>; that is, the method or constructor is visible at most to other types in the same assembly, and is not visible to derived types outside the assembly.</source>
        </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT">
          <source>The actual visibility of a method is limited by the visibility of its type.</source>
        </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsAssembly%2A&gt;</ph> property might be <ph id="ph2">`true`</ph> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</source>
        </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes?displayProperty=fullName&gt;</ph> if the only visibility modifier is <ph id="ph2">`internal`</ph> (<ph id="ph3">`Friend`</ph> in Visual Basic).</source>
        </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is <ph id="ph1">`false`</ph> for methods that are <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++); use the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property to identify such methods.</source>
        </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the visibility of this method or constructor is exactly described by <ph id="ph2">&lt;xref href="System.Reflection.MethodAttributes.Assembly"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the method is a constructor.</source>
        </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsConstructor%2A&gt;</ph> property returns <ph id="ph2">`false`</ph> for a <ph id="ph3">&lt;xref:System.Reflection.Emit.ConstructorBuilder&gt;</ph> object in a dynamic type, unless the <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes?displayProperty=fullName&gt;</ph> flag was included in the <ph id="ph5">`attributes`</ph> parameter when the constructor was defined.</source>
        </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT">
          <source>Omitting the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.RTSpecialName&gt;</ph> flag does not affect the correctness of the emitted constructor.</source>
        </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this method is a constructor represented by a <ph id="ph2">&lt;xref href="System.Reflection.ConstructorInfo"&gt;&lt;/xref&gt;</ph> object (see note in Remarks about <ph id="ph3">&lt;xref href="System.Reflection.Emit.ConstructorBuilder"&gt;&lt;/xref&gt;</ph> objects); otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the visibility of this method or constructor is described by <ph id="ph1">&lt;xref href="System.Reflection.MethodAttributes.Family"&gt;&lt;/xref&gt;</ph>; that is, the method or constructor is visible only within its class and derived classes.</source>
        </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes?displayProperty=fullName&gt;</ph> if the only visibility modifier is <ph id="ph2">`protected`</ph>.</source>
        </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property is <ph id="ph1">`false`</ph> for methods that are <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++); use the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property to identify such methods.</source>
        </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;xref href="System.Reflection.MethodAttributes.Family"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the visibility of this method or constructor is described by <ph id="ph1">&lt;xref href="System.Reflection.MethodAttributes.FamANDAssem"&gt;&lt;/xref&gt;</ph>; that is, the method or constructor can be called by derived classes, but only if they are in the same assembly.</source>
        </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes?displayProperty=fullName&gt;</ph> if the visibility modifier is <ph id="ph2">`protected private`</ph> in C++.</source>
        </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT">
          <source>Methods with this visibility cannot be defined in Visual Basic or C#.</source>
        </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;xref href="System.Reflection.MethodAttributes.FamANDAssem"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the potential visibility of this method or constructor is described by <ph id="ph1">&lt;xref href="System.Reflection.MethodAttributes.FamORAssem"&gt;&lt;/xref&gt;</ph>; that is, the method or constructor can be called by derived classes wherever they are, and by classes in the same assembly.</source>
        </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a type member has <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes?displayProperty=fullName&gt;</ph>visibility, it can be called from any member in a derived class or any member in the same assembly, but not from any other type.</source>
        </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT">
          <source>The actual visibility of a method is limited by the visibility of its type.</source>
        </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A&gt;</ph> property might be <ph id="ph2">`true`</ph> for a method, but if it is a method of a private nested type then the method is not visible outside the containing type.</source>
        </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT">
          <source>The visibility of a method or constructor is exactly described by <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes?displayProperty=fullName&gt;</ph> if the visibility modifier is <ph id="ph2">`protected internal`</ph> in C# (<ph id="ph3">`Protected Friend`</ph> in Visual Basic, <ph id="ph4">`protected public`</ph> in C++).</source>
        </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if access to this method or constructor is exactly described by <ph id="ph2">&lt;xref href="System.Reflection.MethodAttributes.FamORAssem"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether this method is <ph id="ph1">`final`</ph>.</source>
        </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine if a method is overridable, it is not sufficient to check that <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsVirtual%2A&gt;</ph> is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a method to be overridable, <ph id="ph1">`IsVirtual`</ph> must be <ph id="ph2">`true`</ph> and <ph id="ph3">`IsFinal`</ph> must be <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a method might be non-virtual, but it implements an interface method.</source>
        </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime requires that all methods that implement interface members must be marked as <ph id="ph1">`virtual`</ph>; therefore, the compiler marks the method <ph id="ph2">`virtual final`</ph>.</source>
        </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT">
          <source>So there are cases where a method is marked as <ph id="ph1">`virtual`</ph> but is still not overridable.</source>
        </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT">
          <source>To establish with certainty whether a method is overridable, use code such as this:</source>
        </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`false`</ph> or <ph id="ph3">`IsFinal`</ph> is <ph id="ph4">`true`</ph>, then the method cannot be overridden.</source>
        </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this method is <ph id="ph2">`final`</ph>; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the method is generic.</source>
        </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethod%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> object represents a generic method.</source>
        </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT">
          <source>Use the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.ContainsGenericParameters%2A&gt;</ph> property to determine whether the current <ph id="ph2">&lt;xref:System.Reflection.MethodBase&gt;</ph> object represents an open constructed method or a closed constructed method.</source>
        </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT">
          <source>Generics are not supported by default; this property returns <ph id="ph1">`false`</ph> if not overridden in a derived class.</source>
        </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT">
          <source>Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <ph id="ph1">`false`</ph> if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">&lt;xref href="System.Reflection.MethodBase"&gt;&lt;/xref&gt;</ph> represents a generic method; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the method is a generic method definition.</source>
        </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the current <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> represents a generic method definition, then:</source>
        </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT">
          <source>For each <ph id="ph1">&lt;xref:System.Type&gt;</ph> object in the array returned by the <ph id="ph2">&lt;xref:System.Reflection.MethodBase.GetGenericArguments%2A&gt;</ph> method:</source>
        </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.IsGenericParameter%2A?displayProperty=fullName&gt;</ph> property is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.DeclaringMethod%2A?displayProperty=fullName&gt;</ph> property returns the current instance.</source>
        </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Type.GenericParameterPosition%2A?displayProperty=fullName&gt;</ph> property is the same as the position of the <ph id="ph2">&lt;xref:System.Type&gt;</ph> object in the array.</source>
        </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT">
          <source>Generics are not supported by default; this property returns <ph id="ph1">`false`</ph> if not overridden in a derived class.</source>
        </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT">
          <source>Generic constructors are not supported in the .NET Framework version 2.0, so this property returns <ph id="ph1">`false`</ph> if the current instance is of type <ph id="ph2">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for terms specific to generic methods, see the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.IsGenericMethod%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a list of the invariant conditions for other terms used in generic reflection, see the <ph id="ph1">&lt;xref:System.Type.IsGenericType%2A?displayProperty=fullName&gt;</ph> property.</source>
        </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current <ph id="ph2">&lt;xref href="System.Reflection.MethodBase"&gt;&lt;/xref&gt;</ph> object represents the definition of a generic method; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether only a member of the same kind with exactly the same signature is hidden in the derived class.</source>
        </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT">
          <source>When a member in a derived class is declared with the C# <ph id="ph1">`new`</ph> modifier or the Visual Basic <ph id="ph2">`Shadows`</ph> modifier, it can hide a member of the same name in the base class.</source>
        </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT">
          <source>C# hides base class members by signature.</source>
        </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT">
          <source>That is, if the base class member has multiple overloads, the only one that is hidden is the one that has the identical signature.</source>
        </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, Visual Basic hides all the base class overloads.</source>
        </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT">
          <source>Thus, <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> returns <ph id="ph2">`false`</ph> on a member declared with the Visual Basic <ph id="ph3">`Shadows`</ph> modifier, and <ph id="ph4">`true`</ph> on a member declared with the C# <ph id="ph5">`new`</ph> modifier.</source>
        </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT">
          <source>This property does not determine whether a method has the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute.</source>
        </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT">
          <source>A method that is declared with either the <ph id="ph1">`new`</ph> or the <ph id="ph2">`Shadows`</ph> modifier will have the <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, but only methods declared with <ph id="ph4">`new`</ph> (that is, only C# methods) will have the <ph id="ph5">&lt;xref:System.Reflection.MethodBase.IsHideBySig%2A&gt;</ph> property set to <ph id="ph6">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine whether a method has the <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, use code similar to the following: <ph id="ph2">`if ((myMethodInfo.Attributes &amp; MethodAttributes.VtableLayoutMask) == MethodAttributes.NewSlot)`</ph> in C# or <ph id="ph3">`If (myMethodInfo.Attributes And MethodAttributes.VtableLayoutMask) = MethodAttributes.NewSlot`</ph> in Visual Basic.</source>
        </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT">
          <source>Note, however, that although all methods declared with <ph id="ph1">`new`</ph> or <ph id="ph2">`Shadows`</ph> have the <ph id="ph3">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute, not all methods that have the <ph id="ph4">&lt;xref:System.Reflection.MethodAttributes.NewSlot&gt;</ph> attribute are declared with <ph id="ph5">`new`</ph> or <ph id="ph6">`Shadows`</ph>.</source>
        </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the member is hidden by signature; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether this member is private.</source>
        </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT">
          <source>If a type member has <ph id="ph1">`Private`</ph> level visibility, it can be called from any member in the same class and no others.</source>
        </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if access to this method is restricted to other members of the class itself; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether this is a public method.</source>
        </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT">
          <source>To get the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph>, first get the type.</source>
        </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT">
          <source>From the type, get the method.</source>
        </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT">
          <source>From the method, get the <ph id="ph1">`MethodBase`</ph>.</source>
        </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the <ph id="ph1">`MethodBase`</ph> or constructor is other than public, it is protected and cannot be readily accessed.</source>
        </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT">
          <source>To access a non-public method, set the <ph id="ph1">&lt;xref:System.Reflection.BindingFlags&gt;</ph> mask to <ph id="ph2">`NonPublic`</ph> in <ph id="ph3">`GetMethod`</ph>.</source>
        </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this method is public; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the current method or constructor is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</source>
        </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
        </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT">
          <source>The combinations of these properties are shown in the following table:</source>
        </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT">
          <source>Security level</source>
        </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecurityCritical</source>
        </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecuritySafeCritical</source>
        </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecurityTransparent</source>
        </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT">
          <source>Critical</source>
        </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT">
          <source>Safe critical</source>
        </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT">
          <source>Transparent</source>
        </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
        </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
        </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
        </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT">
          <source>The assembly and all its types are treated as transparent.</source>
        </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
        </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
        </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the current method or constructor is security-critical or security-safe-critical at the current trust level; <ph id="ph2">`false`</ph> if it is transparent.</source>
        </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the current method or constructor is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</source>
        </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
        </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT">
          <source>The combinations of these properties are shown in the following table:</source>
        </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT">
          <source>Security level</source>
        </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecurityCritical</source>
        </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecuritySafeCritical</source>
        </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT">
          <source>IsSecurityTransparent</source>
        </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT">
          <source>Critical</source>
        </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT">
          <source>Safe critical</source>
        </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT">
          <source>Transparent</source>
        </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
        </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
        </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
        </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT">
          <source>The assembly and all its types are treated as transparent.</source>
        </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
        </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
        </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the method or constructor is security-safe-critical at the current trust level; <ph id="ph2">`false`</ph> if it is security-critical or transparent.</source>
        </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve">
          <source>Gets a value that indicates whether the current method or constructor is transparent at the current trust level, and therefore cannot perform critical operations.</source>
        </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT">
          <source>If this property returns <ph id="ph1">`true`</ph>, the <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph> properties return <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodBase.IsSecurityCritical%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Reflection.MethodBase.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the method or constructor at its current trust level, as determined by the common language runtime (CLR).</source>
        </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT">
          <source>Using these properties is much simpler than examining the security annotations of an assembly and its types and members, checking the current trust level, and attempting to duplicate the runtime's rules.</source>
        </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT">
          <source>For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</source>
        </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT">
          <source>If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), the runtime ignores the security annotations of the assembly.</source>
        </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT">
          <source>The assembly and all its types are treated as transparent.</source>
        </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT">
          <source>The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</source>
        </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT">
          <source>By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</source>
        </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can determine the current trust levels of assemblies and application domains by using the <ph id="ph1">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> and <ph id="ph2">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> properties.</source>
        </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about reflection and transparency, see <bpt id="p1">[</bpt>Security Considerations for Reflection<ept id="p1">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT">
          <source>For information about transparency, see <bpt id="p1">[</bpt>Security Changes<ept id="p1">](~/docs/framework/security/security-changes.md)</ept>.</source>
        </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if the method or constructor is security-transparent at the current trust level; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether this method has a special name.</source>
        </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT">
          <source>The <ph id="ph1">&lt;xref:System.Reflection.MethodAttributes.SpecialName&gt;</ph> bit is set to flag members that are treated in a special way by some compilers (such as property accessors and operator overloading methods).</source>
        </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this method has a special name; otherwise, <ph id="ph2">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the method is <ph id="ph1">`static`</ph>.</source>
        </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT">
          <source>A static member cannot implicitly reference instance data in a class.</source>
        </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this method is <ph id="ph2">`static`</ph>; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve">
          <source>Gets a value indicating whether the method is <ph id="ph1">`virtual`</ph>.</source>
        </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT">
          <source>A virtual member may reference instance data in a class and must be referenced through an instance of the class.</source>
        </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT">
          <source>To determine if a method is overridable, it is not sufficient to check that <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`true`</ph>.</source>
        </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT">
          <source>For a method to be overridable, <ph id="ph1">`IsVirtual`</ph> must be <ph id="ph2">`true`</ph> and <ph id="ph3">&lt;xref:System.Reflection.MethodBase.IsFinal%2A&gt;</ph> must be <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT">
          <source>For example, a method might be non-virtual, but it implements an interface method.</source>
        </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT">
          <source>The common language runtime requires that all methods that implement interface members must be marked as <ph id="ph1">`virtual`</ph>; therefore, the compiler marks the method <ph id="ph2">`virtual final`</ph>.</source>
        </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT">
          <source>So there are cases where a method is marked as <ph id="ph1">`virtual`</ph> but is still not overridable.</source>
        </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT">
          <source>To establish with certainty whether a method is overridable, use code such as this:</source>
        </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT">
          <source>If <ph id="ph1">`IsVirtual`</ph> is <ph id="ph2">`false`</ph> or <ph id="ph3">`IsFinal`</ph> is <ph id="ph4">`true`</ph>, then the method cannot be overridden.</source>
        </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT">
          <source>You can determine whether the current method overrides a method in a base class by calling the <ph id="ph1">&lt;xref:System.Reflection.MethodInfo.GetBaseDefinition%2A?displayProperty=fullName&gt;</ph> method.</source>
        </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT">
          <source>The following example implements an <ph id="ph1">`IsOverride`</ph> method that does this.</source>
        </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT">
          <source><bpt id="p1">[!code-csharp</bpt><bpt id="p2">[</bpt>system.reflection.methodinfo.getbasedefinition#2<ept id="p2">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)</ept><ept id="p1">]</ept> <bpt id="p3">[!code-vb</bpt><bpt id="p4">[</bpt>system.reflection.methodinfo.getbasedefinition#2<ept id="p4">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)</ept><ept id="p3">]</ept></source>
        </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if this method is <ph id="ph2">`virtual`</ph>; otherwise, <ph id="ph3">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve">
          <source>Gets a handle to the internal metadata representation of a method.</source>
        </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT">
          <source>The handles are valid only in the application domain in which they were obtained.</source>
        </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve">
          <source>A <ph id="ph1">&lt;xref href="System.RuntimeMethodHandle"&gt;&lt;/xref&gt;</ph> object.</source>
        </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve">
          <source>Gets the <ph id="ph1">&lt;xref href="System.Reflection.MethodImplAttributes"&gt;&lt;/xref&gt;</ph> flags that specify the attributes of a method implementation.</source>
        </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT">
          <source>See the <ph id="ph1">&lt;xref:System.Reflection.MethodBase.GetMethodImplementationFlags%2A&gt;</ph> method for more information.</source>
        </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve">
          <source>The method implementation flags.</source>
        </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve">
          <source>Indicates whether two <ph id="ph1">&lt;xref href="System.Reflection.MethodBase"&gt;&lt;/xref&gt;</ph> objects are equal.</source>
        </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve">
          <source>The first object to compare.</source>
        </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve">
          <source>The second object to compare.</source>
        </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve">
          <source>Indicates whether two <ph id="ph1">&lt;xref href="System.Reflection.MethodBase"&gt;&lt;/xref&gt;</ph> objects are not equal.</source>
        </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve">
          <source>The first object to compare.</source>
        </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve">
          <source>The second object to compare.</source>
        </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve">
          <source><ph id="ph1">`true`</ph> if <bpt id="p1">&lt;code&gt;</bpt><ph id="ph2">left</ph><ept id="p1">&lt;/code&gt;</ept> is not equal to <bpt id="p2">&lt;code&gt;</bpt><ph id="ph3">right</ph><ept id="p2">&lt;/code&gt;</ept>; otherwise, <ph id="ph4">`false`</ph>.</source>
        </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve">
          <source>Maps a set of names to a corresponding set of dispatch identifiers.</source>
        </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
        </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
        </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve">
          <source>Passed-in array of names to be mapped.</source>
        </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve">
          <source>Count of the names to be mapped.</source>
        </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret the names.</source>
        </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve">
          <source>Caller-allocated array which receives the IDs corresponding to the names.</source>
        </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.GetType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.GetType"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve">
          <source>Retrieves the type information for an object, which can then be used to get the type information for an interface.</source>
        </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve">
          <source>The type information to return.</source>
        </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve">
          <source>The locale identifier for the type information.</source>
        </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve">
          <source>Receives a pointer to the requested type information object.</source>
        </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve">
          <source>Retrieves the number of type information interfaces that an object provides (either 0 or 1).</source>
        </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve">
          <source>Points to a location that receives the number of type information interfaces provided by the object.</source>
        </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve">
          <source>Provides access to properties and methods exposed by an object.</source>
        </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT">
          <source>This method is for access to managed classes from unmanaged code, and should not be called from managed code.</source>
        </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT">
          <source>For more information about <ph id="ph1">`IDispatch::Invoke`</ph>, see the MSDN Library.</source>
        </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve">
          <source>Identifies the member.</source>
        </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve">
          <source>Reserved for future use.</source>
        </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve">
          <source>Must be IID_NULL.</source>
        </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve">
          <source>The locale context in which to interpret arguments.</source>
        </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve">
          <source>Flags describing the context of the call.</source>
        </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve">
          <source>Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</source>
        </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve">
          <source>Pointer to the location where the result is to be stored.</source>
        </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve">
          <source>Pointer to a structure that contains exception information.</source>
        </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve">
          <source>The index of the first argument that has an error.</source>
        </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve">
          <source>Late-bound access using the COM <bpt id="p1">&lt;code&gt;</bpt><ph id="ph1">IDispatch</ph><ept id="p1">&lt;/code&gt;</ept> interface is not supported.</source>
        </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsAbstract"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsAbstract"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsAssembly"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsAssembly"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsConstructor"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsConstructor"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsFamily"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsFamily"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsFamilyAndAssembly"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsFamilyOrAssembly"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsFinal"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsFinal"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsHideBySig"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsHideBySig"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsPrivate"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsPrivate"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsPublic"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsPublic"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsSpecialName"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsSpecialName"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsStatic"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsStatic"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsVirtual"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT">
          <source>This member is an explicit interface member implementation.</source>
        </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Reflection.MethodBase&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Runtime.InteropServices._MethodBase&gt;</ph> interface.</source>
        </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve">
          <source>For a description of this member, see <ph id="ph1">&lt;xref href="System.Runtime.InteropServices._MethodBase.IsVirtual"&gt;&lt;/xref&gt;</ph>.</source>
        </trans-unit>
      </group>
    </body>
  </file>
</xliff>