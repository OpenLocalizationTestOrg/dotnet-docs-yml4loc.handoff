{"nodes":[{"content":"Represents a wrapper class for operating system handles. This class must be inherited.","nodes":[{"pos":[0,86],"content":"Represents a wrapper class for operating system handles. This class must be inherited.","nodes":[{"content":"Represents a wrapper class for operating system handles. This class must be inherited.","pos":[0,86],"nodes":[{"content":"Represents a wrapper class for operating system handles.","pos":[0,56]},{"content":"This class must be inherited.","pos":[57,86]}]}]}],"pos":[1416,1503],"yaml":true},{"content":"The <xref:System.Runtime.InteropServices.SafeHandle> class provides critical finalization of handle resources, preventing handles from being reclaimed prematurely by garbage collection and from being recycled by Windows to reference unintended unmanaged objects.  \n  \n This topic includes the following sections:  \n  \n [Why SafeHandle?](#Why)   \n [What SafeHandle does](#Does)   \n [Classes derived from SafeHandle](#Derived)  \n  \n<a name=\"Why\"></a>   \n## Why SafeHandle?  \n Before the .NET Framework version 2.0, all operating system handles could only be encapsulated in the <xref:System.IntPtr> managed wrapper object. While this was a convenient way to interoperate with native code, handles could be leaked by asynchronous exceptions, such as a thread aborting unexpectedly or a stack overflow. These asynchronous exceptions are an obstacle to cleaning up operating system resources, and they can occur almost anywhere in your app.  \n  \n Although overrides to the <xref:System.Object.Finalize%2A?displayProperty=fullName> method allow cleanup of unmanaged resources when an object is being garbage collected, in some circumstances, finalizable objects can be reclaimed by garbage collection while executing a method within a platform invoke call. If a finalizer frees the handle passed to that platform invoke call, it could lead to handle corruption. The handle could also be reclaimed while your method is blocked during a platform invoke call, such as while reading a file.  \n  \n More critically, because Windows aggressively recycles handles, a handle could be recycled and point to another resource that might contain sensitive data. This is known as a recycle attack and can potentially corrupt data and be a security threat.  \n  \n<a name=\"Does\"></a>   \n## What SafeHandle does  \n The <xref:System.Runtime.InteropServices.SafeHandle> class simplifies several of these object lifetime issues, and is integrated with platform invoke so that operating system resources are not leaked. The <xref:System.Runtime.InteropServices.SafeHandle> class resolves object lifetime issues by assigning and releasing handles without interruption. It contains a critical finalizer that ensures that the handle is closed and is guaranteed to run during unexpected <xref:System.AppDomain> unloads, even in cases when the platform invoke call is assumed to be in a corrupted state.  \n  \n Because <xref:System.Runtime.InteropServices.SafeHandle> inherits from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, all the noncritical finalizers are called before any of the critical finalizers. The finalizers are called on objects that are no longer live during the same garbage collection pass. For example, a <xref:System.IO.FileStream> object can run a normal finalizer to flush out existing buffered data without the risk of the handle being leaked or recycled. This very weak ordering between critical and noncritical finalizers is not intended for general use. It exists primarily to assist in the migration of existing libraries by allowing those libraries to use <xref:System.Runtime.InteropServices.SafeHandle> without altering their semantics. Additionally, the critical finalizer and anything it calls, such as the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=fullName> method, must be in a constrained execution region. This imposes constraints on what code can be written within the finalizer's call graph.  \n  \n Platform invoke operations automatically increment the reference count of handles encapsulated by a <xref:System.Runtime.InteropServices.SafeHandle> and decrement them upon completion. This ensures that the handle will not be recycled or closed unexpectedly.  \n  \n You can specify ownership of the underlying handle when constructing <xref:System.Runtime.InteropServices.SafeHandle> objects by supplying a value to the `ownsHandle` argument in the <xref:System.Runtime.InteropServices.SafeHandle> class constructor. This controls whether the <xref:System.Runtime.InteropServices.SafeHandle> object will release the handle after the object has been disposed.  This is useful for handles with peculiar lifetime requirements or for consuming a handle whose lifetime is controlled by someone else.  \n  \n<a name=\"Derived\"></a>   \n## Classes derived from SafeHandle  \n <xref:System.Runtime.InteropServices.SafeHandle> is an abstract wrapper class for operating system handles. Deriving from this class is difficult. Instead, use the derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace that provide safe handles for the following:  \n  \n-   Files (the <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> class).  \n  \n-   Memory mapped files (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> class).  \n  \n-   Pipes (the <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class).  \n  \n-   Memory views (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class).  \n  \n-   Cryptography constructs (the <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes).  \n  \n-   Processes (the <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> class).  \n  \n-   Registry keys (the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class).  \n  \n-   Wait handles (the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class).","nodes":[{"pos":[0,262],"content":"The <xref:System.Runtime.InteropServices.SafeHandle> class provides critical finalization of handle resources, preventing handles from being reclaimed prematurely by garbage collection and from being recycled by Windows to reference unintended unmanaged objects.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class provides critical finalization of handle resources, preventing handles from being reclaimed prematurely by garbage collection and from being recycled by Windows to reference unintended unmanaged objects.","pos":[0,262],"source":"The <xref:System.Runtime.InteropServices.SafeHandle> class provides critical finalization of handle resources, preventing handles from being reclaimed prematurely by garbage collection and from being recycled by Windows to reference unintended unmanaged objects."}]},{"pos":[269,312],"content":"This topic includes the following sections:","nodes":[{"content":"This topic includes the following sections:","pos":[0,43]}]},{"pos":[319,424],"content":"[Why SafeHandle?](#Why)   \n [What SafeHandle does](#Does)   \n [Classes derived from SafeHandle](#Derived)","nodes":[{"content":"<bpt id=\"p1\">[</bpt>Why SafeHandle?<ept id=\"p1\">](#Why)</ept><ph id=\"ph1\"> </ph>","pos":[0,24],"source":"[Why SafeHandle?](#Why) "},{"content":"<bpt id=\"p1\"> [</bpt>What SafeHandle does<ept id=\"p1\">](#Does)</ept><ph id=\"ph1\"> </ph>","pos":[27,58],"source":" [What SafeHandle does](#Does) "},{"content":"<bpt id=\"p1\"> [</bpt>Classes derived from SafeHandle<ept id=\"p1\">](#Derived)</ept>","pos":[61,105],"source":" [Classes derived from SafeHandle](#Derived)"}]},{"pos":[455,470],"content":"Why SafeHandle?","linkify":"Why SafeHandle?","nodes":[{"content":"Why SafeHandle?","pos":[0,15]}]},{"pos":[474,935],"content":"Before the .NET Framework version 2.0, all operating system handles could only be encapsulated in the <xref:System.IntPtr> managed wrapper object. While this was a convenient way to interoperate with native code, handles could be leaked by asynchronous exceptions, such as a thread aborting unexpectedly or a stack overflow. These asynchronous exceptions are an obstacle to cleaning up operating system resources, and they can occur almost anywhere in your app.","nodes":[{"content":"Before the .NET Framework version 2.0, all operating system handles could only be encapsulated in the <xref:System.IntPtr> managed wrapper object. While this was a convenient way to interoperate with native code, handles could be leaked by asynchronous exceptions, such as a thread aborting unexpectedly or a stack overflow. These asynchronous exceptions are an obstacle to cleaning up operating system resources, and they can occur almost anywhere in your app.","pos":[0,461],"nodes":[{"content":"Before the .NET Framework version 2.0, all operating system handles could only be encapsulated in the <ph id=\"ph1\">&lt;xref:System.IntPtr&gt;</ph> managed wrapper object.","pos":[0,146],"source":"Before the .NET Framework version 2.0, all operating system handles could only be encapsulated in the <xref:System.IntPtr> managed wrapper object."},{"content":"While this was a convenient way to interoperate with native code, handles could be leaked by asynchronous exceptions, such as a thread aborting unexpectedly or a stack overflow.","pos":[147,324]},{"content":"These asynchronous exceptions are an obstacle to cleaning up operating system resources, and they can occur almost anywhere in your app.","pos":[325,461]}]}]},{"pos":[942,1480],"content":"Although overrides to the <xref:System.Object.Finalize%2A?displayProperty=fullName> method allow cleanup of unmanaged resources when an object is being garbage collected, in some circumstances, finalizable objects can be reclaimed by garbage collection while executing a method within a platform invoke call. If a finalizer frees the handle passed to that platform invoke call, it could lead to handle corruption. The handle could also be reclaimed while your method is blocked during a platform invoke call, such as while reading a file.","nodes":[{"content":"Although overrides to the <xref:System.Object.Finalize%2A?displayProperty=fullName> method allow cleanup of unmanaged resources when an object is being garbage collected, in some circumstances, finalizable objects can be reclaimed by garbage collection while executing a method within a platform invoke call. If a finalizer frees the handle passed to that platform invoke call, it could lead to handle corruption. The handle could also be reclaimed while your method is blocked during a platform invoke call, such as while reading a file.","pos":[0,538],"nodes":[{"content":"Although overrides to the <ph id=\"ph1\">&lt;xref:System.Object.Finalize%2A?displayProperty=fullName&gt;</ph> method allow cleanup of unmanaged resources when an object is being garbage collected, in some circumstances, finalizable objects can be reclaimed by garbage collection while executing a method within a platform invoke call.","pos":[0,308],"source":"Although overrides to the <xref:System.Object.Finalize%2A?displayProperty=fullName> method allow cleanup of unmanaged resources when an object is being garbage collected, in some circumstances, finalizable objects can be reclaimed by garbage collection while executing a method within a platform invoke call."},{"content":"If a finalizer frees the handle passed to that platform invoke call, it could lead to handle corruption.","pos":[309,413]},{"content":"The handle could also be reclaimed while your method is blocked during a platform invoke call, such as while reading a file.","pos":[414,538]}]}]},{"pos":[1487,1735],"content":"More critically, because Windows aggressively recycles handles, a handle could be recycled and point to another resource that might contain sensitive data. This is known as a recycle attack and can potentially corrupt data and be a security threat.","nodes":[{"content":"More critically, because Windows aggressively recycles handles, a handle could be recycled and point to another resource that might contain sensitive data. This is known as a recycle attack and can potentially corrupt data and be a security threat.","pos":[0,248],"nodes":[{"content":"More critically, because Windows aggressively recycles handles, a handle could be recycled and point to another resource that might contain sensitive data.","pos":[0,155]},{"content":"This is known as a recycle attack and can potentially corrupt data and be a security threat.","pos":[156,248]}]}]},{"pos":[1767,1787],"content":"What SafeHandle does","linkify":"What SafeHandle does","nodes":[{"content":"What SafeHandle does","pos":[0,20]}]},{"pos":[1791,2370],"content":"The <xref:System.Runtime.InteropServices.SafeHandle> class simplifies several of these object lifetime issues, and is integrated with platform invoke so that operating system resources are not leaked. The <xref:System.Runtime.InteropServices.SafeHandle> class resolves object lifetime issues by assigning and releasing handles without interruption. It contains a critical finalizer that ensures that the handle is closed and is guaranteed to run during unexpected <xref:System.AppDomain> unloads, even in cases when the platform invoke call is assumed to be in a corrupted state.","nodes":[{"content":"The <xref:System.Runtime.InteropServices.SafeHandle> class simplifies several of these object lifetime issues, and is integrated with platform invoke so that operating system resources are not leaked. The <xref:System.Runtime.InteropServices.SafeHandle> class resolves object lifetime issues by assigning and releasing handles without interruption. It contains a critical finalizer that ensures that the handle is closed and is guaranteed to run during unexpected <xref:System.AppDomain> unloads, even in cases when the platform invoke call is assumed to be in a corrupted state.","pos":[0,579],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class simplifies several of these object lifetime issues, and is integrated with platform invoke so that operating system resources are not leaked.","pos":[0,200],"source":"The <xref:System.Runtime.InteropServices.SafeHandle> class simplifies several of these object lifetime issues, and is integrated with platform invoke so that operating system resources are not leaked."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class resolves object lifetime issues by assigning and releasing handles without interruption.","pos":[201,348],"source":" The <xref:System.Runtime.InteropServices.SafeHandle> class resolves object lifetime issues by assigning and releasing handles without interruption."},{"content":"It contains a critical finalizer that ensures that the handle is closed and is guaranteed to run during unexpected <ph id=\"ph1\">&lt;xref:System.AppDomain&gt;</ph> unloads, even in cases when the platform invoke call is assumed to be in a corrupted state.","pos":[349,579],"source":" It contains a critical finalizer that ensures that the handle is closed and is guaranteed to run during unexpected <xref:System.AppDomain> unloads, even in cases when the platform invoke call is assumed to be in a corrupted state."}]}]},{"pos":[2377,3455],"content":"Because <xref:System.Runtime.InteropServices.SafeHandle> inherits from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, all the noncritical finalizers are called before any of the critical finalizers. The finalizers are called on objects that are no longer live during the same garbage collection pass. For example, a <xref:System.IO.FileStream> object can run a normal finalizer to flush out existing buffered data without the risk of the handle being leaked or recycled. This very weak ordering between critical and noncritical finalizers is not intended for general use. It exists primarily to assist in the migration of existing libraries by allowing those libraries to use <xref:System.Runtime.InteropServices.SafeHandle> without altering their semantics. Additionally, the critical finalizer and anything it calls, such as the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=fullName> method, must be in a constrained execution region. This imposes constraints on what code can be written within the finalizer's call graph.","nodes":[{"content":"Because <xref:System.Runtime.InteropServices.SafeHandle> inherits from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, all the noncritical finalizers are called before any of the critical finalizers. The finalizers are called on objects that are no longer live during the same garbage collection pass. For example, a <xref:System.IO.FileStream> object can run a normal finalizer to flush out existing buffered data without the risk of the handle being leaked or recycled. This very weak ordering between critical and noncritical finalizers is not intended for general use. It exists primarily to assist in the migration of existing libraries by allowing those libraries to use <xref:System.Runtime.InteropServices.SafeHandle> without altering their semantics. Additionally, the critical finalizer and anything it calls, such as the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=fullName> method, must be in a constrained execution region. This imposes constraints on what code can be written within the finalizer's call graph.","pos":[0,1078],"nodes":[{"content":"Because <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> inherits from <ph id=\"ph2\">&lt;xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject&gt;</ph>, all the noncritical finalizers are called before any of the critical finalizers.","pos":[0,219],"source":"Because <xref:System.Runtime.InteropServices.SafeHandle> inherits from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, all the noncritical finalizers are called before any of the critical finalizers."},{"content":"The finalizers are called on objects that are no longer live during the same garbage collection pass.","pos":[220,321]},{"content":"For example, a <ph id=\"ph1\">&lt;xref:System.IO.FileStream&gt;</ph> object can run a normal finalizer to flush out existing buffered data without the risk of the handle being leaked or recycled.","pos":[322,491],"source":" For example, a <xref:System.IO.FileStream> object can run a normal finalizer to flush out existing buffered data without the risk of the handle being leaked or recycled."},{"content":"This very weak ordering between critical and noncritical finalizers is not intended for general use.","pos":[492,592]},{"content":"It exists primarily to assist in the migration of existing libraries by allowing those libraries to use <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> without altering their semantics.","pos":[593,779],"source":" It exists primarily to assist in the migration of existing libraries by allowing those libraries to use <xref:System.Runtime.InteropServices.SafeHandle> without altering their semantics."},{"content":"Additionally, the critical finalizer and anything it calls, such as the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=fullName&gt;</ph> method, must be in a constrained execution region.","pos":[780,990],"source":" Additionally, the critical finalizer and anything it calls, such as the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=fullName> method, must be in a constrained execution region."},{"content":"This imposes constraints on what code can be written within the finalizer's call graph.","pos":[991,1078]}]}]},{"pos":[3462,3720],"content":"Platform invoke operations automatically increment the reference count of handles encapsulated by a <xref:System.Runtime.InteropServices.SafeHandle> and decrement them upon completion. This ensures that the handle will not be recycled or closed unexpectedly.","nodes":[{"content":"Platform invoke operations automatically increment the reference count of handles encapsulated by a <xref:System.Runtime.InteropServices.SafeHandle> and decrement them upon completion. This ensures that the handle will not be recycled or closed unexpectedly.","pos":[0,258],"nodes":[{"content":"Platform invoke operations automatically increment the reference count of handles encapsulated by a <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> and decrement them upon completion.","pos":[0,184],"source":"Platform invoke operations automatically increment the reference count of handles encapsulated by a <xref:System.Runtime.InteropServices.SafeHandle> and decrement them upon completion."},{"content":"This ensures that the handle will not be recycled or closed unexpectedly.","pos":[185,258]}]}]},{"pos":[3727,4255],"content":"You can specify ownership of the underlying handle when constructing <xref:System.Runtime.InteropServices.SafeHandle> objects by supplying a value to the `ownsHandle` argument in the <xref:System.Runtime.InteropServices.SafeHandle> class constructor. This controls whether the <xref:System.Runtime.InteropServices.SafeHandle> object will release the handle after the object has been disposed.  This is useful for handles with peculiar lifetime requirements or for consuming a handle whose lifetime is controlled by someone else.","nodes":[{"content":"You can specify ownership of the underlying handle when constructing <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> objects by supplying a value to the <ph id=\"ph2\">`ownsHandle`</ph> argument in the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class constructor.","pos":[0,250],"source":"You can specify ownership of the underlying handle when constructing <xref:System.Runtime.InteropServices.SafeHandle> objects by supplying a value to the `ownsHandle` argument in the <xref:System.Runtime.InteropServices.SafeHandle> class constructor."},{"content":"This controls whether the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object will release the handle after the object has been disposed.","pos":[251,392],"source":" This controls whether the <xref:System.Runtime.InteropServices.SafeHandle> object will release the handle after the object has been disposed."},{"content":"This is useful for handles with peculiar lifetime requirements or for consuming a handle whose lifetime is controlled by someone else.","pos":[394,528]}]},{"pos":[4290,4321],"content":"Classes derived from SafeHandle","linkify":"Classes derived from SafeHandle","nodes":[{"content":"Classes derived from SafeHandle","pos":[0,31]}]},{"pos":[4325,4601],"content":"<xref:System.Runtime.InteropServices.SafeHandle> is an abstract wrapper class for operating system handles. Deriving from this class is difficult. Instead, use the derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace that provide safe handles for the following:","nodes":[{"content":"<xref:System.Runtime.InteropServices.SafeHandle> is an abstract wrapper class for operating system handles. Deriving from this class is difficult. Instead, use the derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace that provide safe handles for the following:","pos":[0,276],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> is an abstract wrapper class for operating system handles.","pos":[0,107],"source":"<xref:System.Runtime.InteropServices.SafeHandle> is an abstract wrapper class for operating system handles."},{"content":"Deriving from this class is difficult.","pos":[108,146]},{"content":"Instead, use the derived classes in the <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles&gt;</ph> namespace that provide safe handles for the following:","pos":[147,276],"source":" Instead, use the derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace that provide safe handles for the following:"}]}]},{"pos":[4611,4679],"content":"Files (the <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> class).","nodes":[{"content":"Files (the <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeFileHandle&gt;</ph> class).","pos":[0,68],"source":"Files (the <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> class)."}]},{"pos":[4689,4783],"content":"Memory mapped files (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> class).","nodes":[{"content":"Memory mapped files (the <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle&gt;</ph> class).","pos":[0,94],"source":"Memory mapped files (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> class)."}]},{"pos":[4793,4861],"content":"Pipes (the <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class).","nodes":[{"content":"Pipes (the <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafePipeHandle&gt;</ph> class).","pos":[0,68],"source":"Pipes (the <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class)."}]},{"pos":[4871,4958],"content":"Memory views (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class).","nodes":[{"content":"Memory views (the <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle&gt;</ph> class).","pos":[0,87],"source":"Memory views (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class)."}]},{"pos":[4968,5238],"content":"Cryptography constructs (the <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes).","nodes":[{"content":"Cryptography constructs (the <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle&gt;</ph>, <ph id=\"ph2\">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle&gt;</ph>, <ph id=\"ph3\">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle&gt;</ph>, and <ph id=\"ph4\">&lt;xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle&gt;</ph> classes).","pos":[0,270],"source":"Cryptography constructs (the <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes)."}]},{"pos":[5248,5323],"content":"Processes (the <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> class).","nodes":[{"content":"Processes (the <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeProcessHandle&gt;</ph> class).","pos":[0,75],"source":"Processes (the <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> class)."}]},{"pos":[5333,5413],"content":"Registry keys (the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class).","nodes":[{"content":"Registry keys (the <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle&gt;</ph> class).","pos":[0,80],"source":"Registry keys (the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class)."}]},{"pos":[5423,5498],"content":"Wait handles (the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class).","nodes":[{"content":"Wait handles (the <ph id=\"ph1\">&lt;xref:Microsoft.Win32.SafeHandles.SafeWaitHandle&gt;</ph> class).","pos":[0,75],"source":"Wait handles (the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class)."}]}],"pos":[1514,7065],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> class with the specified invalid handle value.","nodes":[{"pos":[0,143],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.SafeHandle\"&gt;&lt;/xref&gt;</ph> class with the specified invalid handle value.","source":"Initializes a new instance of the <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> class with the specified invalid handle value."}],"pos":[11847,11991],"yaml":true},{"content":"If the `ownsHandle` parameter is `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is never called; thus, it is not recommended to use this parameter value as your code may leak resources.","nodes":[{"pos":[0,213],"content":"If the <ph id=\"ph1\">`ownsHandle`</ph> parameter is <ph id=\"ph2\">`false`</ph>, <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> is never called; thus, it is not recommended to use this parameter value as your code may leak resources.","source":"If the `ownsHandle` parameter is `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is never called; thus, it is not recommended to use this parameter value as your code may leak resources."}],"pos":[12002,12216],"yaml":true,"extradata":"MT"},{"content":"The value of an invalid handle (usually 0 or -1).  Your implementation of <xref href=\"System.Runtime.InteropServices.SafeHandle.IsInvalid\"></xref> should return `true` for this value.","nodes":[{"pos":[0,183],"content":"The value of an invalid handle (usually 0 or -1).  Your implementation of <xref href=\"System.Runtime.InteropServices.SafeHandle.IsInvalid\"></xref> should return `true` for this value.","nodes":[{"content":"The value of an invalid handle (usually 0 or -1).","pos":[0,49]},{"content":"Your implementation of <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.SafeHandle.IsInvalid\"&gt;&lt;/xref&gt;</ph> should return <ph id=\"ph2\">`true`</ph> for this value.","pos":[51,183],"source":"  Your implementation of <xref href=\"System.Runtime.InteropServices.SafeHandle.IsInvalid\"></xref> should return `true` for this value."}]}],"pos":[12396,12580],"yaml":true},{"content":"`true` to reliably let <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> release the handle during the finalization phase; otherwise, `false` (not recommended).","nodes":[{"pos":[0,173],"content":"<ph id=\"ph1\">`true`</ph> to reliably let <ph id=\"ph2\">&lt;xref href=\"System.Runtime.InteropServices.SafeHandle\"&gt;&lt;/xref&gt;</ph> release the handle during the finalization phase; otherwise, <ph id=\"ph3\">`false`</ph> (not recommended).","source":"`true` to reliably let <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> release the handle during the finalization phase; otherwise, `false` (not recommended)."}],"pos":[12647,12823],"yaml":true},{"content":"The derived class resides in an assembly without unmanaged code access permission.","nodes":[{"pos":[0,82],"content":"The derived class resides in an assembly without unmanaged code access permission.","nodes":[{"content":"The derived class resides in an assembly without unmanaged code access permission.","pos":[0,82]}]}],"pos":[12992,13075],"yaml":true},{"content":"Marks the handle for releasing and freeing resources.","nodes":[{"pos":[0,53],"content":"Marks the handle for releasing and freeing resources.","nodes":[{"content":"Marks the handle for releasing and freeing resources.","pos":[0,53]}]}],"pos":[14510,14564],"yaml":true},{"content":"Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed. This might not happen immediately if other threads are using the same safe handle object, but will happen as soon as that is no longer the case. Although most classes that use the <xref:System.Runtime.InteropServices.SafeHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.  \n  \n Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object.  \n  \n> [!NOTE]\n>  Always call <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.","nodes":[{"pos":[0,712],"content":"Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed. This might not happen immediately if other threads are using the same safe handle object, but will happen as soon as that is no longer the case. Although most classes that use the <xref:System.Runtime.InteropServices.SafeHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.","nodes":[{"content":"Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed. This might not happen immediately if other threads are using the same safe handle object, but will happen as soon as that is no longer the case. Although most classes that use the <xref:System.Runtime.InteropServices.SafeHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.","pos":[0,712],"nodes":[{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.","pos":[0,173],"source":"Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed."},{"content":"This might not happen immediately if other threads are using the same safe handle object, but will happen as soon as that is no longer the case.","pos":[174,318]},{"content":"Although most classes that use the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).","pos":[319,553],"source":" Although most classes that use the <xref:System.Runtime.InteropServices.SafeHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory)."},{"content":"In this case, the class can provide a finalizer that is guaranteed to run before the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> critical finalizer runs.","pos":[554,712],"source":" In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs."}]}]},{"pos":[719,944],"content":"Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object.","pos":[0,225],"source":"Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object."}]},{"pos":[952,1418],"content":"[!NOTE]\n Always call <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.","leadings":["","> "],"nodes":[{"content":" Always call <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.","pos":[8,464],"nodes":[{"content":"Always call <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> before you release your last reference to the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object.","pos":[1,236],"source":" Always call <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object."},{"content":"Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object's <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A&gt;</ph> method.","pos":[237,456],"source":" Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method."}]}]}],"pos":[14575,16001],"yaml":true,"extradata":"MT"},{"content":"Manually increments the reference counter on <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> instances.","nodes":[{"pos":[0,118],"content":"Manually increments the reference counter on <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.SafeHandle\"&gt;&lt;/xref&gt;</ph> instances.","source":"Manually increments the reference counter on <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> instances."}],"pos":[17608,17727],"yaml":true},{"content":"The <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method). You can use this method to manually increment the reference count on a <xref:System.Runtime.InteropServices.SafeHandle> instance. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> returns a Boolean value using a `ref` parameter (`success`) that indicates whether the reference count was incremented successfully. This allows your program logic to back out in case of failure. You should set `success` to `false` before calling <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. If `success` is `true`, avoid resource leaks by matching the call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> with a corresponding call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.  \n  \n> [!CAUTION]\n>  This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.","nodes":[{"pos":[0,1021],"content":"The <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method). You can use this method to manually increment the reference count on a <xref:System.Runtime.InteropServices.SafeHandle> instance. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> returns a Boolean value using a `ref` parameter (`success`) that indicates whether the reference count was incremented successfully. This allows your program logic to back out in case of failure. You should set `success` to `false` before calling <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. If `success` is `true`, avoid resource leaks by matching the call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> with a corresponding call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> method).","pos":[0,271],"source":"The <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method)."},{"content":"You can use this method to manually increment the reference count on a <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> instance.","pos":[272,401],"source":" You can use this method to manually increment the reference count on a <xref:System.Runtime.InteropServices.SafeHandle> instance."},{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> returns a Boolean value using a <ph id=\"ph2\">`ref`</ph> parameter (<ph id=\"ph3\">`success`</ph>) that indicates whether the reference count was incremented successfully.","pos":[402,602],"source":" <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> returns a Boolean value using a `ref` parameter (`success`) that indicates whether the reference count was incremented successfully."},{"content":"This allows your program logic to back out in case of failure.","pos":[603,665]},{"content":"You should set <ph id=\"ph1\">`success`</ph> to <ph id=\"ph2\">`false`</ph> before calling <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph>.","pos":[666,785],"source":" You should set `success` to `false` before calling <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>."},{"content":"If <ph id=\"ph1\">`success`</ph> is <ph id=\"ph2\">`true`</ph>, avoid resource leaks by matching the call to <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> with a corresponding call to <ph id=\"ph4\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph>.","pos":[786,1021],"source":" If `success` is `true`, avoid resource leaks by matching the call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> with a corresponding call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>."}]},{"pos":[1029,1274],"content":"[!CAUTION]\n This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.","leadings":["","> "],"nodes":[{"content":" This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.","pos":[11,243],"nodes":[{"content":"This method is intended for advanced users and must always be used carefully.","pos":[1,78]},{"content":"To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.","pos":[79,232]}]}]}],"pos":[17738,19018],"yaml":true,"extradata":"MT"},{"content":"`true` if the reference counter was successfully incremented; otherwise, `false`.","nodes":[{"pos":[0,81],"content":"<ph id=\"ph1\">`true`</ph> if the reference counter was successfully incremented; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the reference counter was successfully incremented; otherwise, `false`."}],"pos":[19169,19253],"yaml":true},{"content":"Returns the value of the <xref href=\"System.Runtime.InteropServices.SafeHandle.handle\"></xref> field.","nodes":[{"pos":[0,101],"content":"Returns the value of the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.SafeHandle.handle\"&gt;&lt;/xref&gt;</ph> field.","source":"Returns the value of the <xref href=\"System.Runtime.InteropServices.SafeHandle.handle\"></xref> field."}],"pos":[20916,21018],"yaml":true},{"content":"You can use this method to retrieve the actual handle value from an instance of the <xref:System.Runtime.InteropServices.SafeHandle> derived class. This method is needed for backwards compatibility because many properties in the .NET Framework return `IntPtr` handle types. `IntPtr` handle types are platform-specific types used to represent a pointer or a handle.  \n  \n> [!CAUTION]\n>  Using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method can pose security risks because, if the handle has been marked as invalid with <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> still returns the original, potentially stale handle value. The returned handle can also be recycled at any point. At best, this means the handle might suddenly stop working. At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle. For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource. See the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods for more information about using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.","nodes":[{"pos":[0,364],"content":"You can use this method to retrieve the actual handle value from an instance of the <xref:System.Runtime.InteropServices.SafeHandle> derived class. This method is needed for backwards compatibility because many properties in the .NET Framework return `IntPtr` handle types. `IntPtr` handle types are platform-specific types used to represent a pointer or a handle.","nodes":[{"content":"You can use this method to retrieve the actual handle value from an instance of the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> derived class.","pos":[0,147],"source":"You can use this method to retrieve the actual handle value from an instance of the <xref:System.Runtime.InteropServices.SafeHandle> derived class."},{"content":"This method is needed for backwards compatibility because many properties in the .NET Framework return <ph id=\"ph1\">`IntPtr`</ph> handle types.","pos":[148,273],"source":" This method is needed for backwards compatibility because many properties in the .NET Framework return `IntPtr` handle types."},{"content":"<ph id=\"ph1\">`IntPtr`</ph> handle types are platform-specific types used to represent a pointer or a handle.","pos":[274,364],"source":"`IntPtr` handle types are platform-specific types used to represent a pointer or a handle."}]},{"pos":[372,1465],"content":"[!CAUTION]\n Using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method can pose security risks because, if the handle has been marked as invalid with <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> still returns the original, potentially stale handle value. The returned handle can also be recycled at any point. At best, this means the handle might suddenly stop working. At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle. For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource. See the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods for more information about using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.","leadings":["","> "],"nodes":[{"content":" Using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method can pose security risks because, if the handle has been marked as invalid with <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> still returns the original, potentially stale handle value. The returned handle can also be recycled at any point. At best, this means the handle might suddenly stop working. At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle. For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource. See the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods for more information about using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.","pos":[11,1091],"nodes":[{"content":"Using the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt;</ph> method can pose security risks because, if the handle has been marked as invalid with <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt;</ph> still returns the original, potentially stale handle value.","pos":[1,370],"source":" Using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method can pose security risks because, if the handle has been marked as invalid with <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> still returns the original, potentially stale handle value."},{"content":"The returned handle can also be recycled at any point.","pos":[371,425]},{"content":"At best, this means the handle might suddenly stop working.","pos":[426,485]},{"content":"At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle.","pos":[486,661]},{"content":"For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource.","pos":[662,797]},{"content":"See the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> and the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> methods for more information about using the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A&gt;</ph> methodsafely.","pos":[798,1080],"source":" See the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods for more information about using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely."}]}]}],"pos":[21029,22500],"yaml":true,"extradata":"MT"},{"content":"An `IntPtr` representing the value of the <xref href=\"System.Runtime.InteropServices.SafeHandle.handle\"></xref> field. If the handle has been marked invalid with <xref href=\"System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid\"></xref>, this method still returns the original handle value, which can be a stale value.","nodes":[{"pos":[0,325],"content":"An `IntPtr` representing the value of the <xref href=\"System.Runtime.InteropServices.SafeHandle.handle\"></xref> field. If the handle has been marked invalid with <xref href=\"System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid\"></xref>, this method still returns the original handle value, which can be a stale value.","nodes":[{"content":"An <ph id=\"ph1\">`IntPtr`</ph> representing the value of the <ph id=\"ph2\">&lt;xref href=\"System.Runtime.InteropServices.SafeHandle.handle\"&gt;&lt;/xref&gt;</ph> field.","pos":[0,118],"source":"An `IntPtr` representing the value of the <xref href=\"System.Runtime.InteropServices.SafeHandle.handle\"></xref> field."},{"content":"If the handle has been marked invalid with <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid\"&gt;&lt;/xref&gt;</ph>, this method still returns the original handle value, which can be a stale value.","pos":[119,325],"source":" If the handle has been marked invalid with <xref href=\"System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid\"></xref>, this method still returns the original handle value, which can be a stale value."}]}],"pos":[22636,22962],"yaml":true},{"content":"Manually decrements the reference counter on a <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> instance.","nodes":[{"pos":[0,119],"content":"Manually decrements the reference counter on a <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.SafeHandle\"&gt;&lt;/xref&gt;</ph> instance.","source":"Manually decrements the reference counter on a <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> instance."}],"pos":[24616,24736],"yaml":true},{"content":"The <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method is the counterpart to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. You should always match a call to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method with a successful call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.  \n  \n> [!CAUTION]\n>  This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing. In the same way that unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> calls can cause resource leaks, unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls can cause invalid handle states to become visible to other threads. Do not expose <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> or <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls to untrusted code.","nodes":[{"pos":[0,379],"content":"The <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method is the counterpart to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. You should always match a call to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method with a successful call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.","nodes":[{"content":"The <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method is the counterpart to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. You should always match a call to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method with a successful call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.","pos":[0,379],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> method is the counterpart to <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph>.","pos":[0,170],"source":"The <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method is the counterpart to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>."},{"content":"You should always match a call to the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> method with a successful call to <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph>.","pos":[171,379],"source":" You should always match a call to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method with a successful call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>."}]}]},{"pos":[387,1095],"content":"[!CAUTION]\n This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing. In the same way that unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> calls can cause resource leaks, unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls can cause invalid handle states to become visible to other threads. Do not expose <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> or <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls to untrusted code.","leadings":["","> "],"nodes":[{"content":" This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing. In the same way that unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> calls can cause resource leaks, unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls can cause invalid handle states to become visible to other threads. Do not expose <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> or <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls to untrusted code.","pos":[11,706],"nodes":[{"content":"This method is intended for advanced users and must always be used carefully.","pos":[1,78]},{"content":"To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.","pos":[79,232]},{"content":"In the same way that unmatched <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> calls can cause resource leaks, unmatched <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> calls can cause invalid handle states to become visible to other threads.","pos":[233,516],"source":" In the same way that unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> calls can cause resource leaks, unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls can cause invalid handle states to become visible to other threads."},{"content":"Do not expose <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A&gt;</ph> calls to untrusted code.","pos":[517,695],"source":" Do not expose <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> or <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls to untrusted code."}]}]}],"pos":[24747,25848],"yaml":true,"extradata":"MT"},{"content":"Releases all resources used by the <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> class.","nodes":[{"pos":[0,104],"content":"Releases all resources used by the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.SafeHandle\"&gt;&lt;/xref&gt;</ph> class.","source":"Releases all resources used by the <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> class."}],"pos":[27521,27626],"yaml":true},{"content":"Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed. This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case. Although most classes using <xref:System.Runtime.InteropServices.SafeHandle> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, they can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.  \n  \n Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object. The <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.SafeHandle> object in an unusable state.  \n  \n> [!NOTE]\n>  Always call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.","nodes":[{"pos":[0,703],"content":"Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed. This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case. Although most classes using <xref:System.Runtime.InteropServices.SafeHandle> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, they can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.","nodes":[{"content":"Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed. This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case. Although most classes using <xref:System.Runtime.InteropServices.SafeHandle> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, they can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.","pos":[0,703],"nodes":[{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method allows the resources to be freed.","pos":[0,173],"source":"Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed."},{"content":"This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case.","pos":[174,327]},{"content":"Although most classes using <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).","pos":[328,549],"source":" Although most classes using <xref:System.Runtime.InteropServices.SafeHandle> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory)."},{"content":"In this case, they can provide a finalizer that is guaranteed to run before the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> critical finalizer runs.","pos":[550,703],"source":" In this case, they can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs."}]}]},{"pos":[710,1093],"content":"Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object. The <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.SafeHandle> object in an unusable state.","nodes":[{"content":"Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object. The <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.SafeHandle> object in an unusable state.","pos":[0,383],"nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method when you are finished using the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object.","pos":[0,225],"source":"Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> method leaves the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object in an unusable state.","pos":[226,383],"source":" The <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.SafeHandle> object in an unusable state."}]}]},{"pos":[1101,1578],"content":"[!NOTE]\n Always call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.","leadings":["","> "],"nodes":[{"content":" Always call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.","pos":[8,475],"nodes":[{"content":"Always call the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method before you release your last reference to the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object.","pos":[1,247],"source":" Always call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object."},{"content":"Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object's <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A&gt;</ph> method.","pos":[248,467],"source":" Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method."}]}]}],"pos":[27637,29223],"yaml":true,"extradata":"MT"},{"content":"Releases the unmanaged resources used by the <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> class specifying whether to perform a normal dispose operation.","nodes":[{"pos":[0,171],"content":"Releases the unmanaged resources used by the <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.SafeHandle\"&gt;&lt;/xref&gt;</ph> class specifying whether to perform a normal dispose operation.","source":"Releases the unmanaged resources used by the <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> class specifying whether to perform a normal dispose operation."}],"pos":[30947,31119],"yaml":true},{"content":"You should never explicitly call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method with the `disposing` parameter set to `false`.","nodes":[{"pos":[0,150],"content":"You should never explicitly call the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method with the <ph id=\"ph2\">`disposing`</ph> parameter set to <ph id=\"ph3\">`false`</ph>.","source":"You should never explicitly call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method with the `disposing` parameter set to `false`."}],"pos":[31130,31281],"yaml":true,"extradata":"MT"},{"content":"`true` for a normal dispose operation; `false` to finalize the handle.","nodes":[{"pos":[0,70],"content":"<ph id=\"ph1\">`true`</ph> for a normal dispose operation; <ph id=\"ph2\">`false`</ph> to finalize the handle.","source":"`true` for a normal dispose operation; `false` to finalize the handle."}],"pos":[31486,31559],"yaml":true},{"content":"Frees all resources associated with the handle.","nodes":[{"pos":[0,47],"content":"Frees all resources associated with the handle.","nodes":[{"content":"Frees all resources associated with the handle.","pos":[0,47]}]}],"pos":[33203,33251],"yaml":true},{"content":"The <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.SafeHandle> class. Application code should not call this method directly.","nodes":[{"pos":[0,208],"content":"The <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.SafeHandle> class. Application code should not call this method directly.","nodes":[{"content":"The <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.SafeHandle> class. Application code should not call this method directly.","pos":[0,208],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A&gt;</ph> method is the destructor for the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> class.","pos":[0,153],"source":"The <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.SafeHandle> class."},{"content":"Application code should not call this method directly.","pos":[154,208]}]}]}],"pos":[33262,33471],"yaml":true,"extradata":"MT"},{"content":"Specifies the handle to be wrapped.","nodes":[{"pos":[0,35],"content":"Specifies the handle to be wrapped.","nodes":[{"content":"Specifies the handle to be wrapped.","pos":[0,35]}]}],"pos":[35106,35142],"yaml":true},{"content":"Do not expose the handle publicly (that is, outside of the derived class).","nodes":[{"pos":[0,74],"content":"Do not expose the handle publicly (that is, outside of the derived class).","nodes":[{"content":"Do not expose the handle publicly (that is, outside of the derived class).","pos":[0,74]}]}],"pos":[35153,35228],"yaml":true,"extradata":"MT"},{"content":"Gets a value indicating whether the handle is closed.","nodes":[{"pos":[0,53],"content":"Gets a value indicating whether the handle is closed.","nodes":[{"content":"Gets a value indicating whether the handle is closed.","pos":[0,53]}]}],"pos":[36847,36901],"yaml":true},{"content":"The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.SafeHandle> object's handle is no longer associated with a native resource. This differs from the definition of the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid. The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a `true` value in the following cases:  \n  \n-   The <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method was called.  \n  \n-   The <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.SafeHandle> object on other threads.","nodes":[{"pos":[0,522],"content":"The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.SafeHandle> object's handle is no longer associated with a native resource. This differs from the definition of the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid. The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a `true` value in the following cases:","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A&gt;</ph> method returns a value indicating whether the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object's handle is no longer associated with a native resource.","pos":[0,223],"source":"The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.SafeHandle> object's handle is no longer associated with a native resource."},{"content":"This differs from the definition of the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> property, which computes whether a given handle is always considered invalid.","pos":[224,403],"source":" This differs from the definition of the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A&gt;</ph> method returns a <ph id=\"ph2\">`true`</ph> value in the following cases:","pos":[404,522],"source":" The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a `true` value in the following cases:"}]},{"pos":[532,625],"content":"The <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method was called.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A&gt;</ph> method was called.","pos":[0,93],"source":"The <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method was called."}]},{"pos":[635,893],"content":"The <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.SafeHandle> object on other threads.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A&gt;</ph> method or <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.Close%2A&gt;</ph> method was called and there are no references to the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object on other threads.","pos":[0,258],"source":"The <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.SafeHandle> object on other threads."}]}],"pos":[36912,37812],"yaml":true,"extradata":"MT"},{"content":"`true` if the handle is closed; otherwise, `false`.","nodes":[{"pos":[0,51],"content":"<ph id=\"ph1\">`true`</ph> if the handle is closed; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the handle is closed; otherwise, `false`."}],"pos":[38120,38174],"yaml":true},{"content":"When overridden in a derived class, gets a value indicating whether the handle value is invalid.","nodes":[{"pos":[0,96],"content":"When overridden in a derived class, gets a value indicating whether the handle value is invalid.","nodes":[{"content":"When overridden in a derived class, gets a value indicating whether the handle value is invalid.","pos":[0,96]}]}],"pos":[39842,39939],"yaml":true},{"content":"Derived classes must implement the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required. Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid). These classes can then be further derived for specific safe handle types.  \n  \n Unlike the <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.SafeHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid. Therefore, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property always returns the same value for any one handle value.","nodes":[{"pos":[0,392],"content":"Derived classes must implement the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required. Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid). These classes can then be further derived for specific safe handle types.","nodes":[{"content":"Derived classes must implement the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required. Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid). These classes can then be further derived for specific safe handle types.","pos":[0,392],"nodes":[{"content":"Derived classes must implement the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> property so that the common language runtime can determine whether critical finalization is required.","pos":[0,198],"source":"Derived classes must implement the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required."},{"content":"Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).","pos":[199,318]},{"content":"These classes can then be further derived for specific safe handle types.","pos":[319,392]}]}]},{"pos":[399,893],"content":"Unlike the <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.SafeHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid. Therefore, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property always returns the same value for any one handle value.","nodes":[{"content":"Unlike the <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.SafeHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid. Therefore, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property always returns the same value for any one handle value.","pos":[0,494],"nodes":[{"content":"Unlike the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A&gt;</ph> property, which reports whether the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> object has finished using the underlying handle, the <ph id=\"ph3\">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> property calculates whether the given handle value is always considered invalid.","pos":[0,352],"source":"Unlike the <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.SafeHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid."},{"content":"Therefore, the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> property always returns the same value for any one handle value.","pos":[353,494],"source":" Therefore, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property always returns the same value for any one handle value."}]}]}],"pos":[39950,40848],"yaml":true,"extradata":"MT"},{"content":"`true` if the handle value is invalid; otherwise, `false`.","nodes":[{"pos":[0,58],"content":"<ph id=\"ph1\">`true`</ph> if the handle value is invalid; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the handle value is invalid; otherwise, `false`."}],"pos":[41473,41534],"yaml":true},{"content":"When overridden in a derived class, executes the code required to free the handle.","nodes":[{"pos":[0,82],"content":"When overridden in a derived class, executes the code required to free the handle.","nodes":[{"content":"When overridden in a derived class, executes the code required to free the handle.","pos":[0,82]}]}],"pos":[43231,43314],"yaml":true},{"content":"The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is guaranteed to be called only once and only if the handle is valid as defined by the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property. Implement this method in your <xref:System.Runtime.InteropServices.SafeHandle> derived classes to execute any code that is required to free the handle. Because one of the functions of <xref:System.Runtime.InteropServices.SafeHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> must never fail. The garbage collector calls <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>after normal finalizers have been run for objects that were garbage collected at the same time. The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress. This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph). Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method. In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. In most cases this code should be:  \n  \n `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  \n  \n Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call. For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail. You must ensure that your program logic has fallback code for each of those cases.  \n  \n If <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.  This helps you detect cases where your attempt to release resources fails.","nodes":[{"pos":[0,1568],"content":"The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is guaranteed to be called only once and only if the handle is valid as defined by the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property. Implement this method in your <xref:System.Runtime.InteropServices.SafeHandle> derived classes to execute any code that is required to free the handle. Because one of the functions of <xref:System.Runtime.InteropServices.SafeHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> must never fail. The garbage collector calls <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>after normal finalizers have been run for objects that were garbage collected at the same time. The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress. This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph). Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method. In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. In most cases this code should be:","nodes":[{"content":"The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is guaranteed to be called only once and only if the handle is valid as defined by the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property. Implement this method in your <xref:System.Runtime.InteropServices.SafeHandle> derived classes to execute any code that is required to free the handle. Because one of the functions of <xref:System.Runtime.InteropServices.SafeHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> must never fail. The garbage collector calls <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>after normal finalizers have been run for objects that were garbage collected at the same time. The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress. This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph). Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method. In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. In most cases this code should be:","pos":[0,1568],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> method is guaranteed to be called only once and only if the handle is valid as defined by the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A&gt;</ph> property.","pos":[0,235],"source":"The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is guaranteed to be called only once and only if the handle is valid as defined by the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property."},{"content":"Implement this method in your <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> derived classes to execute any code that is required to free the handle.","pos":[236,387],"source":" Implement this method in your <xref:System.Runtime.InteropServices.SafeHandle> derived classes to execute any code that is required to free the handle."},{"content":"Because one of the functions of <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle&gt;</ph> is to guarantee prevention of resource leaks, the code in your implementation of <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> must never fail.","pos":[388,632],"source":" Because one of the functions of <xref:System.Runtime.InteropServices.SafeHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> must never fail."},{"content":"The garbage collector calls <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph>after normal finalizers have been run for objects that were garbage collected at the same time.","pos":[633,821],"source":" The garbage collector calls <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>after normal finalizers have been run for objects that were garbage collected at the same time."},{"content":"The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress.","pos":[822,959]},{"content":"This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).","pos":[960,1130]},{"content":"Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> method.","pos":[1131,1330],"source":" Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method."},{"content":"In particular, apply the <ph id=\"ph1\">&lt;xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute&gt;</ph> attribute to any methods you call from <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph>.","pos":[1331,1533],"source":" In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>."},{"content":"In most cases this code should be:","pos":[1534,1568]}]}]},{"pos":[1649,2006],"content":"Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call. For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail. You must ensure that your program logic has fallback code for each of those cases.","nodes":[{"content":"Additionally, for simple cleanup (for example, calling the Win32 API <ph id=\"ph1\">`CloseHandle`</ph> on a file handle) you can check the return value for the single platform invoke call.","pos":[0,168],"source":"Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call."},{"content":"For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.","pos":[169,274]},{"content":"You must ensure that your program logic has fallback code for each of those cases.","pos":[275,357]}]},{"pos":[2013,2320],"content":"If <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.  This helps you detect cases where your attempt to release resources fails.","nodes":[{"content":"If <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A&gt;</ph> returns <ph id=\"ph2\">`false`</ph> for any reason, it generates a <bpt id=\"p1\">[</bpt>releaseHandleFailed<ept id=\"p1\">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.","pos":[0,231],"source":"If <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant."},{"content":"This helps you detect cases where your attempt to release resources fails.","pos":[233,307]}]}],"pos":[43325,45654],"yaml":true,"extradata":"MT"},{"content":"`true` if the handle is released successfully; otherwise, in the event of a catastrophic failure, `false`. In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.","nodes":[{"pos":[0,251],"content":"`true` if the handle is released successfully; otherwise, in the event of a catastrophic failure, `false`. In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <ph id=\"ph2\">`false`</ph>.","pos":[0,106],"source":"`true` if the handle is released successfully; otherwise, in the event of a catastrophic failure, `false`."},{"content":"In this case, it generates a <bpt id=\"p1\">[</bpt>releaseHandleFailed<ept id=\"p1\">](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md)</ept> Managed Debugging Assistant.","pos":[107,251],"source":" In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant."}]}],"pos":[46072,46326],"yaml":true},{"content":"Sets the handle to the specified pre-existing handle.","nodes":[{"pos":[0,53],"content":"Sets the handle to the specified pre-existing handle.","nodes":[{"content":"Sets the handle to the specified pre-existing handle.","pos":[0,53]}]}],"pos":[47996,48050],"yaml":true},{"content":"Use the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure.","nodes":[{"pos":[0,295],"content":"Use the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure.","nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A&gt;</ph> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure.","pos":[0,295],"source":"Use the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure."}]}],"pos":[48061,48357],"yaml":true,"extradata":"MT"},{"content":"The pre-existing handle to use.","nodes":[{"pos":[0,31],"content":"The pre-existing handle to use.","nodes":[{"content":"The pre-existing handle to use.","pos":[0,31]}]}],"pos":[48500,48532],"yaml":true},{"content":"Marks a handle as no longer used.","nodes":[{"pos":[0,33],"content":"Marks a handle as no longer used.","nodes":[{"content":"Marks a handle as no longer used.","pos":[0,33]}]}],"pos":[50189,50223],"yaml":true},{"content":"Call the <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method only when you know that your handle no longer references a resource. Doing so does not change the value of the <xref:System.Runtime.InteropServices.SafeHandle.handle> field; it only marks the handle as closed. The handle might then contain a potentially stale value. The effect of this call is that no attempt is made to free the resources.  \n  \n As with the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.","nodes":[{"pos":[0,427],"content":"Call the <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method only when you know that your handle no longer references a resource. Doing so does not change the value of the <xref:System.Runtime.InteropServices.SafeHandle.handle> field; it only marks the handle as closed. The handle might then contain a potentially stale value. The effect of this call is that no attempt is made to free the resources.","nodes":[{"content":"Call the <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method only when you know that your handle no longer references a resource. Doing so does not change the value of the <xref:System.Runtime.InteropServices.SafeHandle.handle> field; it only marks the handle as closed. The handle might then contain a potentially stale value. The effect of this call is that no attempt is made to free the resources.","pos":[0,427],"nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A&gt;</ph> method only when you know that your handle no longer references a resource.","pos":[0,155],"source":"Call the <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method only when you know that your handle no longer references a resource."},{"content":"Doing so does not change the value of the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.handle&gt;</ph> field; it only marks the handle as closed.","pos":[156,296],"source":" Doing so does not change the value of the <xref:System.Runtime.InteropServices.SafeHandle.handle> field; it only marks the handle as closed."},{"content":"The handle might then contain a potentially stale value.","pos":[297,353]},{"content":"The effect of this call is that no attempt is made to free the resources.","pos":[354,427]}]}]},{"pos":[434,641],"content":"As with the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.","nodes":[{"content":"As with the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A&gt;</ph> method, use <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A&gt;</ph> only if you need to support a pre-existing handle.","pos":[0,207],"source":"As with the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle."}]}],"pos":[50234,50880],"yaml":true,"extradata":"MT"}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Runtime.InteropServices.SafeHandle\n  commentId: T:System.Runtime.InteropServices.SafeHandle\n  id: SafeHandle\n  children:\n  - System.Runtime.InteropServices.SafeHandle.#ctor\n  - System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)\n  - System.Runtime.InteropServices.SafeHandle.Close\n  - System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)\n  - System.Runtime.InteropServices.SafeHandle.DangerousGetHandle\n  - System.Runtime.InteropServices.SafeHandle.DangerousRelease\n  - System.Runtime.InteropServices.SafeHandle.Dispose\n  - System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)\n  - System.Runtime.InteropServices.SafeHandle.Finalize\n  - System.Runtime.InteropServices.SafeHandle.handle\n  - System.Runtime.InteropServices.SafeHandle.IsClosed\n  - System.Runtime.InteropServices.SafeHandle.IsInvalid\n  - System.Runtime.InteropServices.SafeHandle.ReleaseHandle\n  - System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)\n  - System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid\n  langs:\n  - csharp\n  name: SafeHandle\n  nameWithType: SafeHandle\n  fullName: System.Runtime.InteropServices.SafeHandle\n  type: Class\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Represents a wrapper class for operating system handles. This class must be inherited.\n  remarks: \"The <xref:System.Runtime.InteropServices.SafeHandle> class provides critical finalization of handle resources, preventing handles from being reclaimed prematurely by garbage collection and from being recycled by Windows to reference unintended unmanaged objects.  \\n  \\n This topic includes the following sections:  \\n  \\n [Why SafeHandle?](#Why)   \\n [What SafeHandle does](#Does)   \\n [Classes derived from SafeHandle](#Derived)  \\n  \\n<a name=\\\"Why\\\"></a>   \\n## Why SafeHandle?  \\n Before the .NET Framework version 2.0, all operating system handles could only be encapsulated in the <xref:System.IntPtr> managed wrapper object. While this was a convenient way to interoperate with native code, handles could be leaked by asynchronous exceptions, such as a thread aborting unexpectedly or a stack overflow. These asynchronous exceptions are an obstacle to cleaning up operating system resources, and they can occur almost anywhere in your app.  \\n  \\n Although overrides to the <xref:System.Object.Finalize%2A?displayProperty=fullName> method allow cleanup of unmanaged resources when an object is being garbage collected, in some circumstances, finalizable objects can be reclaimed by garbage collection while executing a method within a platform invoke call. If a finalizer frees the handle passed to that platform invoke call, it could lead to handle corruption. The handle could also be reclaimed while your method is blocked during a platform invoke call, such as while reading a file.  \\n  \\n More critically, because Windows aggressively recycles handles, a handle could be recycled and point to another resource that might contain sensitive data. This is known as a recycle attack and can potentially corrupt data and be a security threat.  \\n  \\n<a name=\\\"Does\\\"></a>   \\n## What SafeHandle does  \\n The <xref:System.Runtime.InteropServices.SafeHandle> class simplifies several of these object lifetime issues, and is integrated with platform invoke so that operating system resources are not leaked. The <xref:System.Runtime.InteropServices.SafeHandle> class resolves object lifetime issues by assigning and releasing handles without interruption. It contains a critical finalizer that ensures that the handle is closed and is guaranteed to run during unexpected <xref:System.AppDomain> unloads, even in cases when the platform invoke call is assumed to be in a corrupted state.  \\n  \\n Because <xref:System.Runtime.InteropServices.SafeHandle> inherits from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, all the noncritical finalizers are called before any of the critical finalizers. The finalizers are called on objects that are no longer live during the same garbage collection pass. For example, a <xref:System.IO.FileStream> object can run a normal finalizer to flush out existing buffered data without the risk of the handle being leaked or recycled. This very weak ordering between critical and noncritical finalizers is not intended for general use. It exists primarily to assist in the migration of existing libraries by allowing those libraries to use <xref:System.Runtime.InteropServices.SafeHandle> without altering their semantics. Additionally, the critical finalizer and anything it calls, such as the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=fullName> method, must be in a constrained execution region. This imposes constraints on what code can be written within the finalizer's call graph.  \\n  \\n Platform invoke operations automatically increment the reference count of handles encapsulated by a <xref:System.Runtime.InteropServices.SafeHandle> and decrement them upon completion. This ensures that the handle will not be recycled or closed unexpectedly.  \\n  \\n You can specify ownership of the underlying handle when constructing <xref:System.Runtime.InteropServices.SafeHandle> objects by supplying a value to the `ownsHandle` argument in the <xref:System.Runtime.InteropServices.SafeHandle> class constructor. This controls whether the <xref:System.Runtime.InteropServices.SafeHandle> object will release the handle after the object has been disposed.  This is useful for handles with peculiar lifetime requirements or for consuming a handle whose lifetime is controlled by someone else.  \\n  \\n<a name=\\\"Derived\\\"></a>   \\n## Classes derived from SafeHandle  \\n <xref:System.Runtime.InteropServices.SafeHandle> is an abstract wrapper class for operating system handles. Deriving from this class is difficult. Instead, use the derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace that provide safe handles for the following:  \\n  \\n-   Files (the <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> class).  \\n  \\n-   Memory mapped files (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> class).  \\n  \\n-   Pipes (the <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class).  \\n  \\n-   Memory views (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class).  \\n  \\n-   Cryptography constructs (the <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes).  \\n  \\n-   Processes (the <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> class).  \\n  \\n-   Registry keys (the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class).  \\n  \\n-   Wait handles (the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class).\"\n  example:\n  - \"The following code example creates a custom safe handle for an operating system file handle, deriving from <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>. It reads bytes from a file and displays their hexadecimal values. It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.  When using an <xref:System.IntPtr> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.  \\n  \\n You will need a text file in the same folder as the compiled application. Assuming that you name the application \\\"HexViewer\\\", the command line usage is:  \\n  \\n `HexViewer <filename> -Fault`  \\n  \\n Optionally specify `-Fault` to intentionally attempt to leak the handle by aborting the thread in a certain window. Use the Windows Perform.exe tool to monitor handle counts while injecting faults.  \\n  \\n [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable\n  inheritance:\n  - System.Object\n  derivedClasses:\n  - Microsoft.Win32.SafeHandles.SafeAccessTokenHandle\n  - Microsoft.Win32.SafeHandles.SafeFileHandle\n  - Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid\n  - Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid\n  - Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle\n  - Microsoft.Win32.SafeHandles.SafeNCryptHandle\n  - Microsoft.Win32.SafeHandles.SafePipeHandle\n  - Microsoft.Win32.SafeHandles.SafeProcessHandle\n  - Microsoft.Win32.SafeHandles.SafeRegistryHandle\n  - Microsoft.Win32.SafeHandles.SafeWaitHandle\n  - Microsoft.Win32.SafeHandles.SafeX509ChainHandle\n  - System.Runtime.InteropServices.SafeBuffer\n  - System.Security.Authentication.ExtendedProtection.ChannelBinding\n  - System.Security.Cryptography.SafeEvpPKeyHandle\n  implements:\n  - System.IDisposable\n  inheritedMembers:\n  - System.Object.Equals(System.Object)\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.GetHashCode\n  - System.Object.GetType\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  - System.Object.ToString\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.SafeHandle.#ctor\n  commentId: M:System.Runtime.InteropServices.SafeHandle.#ctor\n  id: '#ctor'\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: SafeHandle()\n  nameWithType: SafeHandle.SafeHandle()\n  fullName: SafeHandle.SafeHandle()\n  type: Constructor\n  assemblies:\n  - mscorlib\n  namespace: System.Runtime.InteropServices\n  syntax:\n    content: protected SafeHandle ();\n    parameters: []\n  overload: System.Runtime.InteropServices.SafeHandle.#ctor*\n  exceptions: []\n  version:\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  monikers:\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n- uid: System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)\n  commentId: M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)\n  id: '#ctor(System.IntPtr,System.Boolean)'\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: SafeHandle(IntPtr, Boolean)\n  nameWithType: SafeHandle.SafeHandle(IntPtr, Boolean)\n  fullName: SafeHandle.SafeHandle(IntPtr, Boolean)\n  type: Constructor\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Initializes a new instance of the <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> class with the specified invalid handle value.\n  remarks: If the `ownsHandle` parameter is `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is never called; thus, it is not recommended to use this parameter value as your code may leak resources.\n  syntax:\n    content: protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);\n    parameters:\n    - id: invalidHandleValue\n      type: System.IntPtr\n      description: The value of an invalid handle (usually 0 or -1).  Your implementation of <xref href=\"System.Runtime.InteropServices.SafeHandle.IsInvalid\"></xref> should return `true` for this value.\n    - id: ownsHandle\n      type: System.Boolean\n      description: '`true` to reliably let <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> release the handle during the finalization phase; otherwise, `false` (not recommended).'\n  overload: System.Runtime.InteropServices.SafeHandle.#ctor*\n  exceptions:\n  - type: System.TypeLoadException\n    commentId: T:System.TypeLoadException\n    description: The derived class resides in an assembly without unmanaged code access permission.\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.SafeHandle.Close\n  commentId: M:System.Runtime.InteropServices.SafeHandle.Close\n  id: Close\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: Close()\n  nameWithType: SafeHandle.Close()\n  fullName: SafeHandle.Close()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Marks the handle for releasing and freeing resources.\n  remarks: \"Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed. This might not happen immediately if other threads are using the same safe handle object, but will happen as soon as that is no longer the case. Although most classes that use the <xref:System.Runtime.InteropServices.SafeHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.  \\n  \\n Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object.  \\n  \\n> [!NOTE]\\n>  Always call <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public void Close ();\n    parameters: []\n  overload: System.Runtime.InteropServices.SafeHandle.Close*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)\n  commentId: M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)\n  id: DangerousAddRef(System.Boolean@)\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: DangerousAddRef(Boolean)\n  nameWithType: SafeHandle.DangerousAddRef(Boolean)\n  fullName: SafeHandle.DangerousAddRef(Boolean)\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Manually increments the reference counter on <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> instances.\n  remarks: \"The <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method). You can use this method to manually increment the reference count on a <xref:System.Runtime.InteropServices.SafeHandle> instance. <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> returns a Boolean value using a `ref` parameter (`success`) that indicates whether the reference count was incremented successfully. This allows your program logic to back out in case of failure. You should set `success` to `false` before calling <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. If `success` is `true`, avoid resource leaks by matching the call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> with a corresponding call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.  \\n  \\n> [!CAUTION]\\n>  This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.\"\n  syntax:\n    content: public void DangerousAddRef (ref bool success);\n    parameters:\n    - id: success\n      type: System.Boolean\n      description: '`true` if the reference counter was successfully incremented; otherwise, `false`.'\n  overload: System.Runtime.InteropServices.SafeHandle.DangerousAddRef*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.SafeHandle.DangerousGetHandle\n  commentId: M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle\n  id: DangerousGetHandle\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: DangerousGetHandle()\n  nameWithType: SafeHandle.DangerousGetHandle()\n  fullName: SafeHandle.DangerousGetHandle()\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Returns the value of the <xref href=\"System.Runtime.InteropServices.SafeHandle.handle\"></xref> field.\n  remarks: \"You can use this method to retrieve the actual handle value from an instance of the <xref:System.Runtime.InteropServices.SafeHandle> derived class. This method is needed for backwards compatibility because many properties in the .NET Framework return `IntPtr` handle types. `IntPtr` handle types are platform-specific types used to represent a pointer or a handle.  \\n  \\n> [!CAUTION]\\n>  Using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method can pose security risks because, if the handle has been marked as invalid with <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> still returns the original, potentially stale handle value. The returned handle can also be recycled at any point. At best, this means the handle might suddenly stop working. At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle. For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource. See the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods for more information about using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.\"\n  syntax:\n    content: public IntPtr DangerousGetHandle ();\n    parameters: []\n    return:\n      type: System.IntPtr\n      description: An `IntPtr` representing the value of the <xref href=\"System.Runtime.InteropServices.SafeHandle.handle\"></xref> field. If the handle has been marked invalid with <xref href=\"System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid\"></xref>, this method still returns the original handle value, which can be a stale value.\n  overload: System.Runtime.InteropServices.SafeHandle.DangerousGetHandle*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.SafeHandle.DangerousRelease\n  commentId: M:System.Runtime.InteropServices.SafeHandle.DangerousRelease\n  id: DangerousRelease\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: DangerousRelease()\n  nameWithType: SafeHandle.DangerousRelease()\n  fullName: SafeHandle.DangerousRelease()\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Manually decrements the reference counter on a <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> instance.\n  remarks: \"The <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method is the counterpart to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>. You should always match a call to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method with a successful call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.  \\n  \\n> [!CAUTION]\\n>  This method is intended for advanced users and must always be used carefully. To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing. In the same way that unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> calls can cause resource leaks, unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls can cause invalid handle states to become visible to other threads. Do not expose <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> or <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls to untrusted code.\"\n  syntax:\n    content: public void DangerousRelease ();\n    parameters: []\n  overload: System.Runtime.InteropServices.SafeHandle.DangerousRelease*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.SafeHandle.Dispose\n  commentId: M:System.Runtime.InteropServices.SafeHandle.Dispose\n  id: Dispose\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: Dispose()\n  nameWithType: SafeHandle.Dispose()\n  fullName: SafeHandle.Dispose()\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Releases all resources used by the <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> class.\n  remarks: \"Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed. This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case. Although most classes using <xref:System.Runtime.InteropServices.SafeHandle> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory). In this case, they can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.  \\n  \\n Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object. The <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.SafeHandle> object in an unusable state.  \\n  \\n> [!NOTE]\\n>  Always call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object. Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.\"\n  syntax:\n    content: public void Dispose ();\n    parameters: []\n  overload: System.Runtime.InteropServices.SafeHandle.Dispose*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)\n  commentId: M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)\n  id: Dispose(System.Boolean)\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: Dispose(Boolean)\n  nameWithType: SafeHandle.Dispose(Boolean)\n  fullName: SafeHandle.Dispose(Boolean)\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Releases the unmanaged resources used by the <xref href=\"System.Runtime.InteropServices.SafeHandle\"></xref> class specifying whether to perform a normal dispose operation.\n  remarks: You should never explicitly call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method with the `disposing` parameter set to `false`.\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      protected virtual void Dispose (bool disposing);\n    parameters:\n    - id: disposing\n      type: System.Boolean\n      description: '`true` for a normal dispose operation; `false` to finalize the handle.'\n  overload: System.Runtime.InteropServices.SafeHandle.Dispose*\n  exceptions: []\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.SafeHandle.Finalize\n  commentId: M:System.Runtime.InteropServices.SafeHandle.Finalize\n  id: Finalize\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: Finalize()\n  nameWithType: SafeHandle.Finalize()\n  fullName: SafeHandle.Finalize()\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Frees all resources associated with the handle.\n  remarks: The <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.SafeHandle> class. Application code should not call this method directly.\n  syntax:\n    content: ~SafeHandle ();\n    parameters: []\n  overload: System.Runtime.InteropServices.SafeHandle.Finalize*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.SafeHandle.handle\n  commentId: F:System.Runtime.InteropServices.SafeHandle.handle\n  id: handle\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: handle\n  nameWithType: SafeHandle.handle\n  fullName: SafeHandle.handle\n  type: Field\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Specifies the handle to be wrapped.\n  remarks: Do not expose the handle publicly (that is, outside of the derived class).\n  syntax:\n    content: protected IntPtr handle;\n    return:\n      type: System.IntPtr\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.SafeHandle.IsClosed\n  commentId: P:System.Runtime.InteropServices.SafeHandle.IsClosed\n  id: IsClosed\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: IsClosed\n  nameWithType: SafeHandle.IsClosed\n  fullName: SafeHandle.IsClosed\n  type: Property\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Gets a value indicating whether the handle is closed.\n  remarks: \"The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.SafeHandle> object's handle is no longer associated with a native resource. This differs from the definition of the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid. The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a `true` value in the following cases:  \\n  \\n-   The <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method was called.  \\n  \\n-   The <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.SafeHandle> object on other threads.\"\n  syntax:\n    content: >-\n      [get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]\n\n      public bool IsClosed { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the handle is closed; otherwise, `false`.'\n  overload: System.Runtime.InteropServices.SafeHandle.IsClosed*\n  exceptions: []\n  attributes:\n  - type: 'get: System.Runtime.ConstrainedExecution.ReliabilityContract'\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.SafeHandle.IsInvalid\n  commentId: P:System.Runtime.InteropServices.SafeHandle.IsInvalid\n  id: IsInvalid\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: IsInvalid\n  nameWithType: SafeHandle.IsInvalid\n  fullName: SafeHandle.IsInvalid\n  type: Property\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: When overridden in a derived class, gets a value indicating whether the handle value is invalid.\n  remarks: \"Derived classes must implement the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required. Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid). These classes can then be further derived for specific safe handle types.  \\n  \\n Unlike the <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.SafeHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid. Therefore, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property always returns the same value for any one handle value.\"\n  example:\n  - \"The following example checks if a file was opened successfully. This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.SafeHandle> class.  \\n  \\n [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]\"\n  syntax:\n    content: >-\n      [get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)]\n\n      public abstract bool IsInvalid { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the handle value is invalid; otherwise, `false`.'\n  overload: System.Runtime.InteropServices.SafeHandle.IsInvalid*\n  exceptions: []\n  attributes:\n  - type: 'get: System.Runtime.ConstrainedExecution.ReliabilityContract'\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.SafeHandle.ReleaseHandle\n  commentId: M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle\n  id: ReleaseHandle\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: ReleaseHandle()\n  nameWithType: SafeHandle.ReleaseHandle()\n  fullName: SafeHandle.ReleaseHandle()\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: When overridden in a derived class, executes the code required to free the handle.\n  remarks: \"The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is guaranteed to be called only once and only if the handle is valid as defined by the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property. Implement this method in your <xref:System.Runtime.InteropServices.SafeHandle> derived classes to execute any code that is required to free the handle. Because one of the functions of <xref:System.Runtime.InteropServices.SafeHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> must never fail. The garbage collector calls <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>after normal finalizers have been run for objects that were garbage collected at the same time. The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress. This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph). Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method. In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>. In most cases this code should be:  \\n  \\n `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  \\n  \\n Additionally, for simple cleanup (for example, calling the Win32 API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call. For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail. You must ensure that your program logic has fallback code for each of those cases.  \\n  \\n If <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.  This helps you detect cases where your attempt to release resources fails.\"\n  example:\n  - \"The following code example releases the handle and is part of a larger example provided for the <xref:System.Runtime.InteropServices.SafeHandle> class.  \\n  \\n [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]\"\n  syntax:\n    content: protected abstract bool ReleaseHandle ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the handle is released successfully; otherwise, in the event of a catastrophic failure, `false`. In this case, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.'\n  overload: System.Runtime.InteropServices.SafeHandle.ReleaseHandle*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)\n  commentId: M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)\n  id: SetHandle(System.IntPtr)\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: SetHandle(IntPtr)\n  nameWithType: SafeHandle.SetHandle(IntPtr)\n  fullName: SafeHandle.SetHandle(IntPtr)\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Sets the handle to the specified pre-existing handle.\n  remarks: Use the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure.\n  syntax:\n    content: protected void SetHandle (IntPtr handle);\n    parameters:\n    - id: handle\n      type: System.IntPtr\n      description: The pre-existing handle to use.\n  overload: System.Runtime.InteropServices.SafeHandle.SetHandle*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid\n  commentId: M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid\n  id: SetHandleAsInvalid\n  parent: System.Runtime.InteropServices.SafeHandle\n  langs:\n  - csharp\n  name: SetHandleAsInvalid()\n  nameWithType: SafeHandle.SetHandleAsInvalid()\n  fullName: SafeHandle.SetHandleAsInvalid()\n  type: Method\n  assemblies:\n  - System.Runtime.Handles\n  - mscorlib\n  - System.Runtime.InteropServices\n  - netstandard\n  - System.Runtime\n  namespace: System.Runtime.InteropServices\n  summary: Marks a handle as no longer used.\n  remarks: \"Call the <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method only when you know that your handle no longer references a resource. Doing so does not change the value of the <xref:System.Runtime.InteropServices.SafeHandle.handle> field; it only marks the handle as closed. The handle might then contain a potentially stale value. The effect of this call is that no attempt is made to free the resources.  \\n  \\n As with the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.\"\n  syntax:\n    content: public void SetHandleAsInvalid ();\n    parameters: []\n  overload: System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.TypeLoadException\n  parent: System\n  isExternal: false\n  name: TypeLoadException\n  nameWithType: TypeLoadException\n  fullName: System.TypeLoadException\n- uid: System.Runtime.InteropServices.SafeHandle.#ctor\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: SafeHandle()\n  nameWithType: SafeHandle.SafeHandle()\n  fullName: SafeHandle.SafeHandle()\n- uid: System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: SafeHandle(IntPtr, Boolean)\n  nameWithType: SafeHandle.SafeHandle(IntPtr, Boolean)\n  fullName: SafeHandle.SafeHandle(IntPtr, Boolean)\n- uid: System.IntPtr\n  parent: System\n  isExternal: false\n  name: IntPtr\n  nameWithType: IntPtr\n  fullName: System.IntPtr\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Runtime.InteropServices.SafeHandle.Close\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: Close()\n  nameWithType: SafeHandle.Close()\n  fullName: SafeHandle.Close()\n- uid: System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: DangerousAddRef(Boolean)\n  nameWithType: SafeHandle.DangerousAddRef(Boolean)\n  fullName: SafeHandle.DangerousAddRef(Boolean)\n- uid: System.Runtime.InteropServices.SafeHandle.DangerousGetHandle\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: DangerousGetHandle()\n  nameWithType: SafeHandle.DangerousGetHandle()\n  fullName: SafeHandle.DangerousGetHandle()\n- uid: System.Runtime.InteropServices.SafeHandle.DangerousRelease\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: DangerousRelease()\n  nameWithType: SafeHandle.DangerousRelease()\n  fullName: SafeHandle.DangerousRelease()\n- uid: System.Runtime.InteropServices.SafeHandle.Dispose\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: Dispose()\n  nameWithType: SafeHandle.Dispose()\n  fullName: SafeHandle.Dispose()\n- uid: System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: Dispose(Boolean)\n  nameWithType: SafeHandle.Dispose(Boolean)\n  fullName: SafeHandle.Dispose(Boolean)\n- uid: System.Runtime.InteropServices.SafeHandle.Finalize\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: Finalize()\n  nameWithType: SafeHandle.Finalize()\n  fullName: SafeHandle.Finalize()\n- uid: System.Runtime.InteropServices.SafeHandle.handle\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: handle\n  nameWithType: SafeHandle.handle\n  fullName: SafeHandle.handle\n- uid: System.Runtime.InteropServices.SafeHandle.IsClosed\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: IsClosed\n  nameWithType: SafeHandle.IsClosed\n  fullName: SafeHandle.IsClosed\n- uid: System.Runtime.InteropServices.SafeHandle.IsInvalid\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: IsInvalid\n  nameWithType: SafeHandle.IsInvalid\n  fullName: SafeHandle.IsInvalid\n- uid: System.Runtime.InteropServices.SafeHandle.ReleaseHandle\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: ReleaseHandle()\n  nameWithType: SafeHandle.ReleaseHandle()\n  fullName: SafeHandle.ReleaseHandle()\n- uid: System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: SetHandle(IntPtr)\n  nameWithType: SafeHandle.SetHandle(IntPtr)\n  fullName: SafeHandle.SetHandle(IntPtr)\n- uid: System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: SetHandleAsInvalid()\n  nameWithType: SafeHandle.SetHandleAsInvalid()\n  fullName: SafeHandle.SetHandleAsInvalid()\n- uid: System.Runtime.InteropServices.SafeHandle.#ctor*\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: SafeHandle\n  nameWithType: SafeHandle.SafeHandle\n  fullName: SafeHandle.SafeHandle\n  monikers:\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n- uid: System.Runtime.InteropServices.SafeHandle.Close*\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: Close\n  nameWithType: SafeHandle.Close\n  fullName: SafeHandle.Close\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n- uid: System.Runtime.InteropServices.SafeHandle.DangerousAddRef*\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: DangerousAddRef\n  nameWithType: SafeHandle.DangerousAddRef\n  fullName: SafeHandle.DangerousAddRef\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n- uid: System.Runtime.InteropServices.SafeHandle.DangerousGetHandle*\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: DangerousGetHandle\n  nameWithType: SafeHandle.DangerousGetHandle\n  fullName: SafeHandle.DangerousGetHandle\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n- uid: System.Runtime.InteropServices.SafeHandle.DangerousRelease*\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: DangerousRelease\n  nameWithType: SafeHandle.DangerousRelease\n  fullName: SafeHandle.DangerousRelease\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n- uid: System.Runtime.InteropServices.SafeHandle.Dispose*\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: Dispose\n  nameWithType: SafeHandle.Dispose\n  fullName: SafeHandle.Dispose\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n- uid: System.Runtime.InteropServices.SafeHandle.Finalize*\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: Finalize\n  nameWithType: SafeHandle.Finalize\n  fullName: SafeHandle.Finalize\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n- uid: System.Runtime.InteropServices.SafeHandle.IsClosed*\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: IsClosed\n  nameWithType: SafeHandle.IsClosed\n  fullName: SafeHandle.IsClosed\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n- uid: System.Runtime.InteropServices.SafeHandle.IsInvalid*\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: IsInvalid\n  nameWithType: SafeHandle.IsInvalid\n  fullName: SafeHandle.IsInvalid\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n- uid: System.Runtime.InteropServices.SafeHandle.ReleaseHandle*\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: ReleaseHandle\n  nameWithType: SafeHandle.ReleaseHandle\n  fullName: SafeHandle.ReleaseHandle\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n- uid: System.Runtime.InteropServices.SafeHandle.SetHandle*\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: SetHandle\n  nameWithType: SafeHandle.SetHandle\n  fullName: SafeHandle.SetHandle\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n- uid: System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid*\n  parent: System.Runtime.InteropServices.SafeHandle\n  isExternal: false\n  name: SetHandleAsInvalid\n  nameWithType: SafeHandle.SetHandleAsInvalid\n  fullName: SafeHandle.SetHandleAsInvalid\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System.Runtime.InteropServices/SafeHandle.xml\n- uid: System.Object.Equals(System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Object.Equals(Object)\n  fullName: Object.Equals(Object)\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.GetHashCode\n  parent: System.Object\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Object.GetHashCode()\n  fullName: Object.GetHashCode()\n- uid: System.Object.GetType\n  parent: System.Object\n  isExternal: false\n  name: GetType()\n  nameWithType: Object.GetType()\n  fullName: Object.GetType()\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Object.ToString\n  parent: System.Object\n  isExternal: false\n  name: ToString()\n  nameWithType: Object.ToString()\n  fullName: Object.ToString()\n- uid: System.IDisposable\n  parent: System\n  isExternal: false\n  name: IDisposable\n  nameWithType: IDisposable\n  fullName: System.IDisposable\n"}