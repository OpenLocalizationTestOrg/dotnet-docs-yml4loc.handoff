{"nodes":[{"content":"Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.","nodes":[{"pos":[0,193],"content":"Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.","nodes":[{"content":"Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.","pos":[0,193]}]}],"pos":[10040,10236],"yaml":true},{"content":"> [!NOTE]\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/type.cs#3d00eeab9feb80f3). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \n  \n `Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata. Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.  \n  \n No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels. No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation. However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>. See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  \n  \n `Type` is an abstract base class that allows multiple implementations. The system will always provide the derived class `RuntimeType`. In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.  \n  \n> [!NOTE]\n>  In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data. Other code, over which you have no control, might also lock your class type. This might result in a deadlock. Instead, synchronize access to static data by locking a private `static` object.  \n  \n> [!NOTE]\n>  A derived class can access protected members of the calling code's base classes. Also, access is allowed to assembly members of the calling code's assembly. As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.  \n  \n> [!NOTE]\n>  Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.  \n  \n In this section:  \n  \n [What types does a Type object represent?](#WhatTypes)   \n [Retrieving a Type object](#Retrieve)   \n [Comparing type objects for equality](#Equality)  \n  \n<a name=\"WhatTypes\"></a>   \n## What types does a Type object represent?  \n This class is thread safe; multiple threads can concurrently read from an instance of this type. An instance of the <xref:System.Type> class can represent any of the following types:  \n  \n-   Classes  \n  \n-   Value types  \n  \n-   Arrays  \n  \n-   Interfaces  \n  \n-   Enumerations  \n  \n-   Delegates  \n  \n-   Constructed generic types and generic type definitions  \n  \n-   Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions  \n  \n<a name=\"Retrieve\"></a>   \n## Retrieving a Type object  \n The <xref:System.Type> object associated with a particular type can be obtained in the following ways:  \n  \n-   The instance <xref:System.Object.GetType%2A?displayProperty=fullName> method returns a <xref:System.Type> object that represents the type of an instance. Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.  \n  \n     The following example calls the <xref:System.Object.GetType%2A?displayProperty=fullName> method to determine the runtime type of each object in an object array.  \n  \n     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]\n     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]\n     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  \n  \n-   The static <xref:System.Type.GetType%2A?displayProperty=fullName> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.  \n  \n-   The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=fullName>, <xref:System.Reflection.Module.GetType%2A?displayProperty=fullName>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=fullName> methods return `Type` objects that represent the types defined in a module. The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module. (You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=fullName> method, or through the <xref:System.Type.Module%2A?displayProperty=fullName> property.)  \n  \n-   The <xref:System.Reflection.Assembly?displayProperty=fullName> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=fullName>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=fullName>.  \n  \n-   The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.  \n  \n-   The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element.  \n  \n-   The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.  \n  \n-   The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects. The objects are specified with an array of type <xref:System.Object>.  \n  \n-   The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability. They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.  \n  \n-   The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability. It returns a `Type` object that represents the type specified by a class handle.  \n  \n-   The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type.  \n  \n-   The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise. A generic type can be instantiated only if it is closed.  \n  \n-   The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic).  \n  \n<a name=\"Equality\"></a>   \n## Comparing type objects for equality  \n A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type. This allows for comparison of <xref:System.Type> objects using reference equality. The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.  \n  \n [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]\n [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]\n [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]","nodes":[{"pos":[2,403],"content":"[!NOTE]\n To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/type.cs#3d00eeab9feb80f3). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).","leadings":["","> "],"nodes":[{"content":" To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/type.cs#3d00eeab9feb80f3). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).","pos":[8,399],"nodes":[{"content":"To view the .NET Framework source code for this type, see the <bpt id=\"p1\">[</bpt>Reference Source<ept id=\"p1\">](http://referencesource.microsoft.com/#mscorlib/system/type.cs#3d00eeab9feb80f3)</ept>.","pos":[1,162],"source":" To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/type.cs#3d00eeab9feb80f3)."},{"content":"You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see <bpt id=\"p1\">[</bpt>instructions<ept id=\"p1\">](http://referencesource.microsoft.com/)</ept>.","pos":[163,391],"source":" You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/)."}]}]},{"pos":[410,779],"content":"`Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata. Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.","nodes":[{"content":"<ph id=\"ph1\">`Type`</ph> is the root of the <ph id=\"ph2\">&lt;xref:System.Reflection&gt;</ph> functionality and is the primary way to access metadata.","pos":[0,107],"source":"`Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata."},{"content":"Use the members of <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.","pos":[108,369],"source":" Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed."}]},{"pos":[786,1501],"content":"No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels. No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation. However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>. See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).","nodes":[{"content":"No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.","pos":[0,139]},{"content":"No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.","pos":[140,308]},{"content":"However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <ph id=\"ph1\">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.","pos":[309,586],"source":" However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>."},{"content":"See <bpt id=\"p1\">[</bpt>Security Considerations for Reflection<ept id=\"p1\">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.","pos":[587,715],"source":" See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)."}]},{"pos":[1508,1783],"content":"`Type` is an abstract base class that allows multiple implementations. The system will always provide the derived class `RuntimeType`. In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.","nodes":[{"content":"<ph id=\"ph1\">`Type`</ph> is an abstract base class that allows multiple implementations.","pos":[0,70],"source":"`Type` is an abstract base class that allows multiple implementations."},{"content":"The system will always provide the derived class <ph id=\"ph1\">`RuntimeType`</ph>.","pos":[71,134],"source":" The system will always provide the derived class `RuntimeType`."},{"content":"In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.","pos":[135,275]}]},{"pos":[1791,2109],"content":"[!NOTE]\n In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data. Other code, over which you have no control, might also lock your class type. This might result in a deadlock. Instead, synchronize access to static data by locking a private `static` object.","leadings":["","> "],"nodes":[{"content":" In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data. Other code, over which you have no control, might also lock your class type. This might result in a deadlock. Instead, synchronize access to static data by locking a private `static` object.","pos":[8,316],"nodes":[{"content":"In multithreading scenarios, do not lock <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> objects in order to synchronize access to <ph id=\"ph2\">`static`</ph> data.","pos":[1,117],"source":" In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data."},{"content":"Other code, over which you have no control, might also lock your class type.","pos":[118,194]},{"content":"This might result in a deadlock.","pos":[195,227]},{"content":"Instead, synchronize access to static data by locking a private <ph id=\"ph1\">`static`</ph> object.","pos":[228,308],"source":" Instead, synchronize access to static data by locking a private `static` object."}]}]},{"pos":[2117,2395],"content":"[!NOTE]\n A derived class can access protected members of the calling code's base classes. Also, access is allowed to assembly members of the calling code's assembly. As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.","leadings":["","> "],"nodes":[{"content":" A derived class can access protected members of the calling code's base classes. Also, access is allowed to assembly members of the calling code's assembly. As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.","pos":[8,276],"nodes":[{"content":"A derived class can access protected members of the calling code's base classes.","pos":[1,81]},{"content":"Also, access is allowed to assembly members of the calling code's assembly.","pos":[82,157]},{"content":"As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.","pos":[158,268]}]}]},{"pos":[2403,2516],"content":"[!NOTE]\n Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.","leadings":["","> "],"nodes":[{"content":"Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.","pos":[9,111]}]},{"pos":[2523,2539],"content":"In this section:","nodes":[{"content":"In this section:","pos":[0,16]}]},{"pos":[2546,2695],"content":"[What types does a Type object represent?](#WhatTypes)   \n [Retrieving a Type object](#Retrieve)   \n [Comparing type objects for equality](#Equality)","nodes":[{"content":"<bpt id=\"p1\">[</bpt>What types does a Type object represent?<ept id=\"p1\">](#WhatTypes)</ept><ph id=\"ph1\"> </ph>","pos":[0,55],"source":"[What types does a Type object represent?](#WhatTypes) "},{"content":"<bpt id=\"p1\"> [</bpt>Retrieving a Type object<ept id=\"p1\">](#Retrieve)</ept><ph id=\"ph1\"> </ph>","pos":[58,97],"source":" [Retrieving a Type object](#Retrieve) "},{"content":"<bpt id=\"p1\"> [</bpt>Comparing type objects for equality<ept id=\"p1\">](#Equality)</ept>","pos":[100,149],"source":" [Comparing type objects for equality](#Equality)"}]},{"pos":[2732,2772],"content":"What types does a Type object represent?","linkify":"What types does a Type object represent?","nodes":[{"content":"What types does a Type object represent?","pos":[0,40]}]},{"pos":[2776,2958],"content":"This class is thread safe; multiple threads can concurrently read from an instance of this type. An instance of the <xref:System.Type> class can represent any of the following types:","nodes":[{"content":"This class is thread safe; multiple threads can concurrently read from an instance of this type. An instance of the <xref:System.Type> class can represent any of the following types:","pos":[0,182],"nodes":[{"content":"This class is thread safe; multiple threads can concurrently read from an instance of this type.","pos":[0,96]},{"content":"An instance of the <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> class can represent any of the following types:","pos":[97,182],"source":" An instance of the <xref:System.Type> class can represent any of the following types:"}]}]},{"pos":[2968,2975],"content":"Classes","nodes":[{"content":"Classes","pos":[0,7]}]},{"pos":[2985,2996],"content":"Value types","nodes":[{"content":"Value types","pos":[0,11]}]},{"pos":[3006,3012],"content":"Arrays","nodes":[{"content":"Arrays","pos":[0,6]}]},{"pos":[3022,3032],"content":"Interfaces","nodes":[{"content":"Interfaces","pos":[0,10]}]},{"pos":[3042,3054],"content":"Enumerations","nodes":[{"content":"Enumerations","pos":[0,12]}]},{"pos":[3064,3073],"content":"Delegates","nodes":[{"content":"Delegates","pos":[0,9]}]},{"pos":[3083,3137],"content":"Constructed generic types and generic type definitions","nodes":[{"content":"Constructed generic types and generic type definitions","pos":[0,54]}]},{"pos":[3147,3268],"content":"Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions","nodes":[{"content":"Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions","pos":[0,121]}]},{"pos":[3304,3328],"content":"Retrieving a Type object","linkify":"Retrieving a Type object","nodes":[{"content":"Retrieving a Type object","pos":[0,24]}]},{"pos":[3332,3434],"content":"The <xref:System.Type> object associated with a particular type can be obtained in the following ways:","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object associated with a particular type can be obtained in the following ways:","pos":[0,102],"source":"The <xref:System.Type> object associated with a particular type can be obtained in the following ways:"}]},{"pos":[3444,3742],"content":"The instance <xref:System.Object.GetType%2A?displayProperty=fullName> method returns a <xref:System.Type> object that represents the type of an instance. Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.","nodes":[{"content":"The instance <xref:System.Object.GetType%2A?displayProperty=fullName> method returns a <xref:System.Type> object that represents the type of an instance. Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.","pos":[0,298],"nodes":[{"content":"The instance <ph id=\"ph1\">&lt;xref:System.Object.GetType%2A?displayProperty=fullName&gt;</ph> method returns a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object that represents the type of an instance.","pos":[0,153],"source":"The instance <xref:System.Object.GetType%2A?displayProperty=fullName> method returns a <xref:System.Type> object that represents the type of an instance."},{"content":"Because all managed types derive from <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Object.GetType%2A&gt;</ph> method can be called on an instance of any type.","pos":[154,298],"source":" Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type."}]}]},{"pos":[3753,3913],"content":"The following example calls the <xref:System.Object.GetType%2A?displayProperty=fullName> method to determine the runtime type of each object in an object array.","nodes":[{"content":"The following example calls the <ph id=\"ph1\">&lt;xref:System.Object.GetType%2A?displayProperty=fullName&gt;</ph> method to determine the runtime type of each object in an object array.","pos":[0,160],"source":"The following example calls the <xref:System.Object.GetType%2A?displayProperty=fullName> method to determine the runtime type of each object in an object array."}]},{"pos":[3924,4257],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Type#2<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Type#2<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)</ept><ept id=\"p3\">]</ept>  <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Type#2<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)</ept><ept id=\"p5\">]</ept>","leadings":["","    ","    "],"source":"[!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]\n [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]\n [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]"},{"pos":[4267,4437],"content":"The static <xref:System.Type.GetType%2A?displayProperty=fullName> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.","nodes":[{"content":"The static <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A?displayProperty=fullName&gt;</ph> methods return a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object that represents a type specified by its fully qualified name.","pos":[0,170],"source":"The static <xref:System.Type.GetType%2A?displayProperty=fullName> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name."}]},{"pos":[4447,5163],"content":"The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=fullName>, <xref:System.Reflection.Module.GetType%2A?displayProperty=fullName>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=fullName> methods return `Type` objects that represent the types defined in a module. The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module. (You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=fullName> method, or through the <xref:System.Type.Module%2A?displayProperty=fullName> property.)","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.Module.GetTypes%2A?displayProperty=fullName&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Reflection.Module.GetType%2A?displayProperty=fullName&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Reflection.Module.FindTypes%2A?displayProperty=fullName&gt;</ph> methods return <ph id=\"ph4\">`Type`</ph> objects that represent the types defined in a module.","pos":[0,292],"source":"The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=fullName>, <xref:System.Reflection.Module.GetType%2A?displayProperty=fullName>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=fullName> methods return `Type` objects that represent the types defined in a module."},{"content":"The first method can be used to obtain an array of <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> objects for all the public and private types defined in a module.","pos":[293,428],"source":" The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module."},{"content":"(You can obtain an instance of <ph id=\"ph1\">`Module`</ph> through the <ph id=\"ph2\">&lt;xref:System.Reflection.Assembly.GetModule%2A?displayProperty=fullName&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Assembly.GetModules%2A?displayProperty=fullName&gt;</ph> method, or through the <ph id=\"ph4\">&lt;xref:System.Type.Module%2A?displayProperty=fullName&gt;</ph> property.)","pos":[429,716],"source":" (You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=fullName> method, or through the <xref:System.Type.Module%2A?displayProperty=fullName> property.)"}]},{"pos":[5173,5556],"content":"The <xref:System.Reflection.Assembly?displayProperty=fullName> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=fullName>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=fullName>.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly?displayProperty=fullName&gt;</ph> object contains a number of methods to retrieve the classes defined in an assembly, including <ph id=\"ph2\">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=fullName&gt;</ph>, and <ph id=\"ph4\">&lt;xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=fullName&gt;</ph>.","pos":[0,383],"source":"The <xref:System.Reflection.Assembly?displayProperty=fullName> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=fullName>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=fullName>."}]},{"pos":[5566,5677],"content":"The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> method returns a filtered list of interface types supported by a type.","pos":[0,111],"source":"The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type."}]},{"pos":[5687,5787],"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetElementType%2A&gt;</ph> method returns a <ph id=\"ph2\">`Type`</ph> object that represents the element.","source":"The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element."},{"pos":[5797,5971],"content":"The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Type.GetInterface%2A&gt;</ph> methods return <ph id=\"ph3\">&lt;xref:System.Type&gt;</ph> objects representing the interface types supported by a type.","pos":[0,174],"source":"The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type."}]},{"pos":[5981,6208],"content":"The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects. The objects are specified with an array of type <xref:System.Object>.","nodes":[{"content":"The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects. The objects are specified with an array of type <xref:System.Object>.","pos":[0,227],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetTypeArray%2A&gt;</ph> method returns an array of <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> objects representing the types specified by an arbitrary set of objects.","pos":[0,157],"source":"The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects."},{"content":"The objects are specified with an array of type <ph id=\"ph1\">&lt;xref:System.Object&gt;</ph>.","pos":[158,227],"source":" The objects are specified with an array of type <xref:System.Object>."}]}]},{"pos":[6218,6452],"content":"The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability. They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> methods are provided for COM interoperability.","pos":[0,133],"source":"The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability."},{"content":"They return a <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object that represents the type specified by a <ph id=\"ph2\">`ProgID`</ph> or <ph id=\"ph3\">`CLSID`</ph>.","pos":[134,234],"source":" They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`."}]},{"pos":[6462,6627],"content":"The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability. It returns a `Type` object that represents the type specified by a class handle.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetTypeFromHandle%2A&gt;</ph> method is provided for interoperability.","pos":[0,84],"source":"The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability."},{"content":"It returns a <ph id=\"ph1\">`Type`</ph> object that represents the type specified by a class handle.","pos":[85,165],"source":" It returns a `Type` object that represents the type specified by a class handle."}]},{"pos":[6637,6766],"content":"The C# <ph id=\"ph1\">`typeof`</ph> operator, the C++ <ph id=\"ph2\">`typeid`</ph> operator, and the Visual Basic <ph id=\"ph3\">`GetType`</ph> operator obtain the <ph id=\"ph4\">`Type`</ph> object for a type.","source":"The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type."},{"pos":[6776,7113],"content":"The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise. A generic type can be instantiated only if it is closed.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method returns a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object representing a constructed generic type, which is an open constructed type if its <ph id=\"ph3\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id=\"ph4\">`true`</ph>, and a closed constructed type otherwise.","pos":[0,280],"source":"The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise."},{"content":"A generic type can be instantiated only if it is closed.","pos":[281,337]}]},{"pos":[7123,7453],"content":"The <ph id=\"ph1\">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Type.MakePointerType%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> methods return <ph id=\"ph4\">&lt;xref:System.Type&gt;</ph> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (<ph id=\"ph5\">`ref`</ph> in C#, <ph id=\"ph6\">`ByRef`</ph> in Visual Basic).","source":"The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic)."},{"pos":[7489,7524],"content":"Comparing type objects for equality","linkify":"Comparing type objects for equality","nodes":[{"content":"Comparing type objects for equality","pos":[0,35]}]},{"pos":[7528,7944],"content":"A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type. This allows for comparison of <xref:System.Type> objects using reference equality. The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.","nodes":[{"content":"A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type. This allows for comparison of <xref:System.Type> objects using reference equality. The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.","pos":[0,416],"nodes":[{"content":"A <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object that represents a type is unique; that is, two <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object references refer to the same object if and only if they represent the same type.","pos":[0,181],"source":"A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type."},{"content":"This allows for comparison of <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> objects using reference equality.","pos":[182,264],"source":" This allows for comparison of <xref:System.Type> objects using reference equality."},{"content":"The following example compares the <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> objects that represent a number of integer values to determine whether they are of the same type.","pos":[265,416],"source":" The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type."}]}]},{"pos":[7951,8273],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Type#3<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Type#3<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Type#3<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]\n [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]\n [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]"}],"pos":[10247,18615],"yaml":true,"extradata":"MT"},{"content":"Initializes a new instance of the <xref href=\"System.Type\"></xref> class.","nodes":[{"pos":[0,73],"content":"Initializes a new instance of the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> class.","source":"Initializes a new instance of the <xref href=\"System.Type\"></xref> class."}],"pos":[25722,25796],"yaml":true},{"content":"This constructor is invoked by derived classes during the construction of type objects.","nodes":[{"pos":[0,87],"content":"This constructor is invoked by derived classes during the construction of type objects.","nodes":[{"content":"This constructor is invoked by derived classes during the construction of type objects.","pos":[0,87]}]}],"pos":[25807,25895],"yaml":true,"extradata":"MT"},{"content":"Gets the <xref href=\"System.Reflection.Assembly\"></xref> in which the type is declared. For generic types, gets the <xref href=\"System.Reflection.Assembly\"></xref> in which the generic type is defined.","nodes":[{"pos":[0,201],"content":"Gets the <xref href=\"System.Reflection.Assembly\"></xref> in which the type is declared. For generic types, gets the <xref href=\"System.Reflection.Assembly\"></xref> in which the generic type is defined.","nodes":[{"content":"Gets the <ph id=\"ph1\">&lt;xref href=\"System.Reflection.Assembly\"&gt;&lt;/xref&gt;</ph> in which the type is declared.","pos":[0,87],"source":"Gets the <xref href=\"System.Reflection.Assembly\"></xref> in which the type is declared."},{"content":"For generic types, gets the <ph id=\"ph1\">&lt;xref href=\"System.Reflection.Assembly\"&gt;&lt;/xref&gt;</ph> in which the generic type is defined.","pos":[88,201],"source":" For generic types, gets the <xref href=\"System.Reflection.Assembly\"></xref> in which the generic type is defined."}]}],"pos":[27016,27218],"yaml":true},{"content":"If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition. For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++). If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.  \n  \n Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.  \n  \n If the <xref:System.Type.Assembly%2A?displayProperty=fullName> property is not available on a particular .NET platform, such as .NET Core or the Universal Windows Platform, use the  `System.Reflection.TypeInfo.Assembly` property instead. ?qualifyHint=False&autoUpgrade=True  \n  \n This property is read-only.","nodes":[{"pos":[0,644],"content":"If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition. For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++). If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.","pos":[0,157],"source":"If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition."},{"content":"For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition <ph id=\"ph1\">`MyGenericStack&lt;T&gt;`</ph> (<ph id=\"ph2\">`MyGenericStack(Of T)`</ph> in Visual Basic, <ph id=\"ph3\">`generic&lt;T&gt; ref class MyGenericStack`</ph> in C++).","pos":[158,372],"source":" For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++)."},{"content":"If you create an instance of <ph id=\"ph1\">`MyGenericStack&lt;int&gt;`</ph> (<ph id=\"ph2\">`MyGenericStack(Of Integer)`</ph> in Visual Basic) in another assembly, the <ph id=\"ph3\">&lt;xref:System.Type.Assembly%2A&gt;</ph> property for the constructed type returns an <ph id=\"ph4\">&lt;xref:System.Reflection.Assembly&gt;</ph> object that represents MyGenerics.dll.","pos":[373,644],"source":" If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll."}]},{"pos":[651,834],"content":"Similarly, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object represents an unassigned generic parameter <ph id=\"ph2\">`T`</ph>, this property returns the assembly that contains the generic type that defines <ph id=\"ph3\">`T`</ph>.","source":"Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`."},{"pos":[841,1114],"content":"If the <xref:System.Type.Assembly%2A?displayProperty=fullName> property is not available on a particular .NET platform, such as .NET Core or the Universal Windows Platform, use the  `System.Reflection.TypeInfo.Assembly` property instead. ?qualifyHint=False&autoUpgrade=True","nodes":[{"content":"If the <ph id=\"ph1\">&lt;xref:System.Type.Assembly%2A?displayProperty=fullName&gt;</ph> property is not available on a particular .NET platform, such as .NET Core or the Universal Windows Platform, use the  <ph id=\"ph2\">`System.Reflection.TypeInfo.Assembly`</ph> property instead.","pos":[0,237],"source":"If the <xref:System.Type.Assembly%2A?displayProperty=fullName> property is not available on a particular .NET platform, such as .NET Core or the Universal Windows Platform, use the  `System.Reflection.TypeInfo.Assembly` property instead."},{"content":"?qualifyHint=False&amp;autoUpgrade=True","pos":[238,273],"source":" ?qualifyHint=False&autoUpgrade=True"}]},{"pos":[1121,1148],"content":"This property is read-only.","nodes":[{"content":"This property is read-only.","pos":[0,27]}]}],"pos":[27229,28386],"yaml":true,"extradata":"MT"},{"content":"An <xref href=\"System.Reflection.Assembly\"></xref> instance that describes the assembly containing the current type. For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.","nodes":[{"pos":[0,284],"content":"An <xref href=\"System.Reflection.Assembly\"></xref> instance that describes the assembly containing the current type. For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.","nodes":[{"content":"An <ph id=\"ph1\">&lt;xref href=\"System.Reflection.Assembly\"&gt;&lt;/xref&gt;</ph> instance that describes the assembly containing the current type.","pos":[0,116],"source":"An <xref href=\"System.Reflection.Assembly\"></xref> instance that describes the assembly containing the current type."},{"content":"For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.","pos":[117,284]}]}],"pos":[29016,29301],"yaml":true},{"content":"Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <xref href=\"System.Type\"></xref> object was loaded.","nodes":[{"pos":[0,153],"content":"Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object was loaded.","source":"Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <xref href=\"System.Type\"></xref> object was loaded."}],"pos":[30442,30596],"yaml":true},{"content":"The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly. The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> property.  \n  \n> [!NOTE]\n>  In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \"ProcessorArchitecture=msil\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.  \n  \n All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  \n  \n|Delimiter|Meaning|  \n|---------------|-------------|  \n|Backslash (\\\\)|Escape character.|  \n|Comma (,)|Precedes the Assembly name.|  \n|Plus sign (+)|Precedes a nested class.|  \n|Period (.)|Denotes namespace identifiers.|  \n|Brackets ([])|After a type name, denotes an array of that type.<br /><br /> -or-<br /><br /> For a generic type, encloses the generic type argument list.<br /><br /> -or-<br /><br /> Within a type argument list, encloses an assembly-qualified type.|  \n  \n For example, the assembly-qualified name for a class might look like this:  \n  \n```  \nTopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  \n```  \n  \n If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\\\) to prevent it from being interpreted as a nesting separator. Reflection would emit this string as follows:  \n  \n```  \nTopNamespace.Sub\\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   \n```  \n  \n A \"++\" becomes \"\\\\+\\\\+\", and a \"\\\\\" becomes \"\\\\\\\\\".  \n  \n This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.  \n  \n Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.  \n  \n Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.  \n  \n Generic arguments of generic types are themselves qualified by assembly name. For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.  \n  \n If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.","nodes":[{"pos":[0,291],"content":"The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly. The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> property.","nodes":[{"content":"The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly. The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> property.","pos":[0,291],"nodes":[{"content":"The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.","pos":[0,156]},{"content":"The display name of an assembly is obtained using the <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName&gt;</ph> property.","pos":[157,291],"source":" The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> property."}]}]},{"pos":[299,728],"content":"[!NOTE]\n In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \"ProcessorArchitecture=msil\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.","leadings":["","> "],"nodes":[{"content":" In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \"ProcessorArchitecture=msil\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.","pos":[8,427],"nodes":[{"content":"In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.","pos":[1,144]},{"content":"For example, \"ProcessorArchitecture=msil\".","pos":[145,187]},{"content":"However, it is not included in the string returned by the <ph id=\"ph1\">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.","pos":[188,326],"source":" However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons."},{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName&gt;</ph>.","pos":[327,419],"source":" See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>."}]}]},{"pos":[735,930],"content":"All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.","nodes":[{"content":"All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.","pos":[0,195]}]},{"pos":[937,946],"content":"Delimiter","nodes":[{"content":"Delimiter","pos":[0,9]}]},{"pos":[947,954],"content":"Meaning","nodes":[{"content":"Meaning","pos":[0,7]}]},{"pos":[993,1007],"content":"Backslash (\\\\)","nodes":[{"content":"Backslash (<ph id=\"ph1\">\\\\</ph>)","pos":[0,14],"source":"Backslash (\\\\)"}]},{"pos":[1008,1025],"content":"Escape character.","nodes":[{"content":"Escape character.","pos":[0,17]}]},{"pos":[1030,1039],"content":"Comma (,)","nodes":[{"content":"Comma (,)","pos":[0,9]}]},{"pos":[1040,1067],"content":"Precedes the Assembly name.","nodes":[{"content":"Precedes the Assembly name.","pos":[0,27]}]},{"pos":[1072,1085],"content":"Plus sign (+)","nodes":[{"content":"Plus sign (+)","pos":[0,13]}]},{"pos":[1086,1110],"content":"Precedes a nested class.","nodes":[{"content":"Precedes a nested class.","pos":[0,24]}]},{"pos":[1115,1125],"content":"Period (.)","nodes":[{"content":"Period (.)","pos":[0,10]}]},{"pos":[1126,1156],"content":"Denotes namespace identifiers.","nodes":[{"content":"Denotes namespace identifiers.","pos":[0,30]}]},{"pos":[1161,1174],"content":"Brackets ([])","nodes":[{"content":"Brackets ([])","pos":[0,13]}]},{"pos":[1175,1409],"content":"After a type name, denotes an array of that type.<br /><br /> -or-<br /><br /> For a generic type, encloses the generic type argument list.<br /><br /> -or-<br /><br /> Within a type argument list, encloses an assembly-qualified type.","nodes":[{"content":"After a type name, denotes an array of that type.","pos":[0,49]},{"content":"-or-","pos":[62,66]},{"content":"For a generic type, encloses the generic type argument list.","pos":[79,139]},{"content":"-or-","pos":[152,156]},{"content":"Within a type argument list, encloses an assembly-qualified type.","pos":[169,234]}]},{"pos":[1417,1491],"content":"For example, the assembly-qualified name for a class might look like this:","nodes":[{"content":"For example, the assembly-qualified name for a class might look like this:","pos":[0,74]}]},{"pos":[1648,1903],"content":"If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\\\) to prevent it from being interpreted as a nesting separator. Reflection would emit this string as follows:","nodes":[{"content":"If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\\\) to prevent it from being interpreted as a nesting separator. Reflection would emit this string as follows:","pos":[0,255],"nodes":[{"content":"If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (<ph id=\"ph1\">\\\\</ph>) to prevent it from being interpreted as a nesting separator.","pos":[0,209],"source":"If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\\\) to prevent it from being interpreted as a nesting separator."},{"content":"Reflection would emit this string as follows:","pos":[210,255]}]}]},{"pos":[2063,2114],"content":"A \"++\" becomes \"\\\\+\\\\+\", and a \"\\\\\" becomes \"\\\\\\\\\".","nodes":[{"content":"A \"++\" becomes \"<ph id=\"ph1\">\\\\</ph><ph id=\"ph2\">+</ph><ph id=\"ph3\">\\\\</ph>+\", and a \"<ph id=\"ph4\">\\\\</ph>\" becomes \"<ph id=\"ph5\">\\\\</ph><ph id=\"ph6\">\\\\</ph>\".","pos":[0,51],"source":"A \"++\" becomes \"\\\\+\\\\+\", and a \"\\\\\" becomes \"\\\\\\\\\"."}]},{"pos":[2121,2627],"content":"This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.","nodes":[{"content":"This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.","pos":[0,506],"nodes":[{"content":"This qualified name can be persisted and later used to load the <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph>.","pos":[0,83],"source":"This qualified name can be persisted and later used to load the <xref:System.Type>."},{"content":"To search for and load a <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph>, use <ph id=\"ph2\">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.","pos":[84,235],"source":" To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.","pos":[236,384],"source":" <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> in any assembly.","pos":[385,506],"source":" <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly."}]}]},{"pos":[2634,2927],"content":"Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.","nodes":[{"content":"Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.","pos":[0,172]},{"content":"To retrieve the type name without these trailing characters, use <ph id=\"ph1\">`t.GetElementType().ToString()`</ph>, where <ph id=\"ph2\">`t`</ph> is the type.","pos":[173,293],"source":" To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type."}]},{"pos":[2934,3123],"content":"Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.","nodes":[{"content":"Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.","pos":[0,189],"nodes":[{"content":"Spaces are relevant in all type name components except the assembly name.","pos":[0,73]},{"content":"In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.","pos":[74,189]}]}]},{"pos":[3130,3409],"content":"Generic arguments of generic types are themselves qualified by assembly name. For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.","nodes":[{"content":"Generic arguments of generic types are themselves qualified by assembly name.","pos":[0,77]},{"content":"For example, in the assembly-qualified type name for <ph id=\"ph1\">`MyGenericClass&lt;int&gt;`</ph> (<ph id=\"ph2\">`MyGenericClass(Of Integer)`</ph> in Visual Basic), <ph id=\"ph3\">`int`</ph> is expanded to the assembly-qualified type name for <ph id=\"ph4\">&lt;xref:System.Int32&gt;</ph>.","pos":[78,279],"source":" For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>."}]},{"pos":[3416,3518],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object represents a generic parameter, this property returns <ph id=\"ph2\">`null`</ph>.","source":"If the current <xref:System.Type> object represents a generic parameter, this property returns `null`."}],"pos":[30607,34190],"yaml":true,"extradata":"MT"},{"content":"The assembly-qualified name of the <xref href=\"System.Type\"></xref>, which includes the name of the assembly from which the <xref href=\"System.Type\"></xref> was loaded, or `null` if the current instance represents a generic type parameter.","nodes":[{"pos":[0,239],"content":"The assembly-qualified name of the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, which includes the name of the assembly from which the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> was loaded, or <ph id=\"ph3\">`null`</ph> if the current instance represents a generic type parameter.","source":"The assembly-qualified name of the <xref href=\"System.Type\"></xref>, which includes the name of the assembly from which the <xref href=\"System.Type\"></xref> was loaded, or `null` if the current instance represents a generic type parameter."}],"pos":[35280,35520],"yaml":true},{"content":"Gets the attributes associated with the <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,73],"content":"Gets the attributes associated with the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Gets the attributes associated with the <xref href=\"System.Type\"></xref>."}],"pos":[36952,37026],"yaml":true},{"content":"Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values. Each group includes one member whose underlying value is zero. For example, the underlying value of the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> member in the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> group is zero, as is the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> member in the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> group. Because of this, you must use the mask before testing for those values. The example provides an illustration.  \n  \n> [!TIP]\n>  For most purposes, properties like<xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and<xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition. For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).  \n  \n If the current <xref:System.Type> represents a generic type parameter  that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true`  the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified.","nodes":[{"pos":[0,649],"content":"Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values. Each group includes one member whose underlying value is zero. For example, the underlying value of the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> member in the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> group is zero, as is the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> member in the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> group. Because of this, you must use the mask before testing for those values. The example provides an illustration.","nodes":[{"content":"Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values. Each group includes one member whose underlying value is zero. For example, the underlying value of the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> member in the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> group is zero, as is the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> member in the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> group. Because of this, you must use the mask before testing for those values. The example provides an illustration.","pos":[0,649],"nodes":[{"content":"Some members of the <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration are masks that represent a group of values.","pos":[0,115],"source":"Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values."},{"content":"Each group includes one member whose underlying value is zero.","pos":[116,178]},{"content":"For example, the underlying value of the <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> member in the <ph id=\"ph2\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> group is zero, as is the <ph id=\"ph3\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> member in the <ph id=\"ph4\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> group.","pos":[179,539],"source":" For example, the underlying value of the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> member in the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> group is zero, as is the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> member in the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> group."},{"content":"Because of this, you must use the mask before testing for those values.","pos":[540,611]},{"content":"The example provides an illustration.","pos":[612,649]}]}]},{"pos":[657,845],"content":"[!TIP]\n For most purposes, properties like<xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and<xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.","leadings":["","> "],"nodes":[{"content":"For most purposes, properties like<ph id=\"ph1\">&lt;xref:System.Type.IsClass%2A&gt;</ph>,<ph id=\"ph2\">&lt;xref:System.Type.IsAutoLayout%2A&gt;</ph>, and<ph id=\"ph3\">&lt;xref:System.Type.IsSpecialName%2A&gt;</ph> are easier to use than type attributes.","pos":[8,186],"source":" For most purposes, properties like<xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and<xref:System.Type.IsSpecialName%2A> are easier to use than type attributes."}]},{"pos":[852,1187],"content":"If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition. For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the attributes of the generic type definition.","pos":[0,141],"source":"If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition."},{"content":"For example, the attributes returned for <ph id=\"ph1\">`MyGenericClass&lt;int&gt;`</ph> (<ph id=\"ph2\">`MyGenericClass(Of Integer)`</ph> in Visual Basic) are the attributes of <ph id=\"ph3\">`MyGenericClass&lt;T&gt;`</ph> (<ph id=\"ph4\">`MyGenericClass(Of T)`</ph> in Visual Basic).","pos":[142,335],"source":" For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic)."}]},{"pos":[1194,1440],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a generic type parameter  that is, if the <ph id=\"ph2\">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id=\"ph3\">`true`</ph>  the <ph id=\"ph4\">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> value returned by this property is unspecified.","source":"If the current <xref:System.Type> represents a generic type parameter  that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true`  the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified."}],"pos":[37037,38487],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Reflection.TypeAttributes\"></xref> object representing the attribute set of the <xref href=\"System.Type\"></xref>, unless the <xref href=\"System.Type\"></xref> represents a generic type parameter, in which case the value is unspecified.","nodes":[{"pos":[0,255],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Reflection.TypeAttributes\"&gt;&lt;/xref&gt;</ph> object representing the attribute set of the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, unless the <ph id=\"ph3\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> represents a generic type parameter, in which case the value is unspecified.","source":"A <xref href=\"System.Reflection.TypeAttributes\"></xref> object representing the attribute set of the <xref href=\"System.Type\"></xref>, unless the <xref href=\"System.Type\"></xref> represents a generic type parameter, in which case the value is unspecified."}],"pos":[39015,39271],"yaml":true},{"content":"Gets the type from which the current <xref href=\"System.Type\"></xref> directly inherits.","nodes":[{"pos":[0,88],"content":"Gets the type from which the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> directly inherits.","source":"Gets the type from which the current <xref href=\"System.Type\"></xref> directly inherits."}],"pos":[40336,40425],"yaml":true},{"content":"The base type is the type from which the current type directly inherits. <xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.  \n  \n Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface. The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.  \n  \n If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments. For example, consider the following declarations:  \n  \n [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]\n [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]\n [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  \n  \n For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`.  \n  \n If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit. If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=fullName>.  \n  \n This property is read-only.","nodes":[{"pos":[0,213],"content":"The base type is the type from which the current type directly inherits. <xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.","nodes":[{"content":"The base type is the type from which the current type directly inherits.","pos":[0,72]},{"content":"<ph id=\"ph1\">&lt;xref:System.Object&gt;</ph> is the only type that does not have a base type, therefore <ph id=\"ph2\">`null`</ph> is returned as the base type of <ph id=\"ph3\">&lt;xref:System.Object&gt;</ph>.","pos":[73,213],"source":" <xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>."}]},{"pos":[220,479],"content":"Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface. The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.","nodes":[{"content":"Interfaces inherit from zero or more base interfaces; therefore, this property returns <ph id=\"ph1\">`null`</ph> if the <ph id=\"ph2\">`Type`</ph> object represents an interface.","pos":[0,139],"source":"Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface."},{"content":"The base interfaces can be determined with <ph id=\"ph1\">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph>.","pos":[140,259],"source":" The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>."}]},{"pos":[486,654],"content":"If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments. For example, consider the following declarations:","nodes":[{"content":"If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments. For example, consider the following declarations:","pos":[0,168],"nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, the base type reflects the generic arguments.","pos":[0,118],"source":"If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments."},{"content":"For example, consider the following declarations:","pos":[119,168]}]}]},{"pos":[661,1037],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Type.BaseType#1<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Type.BaseType#1<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Type.BaseType#1<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]\n [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]\n [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]"},{"pos":[1044,1174],"content":"For the constructed type <ph id=\"ph1\">`C&lt;int&gt;`</ph> (<ph id=\"ph2\">`C(Of Integer)`</ph> in Visual Basic), the <ph id=\"ph3\">&lt;xref:System.Type.BaseType%2A&gt;</ph> property returns <ph id=\"ph4\">`B&lt;int&gt;`</ph>.","source":"For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`."},{"pos":[1181,1504],"content":"If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit. If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=fullName>.","nodes":[{"content":"If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit. If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=fullName>.","pos":[0,323],"nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type definition, <ph id=\"ph2\">&lt;xref:System.Type.BaseType%2A&gt;</ph> returns the class constraint, that is, the class the type parameter must inherit.","pos":[0,204],"source":"If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit."},{"content":"If there is no class constraint, <ph id=\"ph1\">&lt;xref:System.Type.BaseType%2A&gt;</ph> returns <ph id=\"ph2\">&lt;xref:System.Object?displayProperty=fullName&gt;</ph>.","pos":[205,323],"source":" If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=fullName>."}]}]},{"pos":[1511,1538],"content":"This property is read-only.","nodes":[{"content":"This property is read-only.","pos":[0,27]}]}],"pos":[40436,41991],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Type\"></xref> from which the current <xref href=\"System.Type\"></xref> directly inherits, or `null` if the current `Type` represents the <xref href=\"System.Object\"></xref> class or an interface.","nodes":[{"pos":[0,216],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> from which the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> directly inherits, or <ph id=\"ph3\">`null`</ph> if the current <ph id=\"ph4\">`Type`</ph> represents the <ph id=\"ph5\">&lt;xref href=\"System.Object\"&gt;&lt;/xref&gt;</ph> class or an interface.","source":"The <xref href=\"System.Type\"></xref> from which the current <xref href=\"System.Type\"></xref> directly inherits, or `null` if the current `Type` represents the <xref href=\"System.Object\"></xref> class or an interface."}],"pos":[43058,43275],"yaml":true},{"content":"Gets a value indicating whether the current <xref href=\"System.Type\"></xref> object has type parameters that have not been replaced by specific types.","nodes":[{"pos":[0,150],"content":"Gets a value indicating whether the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object has type parameters that have not been replaced by specific types.","source":"Gets a value indicating whether the current <xref href=\"System.Type\"></xref> object has type parameters that have not been replaced by specific types."}],"pos":[44440,44591],"yaml":true},{"content":"In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type. Another way of saying this is that when examined recursively, the type must contain no generic type parameters.  \n  \n Since types can be arbitrarily complex, making this determination is difficult. For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot. If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.  \n  \n The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters. For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic. Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.  \n  \n For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.","nodes":[{"pos":[0,327],"content":"In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type. Another way of saying this is that when examined recursively, the type must contain no generic type parameters.","nodes":[{"content":"In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type. Another way of saying this is that when examined recursively, the type must contain no generic type parameters.","pos":[0,327],"nodes":[{"content":"In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.","pos":[0,215]},{"content":"Another way of saying this is that when examined recursively, the type must contain no generic type parameters.","pos":[216,327]}]}]},{"pos":[334,780],"content":"Since types can be arbitrarily complex, making this determination is difficult. For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot. If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.","nodes":[{"content":"Since types can be arbitrarily complex, making this determination is difficult.","pos":[0,79]},{"content":"For convenience and to reduce the chance of error, the <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.","pos":[80,333],"source":" For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot."},{"content":"If the <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id=\"ph2\">`true`</ph>, the type cannot be instantiated.","pos":[334,446],"source":" If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated."}]},{"pos":[787,1157],"content":"The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters. For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic. Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property searches recursively for type parameters.","pos":[0,102],"source":"The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters."},{"content":"For example, it returns <ph id=\"ph1\">`true`</ph> for an array whose elements are type <ph id=\"ph2\">`A&lt;T&gt;`</ph> (<ph id=\"ph3\">`A(Of T)`</ph> in Visual Basic), even though the array is not itself generic.","pos":[103,251],"source":" For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic."},{"content":"Contrast this with the behavior of the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property, which returns <ph id=\"ph2\">`false`</ph> for arrays.","pos":[252,370],"source":" Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays."}]},{"pos":[1164,1329],"content":"For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.","nodes":[{"content":"For a set of example classes and a table showing the values of the <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property, see <ph id=\"ph2\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph>.","pos":[0,165],"source":"For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>."}]}],"pos":[44602,45940],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, `false`.","nodes":[{"pos":[0,180],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, `false`."}],"pos":[47040,47223],"yaml":true},{"content":"Gets a <xref href=\"System.Reflection.MethodBase\"></xref> that represents the declaring method, if the current <xref href=\"System.Type\"></xref> represents a type parameter of a generic method.","nodes":[{"pos":[0,191],"content":"Gets a <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MethodBase\"&gt;&lt;/xref&gt;</ph> that represents the declaring method, if the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> represents a type parameter of a generic method.","source":"Gets a <xref href=\"System.Reflection.MethodBase\"></xref> that represents the declaring method, if the current <xref href=\"System.Type\"></xref> represents a type parameter of a generic method."}],"pos":[48345,48537],"yaml":true},{"content":"The declaring method is a generic method definition. That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.  \n  \n The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:  \n  \n-   If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.  \n  \n-   If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.  \n  \n-   Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.  \n  \n The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.  \n  \n> [!NOTE]\n>  In the .NET Framework version 2.0, generic constructors are not supported.  \n  \n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"pos":[0,191],"content":"The declaring method is a generic method definition. That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.","nodes":[{"content":"The declaring method is a generic method definition.","pos":[0,52]},{"content":"That is, if <ph id=\"ph1\">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> does not return <ph id=\"ph2\">`null`</ph>, then <ph id=\"ph3\">`DeclaringMethod.IsGenericMethodDefinition`</ph> returns <ph id=\"ph4\">`true`</ph>.","pos":[53,191],"source":" That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`."}]},{"pos":[198,416],"content":"The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:","pos":[0,218],"source":"The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:"}]},{"pos":[426,712],"content":"If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.","nodes":[{"content":"If the <ph id=\"ph1\">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id=\"ph2\">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id=\"ph3\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id=\"ph4\">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.","pos":[0,286],"source":"If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition."}]},{"pos":[722,1031],"content":"If the <ph id=\"ph1\">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id=\"ph2\">`null`</ph>, then the <ph id=\"ph3\">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id=\"ph4\">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id=\"ph5\">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.","source":"If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition."},{"pos":[1041,1227],"content":"Getting the <ph id=\"ph1\">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property on a type whose <ph id=\"ph2\">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id=\"ph3\">`false`</ph> throws an <ph id=\"ph4\">&lt;xref:System.InvalidOperationException&gt;</ph>.","source":"Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>."},{"pos":[1234,1509],"content":"The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.MethodBase&gt;</ph> that is returned by the <ph id=\"ph2\">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property is either a <ph id=\"ph3\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> in the case of a generic method, or a <ph id=\"ph4\">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> in the case of a generic constructor.","pos":[0,275],"source":"The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor."}]},{"pos":[1517,1602],"content":"[!NOTE]\n In the .NET Framework version 2.0, generic constructors are not supported.","leadings":["","> "],"nodes":[{"content":"In the .NET Framework version 2.0, generic constructors are not supported.","pos":[9,83]}]},{"pos":[1609,1747],"content":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"content":"For a list of the invariant conditions for terms used in generic reflection, see the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.","pos":[0,138],"source":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks."}]}],"pos":[48548,50313],"yaml":true,"extradata":"MT"},{"content":"If the current <xref href=\"System.Type\"></xref> represents a type parameter of a generic method, a <xref href=\"System.Reflection.MethodBase\"></xref> that represents declaring method; otherwise, `null`.","nodes":[{"pos":[0,201],"content":"If the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> represents a type parameter of a generic method, a <ph id=\"ph2\">&lt;xref href=\"System.Reflection.MethodBase\"&gt;&lt;/xref&gt;</ph> that represents declaring method; otherwise, <ph id=\"ph3\">`null`</ph>.","source":"If the current <xref href=\"System.Type\"></xref> represents a type parameter of a generic method, a <xref href=\"System.Reflection.MethodBase\"></xref> that represents declaring method; otherwise, `null`."}],"pos":[51365,51567],"yaml":true},{"content":"Gets the type that declares the current nested type or generic type parameter.","nodes":[{"pos":[0,78],"content":"Gets the type that declares the current nested type or generic type parameter.","nodes":[{"content":"Gets the type that declares the current nested type or generic type parameter.","pos":[0,78]}]}],"pos":[52667,52746],"yaml":true},{"content":"If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.  \n  \n If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition. If the type is generic, the generic type definition is returned. That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:  \n  \n [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]\n [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]\n [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:  \n  \n-   If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.  \n  \n-   If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.  \n  \n-   Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.","nodes":[{"pos":[0,138],"content":"If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic type, this property returns the generic type definition.","pos":[0,138],"source":"If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition."}]},{"pos":[145,596],"content":"If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition. If the type is generic, the generic type definition is returned. That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:","nodes":[{"content":"If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition. If the type is generic, the generic type definition is returned. That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:","pos":[0,451],"nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.","pos":[0,165],"source":"If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition."},{"content":"If the type is generic, the generic type definition is returned.","pos":[166,230]},{"content":"That is, the following code returns the generic type definition of the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.List%601&gt;</ph> generic class, which contains the <ph id=\"ph2\">&lt;xref:System.Collections.Generic.List%601.ConvertAll%2A&gt;</ph> generic method:","pos":[231,451],"source":" That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:"}]}]},{"pos":[603,1009],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Type.DeclaringType#1<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Type.DeclaringType#1<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Type.DeclaringType#1<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]\n [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]\n [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]"},{"pos":[1016,1348],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, the <ph id=\"ph2\">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:","pos":[0,332],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:"}]},{"pos":[1358,1644],"content":"If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.","nodes":[{"content":"If the <ph id=\"ph1\">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id=\"ph2\">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id=\"ph3\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id=\"ph4\">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.","pos":[0,286],"source":"If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition."}]},{"pos":[1654,1963],"content":"If the <ph id=\"ph1\">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id=\"ph2\">`null`</ph>, then the <ph id=\"ph3\">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id=\"ph4\">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id=\"ph5\">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.","source":"If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition."},{"pos":[1973,2157],"content":"Getting the <ph id=\"ph1\">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property on a type whose <ph id=\"ph2\">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id=\"ph3\">`false`</ph> throws an <ph id=\"ph4\">&lt;xref:System.InvalidOperationException&gt;</ph>.","source":"Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>."}],"pos":[52757,54931],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Type\"></xref> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, `null`.","nodes":[{"pos":[0,329],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <ph id=\"ph2\">`null`</ph>.","source":"A <xref href=\"System.Type\"></xref> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, `null`."}],"pos":[55614,55944],"yaml":true},{"content":"Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <xref href=\"System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])\"></xref>.","nodes":[{"pos":[0,360],"content":"Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <ph id=\"ph1\">&lt;xref href=\"System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])\"&gt;&lt;/xref&gt;</ph>.","source":"Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <xref href=\"System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])\"></xref>."}],"pos":[57386,57747],"yaml":true},{"content":"The default binder provided with the common language runtime is applicable in all but the most specialized circumstances. If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.  \n  \n Reflection models the accessibility rules of the common type system. For example, if the caller is in the same assembly, the caller does not need special permissions for internal members. Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>. This is consistent with lookup of members that are protected, private, and so on.  \n  \n The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data. An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer. This is distinguished from a narrowing conversion, which may lose data. An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.  \n  \n The following table lists the conversions supported by the default binder.  \n  \n|Source Type|Target Type|  \n|-----------------|-----------------|  \n|Any type|Its base type.|  \n|Any type|The interface it implements.|  \n|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  \n|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  \n|SByte|Int16, Int32, Int64, Single, Double|  \n|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  \n|Int16|Int32, Int64, Single, Double|  \n|UInt32|UInt64, Int64, Single, Double|  \n|Int32|Int64, Single, Double|  \n|UInt64|Single, Double|  \n|Int64|Single, Double|  \n|Single|Double|  \n|Non-reference|By-reference.|","nodes":[{"pos":[0,408],"content":"The default binder provided with the common language runtime is applicable in all but the most specialized circumstances. If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.","nodes":[{"content":"The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.","pos":[0,121]},{"content":"If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <ph id=\"ph1\">&lt;xref:System.Reflection.Binder&gt;</ph> class and pass an instance of that type using the <ph id=\"ph2\">`binder`</ph> parameter of one of the <ph id=\"ph3\">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> overloads.","pos":[122,408],"source":" If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads."}]},{"pos":[415,769],"content":"Reflection models the accessibility rules of the common type system. For example, if the caller is in the same assembly, the caller does not need special permissions for internal members. Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>. This is consistent with lookup of members that are protected, private, and so on.","nodes":[{"content":"Reflection models the accessibility rules of the common type system. For example, if the caller is in the same assembly, the caller does not need special permissions for internal members. Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>. This is consistent with lookup of members that are protected, private, and so on.","pos":[0,354],"nodes":[{"content":"Reflection models the accessibility rules of the common type system.","pos":[0,68]},{"content":"For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.","pos":[69,187]},{"content":"Otherwise, the caller needs <ph id=\"ph1\">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph>.","pos":[188,272],"source":" Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>."},{"content":"This is consistent with lookup of members that are protected, private, and so on.","pos":[273,354]}]}]},{"pos":[776,1225],"content":"The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data. An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer. This is distinguished from a narrowing conversion, which may lose data. An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.","nodes":[{"content":"The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data. An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer. This is distinguished from a narrowing conversion, which may lose data. An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.","pos":[0,449],"nodes":[{"content":"The general principle is that <ph id=\"ph1\">&lt;xref:System.Reflection.Binder.ChangeType%2A&gt;</ph> should perform only widening conversions, which never lose data.","pos":[0,140],"source":"The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data."},{"content":"An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.","pos":[141,274]},{"content":"This is distinguished from a narrowing conversion, which may lose data.","pos":[275,346]},{"content":"An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.","pos":[347,449]}]}]},{"pos":[1232,1306],"content":"The following table lists the conversions supported by the default binder.","nodes":[{"content":"The following table lists the conversions supported by the default binder.","pos":[0,74]}]},{"pos":[1313,1324],"content":"Source Type","nodes":[{"content":"Source Type","pos":[0,11]}]},{"pos":[1325,1336],"content":"Target Type","nodes":[{"content":"Target Type","pos":[0,11]}]},{"pos":[1381,1389],"content":"Any type","nodes":[{"content":"Any type","pos":[0,8]}]},{"pos":[1390,1404],"content":"Its base type.","nodes":[{"content":"Its base type.","pos":[0,14]}]},{"pos":[1409,1417],"content":"Any type","nodes":[{"content":"Any type","pos":[0,8]}]},{"pos":[1418,1446],"content":"The interface it implements.","nodes":[{"content":"The interface it implements.","pos":[0,28]}]},{"pos":[1451,1455],"content":"Char","nodes":[{"content":"Char","pos":[0,4]}]},{"pos":[1456,1507],"content":"Unt16, UInt32, Int32, UInt64, Int64, Single, Double","nodes":[{"content":"Unt16, UInt32, Int32, UInt64, Int64, Single, Double","pos":[0,51]}]},{"pos":[1512,1516],"content":"Byte","nodes":[{"content":"Byte","pos":[0,4]}]},{"pos":[1517,1581],"content":"Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double","nodes":[{"content":"Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double","pos":[0,64]}]},{"pos":[1586,1591],"content":"SByte","nodes":[{"content":"SByte","pos":[0,5]}]},{"pos":[1592,1627],"content":"Int16, Int32, Int64, Single, Double","nodes":[{"content":"Int16, Int32, Int64, Single, Double","pos":[0,35]}]},{"pos":[1632,1638],"content":"UInt16","nodes":[{"content":"UInt16","pos":[0,6]}]},{"pos":[1639,1683],"content":"UInt32, Int32, UInt64, Int64, Single, Double","nodes":[{"content":"UInt32, Int32, UInt64, Int64, Single, Double","pos":[0,44]}]},{"pos":[1688,1693],"content":"Int16","nodes":[{"content":"Int16","pos":[0,5]}]},{"pos":[1694,1722],"content":"Int32, Int64, Single, Double","nodes":[{"content":"Int32, Int64, Single, Double","pos":[0,28]}]},{"pos":[1727,1733],"content":"UInt32","nodes":[{"content":"UInt32","pos":[0,6]}]},{"pos":[1734,1763],"content":"UInt64, Int64, Single, Double","nodes":[{"content":"UInt64, Int64, Single, Double","pos":[0,29]}]},{"pos":[1768,1773],"content":"Int32","nodes":[{"content":"Int32","pos":[0,5]}]},{"pos":[1774,1795],"content":"Int64, Single, Double","nodes":[{"content":"Int64, Single, Double","pos":[0,21]}]},{"pos":[1800,1806],"content":"UInt64","nodes":[{"content":"UInt64","pos":[0,6]}]},{"pos":[1807,1821],"content":"Single, Double","nodes":[{"content":"Single, Double","pos":[0,14]}]},{"pos":[1826,1831],"content":"Int64","nodes":[{"content":"Int64","pos":[0,5]}]},{"pos":[1832,1846],"content":"Single, Double","nodes":[{"content":"Single, Double","pos":[0,14]}]},{"pos":[1851,1857],"content":"Single","nodes":[{"content":"Single","pos":[0,6]}]},{"pos":[1858,1864],"content":"Double","nodes":[{"content":"Double","pos":[0,6]}]},{"pos":[1869,1882],"content":"Non-reference","nodes":[{"content":"Non-reference","pos":[0,13]}]},{"pos":[1883,1896],"content":"By-reference.","nodes":[{"content":"By-reference.","pos":[0,13]}]}],"pos":[57758,59680],"yaml":true,"extradata":"MT"},{"content":"A reference to the default binder used by the system.","nodes":[{"pos":[0,53],"content":"A reference to the default binder used by the system.","nodes":[{"content":"A reference to the default binder used by the system.","pos":[0,53]}]}],"pos":[60441,60495],"yaml":true},{"content":"Separates names in the namespace of the <xref href=\"System.Type\"></xref>. This field is read-only.","nodes":[{"pos":[0,98],"content":"Separates names in the namespace of the <xref href=\"System.Type\"></xref>. This field is read-only.","nodes":[{"content":"Separates names in the namespace of the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","pos":[0,73],"source":"Separates names in the namespace of the <xref href=\"System.Type\"></xref>."},{"content":"This field is read-only.","pos":[74,98]}]}],"pos":[61566,61665],"yaml":true},{"content":"Represents an empty array of type <xref href=\"System.Type\"></xref>. This field is read-only.","nodes":[{"pos":[0,92],"content":"Represents an empty array of type <xref href=\"System.Type\"></xref>. This field is read-only.","nodes":[{"content":"Represents an empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","pos":[0,67],"source":"Represents an empty array of type <xref href=\"System.Type\"></xref>."},{"content":"This field is read-only.","pos":[68,92]}]}],"pos":[62967,63060],"yaml":true},{"content":"Determines if the underlying system type of the current <xref href=\"System.Type\"></xref> object is the same as the underlying system type of the specified <xref href=\"System.Object\"></xref>.","nodes":[{"pos":[0,190],"content":"Determines if the underlying system type of the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object is the same as the underlying system type of the specified <ph id=\"ph2\">&lt;xref href=\"System.Object\"&gt;&lt;/xref&gt;</ph>.","source":"Determines if the underlying system type of the current <xref href=\"System.Type\"></xref> object is the same as the underlying system type of the specified <xref href=\"System.Object\"></xref>."}],"pos":[65124,65315],"yaml":true},{"content":"This method overrides <xref:System.Object.Equals%2A?displayProperty=fullName>. It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=fullName> method.","nodes":[{"pos":[0,221],"content":"This method overrides <xref:System.Object.Equals%2A?displayProperty=fullName>. It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=fullName> method.","nodes":[{"content":"This method overrides <ph id=\"ph1\">&lt;xref:System.Object.Equals%2A?displayProperty=fullName&gt;</ph>.","pos":[0,78],"source":"This method overrides <xref:System.Object.Equals%2A?displayProperty=fullName>."},{"content":"It casts <ph id=\"ph1\">`o`</ph> to an object of type <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> and calls the <ph id=\"ph3\">&lt;xref:System.Type.Equals%28System.Type%29?displayProperty=fullName&gt;</ph> method.","pos":[79,221],"source":" It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=fullName> method."}]}],"pos":[65326,65548],"yaml":true,"extradata":"MT"},{"content":"The object whose underlying system type is to be compared with the underlying system type of the current <xref href=\"System.Type\"></xref>. For the comparison to succeed, <code>o</code> must be able to be cast or converted to an object of type   <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,278],"content":"The object whose underlying system type is to be compared with the underlying system type of the current <xref href=\"System.Type\"></xref>. For the comparison to succeed, <code>o</code> must be able to be cast or converted to an object of type   <xref href=\"System.Type\"></xref>.","nodes":[{"content":"The object whose underlying system type is to be compared with the underlying system type of the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","pos":[0,138],"source":"The object whose underlying system type is to be compared with the underlying system type of the current <xref href=\"System.Type\"></xref>."},{"content":"For the comparison to succeed, <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">o</ph><ept id=\"p1\">&lt;/code&gt;</ept> must be able to be cast or converted to an object of type   <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","pos":[139,278],"source":" For the comparison to succeed, <code>o</code> must be able to be cast or converted to an object of type   <xref href=\"System.Type\"></xref>."}]}],"pos":[66674,66953],"yaml":true},{"content":"`true` if the underlying system type of <code>o</code> is the same as the underlying system type of the current <xref href=\"System.Type\"></xref>; otherwise, `false`. This method also returns `false` if: .  \n  \n-   <code>o</code> is `null`.  \n  \n-   <code>o</code> cannot be cast or converted to a <xref href=\"System.Type\"></xref> object.","nodes":[{"pos":[0,204],"content":"`true` if the underlying system type of <code>o</code> is the same as the underlying system type of the current <xref href=\"System.Type\"></xref>; otherwise, `false`. This method also returns `false` if: .","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the underlying system type of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">o</ph><ept id=\"p1\">&lt;/code&gt;</ept> is the same as the underlying system type of the current <ph id=\"ph3\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id=\"ph4\">`false`</ph>.","pos":[0,165],"source":"`true` if the underlying system type of <code>o</code> is the same as the underlying system type of the current <xref href=\"System.Type\"></xref>; otherwise, `false`."},{"content":"This method also returns <ph id=\"ph1\">`false`</ph> if: .","pos":[166,204],"source":" This method also returns `false` if: ."}]},{"pos":[210,239],"content":"<ph id=\"ph1\">-   &lt;code&gt;o&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"-   <code>o</code> is `null`."},{"pos":[245,337],"content":"<ph id=\"ph1\">-   &lt;code&gt;o&lt;/code&gt;</ph> cannot be cast or converted to a <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object.","source":"-   <code>o</code> cannot be cast or converted to a <xref href=\"System.Type\"></xref> object."}],"pos":[67011,67359],"yaml":true},{"content":"Determines if the underlying system type of the current <xref href=\"System.Type\"></xref> is the same as the underlying system type of the specified <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,181],"content":"Determines if the underlying system type of the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is the same as the underlying system type of the specified <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Determines if the underlying system type of the current <xref href=\"System.Type\"></xref> is the same as the underlying system type of the specified <xref href=\"System.Type\"></xref>."}],"pos":[68807,68989],"yaml":true},{"content":"The object whose underlying system type is to be compared with the underlying system type of the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,138],"content":"The object whose underlying system type is to be compared with the underlying system type of the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"The object whose underlying system type is to be compared with the underlying system type of the current <xref href=\"System.Type\"></xref>."}],"pos":[69504,69643],"yaml":true},{"content":"`true` if the underlying system type of <code>o</code> is the same as the underlying system type of the current <xref href=\"System.Type\"></xref>; otherwise, `false`.","nodes":[{"pos":[0,165],"content":"<ph id=\"ph1\">`true`</ph> if the underlying system type of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">o</ph><ept id=\"p1\">&lt;/code&gt;</ept> is the same as the underlying system type of the current <ph id=\"ph3\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id=\"ph4\">`false`</ph>.","source":"`true` if the underlying system type of <code>o</code> is the same as the underlying system type of the current <xref href=\"System.Type\"></xref>; otherwise, `false`."}],"pos":[69701,69869],"yaml":true},{"content":"Represents the member filter used on attributes. This field is read-only.","nodes":[{"pos":[0,73],"content":"Represents the member filter used on attributes. This field is read-only.","nodes":[{"content":"Represents the member filter used on attributes. This field is read-only.","pos":[0,73],"nodes":[{"content":"Represents the member filter used on attributes.","pos":[0,48]},{"content":"This field is read-only.","pos":[49,73]}]}]}],"pos":[71313,71387],"yaml":true},{"content":"This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method. The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`. The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`. The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.  \n  \n For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public. In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.","nodes":[{"pos":[0,566],"content":"This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method. The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`. The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`. The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.","nodes":[{"content":"This field holds a reference to the delegate used by the <ph id=\"ph1\">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.","pos":[0,98],"source":"This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method."},{"content":"The method encapsulated by this delegate takes two parameters: the first is a <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id=\"ph2\">`Object`</ph>.","pos":[99,250],"source":" The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`."},{"content":"The method determines whether the <ph id=\"ph1\">`MemberInfo`</ph> object matches the criteria specified by the <ph id=\"ph2\">`Object`</ph>.","pos":[251,352],"source":" The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`."},{"content":"The <ph id=\"ph1\">`Object`</ph> may be assigned the value of any one of the fields on the classes <ph id=\"ph2\">&lt;xref:System.Reflection.FieldAttributes&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Reflection.MethodAttributes&gt;</ph>, or <ph id=\"ph4\">&lt;xref:System.Reflection.MethodImplAttributes&gt;</ph>.","pos":[353,566],"source":" The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>."}]},{"pos":[573,874],"content":"For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public. In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.","nodes":[{"content":"For example, the <ph id=\"ph1\">`Object`</ph> can be assigned the value of a field from <ph id=\"ph2\">`FieldAttributes`</ph> such as Public.","pos":[0,101],"source":"For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public."},{"content":"In that case, when the <ph id=\"ph1\">`FilterAttribute`</ph> delegate is invoked, it will return <ph id=\"ph2\">`true`</ph> only if the method represented by the <ph id=\"ph3\">`MemberInfo`</ph> object is decorated with the public field attribute in metadata.","pos":[102,301],"source":" In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata."}]}],"pos":[71398,72277],"yaml":true,"extradata":"MT"},{"content":"Represents the case-sensitive member filter used on names. This field is read-only.","nodes":[{"pos":[0,83],"content":"Represents the case-sensitive member filter used on names. This field is read-only.","nodes":[{"content":"Represents the case-sensitive member filter used on names. This field is read-only.","pos":[0,83],"nodes":[{"content":"Represents the case-sensitive member filter used on names.","pos":[0,58]},{"content":"This field is read-only.","pos":[59,83]}]}]}],"pos":[74098,74182],"yaml":true},{"content":"This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method. The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`. The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`. The `Object` is assigned a string value, which may include a trailing \"*\" wildcard character. Only wildcard end string matching is supported.  \n  \n For example, the `Object` may be assigned the value \"Byte*\". In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with \"Byte\".","nodes":[{"pos":[0,494],"content":"This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method. The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`. The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`. The `Object` is assigned a string value, which may include a trailing \"*\" wildcard character. Only wildcard end string matching is supported.","nodes":[{"content":"This field holds a reference to the delegate used by the <ph id=\"ph1\">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.","pos":[0,98],"source":"This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method."},{"content":"The method encapsulated by this delegate takes two parameters: the first is a <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id=\"ph2\">`Object`</ph>.","pos":[99,250],"source":" The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`."},{"content":"The method determines whether the <ph id=\"ph1\">`MemberInfo`</ph> object matches the criteria specified by the <ph id=\"ph2\">`Object`</ph>.","pos":[251,352],"source":" The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`."},{"content":"The <ph id=\"ph1\">`Object`</ph> is assigned a string value, which may include a trailing \"*\" wildcard character.","pos":[353,446],"source":" The `Object` is assigned a string value, which may include a trailing \"*\" wildcard character."},{"content":"Only wildcard end string matching is supported.","pos":[447,494]}]},{"pos":[501,734],"content":"For example, the `Object` may be assigned the value \"Byte*\". In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with \"Byte\".","nodes":[{"content":"For example, the <ph id=\"ph1\">`Object`</ph> may be assigned the value \"Byte*\".","pos":[0,60],"source":"For example, the `Object` may be assigned the value \"Byte*\"."},{"content":"In that case, when the <ph id=\"ph1\">`FilterName`</ph> delegate is invoked, it will return <ph id=\"ph2\">`true`</ph> only if the method represented by the <ph id=\"ph3\">`MemberInfo`</ph> object has a name that begins with \"Byte\".","pos":[61,233],"source":" In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with \"Byte\"."}]}],"pos":[74193,74938],"yaml":true,"extradata":"MT"},{"content":"Represents the case-insensitive member filter used on names. This field is read-only.","nodes":[{"pos":[0,85],"content":"Represents the case-insensitive member filter used on names. This field is read-only.","nodes":[{"content":"Represents the case-insensitive member filter used on names. This field is read-only.","pos":[0,85],"nodes":[{"content":"Represents the case-insensitive member filter used on names.","pos":[0,60]},{"content":"This field is read-only.","pos":[61,85]}]}]}],"pos":[76769,76855],"yaml":true},{"content":"This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method. The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`. The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`. The `Object` is assigned a string value, which may include a trailing \"*\" wildcard character. Only wildcard end string matching is supported.  \n  \n For example, the `Object` may be assigned the value \"ByTe*\". In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with \"byte\", ignoring case.","nodes":[{"pos":[0,494],"content":"This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method. The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`. The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`. The `Object` is assigned a string value, which may include a trailing \"*\" wildcard character. Only wildcard end string matching is supported.","nodes":[{"content":"This field holds a reference to the delegate used by the <ph id=\"ph1\">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method.","pos":[0,98],"source":"This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method."},{"content":"The method encapsulated by this delegate takes two parameters: the first is a <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo&gt;</ph> object and the second is an <ph id=\"ph2\">`Object`</ph>.","pos":[99,250],"source":" The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`."},{"content":"The method determines whether the <ph id=\"ph1\">`MemberInfo`</ph> object matches the criteria specified by the <ph id=\"ph2\">`Object`</ph>.","pos":[251,352],"source":" The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`."},{"content":"The <ph id=\"ph1\">`Object`</ph> is assigned a string value, which may include a trailing \"*\" wildcard character.","pos":[353,446],"source":" The `Object` is assigned a string value, which may include a trailing \"*\" wildcard character."},{"content":"Only wildcard end string matching is supported.","pos":[447,494]}]},{"pos":[501,747],"content":"For example, the `Object` may be assigned the value \"ByTe*\". In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with \"byte\", ignoring case.","nodes":[{"content":"For example, the <ph id=\"ph1\">`Object`</ph> may be assigned the value \"ByTe*\".","pos":[0,60],"source":"For example, the `Object` may be assigned the value \"ByTe*\"."},{"content":"In that case, when the <ph id=\"ph1\">`FilterName`</ph> delegate is invoked, it will return true only if the method represented by the <ph id=\"ph2\">`MemberInfo`</ph> object has a name that begins with \"byte\", ignoring case.","pos":[61,246],"source":" In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with \"byte\", ignoring case."}]}],"pos":[76866,77624],"yaml":true,"extradata":"MT"},{"content":"Returns an array of <xref href=\"System.Type\"></xref> objects representing a filtered list of interfaces implemented or inherited by the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,177],"content":"Returns an array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing a filtered list of interfaces implemented or inherited by the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Returns an array of <xref href=\"System.Type\"></xref> objects representing a filtered list of interfaces implemented or inherited by the current <xref href=\"System.Type\"></xref>."}],"pos":[79777,79955],"yaml":true},{"content":"This method can be overridden by a derived class.  \n  \n The <xref:System.Reflection.Module.FilterTypeName?displayProperty=fullName> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=fullName> delegates supplied by the <xref:System.Reflection.Module?displayProperty=fullName> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=fullName> delegate.  \n  \n All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.  \n  \n This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned). No duplicate interfaces are returned.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints. If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.  \n  \n> [!NOTE]\n>  <xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic. For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).","nodes":[{"pos":[0,49],"content":"This method can be overridden by a derived class.","nodes":[{"content":"This method can be overridden by a derived class.","pos":[0,49]}]},{"pos":[56,410],"content":"The <xref:System.Reflection.Module.FilterTypeName?displayProperty=fullName> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=fullName> delegates supplied by the <xref:System.Reflection.Module?displayProperty=fullName> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=fullName> delegate.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.Module.FilterTypeName?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=fullName&gt;</ph> delegates supplied by the <ph id=\"ph3\">&lt;xref:System.Reflection.Module?displayProperty=fullName&gt;</ph> class may also be used, in lieu of the <ph id=\"ph4\">&lt;xref:System.Reflection.TypeFilter?displayProperty=fullName&gt;</ph> delegate.","pos":[0,354],"source":"The <xref:System.Reflection.Module.FilterTypeName?displayProperty=fullName> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=fullName> delegates supplied by the <xref:System.Reflection.Module?displayProperty=fullName> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=fullName> delegate."}]},{"pos":[417,553],"content":"All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.","nodes":[{"content":"All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.","pos":[0,136]}]},{"pos":[560,857],"content":"This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned). No duplicate interfaces are returned.","nodes":[{"content":"This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned). No duplicate interfaces are returned.","pos":[0,297],"nodes":[{"content":"This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).","pos":[0,259]},{"content":"No duplicate interfaces are returned.","pos":[260,297]}]}]},{"pos":[864,1386],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints. If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.","nodes":[{"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints. If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.","pos":[0,522],"nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, <ph id=\"ph2\">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.","pos":[0,313],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints."},{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type argument of a generic type, <ph id=\"ph2\">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> searches all the interfaces implemented by the type, whether or not they match constraints.","pos":[314,522],"source":" If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints."}]}]},{"pos":[1394,1619],"content":"[!NOTE]\n <xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic. For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).","leadings":["","> "],"nodes":[{"content":" <xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic. For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).","pos":[8,223],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Type.FindInterfaces%2A&gt;</ph> can return generic interfaces, even on types that are not generic.","pos":[1,104],"source":" <xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic."},{"content":"For example, a nongeneric type might implement <ph id=\"ph1\">`IEnumerable&lt;int&gt;`</ph> (<ph id=\"ph2\">`IEnumerable(Of Integer)`</ph> in Visual Basic).","pos":[105,215],"source":" For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic)."}]}]}],"pos":[79966,81599],"yaml":true,"extradata":"MT"},{"content":"The delegate that compares the interfaces against <code>filterCriteria</code>.","nodes":[{"pos":[0,78],"content":"The delegate that compares the interfaces against <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">filterCriteria</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The delegate that compares the interfaces against <code>filterCriteria</code>."}],"pos":[82366,82445],"yaml":true},{"content":"The search criteria that determines whether an interface should be included in the returned array.","nodes":[{"pos":[0,98],"content":"The search criteria that determines whether an interface should be included in the returned array.","nodes":[{"content":"The search criteria that determines whether an interface should be included in the returned array.","pos":[0,98]}]}],"pos":[82515,82614],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing a filtered list of the interfaces implemented or inherited by the current <xref href=\"System.Type\"></xref>, or an empty array of type <xref href=\"System.Type\"></xref> if no interfaces matching the filter are implemented or inherited by the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,347],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing a filtered list of the interfaces implemented or inherited by the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, or an empty array of type <ph id=\"ph3\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> if no interfaces matching the filter are implemented or inherited by the current <ph id=\"ph4\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"An array of <xref href=\"System.Type\"></xref> objects representing a filtered list of the interfaces implemented or inherited by the current <xref href=\"System.Type\"></xref>, or an empty array of type <xref href=\"System.Type\"></xref> if no interfaces matching the filter are implemented or inherited by the current <xref href=\"System.Type\"></xref>."}],"pos":[82671,83019],"yaml":true},{"content":"<code>filter</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;filter&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>filter</code> is `null`."}],"pos":[83175,83206],"yaml":true},{"content":"A static initializer is invoked and throws an exception.","nodes":[{"pos":[0,56],"content":"A static initializer is invoked and throws an exception.","nodes":[{"content":"A static initializer is invoked and throws an exception.","pos":[0,56]}]}],"pos":[83338,83395],"yaml":true},{"content":"Returns a filtered array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects of the specified member type.","nodes":[{"pos":[0,115],"content":"Returns a filtered array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MemberInfo\"&gt;&lt;/xref&gt;</ph> objects of the specified member type.","source":"Returns a filtered array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects of the specified member type."}],"pos":[84891,85007],"yaml":true},{"content":"This method can be overridden by a derived class.  \n  \n Members include properties, methods, fields, events, and so on.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Instance` to include instance members in the search.  \n  \n-   Specify `BindingFlags.Static` to include static members in the search.  \n  \n-   Specify `BindingFlags.Public` to include public members in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n Valid values for <xref:System.Type.MemberType%2A> are defined in <xref:System.Reflection.MemberInfo>. If no such members are found, an empty array is returned.  \n  \n To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \n  \n If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.","nodes":[{"pos":[0,49],"content":"This method can be overridden by a derived class.","nodes":[{"content":"This method can be overridden by a derived class.","pos":[0,49]}]},{"pos":[56,119],"content":"Members include properties, methods, fields, events, and so on.","nodes":[{"content":"Members include properties, methods, fields, events, and so on.","pos":[0,63]}]},{"pos":[126,252],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:","pos":[0,126],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:"}]},{"pos":[262,360],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[370,444],"content":"Specify <ph id=\"ph1\">`BindingFlags.Instance`</ph> to include instance members in the search.","source":"Specify `BindingFlags.Instance` to include instance members in the search."},{"pos":[454,524],"content":"Specify <ph id=\"ph1\">`BindingFlags.Static`</ph> to include static members in the search.","source":"Specify `BindingFlags.Static` to include static members in the search."},{"pos":[534,604],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public members in the search.","source":"Specify `BindingFlags.Public` to include public members in the search."},{"pos":[614,743],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search."},{"pos":[750,860],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[870,1000],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited."},{"pos":[1007,1095],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1102,1261],"content":"Valid values for <xref:System.Type.MemberType%2A> are defined in <xref:System.Reflection.MemberInfo>. If no such members are found, an empty array is returned.","nodes":[{"content":"Valid values for <xref:System.Type.MemberType%2A> are defined in <xref:System.Reflection.MemberInfo>. If no such members are found, an empty array is returned.","pos":[0,159],"nodes":[{"content":"Valid values for <ph id=\"ph1\">&lt;xref:System.Type.MemberType%2A&gt;</ph> are defined in <ph id=\"ph2\">&lt;xref:System.Reflection.MemberInfo&gt;</ph>.","pos":[0,101],"source":"Valid values for <xref:System.Type.MemberType%2A> are defined in <xref:System.Reflection.MemberInfo>."},{"content":"If no such members are found, an empty array is returned.","pos":[102,159]}]}]},{"pos":[1268,1719],"content":"To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.","nodes":[{"content":"To get the class initializer (.cctor) using this method, you must specify <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph4\">`Or`</ph><ph id=\"ph5\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).","pos":[0,354],"source":"To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic)."},{"content":"You can also get the class initializer using the <ph id=\"ph1\">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.","pos":[355,451],"source":" You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property."}]},{"pos":[1726,1966],"content":"If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type or generic method, <ph id=\"ph2\">&lt;xref:System.Type.FindMembers%2A&gt;</ph> processes any members declared by the class constraint and the interface constraints of the type parameter.","pos":[0,240],"source":"If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter."}]}],"pos":[85018,87013],"yaml":true,"extradata":"MT"},{"content":"An object that indicates the type of member to search for.","nodes":[{"pos":[0,58],"content":"An object that indicates the type of member to search for.","nodes":[{"content":"An object that indicates the type of member to search for.","pos":[0,58]}]}],"pos":[87864,87923],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[88007,88185],"yaml":true},{"content":"The delegate that does the comparisons, returning `true` if the member currently being inspected matches the <code>filterCriteria</code> and `false` otherwise. You can use the `FilterAttribute`, `FilterName`, and `FilterNameIgnoreCase` delegates supplied by this class. The first uses the fields of `FieldAttributes`, `MethodAttributes`, and `MethodImplAttributes` as search criteria, and the other two delegates use `String` objects as the search criteria.","nodes":[{"pos":[0,457],"content":"The delegate that does the comparisons, returning `true` if the member currently being inspected matches the <code>filterCriteria</code> and `false` otherwise. You can use the `FilterAttribute`, `FilterName`, and `FilterNameIgnoreCase` delegates supplied by this class. The first uses the fields of `FieldAttributes`, `MethodAttributes`, and `MethodImplAttributes` as search criteria, and the other two delegates use `String` objects as the search criteria.","nodes":[{"content":"The delegate that does the comparisons, returning <ph id=\"ph1\">`true`</ph> if the member currently being inspected matches the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">filterCriteria</ph><ept id=\"p1\">&lt;/code&gt;</ept> and <ph id=\"ph3\">`false`</ph> otherwise.","pos":[0,159],"source":"The delegate that does the comparisons, returning `true` if the member currently being inspected matches the <code>filterCriteria</code> and `false` otherwise."},{"content":"You can use the <ph id=\"ph1\">`FilterAttribute`</ph>, <ph id=\"ph2\">`FilterName`</ph>, and <ph id=\"ph3\">`FilterNameIgnoreCase`</ph> delegates supplied by this class.","pos":[160,269],"source":" You can use the `FilterAttribute`, `FilterName`, and `FilterNameIgnoreCase` delegates supplied by this class."},{"content":"The first uses the fields of <ph id=\"ph1\">`FieldAttributes`</ph>, <ph id=\"ph2\">`MethodAttributes`</ph>, and <ph id=\"ph3\">`MethodImplAttributes`</ph> as search criteria, and the other two delegates use <ph id=\"ph4\">`String`</ph> objects as the search criteria.","pos":[270,457],"source":" The first uses the fields of `FieldAttributes`, `MethodAttributes`, and `MethodImplAttributes` as search criteria, and the other two delegates use `String` objects as the search criteria."}]}],"pos":[88264,88722],"yaml":true},{"content":"The search criteria that determines whether a member is returned in the array of `MemberInfo` objects.  \n  \n The fields of `FieldAttributes`, `MethodAttributes`, and `MethodImplAttributes` can be used in conjunction with the `FilterAttribute` delegate supplied by this class.","nodes":[{"pos":[0,102],"content":"The search criteria that determines whether a member is returned in the array of <ph id=\"ph1\">`MemberInfo`</ph> objects.","source":"The search criteria that determines whether a member is returned in the array of `MemberInfo` objects."},{"pos":[109,275],"content":"The fields of <ph id=\"ph1\">`FieldAttributes`</ph>, <ph id=\"ph2\">`MethodAttributes`</ph>, and <ph id=\"ph3\">`MethodImplAttributes`</ph> can be used in conjunction with the <ph id=\"ph4\">`FilterAttribute`</ph> delegate supplied by this class.","source":"The fields of `FieldAttributes`, `MethodAttributes`, and `MethodImplAttributes` can be used in conjunction with the `FilterAttribute` delegate supplied by this class."}],"pos":[88792,89072],"yaml":true},{"content":"A filtered array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects of the specified member type.  \n  \n -or-  \n  \n An empty array of type <xref href=\"System.Reflection.MemberInfo\"></xref>, if the current <xref href=\"System.Type\"></xref> does not have members of type <code>memberType</code> that match the filter criteria.","nodes":[{"pos":[0,107],"content":"A filtered array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MemberInfo\"&gt;&lt;/xref&gt;</ph> objects of the specified member type.","source":"A filtered array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects of the specified member type."},{"pos":[114,118],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[125,332],"content":"An empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MemberInfo\"&gt;&lt;/xref&gt;</ph>, if the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> does not have members of type <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph3\">memberType</ph><ept id=\"p1\">&lt;/code&gt;</ept> that match the filter criteria.","source":"An empty array of type <xref href=\"System.Reflection.MemberInfo\"></xref>, if the current <xref href=\"System.Type\"></xref> does not have members of type <code>memberType</code> that match the filter criteria."}],"pos":[89146,89491],"yaml":true},{"content":"<code>filter</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;filter&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>filter</code> is `null`."}],"pos":[89644,89675],"yaml":true},{"content":"Gets the fully qualified name of the type, including its namespace but not its assembly.","nodes":[{"pos":[0,88],"content":"Gets the fully qualified name of the type, including its namespace but not its assembly.","nodes":[{"content":"Gets the fully qualified name of the type, including its namespace but not its assembly.","pos":[0,88]}]}],"pos":[90687,90776],"yaml":true},{"content":"For example, the fully qualified name of the <xref:System.String> type is `System.String`. Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.  \n  \n If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A>property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name. The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.  \n  \n [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]\n [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  \n  \n This property returns `null` if:  \n  \n-   The current <xref:System.Type> object represents a type parameter of a generic type.  \n  \n     The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.  \n  \n     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]\n     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  \n  \n-   The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter.  \n  \n     The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference. Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type. The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.  \n  \n     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]\n     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  \n  \n-   The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`  \n  \n     In the following example, `Derived<T>` inherits from `Base<T>`. The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.  \n  \n     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]\n     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  \n  \n     To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates.  \n  \n This property is read-only.","nodes":[{"pos":[0,268],"content":"For example, the fully qualified name of the <xref:System.String> type is `System.String`. Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.","nodes":[{"content":"For example, the fully qualified name of the <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> type is <ph id=\"ph2\">`System.String`</ph>.","pos":[0,90],"source":"For example, the fully qualified name of the <xref:System.String> type is `System.String`."},{"content":"Contrast this with the assembly-qualified name returned by the <ph id=\"ph1\">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, which consists of the full name plus the full assembly name.","pos":[91,268],"source":" Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name."}]},{"pos":[275,740],"content":"If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A>property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name. The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.","nodes":[{"content":"If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A>property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name. The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.","pos":[0,465],"nodes":[{"content":"If the current type represents a closed generic type, the type arguments in the string returned by the <ph id=\"ph1\">&lt;xref:System.Type.FullName%2A&gt;</ph>property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.","pos":[0,293],"source":"If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A>property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name."},{"content":"The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.","pos":[294,465]}]}]},{"pos":[747,1008],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Type.FullName#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Type.FullName#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]\n [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]"},{"pos":[1015,1047],"content":"This property returns <ph id=\"ph1\">`null`</ph> if:","source":"This property returns `null` if:"},{"pos":[1057,1141],"content":"The current <xref:System.Type> object represents a type parameter of a generic type.","nodes":[{"content":"The current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object represents a type parameter of a generic type.","pos":[0,84],"source":"The current <xref:System.Type> object represents a type parameter of a generic type."}]},{"pos":[1152,1310],"content":"The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.","nodes":[{"content":"The following example retrieves the type parameter of the <ph id=\"ph1\">&lt;xref:System.Nullable%601&gt;</ph> type and attempts to display its <ph id=\"ph2\">&lt;xref:System.Type.FullName%2A&gt;</ph> property.","pos":[0,158],"source":"The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property."}]},{"pos":[1321,1582],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Type.FullName#3<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Type.FullName#3<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)</ept><ept id=\"p3\">]</ept>","leadings":["","    "],"source":"[!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]\n [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]"},{"pos":[1592,1733],"content":"The current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object represents an array type, a pointer  type, or a <ph id=\"ph2\">`byref`</ph> type that is based on a generic type parameter.","source":"The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter."},{"pos":[1744,2378],"content":"The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference. Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type. The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.","nodes":[{"content":"The following example defines a generic type, <ph id=\"ph1\">`Generictype1&lt;T&gt;`</ph>, with three methods: <ph id=\"ph2\">`Display(T[])`</ph>, which is passed an array of type T; <ph id=\"ph3\">`HandleT(T)`</ph>, which is passed a T object; and <ph id=\"ph4\">`ChangeValue(ref T)`</ph>, which is passed a T object by reference.","pos":[0,245],"source":"The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference."},{"content":"Because C# and Visual Basic do not allow us to define T as a pointer in the <ph id=\"ph1\">`HandleT`</ph> method, we have to call the <ph id=\"ph2\">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> method on the <ph id=\"ph3\">&lt;xref:System.Type&gt;</ph> object that represents the method's parameter type to create a pointer to a generic type.","pos":[246,520],"source":" Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type."},{"content":"The output from the example shows that in all three cases, the <ph id=\"ph1\">&lt;xref:System.Type.FullName%2A&gt;</ph> property is <ph id=\"ph2\">`null`</ph>.","pos":[521,634],"source":" The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`."}]},{"pos":[2389,2650],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Type.FullName#4<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Type.FullName#4<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)</ept><ept id=\"p3\">]</ept>","leadings":["","    "],"source":"[!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]\n [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]"},{"pos":[2660,2974],"content":"The current type contains generic type parameters that have not been replaced by specific types (that is, the <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id=\"ph2\">`true`</ph>), but the type is not a generic type definition (that is, the <ph id=\"ph3\">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property returns <ph id=\"ph4\">`false`</ph>","source":"The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`"},{"pos":[2985,3242],"content":"In the following example, `Derived<T>` inherits from `Base<T>`. The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.","nodes":[{"content":"In the following example, <ph id=\"ph1\">`Derived&lt;T&gt;`</ph> inherits from <ph id=\"ph2\">`Base&lt;T&gt;`</ph>.","pos":[0,63],"source":"In the following example, `Derived<T>` inherits from `Base<T>`."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.BaseType%2A&gt;</ph> property obtains the  <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object that represents the base type of <ph id=\"ph3\">`Derived&lt;T&gt;`</ph>, and its <ph id=\"ph4\">&lt;xref:System.Type.FullName%2A&gt;</ph> property returns <ph id=\"ph5\">`null`</ph>.","pos":[64,257],"source":" The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`."}]},{"pos":[3253,3514],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Type.FullName#5<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Type.FullName#5<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)</ept><ept id=\"p3\">]</ept>","leadings":["","    "],"source":"[!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]\n [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]"},{"pos":[3525,3718],"content":"To get a <ph id=\"ph1\">&lt;xref:System.Type.FullName%2A&gt;</ph> that is not <ph id=\"ph2\">`null`</ph>, you can use the <ph id=\"ph3\">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method to get the generic type definition, as the example illustrates.","source":"To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates."},{"pos":[3725,3752],"content":"This property is read-only.","nodes":[{"content":"This property is read-only.","pos":[0,27]}]}],"pos":[90787,94574],"yaml":true,"extradata":"MT"},{"content":"The fully qualified name of the type, including its namespace but not its assembly; or `null` if the current instance represents a generic type parameter, an array type, pointer type, or `byref` type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.","nodes":[{"pos":[0,323],"content":"The fully qualified name of the type, including its namespace but not its assembly; or <ph id=\"ph1\">`null`</ph> if the current instance represents a generic type parameter, an array type, pointer type, or <ph id=\"ph2\">`byref`</ph> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.","source":"The fully qualified name of the type, including its namespace but not its assembly; or `null` if the current instance represents a generic type parameter, an array type, pointer type, or `byref` type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters."}],"pos":[95593,95917],"yaml":true},{"content":"Gets a combination of <xref href=\"System.Reflection.GenericParameterAttributes\"></xref> flags that describe the covariance and special constraints of the current generic type parameter.","nodes":[{"pos":[0,185],"content":"Gets a combination of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.GenericParameterAttributes\"&gt;&lt;/xref&gt;</ph> flags that describe the covariance and special constraints of the current generic type parameter.","source":"Gets a combination of <xref href=\"System.Reflection.GenericParameterAttributes\"></xref> flags that describe the covariance and special constraints of the current generic type parameter."}],"pos":[97432,97618],"yaml":true},{"content":"The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints. Use the <xref:System.Reflection.GenericParameterAttributes?displayProperty=fullName> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes?displayProperty=fullName> value to select the constraint flags.  \n  \n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"pos":[0,411],"content":"The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints. Use the <xref:System.Reflection.GenericParameterAttributes?displayProperty=fullName> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes?displayProperty=fullName> value to select the constraint flags.","nodes":[{"content":"The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints. Use the <xref:System.Reflection.GenericParameterAttributes?displayProperty=fullName> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes?displayProperty=fullName> value to select the constraint flags.","pos":[0,411],"nodes":[{"content":"The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.","pos":[0,161]},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Reflection.GenericParameterAttributes?displayProperty=fullName&gt;</ph> value to select the covariance flags, and use the <ph id=\"ph2\">&lt;xref:System.Reflection.GenericParameterAttributes?displayProperty=fullName&gt;</ph> value to select the constraint flags.","pos":[162,411],"source":" Use the <xref:System.Reflection.GenericParameterAttributes?displayProperty=fullName> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes?displayProperty=fullName> value to select the constraint flags."}]}]},{"pos":[418,556],"content":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"content":"For a list of the invariant conditions for terms used in generic reflection, see the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.","pos":[0,138],"source":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks."}]}],"pos":[97629,98190],"yaml":true,"extradata":"MT"},{"content":"A bitwise combination of <xref href=\"System.Reflection.GenericParameterAttributes\"></xref> values that describes the covariance and special constraints of the current generic type parameter.","nodes":[{"pos":[0,190],"content":"A bitwise combination of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.GenericParameterAttributes\"&gt;&lt;/xref&gt;</ph> values that describes the covariance and special constraints of the current generic type parameter.","source":"A bitwise combination of <xref href=\"System.Reflection.GenericParameterAttributes\"></xref> values that describes the covariance and special constraints of the current generic type parameter."}],"pos":[99238,99429],"yaml":true},{"content":"The current <xref href=\"System.Type\"></xref> object is not a generic type parameter. That is, the <xref href=\"System.Type.IsGenericParameter\"></xref> property returns `false`.","nodes":[{"pos":[0,175],"content":"The current <xref href=\"System.Type\"></xref> object is not a generic type parameter. That is, the <xref href=\"System.Type.IsGenericParameter\"></xref> property returns `false`.","nodes":[{"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object is not a generic type parameter.","pos":[0,84],"source":"The current <xref href=\"System.Type\"></xref> object is not a generic type parameter."},{"content":"That is, the <ph id=\"ph1\">&lt;xref href=\"System.Type.IsGenericParameter\"&gt;&lt;/xref&gt;</ph> property returns <ph id=\"ph2\">`false`</ph>.","pos":[85,175],"source":" That is, the <xref href=\"System.Type.IsGenericParameter\"></xref> property returns `false`."}]}],"pos":[99605,99781],"yaml":true},{"content":"The invoked method is not supported in the base class.","nodes":[{"pos":[0,54],"content":"The invoked method is not supported in the base class.","nodes":[{"content":"The invoked method is not supported in the base class.","pos":[0,54]}]}],"pos":[99883,99938],"yaml":true},{"content":"Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <xref href=\"System.Type\"></xref> object represents a type parameter of a generic type or a generic method.","nodes":[{"pos":[0,241],"content":"Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object represents a type parameter of a generic type or a generic method.","source":"Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <xref href=\"System.Type\"></xref> object represents a type parameter of a generic type or a generic method."}],"pos":[101046,101288],"yaml":true},{"content":"The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined. The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:  \n  \n-   If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.  \n  \n-   If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.  \n  \n To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to. For example, consider the return value of the generic method `GetSomething` in the following code:  \n  \n [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]\n [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]\n [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  \n  \n The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself. You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type. When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both. The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`. The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.  \n  \n> [!NOTE]\n>  Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter. When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types. The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.","nodes":[{"pos":[0,372],"content":"The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined. The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:","nodes":[{"content":"The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined. The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:","pos":[0,372],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.","pos":[0,231],"source":"The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> properties identify the generic type or method definition:","pos":[232,372],"source":" The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:"}]}]},{"pos":[382,668],"content":"If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.","nodes":[{"content":"If the <ph id=\"ph1\">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns a <ph id=\"ph2\">&lt;xref:System.Reflection.MethodInfo&gt;</ph>, that <ph id=\"ph3\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> represents a generic method definition, and the current <ph id=\"ph4\">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic method definition.","pos":[0,286],"source":"If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition."}]},{"pos":[678,987],"content":"If the <ph id=\"ph1\">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> property returns <ph id=\"ph2\">`null`</ph>, then the <ph id=\"ph3\">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property always returns a <ph id=\"ph4\">&lt;xref:System.Type&gt;</ph> object representing a generic type definition, and the current <ph id=\"ph5\">&lt;xref:System.Type&gt;</ph> object represents a type parameter of that generic type definition.","source":"If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition."},{"pos":[994,1285],"content":"To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to. For example, consider the return value of the generic method `GetSomething` in the following code:","nodes":[{"content":"To provide the correct context for the value of the <ph id=\"ph1\">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property, it is necessary to identify the generic type or method a type parameter belongs to.","pos":[0,192],"source":"To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to."},{"content":"For example, consider the return value of the generic method <ph id=\"ph1\">`GetSomething`</ph> in the following code:","pos":[193,291],"source":" For example, consider the return value of the generic method `GetSomething` in the following code:"}]},{"pos":[1292,1764],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Type.GenericParameterPosition#1<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Type.GenericParameterPosition#1<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Type.GenericParameterPosition#1<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)</ept><ept id=\"p5\">]</ept>","leadings":[""," "," "],"source":"[!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]\n[!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]\n[!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]"},{"pos":[1771,2350],"content":"The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself. You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type. When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both. The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`. The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.","nodes":[{"content":"The type returned by <ph id=\"ph1\">`GetSomething`</ph> depends on the type arguments supplied to class <ph id=\"ph2\">`A`</ph> and to <ph id=\"ph3\">`GetSomething`</ph> itself.","pos":[0,117],"source":"The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself."},{"content":"You can obtain a <ph id=\"ph1\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> for <ph id=\"ph2\">`GetSomething`</ph>, and from that you can obtain the return type.","pos":[118,236],"source":" You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type."},{"content":"When you examine the type parameters of the return type, <ph id=\"ph1\">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> returns 0 for both.","pos":[237,360],"source":" When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both."},{"content":"The position of <ph id=\"ph1\">`V`</ph> is 0 because <ph id=\"ph2\">`V`</ph> is the first type parameter in the type parameter list for class <ph id=\"ph3\">`A`</ph>.","pos":[361,467],"source":" The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`."},{"content":"The position of <ph id=\"ph1\">`X`</ph> is 0 because <ph id=\"ph2\">`X`</ph> is the first type parameter in the type parameter list for <ph id=\"ph3\">`GetSomething`</ph>.","pos":[468,579],"source":" The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`."}]},{"pos":[2358,3063],"content":"[!NOTE]\n Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter. When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types. The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.","leadings":["","> "],"nodes":[{"content":" Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter. When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types. The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.","pos":[8,703],"nodes":[{"content":"Calling the <ph id=\"ph1\">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> property causes an exception if the current <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> does not represent a type parameter.","pos":[1,159],"source":" Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter."},{"content":"When you examine the type arguments of an open constructed type, use the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell which are type parameters and which are types.","pos":[160,337],"source":" When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id=\"ph2\">`true`</ph> for a type parameter; you can then use the <ph id=\"ph3\">&lt;xref:System.Type.GenericParameterPosition%2A&gt;</ph> method to obtain its position and use the <ph id=\"ph4\">&lt;xref:System.Type.DeclaringMethod%2A&gt;</ph> and <ph id=\"ph5\">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> properties to determine the generic method or type definition that defines it.","pos":[338,695],"source":" The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it."}]}]}],"pos":[101299,104380],"yaml":true,"extradata":"MT"},{"content":"The position of a type parameter in the type parameter list of the generic type or method that defines the parameter. Position numbers begin at 0.","nodes":[{"pos":[0,146],"content":"The position of a type parameter in the type parameter list of the generic type or method that defines the parameter. Position numbers begin at 0.","nodes":[{"content":"The position of a type parameter in the type parameter list of the generic type or method that defines the parameter. Position numbers begin at 0.","pos":[0,146],"nodes":[{"content":"The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.","pos":[0,117]},{"content":"Position numbers begin at 0.","pos":[118,146]}]}]}],"pos":[105472,105619],"yaml":true},{"content":"The current type does not represent a type parameter. That is, <xref href=\"System.Type.IsGenericParameter\"></xref> returns `false`.","nodes":[{"pos":[0,131],"content":"The current type does not represent a type parameter. That is, <xref href=\"System.Type.IsGenericParameter\"></xref> returns `false`.","nodes":[{"content":"The current type does not represent a type parameter.","pos":[0,53]},{"content":"That is, <ph id=\"ph1\">&lt;xref href=\"System.Type.IsGenericParameter\"&gt;&lt;/xref&gt;</ph> returns <ph id=\"ph2\">`false`</ph>.","pos":[54,131],"source":" That is, <xref href=\"System.Type.IsGenericParameter\"></xref> returns `false`."}]}],"pos":[105793,105925],"yaml":true},{"content":"Gets an array of the generic type arguments for this type.","nodes":[{"pos":[0,58],"content":"Gets an array of the generic type arguments for this type.","nodes":[{"content":"Gets an array of the generic type arguments for this type.","pos":[0,58]}]}],"pos":[107353,107412],"yaml":true},{"content":"This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type. If the current type is a generic type definition, this property returns an empty array.  \n  \n> [!NOTE]\n>  If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.  \n  \n To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=fullName> property. To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=fullName> extension method.","nodes":[{"pos":[0,236],"content":"This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type. If the current type is a generic type definition, this property returns an empty array.","nodes":[{"content":"This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type. If the current type is a generic type definition, this property returns an empty array.","pos":[0,236],"nodes":[{"content":"This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.","pos":[0,148]},{"content":"If the current type is a generic type definition, this property returns an empty array.","pos":[149,236]}]}]},{"pos":[244,429],"content":"[!NOTE]\n If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.","leadings":["","> "],"nodes":[{"content":"If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.","pos":[9,183]}]},{"pos":[436,833],"content":"To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=fullName> property. To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=fullName> extension method.","nodes":[{"content":"To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=fullName> property. To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=fullName> extension method.","pos":[0,397],"nodes":[{"content":"To get the generic type parameters of a type that represents a generic type definition, use the <ph id=\"ph1\">&lt;xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=fullName&gt;</ph> property.","pos":[0,189],"source":"To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=fullName> property."},{"content":"To get a <ph id=\"ph1\">&lt;xref:System.Reflection.TypeInfo&gt;</ph> object for the current <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object, use the <ph id=\"ph3\">&lt;xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=fullName&gt;</ph> extension method.","pos":[190,397],"source":" To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=fullName> extension method."}]}]}],"pos":[107423,108264],"yaml":true,"extradata":"MT"},{"content":"An array of the generic type arguments for this type.","nodes":[{"pos":[0,53],"content":"An array of the generic type arguments for this type.","nodes":[{"content":"An array of the generic type arguments for this type.","pos":[0,53]}]}],"pos":[108396,108450],"yaml":true},{"content":"Gets the number of dimensions in an array.","nodes":[{"pos":[0,42],"content":"Gets the number of dimensions in an array.","nodes":[{"content":"Gets the number of dimensions in an array.","pos":[0,42]}]}],"pos":[109897,109940],"yaml":true},{"content":"An integer that contains the number of dimensions in the current type.","nodes":[{"pos":[0,70],"content":"An integer that contains the number of dimensions in the current type.","nodes":[{"content":"An integer that contains the number of dimensions in the current type.","pos":[0,70]}]}],"pos":[110552,110623],"yaml":true},{"content":"The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.","nodes":[{"pos":[0,117],"content":"The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.","nodes":[{"content":"The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.","pos":[0,117]}]}],"pos":[110777,110895],"yaml":true},{"content":"The current type is not an array.","nodes":[{"pos":[0,33],"content":"The current type is not an array.","nodes":[{"content":"The current type is not an array.","pos":[0,33]}]}],"pos":[110989,111023],"yaml":true},{"content":"When overridden in a derived class, implements the <xref href=\"System.Type.Attributes\"></xref> property and gets a bitmask indicating the attributes associated with the <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,202],"content":"When overridden in a derived class, implements the <ph id=\"ph1\">&lt;xref href=\"System.Type.Attributes\"&gt;&lt;/xref&gt;</ph> property and gets a bitmask indicating the attributes associated with the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"When overridden in a derived class, implements the <xref href=\"System.Type.Attributes\"></xref> property and gets a bitmask indicating the attributes associated with the <xref href=\"System.Type\"></xref>."}],"pos":[112461,112664],"yaml":true},{"content":"A <xref href=\"System.Reflection.TypeAttributes\"></xref> object representing the attribute set of the <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,134],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Reflection.TypeAttributes\"&gt;&lt;/xref&gt;</ph> object representing the attribute set of the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"A <xref href=\"System.Reflection.TypeAttributes\"></xref> object representing the attribute set of the <xref href=\"System.Type\"></xref>."}],"pos":[112860,112995],"yaml":true},{"content":"Searches for a public instance constructor whose parameters match the types in the specified array.","nodes":[{"pos":[0,99],"content":"Searches for a public instance constructor whose parameters match the types in the specified array.","nodes":[{"content":"Searches for a public instance constructor whose parameters match the types in the specified array.","pos":[0,99]}]}],"pos":[114174,114274],"yaml":true},{"content":"This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor). To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \n  \n If the requested constructor is non-public, this method returns `null`.  \n  \n> [!NOTE]\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments. If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.","nodes":[{"pos":[0,602],"content":"This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor). To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.","nodes":[{"content":"This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).","pos":[0,118]},{"content":"To get a class initializer, use an overload that takes <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id=\"ph4\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph5\">`Or`</ph><ph id=\"ph6\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).","pos":[119,505],"source":" To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic)."},{"content":"You can also get the class initializer using the <ph id=\"ph1\">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.","pos":[506,602],"source":" You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property."}]},{"pos":[609,680],"content":"If the requested constructor is non-public, this method returns <ph id=\"ph1\">`null`</ph>.","source":"If the requested constructor is non-public, this method returns `null`."},{"pos":[688,811],"content":"[!NOTE]\n You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","leadings":["","> "],"nodes":[{"content":" You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","pos":[8,121],"nodes":[{"content":"You cannot omit parameters when looking up constructors and methods.","pos":[1,69]},{"content":"You can only omit parameters when invoking.","pos":[70,113]}]}]},{"pos":[818,1176],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments. If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,206],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments."},{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id=\"ph2\">`null`</ph>.","pos":[207,358],"source":" If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`."}]}],"pos":[114285,115471],"yaml":true,"extradata":"MT"},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the desired constructor.  \n  \n -or-  \n  \n An empty array of <xref href=\"System.Type\"></xref> objects, to get a constructor that takes no parameters. Such an empty array is provided by the `static` field <xref href=\"System.Type.EmptyTypes\"></xref>.","nodes":[{"pos":[0,140],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the desired constructor.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the desired constructor."},{"pos":[147,151],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[158,363],"content":"An empty array of <xref href=\"System.Type\"></xref> objects, to get a constructor that takes no parameters. Such an empty array is provided by the `static` field <xref href=\"System.Type.EmptyTypes\"></xref>.","nodes":[{"content":"An empty array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects, to get a constructor that takes no parameters.","pos":[0,106],"source":"An empty array of <xref href=\"System.Type\"></xref> objects, to get a constructor that takes no parameters."},{"content":"Such an empty array is provided by the <ph id=\"ph1\">`static`</ph> field <ph id=\"ph2\">&lt;xref href=\"System.Type.EmptyTypes\"&gt;&lt;/xref&gt;</ph>.","pos":[107,205],"source":" Such an empty array is provided by the `static` field <xref href=\"System.Type.EmptyTypes\"></xref>."}]}],"pos":[116273,116649],"yaml":true},{"content":"An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, `null`.","nodes":[{"pos":[0,145],"content":"An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, `null`."}],"pos":[116726,116872],"yaml":true},{"content":"<code>types</code> is `null`.  \n  \n -or-  \n  \n One of the elements in <code>types</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>types</code> is `null`."},{"pos":[36,40],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[47,99],"content":"One of the elements in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"One of the elements in <code>types</code> is `null`."}],"pos":[117028,117134],"yaml":true},{"content":"<code>types</code> is multidimensional.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.","source":"<code>types</code> is multidimensional."}],"pos":[117228,117268],"yaml":true},{"content":"Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.","nodes":[{"pos":[0,134],"content":"Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.","nodes":[{"content":"Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.","pos":[0,134]}]}],"pos":[118869,119004],"yaml":true},{"content":"If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match. If the `binder` is unable to select a match, then `null` is returned.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public constructors in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \n  \n> [!NOTE]\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments. If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.","nodes":[{"pos":[0,218],"content":"If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match. If the `binder` is unable to select a match, then `null` is returned.","nodes":[{"content":"If an exact match does not exist, the <ph id=\"ph1\">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id=\"ph2\">`types`</ph> array in order to select a match.","pos":[0,148],"source":"If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match."},{"content":"If the <ph id=\"ph1\">`binder`</ph> is unable to select a match, then <ph id=\"ph2\">`null`</ph> is returned.","pos":[149,218],"source":" If the `binder` is unable to select a match, then `null` is returned."}]},{"pos":[225,356],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:","pos":[0,131],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:"}]},{"pos":[366,464],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[474,549],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public constructors in the search.","source":"Specify `BindingFlags.Public` to include public constructors in the search."},{"pos":[559,698],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search."},{"pos":[705,793],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[800,1260],"content":"To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.","nodes":[{"content":"To get the class initializer (.cctor) using this method overload, you must specify <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph4\">`Or`</ph><ph id=\"ph5\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).","pos":[0,363],"source":"To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic)."},{"content":"You can also get the class initializer using the <ph id=\"ph1\">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.","pos":[364,460],"source":" You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property."}]},{"pos":[1268,1391],"content":"[!NOTE]\n You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","leadings":["","> "],"nodes":[{"content":" You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","pos":[8,121],"nodes":[{"content":"You cannot omit parameters when looking up constructors and methods.","pos":[1,69]},{"content":"You can only omit parameters when invoking.","pos":[70,113]}]}]},{"pos":[1398,1756],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments. If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,206],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments."},{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id=\"ph2\">`null`</ph>.","pos":[207,358],"source":" If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`."}]}],"pos":[119015,120791],"yaml":true,"extradata":"MT"},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[121802,121980],"yaml":true},{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \n  \n -or-  \n  \n A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>.","nodes":[{"pos":[0,191],"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","nodes":[{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","pos":[0,191]}]},{"pos":[198,202],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[209,313],"content":"A null reference (<ph id=\"ph1\">`Nothing`</ph> in Visual Basic), to use the <ph id=\"ph2\">&lt;xref href=\"System.Type.DefaultBinder\"&gt;&lt;/xref&gt;</ph>.","source":"A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>."}],"pos":[122053,122375],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the constructor to get.  \n  \n -or-  \n  \n An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.  \n  \n -or-  \n  \n <xref href=\"System.Type.EmptyTypes\"></xref>.","nodes":[{"pos":[0,139],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the constructor to get."},{"pos":[146,150],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[157,301],"content":"An empty array of the type <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.","source":"An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters."},{"pos":[308,312],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[319,363],"content":"<ph id=\"ph1\">&lt;xref href=\"System.Type.EmptyTypes\"&gt;&lt;/xref&gt;</ph>.","source":"<xref href=\"System.Type.EmptyTypes\"></xref>."}],"pos":[122436,122816],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the parameter type array. The default binder does not process this parameter.","nodes":[{"pos":[0,227],"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the parameter type array. The default binder does not process this parameter.","nodes":[{"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ParameterModifier\"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the parameter type array.","pos":[0,175],"source":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the parameter type array."},{"content":"The default binder does not process this parameter.","pos":[176,227]}]}],"pos":[122905,123133],"yaml":true},{"content":"A <xref href=\"System.Reflection.ConstructorInfo\"></xref> object representing the constructor that matches the specified requirements, if found; otherwise, `null`.","nodes":[{"pos":[0,162],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ConstructorInfo\"&gt;&lt;/xref&gt;</ph> object representing the constructor that matches the specified requirements, if found; otherwise, <ph id=\"ph2\">`null`</ph>.","source":"A <xref href=\"System.Reflection.ConstructorInfo\"></xref> object representing the constructor that matches the specified requirements, if found; otherwise, `null`."}],"pos":[123210,123373],"yaml":true},{"content":"<code>types</code> is `null`.  \n  \n -or-  \n  \n One of the elements in <code>types</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>types</code> is `null`."},{"pos":[36,40],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[47,99],"content":"One of the elements in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"One of the elements in <code>types</code> is `null`."}],"pos":[123529,123635],"yaml":true},{"content":"<code>types</code> is multidimensional.  \n  \n -or-  \n  \n <code>modifiers</code> is multidimensional.  \n  \n -or-  \n  \n <code>types</code> and <code>modifiers</code> do not have the same length.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.","source":"<code>types</code> is multidimensional."},{"pos":[46,50],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[57,100],"content":"<ph id=\"ph1\">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.","source":"<code>modifiers</code> is multidimensional."},{"pos":[107,111],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[118,192],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.","source":"<code>types</code> and <code>modifiers</code> do not have the same length."}],"pos":[123729,123932],"yaml":true},{"content":"Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.","nodes":[{"pos":[0,171],"content":"Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.","nodes":[{"content":"Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.","pos":[0,171]}]}],"pos":[125704,125876],"yaml":true},{"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \n  \n If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match. If the `binder` is unable to select a match, then `null` is returned.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public constructors in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n> [!NOTE]\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments. If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.","nodes":[{"pos":[0,389],"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.","nodes":[{"content":"Although the default binder does not process <ph id=\"ph1\">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id=\"ph2\">`modifiers`</ph> parameter), you can use the abstract <ph id=\"ph3\">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id=\"ph4\">`modifiers`</ph>.","pos":[0,260],"source":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`."},{"content":"<ph id=\"ph1\">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.","pos":[261,389],"source":"`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled."}]},{"pos":[396,614],"content":"If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match. If the `binder` is unable to select a match, then `null` is returned.","nodes":[{"content":"If an exact match does not exist, the <ph id=\"ph1\">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id=\"ph2\">`types`</ph> array in order to select a match.","pos":[0,148],"source":"If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match."},{"content":"If the <ph id=\"ph1\">`binder`</ph> is unable to select a match, then <ph id=\"ph2\">`null`</ph> is returned.","pos":[149,218],"source":" If the `binder` is unable to select a match, then `null` is returned."}]},{"pos":[621,752],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:","pos":[0,131],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:"}]},{"pos":[762,860],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[870,945],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public constructors in the search.","source":"Specify `BindingFlags.Public` to include public constructors in the search."},{"pos":[955,1094],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search."},{"pos":[1101,1189],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1196,1647],"content":"To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.","nodes":[{"content":"To get the class initializer (.cctor) using this method, you must specify <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph4\">`Or`</ph><ph id=\"ph5\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).","pos":[0,354],"source":"To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic)."},{"content":"You can also get the class initializer using the <ph id=\"ph1\">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.","pos":[355,451],"source":" You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property."}]},{"pos":[1654,1769],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[1776,1787],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[1788,1794],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[1795,1805],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[1863,1874],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[1875,1877],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1878,1880],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1885,1890],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[1891,1893],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1894,1944],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[1949,1954],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[1955,1969],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1970,2163],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[2168,2174],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[2175,2177],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2178,2273],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[2278,2289],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[2290,2292],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2293,2295],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2300,2308],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[2309,2323],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[2324,2517],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[2528,2733],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[2743,3059],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[3069,3126],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[3134,3257],"content":"[!NOTE]\n You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","leadings":["","> "],"nodes":[{"content":" You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","pos":[8,121],"nodes":[{"content":"You cannot omit parameters when looking up constructors and methods.","pos":[1,69]},{"content":"You can only omit parameters when invoking.","pos":[70,113]}]}]},{"pos":[3264,3622],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments. If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,206],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments."},{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method always returns <ph id=\"ph2\">`null`</ph>.","pos":[207,358],"source":" If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`."}]}],"pos":[125887,129548],"yaml":true,"extradata":"MT"},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[130603,130781],"yaml":true},{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \n  \n -or-  \n  \n A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>.","nodes":[{"pos":[0,191],"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","nodes":[{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","pos":[0,191]}]},{"pos":[198,202],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[209,313],"content":"A null reference (<ph id=\"ph1\">`Nothing`</ph> in Visual Basic), to use the <ph id=\"ph2\">&lt;xref href=\"System.Type.DefaultBinder\"&gt;&lt;/xref&gt;</ph>.","source":"A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>."}],"pos":[130854,131176],"yaml":true},{"content":"The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.","nodes":[{"pos":[0,194],"content":"The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.","nodes":[{"content":"The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.","pos":[0,194]}]}],"pos":[131269,131464],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the constructor to get.  \n  \n -or-  \n  \n An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.","nodes":[{"pos":[0,139],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the constructor to get."},{"pos":[146,150],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[157,301],"content":"An empty array of the type <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.","source":"An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters."}],"pos":[131525,131837],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.","nodes":[{"pos":[0,231],"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.","nodes":[{"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ParameterModifier\"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> array.","pos":[0,179],"source":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array."},{"content":"The default binder does not process this parameter.","pos":[180,231]}]}],"pos":[131926,132158],"yaml":true},{"content":"An object representing the constructor that matches the specified requirements, if found; otherwise, `null`.","nodes":[{"pos":[0,108],"content":"An object representing the constructor that matches the specified requirements, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the constructor that matches the specified requirements, if found; otherwise, `null`."}],"pos":[132235,132344],"yaml":true},{"content":"<code>types</code> is `null`.  \n  \n -or-  \n  \n One of the elements in <code>types</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>types</code> is `null`."},{"pos":[36,40],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[47,99],"content":"One of the elements in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"One of the elements in <code>types</code> is `null`."}],"pos":[132500,132606],"yaml":true},{"content":"<code>types</code> is multidimensional.  \n  \n -or-  \n  \n <code>modifiers</code> is multidimensional.  \n  \n -or-  \n  \n <code>types</code> and <code>modifiers</code> do not have the same length.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.","source":"<code>types</code> is multidimensional."},{"pos":[46,50],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[57,100],"content":"<ph id=\"ph1\">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.","source":"<code>modifiers</code> is multidimensional."},{"pos":[107,111],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[118,192],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.","source":"<code>types</code> and <code>modifiers</code> do not have the same length."}],"pos":[132700,132903],"yaml":true},{"content":"When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.","nodes":[{"pos":[0,207],"content":"When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.","nodes":[{"content":"When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.","pos":[0,207]}]}],"pos":[134699,134907],"yaml":true},{"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \n  \n If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match. If the `binder` is unable to select a match, then `null` is returned.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public constructors in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n This method implements <xref:System.Type.GetConstructor%2A>.","nodes":[{"pos":[0,389],"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.","nodes":[{"content":"Although the default binder does not process <ph id=\"ph1\">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id=\"ph2\">`modifiers`</ph> parameter), you can use the abstract <ph id=\"ph3\">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id=\"ph4\">`modifiers`</ph>.","pos":[0,260],"source":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`."},{"content":"<ph id=\"ph1\">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.","pos":[261,389],"source":"`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled."}]},{"pos":[396,614],"content":"If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match. If the `binder` is unable to select a match, then `null` is returned.","nodes":[{"content":"If an exact match does not exist, the <ph id=\"ph1\">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id=\"ph2\">`types`</ph> array in order to select a match.","pos":[0,148],"source":"If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match."},{"content":"If the <ph id=\"ph1\">`binder`</ph> is unable to select a match, then <ph id=\"ph2\">`null`</ph> is returned.","pos":[149,218],"source":" If the `binder` is unable to select a match, then `null` is returned."}]},{"pos":[621,752],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:","pos":[0,131],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:"}]},{"pos":[762,860],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[870,945],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public constructors in the search.","source":"Specify `BindingFlags.Public` to include public constructors in the search."},{"pos":[955,1094],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search."},{"pos":[1101,1189],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1196,1256],"content":"This method implements <xref:System.Type.GetConstructor%2A>.","nodes":[{"content":"This method implements <ph id=\"ph1\">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>.","pos":[0,60],"source":"This method implements <xref:System.Type.GetConstructor%2A>."}]}],"pos":[134918,136191],"yaml":true,"extradata":"MT"},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[136581,136759],"yaml":true},{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \n  \n -or-  \n  \n A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>.","nodes":[{"pos":[0,191],"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","nodes":[{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","pos":[0,191]}]},{"pos":[198,202],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[209,313],"content":"A null reference (<ph id=\"ph1\">`Nothing`</ph> in Visual Basic), to use the <ph id=\"ph2\">&lt;xref href=\"System.Type.DefaultBinder\"&gt;&lt;/xref&gt;</ph>.","source":"A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>."}],"pos":[136832,137154],"yaml":true},{"content":"The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.","nodes":[{"pos":[0,194],"content":"The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.","nodes":[{"content":"The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.","pos":[0,194]}]}],"pos":[137247,137442],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the constructor to get.  \n  \n -or-  \n  \n An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.","nodes":[{"pos":[0,139],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the constructor to get.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the constructor to get."},{"pos":[146,150],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[157,301],"content":"An empty array of the type <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.","source":"An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters."}],"pos":[137503,137815],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.","nodes":[{"pos":[0,231],"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.","nodes":[{"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ParameterModifier\"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> array.","pos":[0,179],"source":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array."},{"content":"The default binder does not process this parameter.","pos":[180,231]}]}],"pos":[137904,138136],"yaml":true},{"content":"A <xref href=\"System.Reflection.ConstructorInfo\"></xref> object representing the constructor that matches the specified requirements, if found; otherwise, `null`.","nodes":[{"pos":[0,162],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ConstructorInfo\"&gt;&lt;/xref&gt;</ph> object representing the constructor that matches the specified requirements, if found; otherwise, <ph id=\"ph2\">`null`</ph>.","source":"A <xref href=\"System.Reflection.ConstructorInfo\"></xref> object representing the constructor that matches the specified requirements, if found; otherwise, `null`."}],"pos":[138213,138376],"yaml":true},{"content":"<code>types</code> is `null`.  \n  \n -or-  \n  \n One of the elements in <code>types</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>types</code> is `null`."},{"pos":[36,40],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[47,99],"content":"One of the elements in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"One of the elements in <code>types</code> is `null`."}],"pos":[138536,138642],"yaml":true},{"content":"<code>types</code> is multidimensional.  \n  \n -or-  \n  \n <code>modifiers</code> is multidimensional.  \n  \n -or-  \n  \n <code>types</code> and <code>modifiers</code> do not have the same length.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.","source":"<code>types</code> is multidimensional."},{"pos":[46,50],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[57,100],"content":"<ph id=\"ph1\">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.","source":"<code>modifiers</code> is multidimensional."},{"pos":[107,111],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[118,192],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.","source":"<code>types</code> and <code>modifiers</code> do not have the same length."}],"pos":[138736,138939],"yaml":true},{"content":"The current type is a <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref> or <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\"></xref>.","nodes":[{"pos":[0,153],"content":"The current type is a <ph id=\"ph1\">&lt;xref href=\"System.Reflection.Emit.TypeBuilder\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\"&gt;&lt;/xref&gt;</ph>.","source":"The current type is a <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref> or <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\"></xref>."}],"pos":[139041,139195],"yaml":true},{"content":"Returns all the public constructors defined for the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,93],"content":"Returns all the public constructors defined for the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Returns all the public constructors defined for the current <xref href=\"System.Type\"></xref>."}],"pos":[140253,140347],"yaml":true},{"content":"The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order. Your code must not depend on the order in which constructors are returned, because that order varies.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). It will not find class initializers (.cctor). To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments. For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).  \n  \n If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.","nodes":[{"pos":[0,229],"content":"The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order. Your code must not depend on the order in which constructors are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order. Your code must not depend on the order in which constructors are returned, because that order varies.","pos":[0,229],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method does not return constructors in a particular order, such as declaration order.","pos":[0,127],"source":"The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order."},{"content":"Your code must not depend on the order in which constructors are returned, because that order varies.","pos":[128,229]}]}]},{"pos":[236,351],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[358,369],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[370,376],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[377,387],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[445,456],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[457,459],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[460,462],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[467,472],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[473,475],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[476,526],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[531,536],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[537,551],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[552,745],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[750,756],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[757,759],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[760,855],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[860,871],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[872,874],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[875,877],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[882,890],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[891,905],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[906,1099],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1110,1315],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[1325,1641],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[1651,1708],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[1715,2649],"content":"This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). It will not find class initializers (.cctor). To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.","nodes":[{"content":"This method overload calls the <ph id=\"ph1\">&lt;xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29&gt;</ph> method overload, with <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id=\"ph4\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph5\">`Or`</ph><ph id=\"ph6\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).","pos":[0,404],"source":"This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic)."},{"content":"It will not find class initializers (.cctor).","pos":[405,450]},{"content":"To find class initializers, use an overload that takes <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id=\"ph4\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph5\">`Or`</ph><ph id=\"ph6\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).","pos":[451,837],"source":" To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic)."},{"content":"You can also get the class initializer using the <ph id=\"ph1\">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.","pos":[838,934],"source":" You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property."}]},{"pos":[2656,3164],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments. For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.","pos":[0,214],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments."},{"content":"For example, if class <ph id=\"ph1\">`C&lt;T&gt;`</ph> has a constructor <ph id=\"ph2\">`C(T t1)`</ph> (<ph id=\"ph3\">`Sub New(ByVal t1 As T)`</ph> in Visual Basic), calling <ph id=\"ph4\">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> on <ph id=\"ph5\">`C&lt;int&gt;`</ph> returns a <ph id=\"ph6\">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents <ph id=\"ph7\">`C(int t1)`</ph> in C# (<ph id=\"ph8\">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).","pos":[215,508],"source":" For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic)."}]},{"pos":[3171,3314],"content":"If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a generic type parameter, the <ph id=\"ph2\">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method returns an empty array.","pos":[0,143],"source":"If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array."}]}],"pos":[140358,143698],"yaml":true,"extradata":"MT"},{"content":"An array of <xref href=\"System.Reflection.ConstructorInfo\"></xref> objects representing all the public instance constructors defined for the current <xref href=\"System.Type\"></xref>, but not including the type initializer (static constructor). If no public instance constructors are defined for the current <xref href=\"System.Type\"></xref>, or if the current <xref href=\"System.Type\"></xref> represents a type parameter in the definition of a generic type or generic method, an empty array of type <xref href=\"System.Reflection.ConstructorInfo\"></xref> is returned.","nodes":[{"pos":[0,565],"content":"An array of <xref href=\"System.Reflection.ConstructorInfo\"></xref> objects representing all the public instance constructors defined for the current <xref href=\"System.Type\"></xref>, but not including the type initializer (static constructor). If no public instance constructors are defined for the current <xref href=\"System.Type\"></xref>, or if the current <xref href=\"System.Type\"></xref> represents a type parameter in the definition of a generic type or generic method, an empty array of type <xref href=\"System.Reflection.ConstructorInfo\"></xref> is returned.","nodes":[{"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ConstructorInfo\"&gt;&lt;/xref&gt;</ph> objects representing all the public instance constructors defined for the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, but not including the type initializer (static constructor).","pos":[0,243],"source":"An array of <xref href=\"System.Reflection.ConstructorInfo\"></xref> objects representing all the public instance constructors defined for the current <xref href=\"System.Type\"></xref>, but not including the type initializer (static constructor)."},{"content":"If no public instance constructors are defined for the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, or if the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> represents a type parameter in the definition of a generic type or generic method, an empty array of type <ph id=\"ph3\">&lt;xref href=\"System.Reflection.ConstructorInfo\"&gt;&lt;/xref&gt;</ph> is returned.","pos":[244,565],"source":" If no public instance constructors are defined for the current <xref href=\"System.Type\"></xref>, or if the current <xref href=\"System.Type\"></xref> represents a type parameter in the definition of a generic type or generic method, an empty array of type <xref href=\"System.Reflection.ConstructorInfo\"></xref> is returned."}]}],"pos":[146014,146580],"yaml":true},{"content":"When overridden in a derived class, searches for the constructors defined for the current <xref href=\"System.Type\"></xref>, using the specified `BindingFlags`.","nodes":[{"pos":[0,159],"content":"When overridden in a derived class, searches for the constructors defined for the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, using the specified <ph id=\"ph2\">`BindingFlags`</ph>.","source":"When overridden in a derived class, searches for the constructors defined for the current <xref href=\"System.Type\"></xref>, using the specified `BindingFlags`."}],"pos":[147903,148063],"yaml":true},{"content":"The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order. Your code must not depend on the order in which constructors are returned, because that order varies.  \n  \n `bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors.  \n  \n If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match. If the `binder` is unable to select a match, then `null` is returned.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public constructors in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search. Constructors of base classes are not returned.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments. For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).  \n  \n If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.","nodes":[{"pos":[0,229],"content":"The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order. Your code must not depend on the order in which constructors are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order. Your code must not depend on the order in which constructors are returned, because that order varies.","pos":[0,229],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method does not return constructors in a particular order, such as declaration order.","pos":[0,127],"source":"The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order."},{"content":"Your code must not depend on the order in which constructors are returned, because that order varies.","pos":[128,229]}]}]},{"pos":[236,359],"content":"<ph id=\"ph1\">`bindingAttr`</ph> can be used to specify whether to return only public constructors or both public and non-public constructors.","source":"`bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors."},{"pos":[366,584],"content":"If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match. If the `binder` is unable to select a match, then `null` is returned.","nodes":[{"content":"If an exact match does not exist, the <ph id=\"ph1\">`binder`</ph> will attempt to coerce the parameter types specified in the <ph id=\"ph2\">`types`</ph> array in order to select a match.","pos":[0,148],"source":"If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match."},{"content":"If the <ph id=\"ph1\">`binder`</ph> is unable to select a match, then <ph id=\"ph2\">`null`</ph> is returned.","pos":[149,218],"source":" If the `binder` is unable to select a match, then `null` is returned."}]},{"pos":[591,722],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which constructors to include in the search:","pos":[0,131],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:"}]},{"pos":[732,830],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[840,915],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public constructors in the search.","source":"Specify `BindingFlags.Public` to include public constructors in the search."},{"pos":[925,1111],"content":"Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search. Constructors of base classes are not returned.","nodes":[{"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public constructors (that is, private, internal, and protected constructors) in the search.","pos":[0,139],"source":"Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search."},{"content":"Constructors of base classes are not returned.","pos":[140,186]}]},{"pos":[1118,1206],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1213,1673],"content":"To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.","nodes":[{"content":"To get the class initializer (.cctor) using this method overload, you must specify <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph4\">`Or`</ph><ph id=\"ph5\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).","pos":[0,363],"source":"To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic)."},{"content":"You can also get the class initializer using the <ph id=\"ph1\">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.","pos":[364,460],"source":" You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property."}]},{"pos":[1680,2188],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments. For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.","pos":[0,214],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments."},{"content":"For example, if class <ph id=\"ph1\">`C&lt;T&gt;`</ph> has a constructor <ph id=\"ph2\">`C(T t1)`</ph> (<ph id=\"ph3\">`Sub New(ByVal t1 As T)`</ph> in Visual Basic), calling <ph id=\"ph4\">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> on <ph id=\"ph5\">`C&lt;int&gt;`</ph> returns a <ph id=\"ph6\">&lt;xref:System.Reflection.ConstructorInfo&gt;</ph> that represents <ph id=\"ph7\">`C(int t1)`</ph> in C# (<ph id=\"ph8\">`Sub New(ByVal t1 As Integer)`</ph> in Visual Basic).","pos":[215,508],"source":" For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic)."}]},{"pos":[2195,2338],"content":"If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a generic type parameter, the <ph id=\"ph2\">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> method returns an empty array.","pos":[0,143],"source":"If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array."}]}],"pos":[148074,150435],"yaml":true,"extradata":"MT"},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[152738,152916],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.ConstructorInfo\"></xref> objects representing all constructors defined for the current <xref href=\"System.Type\"></xref> that match the specified binding constraints, including the type initializer if it is defined. Returns an empty array of type <xref href=\"System.Reflection.ConstructorInfo\"></xref> if no constructors are defined for the current <xref href=\"System.Type\"></xref>, if none of the defined constructors match the binding constraints, or if the current <xref href=\"System.Type\"></xref> represents a type parameter in the definition of a generic type or generic method.","nodes":[{"pos":[0,624],"content":"An array of <xref href=\"System.Reflection.ConstructorInfo\"></xref> objects representing all constructors defined for the current <xref href=\"System.Type\"></xref> that match the specified binding constraints, including the type initializer if it is defined. Returns an empty array of type <xref href=\"System.Reflection.ConstructorInfo\"></xref> if no constructors are defined for the current <xref href=\"System.Type\"></xref>, if none of the defined constructors match the binding constraints, or if the current <xref href=\"System.Type\"></xref> represents a type parameter in the definition of a generic type or generic method.","nodes":[{"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ConstructorInfo\"&gt;&lt;/xref&gt;</ph> objects representing all constructors defined for the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints, including the type initializer if it is defined.","pos":[0,256],"source":"An array of <xref href=\"System.Reflection.ConstructorInfo\"></xref> objects representing all constructors defined for the current <xref href=\"System.Type\"></xref> that match the specified binding constraints, including the type initializer if it is defined."},{"content":"Returns an empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ConstructorInfo\"&gt;&lt;/xref&gt;</ph> if no constructors are defined for the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, if none of the defined constructors match the binding constraints, or if the current <ph id=\"ph3\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> represents a type parameter in the definition of a generic type or generic method.","pos":[257,624],"source":" Returns an empty array of type <xref href=\"System.Reflection.ConstructorInfo\"></xref> if no constructors are defined for the current <xref href=\"System.Type\"></xref>, if none of the defined constructors match the binding constraints, or if the current <xref href=\"System.Type\"></xref> represents a type parameter in the definition of a generic type or generic method."}]}],"pos":[152995,153620],"yaml":true},{"content":"Searches for the members defined for the current <xref href=\"System.Type\"></xref> whose <xref href=\"System.Reflection.DefaultMemberAttribute\"></xref> is set.","nodes":[{"pos":[0,157],"content":"Searches for the members defined for the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> whose <ph id=\"ph2\">&lt;xref href=\"System.Reflection.DefaultMemberAttribute\"&gt;&lt;/xref&gt;</ph> is set.","source":"Searches for the members defined for the current <xref href=\"System.Type\"></xref> whose <xref href=\"System.Reflection.DefaultMemberAttribute\"></xref> is set."}],"pos":[154823,154981],"yaml":true},{"content":"The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  \n  \n This method can be overridden by a derived class.  \n  \n Members include properties, methods, fields, events, and so on.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments. For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.","nodes":[{"pos":[0,237],"content":"The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.","pos":[0,237],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.","pos":[0,140],"source":"The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which members are returned, because that order varies.","pos":[141,237]}]}]},{"pos":[244,293],"content":"This method can be overridden by a derived class.","nodes":[{"content":"This method can be overridden by a derived class.","pos":[0,49]}]},{"pos":[300,363],"content":"Members include properties, methods, fields, events, and so on.","nodes":[{"content":"Members include properties, methods, fields, events, and so on.","pos":[0,63]}]},{"pos":[370,485],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[492,503],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[504,510],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[511,521],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[579,590],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[591,593],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[594,596],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[601,606],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[607,609],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[610,660],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[665,670],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[671,685],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[686,879],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[884,890],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[891,893],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[894,989],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[994,1005],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[1006,1008],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1009,1011],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1016,1024],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[1025,1039],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1040,1233],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1244,1449],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[1459,1775],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[1785,1842],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[1849,2249],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments. For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.","pos":[0,209],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments."},{"content":"For example, if class <ph id=\"ph1\">`C&lt;T&gt;`</ph> has a property <ph id=\"ph2\">`P`</ph> that returns <ph id=\"ph3\">`T`</ph>, calling <ph id=\"ph4\">&lt;xref:System.Type.GetDefaultMembers%2A&gt;</ph> on <ph id=\"ph5\">`C&lt;int&gt;`</ph> returns <ph id=\"ph6\">`int P`</ph> in C# (<ph id=\"ph7\">`Property P As Integer`</ph> in Visual Basic).","pos":[210,400],"source":" For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic)."}]},{"pos":[2256,2502],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> if there is no class constraint.","pos":[0,246],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint."}]}],"pos":[154992,157522],"yaml":true,"extradata":"MT"},{"content":"An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing all default members of the current <xref href=\"System.Type\"></xref>.  \n  \n -or-  \n  \n An empty array of type <xref href=\"System.Reflection.MemberInfo\"></xref>, if the current <xref href=\"System.Type\"></xref> does not have default members.","nodes":[{"pos":[0,151],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MemberInfo\"&gt;&lt;/xref&gt;</ph> objects representing all default members of the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing all default members of the current <xref href=\"System.Type\"></xref>."},{"pos":[158,162],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[169,321],"content":"An empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MemberInfo\"&gt;&lt;/xref&gt;</ph>, if the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> does not have default members.","source":"An empty array of type <xref href=\"System.Reflection.MemberInfo\"></xref>, if the current <xref href=\"System.Type\"></xref> does not have default members."}],"pos":[158254,158590],"yaml":true},{"content":"When overridden in a derived class, returns the <xref href=\"System.Type\"></xref> of the object encompassed or referred to by the current array, pointer or reference type.","nodes":[{"pos":[0,170],"content":"When overridden in a derived class, returns the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> of the object encompassed or referred to by the current array, pointer or reference type.","source":"When overridden in a derived class, returns the <xref href=\"System.Type\"></xref> of the object encompassed or referred to by the current array, pointer or reference type."}],"pos":[159702,159873],"yaml":true},{"content":"This method returns `null` for the <xref:System.Array> class.","nodes":[{"pos":[0,61],"content":"This method returns <ph id=\"ph1\">`null`</ph> for the <ph id=\"ph2\">&lt;xref:System.Array&gt;</ph> class.","source":"This method returns `null` for the <xref:System.Array> class."}],"pos":[159884,159946],"yaml":true,"extradata":"MT"},{"content":"The <xref href=\"System.Type\"></xref> of the object encompassed or referred to by the current array, pointer, or reference type, or `null` if the current <xref href=\"System.Type\"></xref> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.","nodes":[{"pos":[0,350],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> of the object encompassed or referred to by the current array, pointer, or reference type, or <ph id=\"ph2\">`null`</ph> if the current <ph id=\"ph3\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.","source":"The <xref href=\"System.Type\"></xref> of the object encompassed or referred to by the current array, pointer, or reference type, or `null` if the current <xref href=\"System.Type\"></xref> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method."}],"pos":[160557,160908],"yaml":true},{"content":"Returns the name of the constant that has the specified value, for the current enumeration type.","nodes":[{"pos":[0,96],"content":"Returns the name of the constant that has the specified value, for the current enumeration type.","nodes":[{"content":"Returns the name of the constant that has the specified value, for the current enumeration type.","pos":[0,96]}]}],"pos":[162406,162503],"yaml":true},{"content":"The value whose name is to be retrieved.","nodes":[{"pos":[0,40],"content":"The value whose name is to be retrieved.","nodes":[{"content":"The value whose name is to be retrieved.","pos":[0,40]}]}],"pos":[162653,162694],"yaml":true},{"content":"The name of the member of the current enumeration type that has the specified value, or `null` if no such constant is found.","nodes":[{"pos":[0,124],"content":"The name of the member of the current enumeration type that has the specified value, or <ph id=\"ph1\">`null`</ph> if no such constant is found.","source":"The name of the member of the current enumeration type that has the specified value, or `null` if no such constant is found."}],"pos":[162751,162876],"yaml":true},{"content":"The current type is not an enumeration.  \n  \n -or-  \n  \n <code>value</code> is neither of the current type nor does it have the same underlying type as the current type.","nodes":[{"pos":[0,39],"content":"The current type is not an enumeration.","nodes":[{"content":"The current type is not an enumeration.","pos":[0,39]}]},{"pos":[46,50],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[57,169],"content":"<ph id=\"ph1\">&lt;code&gt;value&lt;/code&gt;</ph> is neither of the current type nor does it have the same underlying type as the current type.","source":"<code>value</code> is neither of the current type nor does it have the same underlying type as the current type."}],"pos":[163021,163197],"yaml":true},{"content":"<code>value</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>value</code> is `null`."}],"pos":[163299,163329],"yaml":true},{"content":"Returns the names of the members of the current enumeration type.","nodes":[{"pos":[0,65],"content":"Returns the names of the members of the current enumeration type.","nodes":[{"content":"Returns the names of the members of the current enumeration type.","pos":[0,65]}]}],"pos":[164369,164435],"yaml":true},{"content":"The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants. If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.","nodes":[{"pos":[0,249],"content":"The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants. If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.","nodes":[{"content":"The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants. If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.","pos":[0,249],"nodes":[{"content":"The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.","pos":[0,130]},{"content":"If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.","pos":[131,249]}]}]}],"pos":[164446,164696],"yaml":true,"extradata":"MT"},{"content":"An array that contains the names of the members of the enumeration.","nodes":[{"pos":[0,67],"content":"An array that contains the names of the members of the enumeration.","nodes":[{"content":"An array that contains the names of the members of the enumeration.","pos":[0,67]}]}],"pos":[164838,164906],"yaml":true},{"content":"The current type is not an enumeration.","nodes":[{"pos":[0,39],"content":"The current type is not an enumeration.","nodes":[{"content":"The current type is not an enumeration.","pos":[0,39]}]}],"pos":[165052,165092],"yaml":true},{"content":"Returns the underlying type of the current enumeration type.","nodes":[{"pos":[0,60],"content":"Returns the underlying type of the current enumeration type.","nodes":[{"content":"Returns the underlying type of the current enumeration type.","pos":[0,60]}]}],"pos":[166186,166247],"yaml":true},{"content":"By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>. Other integer types can be specified.","nodes":[{"pos":[0,134],"content":"By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>. Other integer types can be specified.","nodes":[{"content":"By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>. Other integer types can be specified.","pos":[0,134],"nodes":[{"content":"By default, the underlying type of an enumeration in C# and Visual Basic is <ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph>.","pos":[0,96],"source":"By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>."},{"content":"Other integer types can be specified.","pos":[97,134]}]}]}],"pos":[166258,166393],"yaml":true,"extradata":"MT"},{"content":"The underlying type of the current enumeration.","nodes":[{"pos":[0,47],"content":"The underlying type of the current enumeration.","nodes":[{"content":"The underlying type of the current enumeration.","pos":[0,47]}]}],"pos":[166536,166584],"yaml":true},{"content":"The current type is not an enumeration.  \n  \n -or-  \n  \n The enumeration type is not valid, because it contains more than one instance field.","nodes":[{"pos":[0,39],"content":"The current type is not an enumeration.","nodes":[{"content":"The current type is not an enumeration.","pos":[0,39]}]},{"pos":[46,50],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[57,141],"content":"The enumeration type is not valid, because it contains more than one instance field.","nodes":[{"content":"The enumeration type is not valid, because it contains more than one instance field.","pos":[0,84]}]}],"pos":[166739,166887],"yaml":true},{"content":"Returns an array of the values of the constants in the current enumeration type.","nodes":[{"pos":[0,80],"content":"Returns an array of the values of the constants in the current enumeration type.","nodes":[{"content":"Returns an array of the values of the constants in the current enumeration type.","pos":[0,80]}]}],"pos":[167933,168014],"yaml":true},{"content":"An array that contains the values. The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.","nodes":[{"pos":[0,153],"content":"An array that contains the values. The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.","nodes":[{"content":"An array that contains the values. The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.","pos":[0,153],"nodes":[{"content":"An array that contains the values.","pos":[0,34]},{"content":"The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.","pos":[35,153]}]}]}],"pos":[168151,168305],"yaml":true},{"content":"The current type is not an enumeration.","nodes":[{"pos":[0,39],"content":"The current type is not an enumeration.","nodes":[{"content":"The current type is not an enumeration.","pos":[0,39]}]}],"pos":[168452,168492],"yaml":true},{"content":"Returns the <xref href=\"System.Reflection.EventInfo\"></xref> object representing the specified public event.","nodes":[{"pos":[0,108],"content":"Returns the <ph id=\"ph1\">&lt;xref href=\"System.Reflection.EventInfo\"&gt;&lt;/xref&gt;</ph> object representing the specified public event.","source":"Returns the <xref href=\"System.Reflection.EventInfo\"></xref> object representing the specified public event."}],"pos":[169571,169680],"yaml":true},{"content":"An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \n  \n The search for `name` is case-sensitive. The search includes public static and public instance events.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.","nodes":[{"pos":[0,424],"content":"An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.","nodes":[{"content":"An event is considered public to reflection if it has at least one method or accessor that is public.","pos":[0,101]},{"content":"Otherwise the event is considered private, and you must use <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id=\"ph4\">`Or`</ph>) to get it.","pos":[102,424],"source":" Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it."}]},{"pos":[431,533],"content":"The search for `name` is case-sensitive. The search includes public static and public instance events.","nodes":[{"content":"The search for <ph id=\"ph1\">`name`</ph> is case-sensitive.","pos":[0,40],"source":"The search for `name` is case-sensitive."},{"content":"The search includes public static and public instance events.","pos":[41,102]}]},{"pos":[540,655],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[662,673],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[674,680],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[681,691],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[749,760],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[761,763],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[764,766],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[771,776],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[777,779],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[780,830],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[835,840],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[841,855],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[856,1049],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1054,1060],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[1061,1063],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1064,1159],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[1164,1175],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[1176,1178],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1179,1181],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1186,1194],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[1195,1209],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1210,1403],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1414,1619],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[1629,1945],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[1955,2012],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[2019,2219],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.EventInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,200],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[2226,2399],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.","pos":[0,173],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint."}]}],"pos":[169691,172116],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of an event that is declared or inherited by the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,121],"content":"The string containing the name of an event that is declared or inherited by the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"The string containing the name of an event that is declared or inherited by the current <xref href=\"System.Type\"></xref>."}],"pos":[172771,172893],"yaml":true},{"content":"The object representing the specified public event that is declared or inherited by the current <xref href=\"System.Type\"></xref>, if found; otherwise, `null`.","nodes":[{"pos":[0,158],"content":"The object representing the specified public event that is declared or inherited by the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, if found; otherwise, <ph id=\"ph2\">`null`</ph>.","source":"The object representing the specified public event that is declared or inherited by the current <xref href=\"System.Type\"></xref>, if found; otherwise, `null`."}],"pos":[172964,173123],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[173273,173302],"yaml":true},{"content":"When overridden in a derived class, returns the <xref href=\"System.Reflection.EventInfo\"></xref> object representing the specified event, using the specified binding constraints.","nodes":[{"pos":[0,178],"content":"When overridden in a derived class, returns the <ph id=\"ph1\">&lt;xref href=\"System.Reflection.EventInfo\"&gt;&lt;/xref&gt;</ph> object representing the specified event, using the specified binding constraints.","source":"When overridden in a derived class, returns the <xref href=\"System.Reflection.EventInfo\"></xref> object representing the specified event, using the specified binding constraints."}],"pos":[174516,174695],"yaml":true},{"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public events in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \n  \n-   `BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.","nodes":[{"pos":[0,125],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which events to include in the search:","pos":[0,125],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:"}]},{"pos":[135,233],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[243,312],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public events in the search.","source":"Specify `BindingFlags.Public` to include public events in the search."},{"pos":[322,449],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public events (that is, private, internal, and protected events) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search."},{"pos":[459,631],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[638,748],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[758,813],"content":"<ph id=\"ph1\">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id=\"ph2\">`name`</ph>.","source":"`BindingFlags.IgnoreCase` to ignore the case of `name`."},{"pos":[823,951],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the events declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not events that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited."},{"pos":[958,1046],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1053,1477],"content":"An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.","nodes":[{"content":"An event is considered public to reflection if it has at least one method or accessor that is public.","pos":[0,101]},{"content":"Otherwise the event is considered private, and you must use <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id=\"ph4\">`Or`</ph>) to get it.","pos":[102,424],"source":" Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it."}]},{"pos":[1484,1684],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.EventInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,200],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[1691,1864],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.","pos":[0,173],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint."}]}],"pos":[174706,176595],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of an event which is declared or inherited by the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,122],"content":"The string containing the name of an event which is declared or inherited by the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"The string containing the name of an event which is declared or inherited by the current <xref href=\"System.Type\"></xref>."}],"pos":[177412,177535],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[177619,177797],"yaml":true},{"content":"The object representing the specified event that is declared or inherited by the current <xref href=\"System.Type\"></xref>, if found; otherwise, `null`.","nodes":[{"pos":[0,151],"content":"The object representing the specified event that is declared or inherited by the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, if found; otherwise, <ph id=\"ph2\">`null`</ph>.","source":"The object representing the specified event that is declared or inherited by the current <xref href=\"System.Type\"></xref>, if found; otherwise, `null`."}],"pos":[177868,178020],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[178170,178199],"yaml":true},{"content":"Returns all the public events that are declared or inherited by the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,109],"content":"Returns all the public events that are declared or inherited by the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Returns all the public events that are declared or inherited by the current <xref href=\"System.Type\"></xref>."}],"pos":[179221,179331],"yaml":true},{"content":"An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \n  \n The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which events are returned, because that order varies.  \n  \n This method can be overridden by a derived class.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.","nodes":[{"pos":[0,424],"content":"An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.","nodes":[{"content":"An event is considered public to reflection if it has at least one method or accessor that is public.","pos":[0,101]},{"content":"Otherwise the event is considered private, and you must use <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id=\"ph4\">`Or`</ph>) to get it.","pos":[102,424],"source":" Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it."}]},{"pos":[431,658],"content":"The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which events are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which events are returned, because that order varies.","pos":[0,227],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetEvents%2A&gt;</ph> method does not return events in a particular order, such as alphabetical or declaration order.","pos":[0,131],"source":"The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which events are returned, because that order varies.","pos":[132,227]}]}]},{"pos":[665,714],"content":"This method can be overridden by a derived class.","nodes":[{"content":"This method can be overridden by a derived class.","pos":[0,49]}]},{"pos":[721,836],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[843,854],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[855,861],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[862,872],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[930,941],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[942,944],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[945,947],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[952,957],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[958,960],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[961,1011],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[1016,1021],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[1022,1036],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1037,1230],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1235,1241],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[1242,1244],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1245,1340],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[1345,1356],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[1357,1359],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1360,1362],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1367,1375],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[1376,1390],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1391,1584],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1595,1800],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[1810,2126],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[2136,2193],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[2200,2408],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.","pos":[0,208],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments."}]},{"pos":[2415,2588],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.","pos":[0,173],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint."}]}],"pos":[179342,181958],"yaml":true,"extradata":"MT"},{"content":"An array of <xref href=\"System.Reflection.EventInfo\"></xref> objects representing all the public events which are declared or inherited by the current <xref href=\"System.Type\"></xref>.  \n  \n -or-  \n  \n An empty array of type <xref href=\"System.Reflection.EventInfo\"></xref>, if the current <xref href=\"System.Type\"></xref> does not have public events.","nodes":[{"pos":[0,184],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.EventInfo\"&gt;&lt;/xref&gt;</ph> objects representing all the public events which are declared or inherited by the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"An array of <xref href=\"System.Reflection.EventInfo\"></xref> objects representing all the public events which are declared or inherited by the current <xref href=\"System.Type\"></xref>."},{"pos":[191,195],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[202,351],"content":"An empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Reflection.EventInfo\"&gt;&lt;/xref&gt;</ph>, if the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> does not have public events.","source":"An empty array of type <xref href=\"System.Reflection.EventInfo\"></xref>, if the current <xref href=\"System.Type\"></xref> does not have public events."}],"pos":[182811,183177],"yaml":true},{"content":"When overridden in a derived class, searches for events that are declared or inherited by the current <xref href=\"System.Type\"></xref>, using the specified binding constraints.","nodes":[{"pos":[0,176],"content":"When overridden in a derived class, searches for events that are declared or inherited by the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, using the specified binding constraints.","source":"When overridden in a derived class, searches for events that are declared or inherited by the current <xref href=\"System.Type\"></xref>, using the specified binding constraints."}],"pos":[184383,184560],"yaml":true},{"content":"The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which events are returned, because that order varies.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public events in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search. Only protected and internal events on base classes are returned; private events on base classes are not returned.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.","nodes":[{"pos":[0,227],"content":"The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which events are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which events are returned, because that order varies.","pos":[0,227],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetEvents%2A&gt;</ph> method does not return events in a particular order, such as alphabetical or declaration order.","pos":[0,131],"source":"The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which events are returned, because that order varies.","pos":[132,227]}]}]},{"pos":[234,359],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which events to include in the search:","pos":[0,125],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:"}]},{"pos":[369,467],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[477,546],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public events in the search.","source":"Specify `BindingFlags.Public` to include public events in the search."},{"pos":[556,797],"content":"Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search. Only protected and internal events on base classes are returned; private events on base classes are not returned.","nodes":[{"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public events (that is, private, internal, and protected events) in the search.","pos":[0,127],"source":"Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search."},{"content":"Only protected and internal events on base classes are returned; private events on base classes are not returned.","pos":[128,241]}]},{"pos":[807,979],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[986,1096],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[1106,1234],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the events declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not events that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited."},{"pos":[1241,1329],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1336,1760],"content":"An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.","nodes":[{"content":"An event is considered public to reflection if it has at least one method or accessor that is public.","pos":[0,101]},{"content":"Otherwise the event is considered private, and you must use <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id=\"ph4\">`Or`</ph>) to get it.","pos":[102,424],"source":" Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it."}]},{"pos":[1767,1975],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.EventInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.","pos":[0,208],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments."}]},{"pos":[1982,2155],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.","pos":[0,173],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint."}]}],"pos":[184571,186751],"yaml":true,"extradata":"MT"},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[187694,187872],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.EventInfo\"></xref> objects representing all events that are declared or inherited by the current <xref href=\"System.Type\"></xref> that match the specified binding constraints.  \n  \n -or-  \n  \n An empty array of type <xref href=\"System.Reflection.EventInfo\"></xref>, if the current <xref href=\"System.Type\"></xref> does not have events, or if none of the events match the binding constraints.","nodes":[{"pos":[0,217],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.EventInfo\"&gt;&lt;/xref&gt;</ph> objects representing all events that are declared or inherited by the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints.","source":"An array of <xref href=\"System.Reflection.EventInfo\"></xref> objects representing all events that are declared or inherited by the current <xref href=\"System.Type\"></xref> that match the specified binding constraints."},{"pos":[224,228],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[235,433],"content":"An empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Reflection.EventInfo\"&gt;&lt;/xref&gt;</ph>, if the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> does not have events, or if none of the events match the binding constraints.","source":"An empty array of type <xref href=\"System.Reflection.EventInfo\"></xref>, if the current <xref href=\"System.Type\"></xref> does not have events, or if none of the events match the binding constraints."}],"pos":[187945,188393],"yaml":true},{"content":"Searches for the public field with the specified name.","nodes":[{"pos":[0,54],"content":"Searches for the public field with the specified name.","nodes":[{"content":"Searches for the public field with the specified name.","pos":[0,54]}]}],"pos":[189524,189579],"yaml":true},{"content":"The search for `name` is case-sensitive. The search includes public static and public instance fields.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.","nodes":[{"pos":[0,102],"content":"The search for `name` is case-sensitive. The search includes public static and public instance fields.","nodes":[{"content":"The search for <ph id=\"ph1\">`name`</ph> is case-sensitive.","pos":[0,40],"source":"The search for `name` is case-sensitive."},{"content":"The search includes public static and public instance fields.","pos":[41,102]}]},{"pos":[109,309],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.FieldInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,200],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[316,489],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.","pos":[0,173],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint."}]}],"pos":[189590,190086],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the data field to get.","nodes":[{"pos":[0,56],"content":"The string containing the name of the data field to get.","nodes":[{"content":"The string containing the name of the data field to get.","pos":[0,56]}]}],"pos":[190779,190836],"yaml":true},{"content":"An object representing the public field with the specified name, if found; otherwise, `null`.","nodes":[{"pos":[0,93],"content":"An object representing the public field with the specified name, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the public field with the specified name, if found; otherwise, `null`."}],"pos":[190907,191001],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[191151,191180],"yaml":true},{"content":"This <xref href=\"System.Type\"></xref> object is a <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref> whose <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\"></xref> method has not yet been called.","nodes":[{"pos":[0,210],"content":"This <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object is a <ph id=\"ph2\">&lt;xref href=\"System.Reflection.Emit.TypeBuilder\"&gt;&lt;/xref&gt;</ph> whose <ph id=\"ph3\">&lt;xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\"&gt;&lt;/xref&gt;</ph> method has not yet been called.","source":"This <xref href=\"System.Type\"></xref> object is a <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref> whose <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\"></xref> method has not yet been called."}],"pos":[191282,191493],"yaml":true},{"content":"Searches for the specified field, using the specified binding constraints.","nodes":[{"pos":[0,74],"content":"Searches for the specified field, using the specified binding constraints.","nodes":[{"content":"Searches for the specified field, using the specified binding constraints.","pos":[0,74]}]}],"pos":[192707,192782],"yaml":true},{"content":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public fields in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \n  \n-   `BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.","nodes":[{"pos":[0,115],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[122,133],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[134,140],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[141,151],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[209,220],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[221,223],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[224,226],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[231,236],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[237,239],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[240,290],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[295,300],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[301,315],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[316,509],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[514,520],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[521,523],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[524,619],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[624,635],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[636,638],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[639,641],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[646,654],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[655,669],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[670,863],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[874,1079],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[1089,1405],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[1415,1472],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[1479,1604],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which fields to include in the search:","pos":[0,125],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:"}]},{"pos":[1614,1712],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[1722,1791],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public fields in the search.","source":"Specify `BindingFlags.Public` to include public fields in the search."},{"pos":[1801,1928],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public fields (that is, private, internal, and protected fields) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search."},{"pos":[1938,2110],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[2117,2227],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[2237,2292],"content":"<ph id=\"ph1\">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id=\"ph2\">`name`</ph>.","source":"`BindingFlags.IgnoreCase` to ignore the case of `name`."},{"pos":[2302,2430],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the fields declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not fields that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited."},{"pos":[2437,2525],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[2532,2732],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.FieldInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,200],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[2739,2912],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.","pos":[0,173],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint."}]}],"pos":[192793,195745],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the data field to get.","nodes":[{"pos":[0,56],"content":"The string containing the name of the data field to get.","nodes":[{"content":"The string containing the name of the data field to get.","pos":[0,56]}]}],"pos":[196532,196589],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[196673,196851],"yaml":true},{"content":"An object representing the field that matches the specified requirements, if found; otherwise, `null`.","nodes":[{"pos":[0,102],"content":"An object representing the field that matches the specified requirements, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the field that matches the specified requirements, if found; otherwise, `null`."}],"pos":[196922,197025],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[197175,197204],"yaml":true},{"content":"Returns all the public fields of the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,78],"content":"Returns all the public fields of the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Returns all the public fields of the current <xref href=\"System.Type\"></xref>."}],"pos":[198226,198305],"yaml":true},{"content":"The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order varies.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.","nodes":[{"pos":[0,227],"content":"The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order varies.","pos":[0,227],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.","pos":[0,131],"source":"The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which fields are returned, because that order varies.","pos":[132,227]}]}]},{"pos":[234,349],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[356,367],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[368,374],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[375,385],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[443,454],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[455,457],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[458,460],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[465,470],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[471,473],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[474,524],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[529,534],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[535,549],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[550,743],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[748,754],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[755,757],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[758,853],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[858,869],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[870,872],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[873,875],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[880,888],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[889,903],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[904,1097],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1108,1313],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[1323,1639],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[1649,1706],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[1713,1921],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.","pos":[0,208],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments."}]},{"pos":[1928,2108],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.","pos":[0,180],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint."}]}],"pos":[198316,200448],"yaml":true,"extradata":"MT"},{"content":"An array of <xref href=\"System.Reflection.FieldInfo\"></xref> objects representing all the public fields defined for the current <xref href=\"System.Type\"></xref>.  \n  \n -or-  \n  \n An empty array of type <xref href=\"System.Reflection.FieldInfo\"></xref>, if no public fields are defined for the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,161],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.FieldInfo\"&gt;&lt;/xref&gt;</ph> objects representing all the public fields defined for the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"An array of <xref href=\"System.Reflection.FieldInfo\"></xref> objects representing all the public fields defined for the current <xref href=\"System.Type\"></xref>."},{"pos":[168,172],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[179,333],"content":"An empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Reflection.FieldInfo\"&gt;&lt;/xref&gt;</ph>, if no public fields are defined for the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"An empty array of type <xref href=\"System.Reflection.FieldInfo\"></xref>, if no public fields are defined for the current <xref href=\"System.Type\"></xref>."}],"pos":[201126,201474],"yaml":true},{"content":"When overridden in a derived class, searches for the fields defined for the current <xref href=\"System.Type\"></xref>, using the specified binding constraints.","nodes":[{"pos":[0,158],"content":"When overridden in a derived class, searches for the fields defined for the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, using the specified binding constraints.","source":"When overridden in a derived class, searches for the fields defined for the current <xref href=\"System.Type\"></xref>, using the specified binding constraints."}],"pos":[202680,202839],"yaml":true},{"content":"The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order varies.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public fields in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search. Only protected and internal fields on base classes are returned; private fields on base classes are not returned.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.","nodes":[{"pos":[0,227],"content":"The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order varies.","pos":[0,227],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetFields%2A&gt;</ph> method does not return fields in a particular order, such as alphabetical or declaration order.","pos":[0,131],"source":"The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which fields are returned, because that order varies.","pos":[132,227]}]}]},{"pos":[234,359],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which fields to include in the search:","pos":[0,125],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:"}]},{"pos":[369,467],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[477,546],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public fields in the search.","source":"Specify `BindingFlags.Public` to include public fields in the search."},{"pos":[556,797],"content":"Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search. Only protected and internal fields on base classes are returned; private fields on base classes are not returned.","nodes":[{"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public fields (that is, private, internal, and protected fields) in the search.","pos":[0,127],"source":"Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search."},{"content":"Only protected and internal fields on base classes are returned; private fields on base classes are not returned.","pos":[128,241]}]},{"pos":[807,979],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[986,1096],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[1106,1234],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the fields declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not fields that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited."},{"pos":[1241,1329],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1336,1544],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.FieldInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.","pos":[0,208],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments."}]},{"pos":[1551,1731],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.","pos":[0,180],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint."}]}],"pos":[202850,204604],"yaml":true,"extradata":"MT"},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[205410,205588],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.FieldInfo\"></xref> objects representing all fields defined for the current <xref href=\"System.Type\"></xref> that match the specified binding constraints.  \n  \n -or-  \n  \n An empty array of type <xref href=\"System.Reflection.FieldInfo\"></xref>, if no fields are defined for the current <xref href=\"System.Type\"></xref>, or if none of the defined fields match the binding constraints.","nodes":[{"pos":[0,195],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.FieldInfo\"&gt;&lt;/xref&gt;</ph> objects representing all fields defined for the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints.","source":"An array of <xref href=\"System.Reflection.FieldInfo\"></xref> objects representing all fields defined for the current <xref href=\"System.Type\"></xref> that match the specified binding constraints."},{"pos":[202,206],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[213,424],"content":"An empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Reflection.FieldInfo\"&gt;&lt;/xref&gt;</ph>, if no fields are defined for the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, or if none of the defined fields match the binding constraints.","source":"An empty array of type <xref href=\"System.Reflection.FieldInfo\"></xref>, if no fields are defined for the current <xref href=\"System.Type\"></xref>, or if none of the defined fields match the binding constraints."}],"pos":[205661,206100],"yaml":true},{"content":"Returns an array of <xref href=\"System.Type\"></xref> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.","nodes":[{"pos":[0,172],"content":"Returns an array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.","source":"Returns an array of <xref href=\"System.Type\"></xref> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition."}],"pos":[207234,207407],"yaml":true},{"content":"The array elements are returned in the order in which they appear in the list of type arguments for the generic type.  \n  \n-   If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition.  \n  \n-   If the current type is a generic type definition, the array contains the type parameters.  \n  \n-   If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters. Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart. For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.  \n  \n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"pos":[0,117],"content":"The array elements are returned in the order in which they appear in the list of type arguments for the generic type.","nodes":[{"content":"The array elements are returned in the order in which they appear in the list of type arguments for the generic type.","pos":[0,117]}]},{"pos":[127,445],"content":"If the current type is a closed constructed type (that is, the <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id=\"ph2\">`false`</ph>), the array returned by the <ph id=\"ph3\">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method contains the types that have been assigned to the generic type parameters of the generic type definition.","source":"If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition."},{"pos":[455,544],"content":"If the current type is a generic type definition, the array contains the type parameters.","nodes":[{"content":"If the current type is a generic type definition, the array contains the type parameters.","pos":[0,89]}]},{"pos":[554,1078],"content":"If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters. Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart. For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.","nodes":[{"content":"If the current type is an open constructed type (that is, the <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property returns <ph id=\"ph2\">`true`</ph>) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.","pos":[0,321],"source":"If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property to tell them apart.","pos":[322,399],"source":" Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart."},{"content":"For a demonstration of this scenario, see the code example for the <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property.","pos":[400,524],"source":" For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property."}]},{"pos":[1085,1223],"content":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"content":"For a list of the invariant conditions for terms used in generic reflection, see the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.","pos":[0,138],"source":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks."}]}],"pos":[207418,208652],"yaml":true,"extradata":"MT"},{"content":"An array of <xref href=\"System.Type\"></xref> objects that represent the type arguments of a generic type. Returns an empty array if the current type is not a generic type.","nodes":[{"pos":[0,171],"content":"An array of <xref href=\"System.Type\"></xref> objects that represent the type arguments of a generic type. Returns an empty array if the current type is not a generic type.","nodes":[{"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects that represent the type arguments of a generic type.","pos":[0,105],"source":"An array of <xref href=\"System.Type\"></xref> objects that represent the type arguments of a generic type."},{"content":"Returns an empty array if the current type is not a generic type.","pos":[106,171]}]}],"pos":[209650,209822],"yaml":true},{"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","nodes":[{"pos":[0,102],"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","nodes":[{"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","pos":[0,102],"nodes":[{"content":"The invoked method is not supported in the base class.","pos":[0,54]},{"content":"Derived classes must provide an implementation.","pos":[55,102]}]}]}],"pos":[209983,210086],"yaml":true},{"content":"Returns an array of <xref href=\"System.Type\"></xref> objects that represent the constraints on the current generic type parameter.","nodes":[{"pos":[0,130],"content":"Returns an array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects that represent the constraints on the current generic type parameter.","source":"Returns an array of <xref href=\"System.Type\"></xref> objects that represent the constraints on the current generic type parameter."}],"pos":[211234,211365],"yaml":true},{"content":"Each constraint on a generic type parameter is expressed as a <xref:System.Type> object. Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint. If a type parameter has no class constraint and no interface constraints, an empty array is returned.  \n  \n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"pos":[0,377],"content":"Each constraint on a generic type parameter is expressed as a <xref:System.Type> object. Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint. If a type parameter has no class constraint and no interface constraints, an empty array is returned.","nodes":[{"content":"Each constraint on a generic type parameter is expressed as a <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object.","pos":[0,88],"source":"Each constraint on a generic type parameter is expressed as a <xref:System.Type> object."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Type.IsClass%2A&gt;</ph> property to determine whether a constraint is the base class constraint; if the property returns <ph id=\"ph2\">`false`</ph>, the constraint is an interface constraint.","pos":[89,275],"source":" Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint."},{"content":"If a type parameter has no class constraint and no interface constraints, an empty array is returned.","pos":[276,377]}]},{"pos":[384,522],"content":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"content":"For a list of the invariant conditions for terms used in generic reflection, see the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.","pos":[0,138],"source":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks."}]}],"pos":[211376,211903],"yaml":true,"extradata":"MT"},{"content":"An array of <xref href=\"System.Type\"></xref> objects that represent the constraints on the current generic type parameter.","nodes":[{"pos":[0,122],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects that represent the constraints on the current generic type parameter.","source":"An array of <xref href=\"System.Type\"></xref> objects that represent the constraints on the current generic type parameter."}],"pos":[212900,213023],"yaml":true},{"content":"The current <xref href=\"System.Type\"></xref> object is not a generic type parameter. That is, the <xref href=\"System.Type.IsGenericParameter\"></xref> property returns `false`.","nodes":[{"pos":[0,175],"content":"The current <xref href=\"System.Type\"></xref> object is not a generic type parameter. That is, the <xref href=\"System.Type.IsGenericParameter\"></xref> property returns `false`.","nodes":[{"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object is not a generic type parameter.","pos":[0,84],"source":"The current <xref href=\"System.Type\"></xref> object is not a generic type parameter."},{"content":"That is, the <ph id=\"ph1\">&lt;xref href=\"System.Type.IsGenericParameter\"&gt;&lt;/xref&gt;</ph> property returns <ph id=\"ph2\">`false`</ph>.","pos":[85,175],"source":" That is, the <xref href=\"System.Type.IsGenericParameter\"></xref> property returns `false`."}]}],"pos":[213203,213379],"yaml":true},{"content":"Returns a <xref href=\"System.Type\"></xref> object that represents a generic type definition from which the current generic type can be constructed.","nodes":[{"pos":[0,147],"content":"Returns a <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object that represents a generic type definition from which the current generic type can be constructed.","source":"Returns a <xref href=\"System.Type\"></xref> object that represents a generic type definition from which the current generic type can be constructed."}],"pos":[214491,214639],"yaml":true},{"content":"A generic type definition is a template from which other types can be constructed. For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic). Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.  \n  \n If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.  \n  \n If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.  \n  \n> [!IMPORTANT]\n>  An array of generic types is not itself generic. In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic. Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.  \n  \n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"pos":[0,484],"content":"A generic type definition is a template from which other types can be constructed. For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic). Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.","nodes":[{"content":"A generic type definition is a template from which other types can be constructed.","pos":[0,82]},{"content":"For example, from the generic type definition <ph id=\"ph1\">`G&lt;T&gt;`</ph> (expressed in C# syntax; <ph id=\"ph2\">`G(Of T)`</ph> in Visual Basic or <ph id=\"ph3\">`generic &lt;typename T&gt; ref class G`</ph> in C++) you can construct and instantiate the type <ph id=\"ph4\">`G&lt;int&gt;`</ph> (<ph id=\"ph5\">`G(Of Integer)`</ph> in Visual Basic).","pos":[83,319],"source":" For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic)."},{"content":"Given a <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object representing this constructed type, the <ph id=\"ph2\">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method returns the generic type definition.","pos":[320,484],"source":" Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition."}]},{"pos":[491,714],"content":"If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.","nodes":[{"content":"If two constructed types are created from the same generic type definition, using the same type arguments, the <ph id=\"ph1\">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method returns the same <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object for both types.","pos":[0,223],"source":"If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types."}]},{"pos":[721,915],"content":"If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.","nodes":[{"content":"If you call the <ph id=\"ph1\">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method on a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object that already represents a generic type definition, it returns the current <ph id=\"ph3\">&lt;xref:System.Type&gt;</ph>.","pos":[0,194],"source":"If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>."}]},{"pos":[923,1252],"content":"[!IMPORTANT]\n An array of generic types is not itself generic. In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic. Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.","leadings":["","> "],"nodes":[{"content":" An array of generic types is not itself generic. In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic. Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.","pos":[13,327],"nodes":[{"content":"An array of generic types is not itself generic.","pos":[1,49]},{"content":"In the C# code <ph id=\"ph1\">`A&lt;int&gt;[] v;`</ph> or the Visual Basic code <ph id=\"ph2\">`Dim v() As A(Of Integer)`</ph>, the type of variable <ph id=\"ph3\">`v`</ph> is not generic.","pos":[50,172],"source":" In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic."},{"content":"Use <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> to determine whether a type is generic before calling <ph id=\"ph2\">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph>.","pos":[173,314],"source":" Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>."}]}]},{"pos":[1259,1397],"content":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"content":"For a list of the invariant conditions for terms used in generic reflection, see the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.","pos":[0,138],"source":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks."}]}],"pos":[214650,216059],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Type\"></xref> object representing a generic type from which the current type can be constructed.","nodes":[{"pos":[0,117],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object representing a generic type from which the current type can be constructed.","source":"A <xref href=\"System.Type\"></xref> object representing a generic type from which the current type can be constructed."}],"pos":[217184,217302],"yaml":true},{"content":"The current type is not a generic type.  That is, <xref href=\"System.Type.IsGenericType\"></xref> returns `false`.","nodes":[{"pos":[0,113],"content":"The current type is not a generic type.  That is, <xref href=\"System.Type.IsGenericType\"></xref> returns `false`.","nodes":[{"content":"The current type is not a generic type.","pos":[0,39]},{"content":"That is, <ph id=\"ph1\">&lt;xref href=\"System.Type.IsGenericType\"&gt;&lt;/xref&gt;</ph> returns <ph id=\"ph2\">`false`</ph>.","pos":[41,113],"source":"  That is, <xref href=\"System.Type.IsGenericType\"></xref> returns `false`."}]}],"pos":[217476,217590],"yaml":true},{"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","nodes":[{"pos":[0,102],"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","nodes":[{"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","pos":[0,102],"nodes":[{"content":"The invoked method is not supported in the base class.","pos":[0,54]},{"content":"Derived classes must provide an implementation.","pos":[55,102]}]}]}],"pos":[217692,217795],"yaml":true},{"content":"Returns the hash code for this instance.","nodes":[{"pos":[0,40],"content":"Returns the hash code for this instance.","nodes":[{"content":"Returns the hash code for this instance.","pos":[0,40]}]}],"pos":[219173,219214],"yaml":true},{"content":"This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.","nodes":[{"pos":[0,83],"content":"This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.","nodes":[{"content":"This method overrides <ph id=\"ph1\">&lt;xref:System.Object.GetHashCode%2A?displayProperty=fullName&gt;</ph>.","pos":[0,83],"source":"This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=fullName>."}]}],"pos":[219225,219309],"yaml":true,"extradata":"MT"},{"content":"The hash code for this instance.","nodes":[{"pos":[0,32],"content":"The hash code for this instance.","nodes":[{"content":"The hash code for this instance.","pos":[0,32]}]}],"pos":[220008,220041],"yaml":true},{"content":"Searches for the interface with the specified name.","nodes":[{"pos":[0,51],"content":"Searches for the interface with the specified name.","nodes":[{"content":"Searches for the interface with the specified name.","pos":[0,51]}]}],"pos":[221542,221594],"yaml":true},{"content":"The search for `name` is case-sensitive.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.  \n  \n> [!NOTE]\n>  For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\\`) and the number of type parameters. This is true for both generic interface definitions and constructed generic interfaces. For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``\"IExample`1\"``.","nodes":[{"pos":[0,40],"content":"The search for <ph id=\"ph1\">`name`</ph> is case-sensitive.","source":"The search for `name` is case-sensitive."},{"pos":[47,231],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,184],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[238,467],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.","pos":[0,229],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints."}]},{"pos":[475,868],"content":"[!NOTE]\n For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\\`) and the number of type parameters. This is true for both generic interface definitions and constructed generic interfaces. For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``\"IExample`1\"``.","leadings":["","> "],"nodes":[{"content":" For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\\`) and the number of type parameters. This is true for both generic interface definitions and constructed generic interfaces. For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``\"IExample`1\"``.","pos":[8,391],"nodes":[{"content":"For generic interfaces, the <ph id=\"ph1\">`name`</ph> parameter is the mangled name, ending with a grave accent (<ph id=\"ph2\">\\`</ph>) and the number of type parameters.","pos":[1,133],"source":" For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\\`) and the number of type parameters."},{"content":"This is true for both generic interface definitions and constructed generic interfaces.","pos":[134,221]},{"content":"For example, to find <ph id=\"ph1\">`IExample&lt;T&gt;`</ph> (<ph id=\"ph2\">`IExample(Of T)`</ph> in Visual Basic) or <ph id=\"ph3\">`IExample&lt;string&gt;`</ph> (<ph id=\"ph4\">`IExample(Of String)`</ph> in Visual Basic), search for <ph id=\"ph5\">``\"IExample`1\"``</ph>.","pos":[222,383],"source":" For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``\"IExample`1\"``."}]}]}],"pos":[221605,222486],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the interface to get. For generic interfaces, this is the mangled name.","nodes":[{"pos":[0,105],"content":"The string containing the name of the interface to get. For generic interfaces, this is the mangled name.","nodes":[{"content":"The string containing the name of the interface to get. For generic interfaces, this is the mangled name.","pos":[0,105],"nodes":[{"content":"The string containing the name of the interface to get.","pos":[0,55]},{"content":"For generic interfaces, this is the mangled name.","pos":[56,105]}]}]}],"pos":[223475,223581],"yaml":true},{"content":"An object representing the interface with the specified name, implemented or inherited by the current <xref href=\"System.Type\"></xref>, if found; otherwise, `null`.","nodes":[{"pos":[0,164],"content":"An object representing the interface with the specified name, implemented or inherited by the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, if found; otherwise, <ph id=\"ph2\">`null`</ph>.","source":"An object representing the interface with the specified name, implemented or inherited by the current <xref href=\"System.Type\"></xref>, if found; otherwise, `null`."}],"pos":[223636,223801],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[223955,223984],"yaml":true},{"content":"The current <xref href=\"System.Type\"></xref> represents a type that implements the same generic interface with different type arguments.","nodes":[{"pos":[0,136],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> represents a type that implements the same generic interface with different type arguments.","source":"The current <xref href=\"System.Type\"></xref> represents a type that implements the same generic interface with different type arguments."}],"pos":[224112,224249],"yaml":true},{"content":"When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.","nodes":[{"pos":[0,148],"content":"When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.","nodes":[{"content":"When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.","pos":[0,148]}]}],"pos":[225424,225573],"yaml":true},{"content":"The `ignoreCase` parameter applies only to the simple interface name, not to the namespace. The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found. For example, the string \"System.icomparable\" finds the <xref:System.IComparable> interface, but the string \"system.icomparable\" does not.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.  \n  \n> [!NOTE]\n>  For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\\`) and the number of type parameters. This is true for both generic interface definitions and constructed generic interfaces. For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `\"IExample`1\"`.","nodes":[{"pos":[0,344],"content":"The `ignoreCase` parameter applies only to the simple interface name, not to the namespace. The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found. For example, the string \"System.icomparable\" finds the <xref:System.IComparable> interface, but the string \"system.icomparable\" does not.","nodes":[{"content":"The <ph id=\"ph1\">`ignoreCase`</ph> parameter applies only to the simple interface name, not to the namespace.","pos":[0,91],"source":"The `ignoreCase` parameter applies only to the simple interface name, not to the namespace."},{"content":"The portion of <ph id=\"ph1\">`name`</ph> that specifies the namespace must have the correct case, or the interface will not be found.","pos":[92,206],"source":" The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found."},{"content":"For example, the string \"System.icomparable\" finds the <ph id=\"ph1\">&lt;xref:System.IComparable&gt;</ph> interface, but the string \"system.icomparable\" does not.","pos":[207,344],"source":" For example, the string \"System.icomparable\" finds the <xref:System.IComparable> interface, but the string \"system.icomparable\" does not."}]},{"pos":[351,535],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,184],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[542,771],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.","pos":[0,229],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints."}]},{"pos":[779,1170],"content":"[!NOTE]\n For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\\`) and the number of type parameters. This is true for both generic interface definitions and constructed generic interfaces. For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `\"IExample`1\"`.","leadings":["","> "],"nodes":[{"content":" For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\\`) and the number of type parameters. This is true for both generic interface definitions and constructed generic interfaces. For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `\"IExample`1\"`.","pos":[8,389],"nodes":[{"content":"For generic interfaces, the <ph id=\"ph1\">`name`</ph> parameter is the mangled name, ending with a grave accent (<ph id=\"ph2\">\\`</ph>) and the number of type parameters.","pos":[1,133],"source":" For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\\`) and the number of type parameters."},{"content":"This is true for both generic interface definitions and constructed generic interfaces.","pos":[134,221]},{"content":"For example, to find <ph id=\"ph1\">`IExample&lt;T&gt;`</ph> (<ph id=\"ph2\">`IExample(Of T)`</ph> in Visual Basic) or <ph id=\"ph3\">`IExample&lt;string&gt;`</ph> (<ph id=\"ph4\">`IExample(Of String)`</ph> in Visual Basic), search for <ph id=\"ph5\">`\"IExample`</ph>1\"`.","pos":[222,381],"source":" For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `\"IExample`1\"`."}]}]}],"pos":[225584,226771],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the interface to get. For generic interfaces, this is the mangled name.","nodes":[{"pos":[0,105],"content":"The string containing the name of the interface to get. For generic interfaces, this is the mangled name.","nodes":[{"content":"The string containing the name of the interface to get. For generic interfaces, this is the mangled name.","pos":[0,105],"nodes":[{"content":"The string containing the name of the interface to get.","pos":[0,55]},{"content":"For generic interfaces, this is the mangled name.","pos":[56,105]}]}]}],"pos":[227753,227859],"yaml":true},{"content":"`true` to ignore the case of that part of <code>name</code> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).  \n  \n -or-  \n  \n `false` to perform a case-sensitive search for all parts of <code>name</code>.","nodes":[{"pos":[0,165],"content":"<ph id=\"ph1\">`true`</ph> to ignore the case of that part of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">name</ph><ept id=\"p1\">&lt;/code&gt;</ept> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).","source":"`true` to ignore the case of that part of <code>name</code> that specifies the simple interface name (the part that specifies the namespace must be correctly cased)."},{"pos":[172,176],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[183,261],"content":"<ph id=\"ph1\">`false`</ph> to perform a case-sensitive search for all parts of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">name</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"`false` to perform a case-sensitive search for all parts of <code>name</code>."}],"pos":[227926,228194],"yaml":true},{"content":"An object representing the interface with the specified name, implemented or inherited by the current <xref href=\"System.Type\"></xref>, if found; otherwise, `null`.","nodes":[{"pos":[0,164],"content":"An object representing the interface with the specified name, implemented or inherited by the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, if found; otherwise, <ph id=\"ph2\">`null`</ph>.","source":"An object representing the interface with the specified name, implemented or inherited by the current <xref href=\"System.Type\"></xref>, if found; otherwise, `null`."}],"pos":[228249,228414],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[228568,228597],"yaml":true},{"content":"The current <xref href=\"System.Type\"></xref> represents a type that implements the same generic interface with different type arguments.","nodes":[{"pos":[0,136],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> represents a type that implements the same generic interface with different type arguments.","source":"The current <xref href=\"System.Type\"></xref> represents a type that implements the same generic interface with different type arguments."}],"pos":[228725,228862],"yaml":true},{"content":"Returns an interface mapping for the specified interface type.","nodes":[{"pos":[0,62],"content":"Returns an interface mapping for the specified interface type.","nodes":[{"content":"Returns an interface mapping for the specified interface type.","pos":[0,62]}]}],"pos":[229971,230034],"yaml":true},{"content":"The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.  \n  \n If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.","nodes":[{"pos":[0,119],"content":"The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.","nodes":[{"content":"The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.","pos":[0,119]}]},{"pos":[126,351],"content":"If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <ph id=\"ph2\">&lt;xref:System.Reflection.InterfaceMapping&gt;</ph> returned by this method.","pos":[0,225],"source":"If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method."}]}],"pos":[230045,230401],"yaml":true,"extradata":"MT"},{"content":"The interface type to retrieve a mapping for.","nodes":[{"pos":[0,45],"content":"The interface type to retrieve a mapping for.","nodes":[{"content":"The interface type to retrieve a mapping for.","pos":[0,45]}]}],"pos":[231541,231587],"yaml":true},{"content":"An object that represents the interface mapping for <code>interfaceType</code>.","nodes":[{"pos":[0,79],"content":"An object that represents the interface mapping for <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">interfaceType</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"An object that represents the interface mapping for <code>interfaceType</code>."}],"pos":[231665,231745],"yaml":true},{"content":"<code>interfaceType</code> is not implemented by the current type.  \n  \n -or-  \n  \n The <code>interfaceType</code> parameter does not refer to an interface.  \n  \n -or-  \n  \n <code>interfaceType</code> is a generic interface, and the current type is an array type.","nodes":[{"pos":[0,66],"content":"<ph id=\"ph1\">&lt;code&gt;interfaceType&lt;/code&gt;</ph> is not implemented by the current type.","source":"<code>interfaceType</code> is not implemented by the current type."},{"pos":[73,77],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[84,156],"content":"The <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">interfaceType</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter does not refer to an interface.","source":"The <code>interfaceType</code> parameter does not refer to an interface."},{"pos":[163,167],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[174,263],"content":"<ph id=\"ph1\">&lt;code&gt;interfaceType&lt;/code&gt;</ph> is a generic interface, and the current type is an array type.","source":"<code>interfaceType</code> is a generic interface, and the current type is an array type."}],"pos":[231894,232168],"yaml":true},{"content":"<code>interfaceType</code> is `null`.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;interfaceType&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>interfaceType</code> is `null`."}],"pos":[232270,232308],"yaml":true},{"content":"The current <xref href=\"System.Type\"></xref> represents a generic type parameter; that is, <xref href=\"System.Type.IsGenericParameter\"></xref> is `true`.","nodes":[{"pos":[0,153],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> represents a generic type parameter; that is, <ph id=\"ph2\">&lt;xref href=\"System.Type.IsGenericParameter\"&gt;&lt;/xref&gt;</ph> is <ph id=\"ph3\">`true`</ph>.","source":"The current <xref href=\"System.Type\"></xref> represents a generic type parameter; that is, <xref href=\"System.Type.IsGenericParameter\"></xref> is `true`."}],"pos":[232418,232572],"yaml":true},{"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","nodes":[{"pos":[0,102],"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","nodes":[{"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","pos":[0,102],"nodes":[{"content":"The invoked method is not supported in the base class.","pos":[0,54]},{"content":"Derived classes must provide an implementation.","pos":[55,102]}]}]}],"pos":[232674,232777],"yaml":true},{"content":"When overridden in a derived class, gets all the interfaces implemented or inherited by the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,133],"content":"When overridden in a derived class, gets all the interfaces implemented or inherited by the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"When overridden in a derived class, gets all the interfaces implemented or inherited by the current <xref href=\"System.Type\"></xref>."}],"pos":[233898,234032],"yaml":true},{"content":"The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which interfaces are returned, because that order varies.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.","nodes":[{"pos":[0,239],"content":"The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which interfaces are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which interfaces are returned, because that order varies.","pos":[0,239],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetInterfaces%2A&gt;</ph> method does not return interfaces in a particular order, such as alphabetical or declaration order.","pos":[0,139],"source":"The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which interfaces are returned, because that order varies.","pos":[140,239]}]}]},{"pos":[246,438],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.","pos":[0,192],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments."}]},{"pos":[445,674],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.","pos":[0,229],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints."}]}],"pos":[234043,234724],"yaml":true,"extradata":"MT"},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing all the interfaces implemented or inherited by the current <xref href=\"System.Type\"></xref>.  \n  \n -or-  \n  \n An empty array of type <xref href=\"System.Type\"></xref>, if no interfaces are implemented or inherited by the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,158],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing all the interfaces implemented or inherited by the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"An array of <xref href=\"System.Type\"></xref> objects representing all the interfaces implemented or inherited by the current <xref href=\"System.Type\"></xref>."},{"pos":[165,169],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[176,327],"content":"An empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, if no interfaces are implemented or inherited by the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"An empty array of type <xref href=\"System.Type\"></xref>, if no interfaces are implemented or inherited by the current <xref href=\"System.Type\"></xref>."}],"pos":[235549,235891],"yaml":true},{"content":"A static initializer is invoked and throws an exception.","nodes":[{"pos":[0,56],"content":"A static initializer is invoked and throws an exception.","nodes":[{"content":"A static initializer is invoked and throws an exception.","pos":[0,56]}]}],"pos":[236076,236133],"yaml":true},{"content":"Searches for the public members with the specified name.","nodes":[{"pos":[0,56],"content":"Searches for the public members with the specified name.","nodes":[{"content":"Searches for the public members with the specified name.","pos":[0,56]}]}],"pos":[237218,237275],"yaml":true},{"content":"The search for `name` is case-sensitive. The search includes public static and public instance members.  \n  \n Members include properties, methods, fields, events, and so on.  \n  \n The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  \n  \n This method overload will not find class initializers (.cctor). To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.  \n  \n> [!NOTE]\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","nodes":[{"pos":[0,103],"content":"The search for `name` is case-sensitive. The search includes public static and public instance members.","nodes":[{"content":"The search for <ph id=\"ph1\">`name`</ph> is case-sensitive.","pos":[0,40],"source":"The search for `name` is case-sensitive."},{"content":"The search includes public static and public instance members.","pos":[41,103]}]},{"pos":[110,173],"content":"Members include properties, methods, fields, events, and so on.","nodes":[{"content":"Members include properties, methods, fields, events, and so on.","pos":[0,63]}]},{"pos":[180,409],"content":"The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.","pos":[0,229],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.","pos":[0,132],"source":"The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which members are returned, because that order varies.","pos":[133,229]}]}]},{"pos":[416,963],"content":"This method overload will not find class initializers (.cctor). To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.","nodes":[{"content":"This method overload will not find class initializers (.cctor).","pos":[0,63]},{"content":"To find class initializers, use an overload that takes <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id=\"ph4\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph5\">`Or`</ph><ph id=\"ph6\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).","pos":[64,450],"source":" To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic)."},{"content":"You can also get the class initializer using the <ph id=\"ph1\">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.","pos":[451,547],"source":" You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property."}]},{"pos":[970,1085],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[1092,1103],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[1104,1110],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[1111,1121],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[1179,1190],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[1191,1193],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1194,1196],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1201,1206],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[1207,1209],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1210,1260],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[1265,1270],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[1271,1285],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1286,1479],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1484,1490],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[1491,1493],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1494,1589],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[1594,1605],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[1606,1608],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1609,1611],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1616,1624],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[1625,1639],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1640,1833],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1844,2049],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[2059,2375],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[2385,2442],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[2449,2650],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,201],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[2657,2903],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> if there is no class constraint.","pos":[0,246],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint."}]},{"pos":[2911,3188],"content":"[!NOTE]\n For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","leadings":["","> "],"nodes":[{"content":" For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","pos":[8,275],"nodes":[{"content":"For generic methods, do not include the type arguments in <ph id=\"ph1\">`name`</ph>.","pos":[1,66],"source":" For generic methods, do not include the type arguments in `name`."},{"content":"For example, the C# code <ph id=\"ph1\">`GetMember(\"MyMethod&lt;int&gt;\")`</ph> searches for a member with the text name \"<ph id=\"ph2\">`MyMethod&lt;int&gt;`</ph>\", rather than for a method named <ph id=\"ph3\">`MyMethod`</ph> that has one generic argument of type <ph id=\"ph4\">`int`</ph>.","pos":[67,267],"source":" For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`."}]}]}],"pos":[237286,240511],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the public members to get.","nodes":[{"pos":[0,60],"content":"The string containing the name of the public members to get.","nodes":[{"content":"The string containing the name of the public members to get.","pos":[0,60]}]}],"pos":[241140,241201],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing the public members with the specified name, if found; otherwise, an empty array.","nodes":[{"pos":[0,163],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MemberInfo\"&gt;&lt;/xref&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.","source":"An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing the public members with the specified name, if found; otherwise, an empty array."}],"pos":[241275,241439],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[241590,241619],"yaml":true},{"content":"Searches for the specified members, using the specified binding constraints.","nodes":[{"pos":[0,76],"content":"Searches for the specified members, using the specified binding constraints.","nodes":[{"content":"Searches for the specified members, using the specified binding constraints.","pos":[0,76]}]}],"pos":[242839,242916],"yaml":true},{"content":"This method can be overridden by a derived class.  \n  \n Members include properties, methods, fields, events, and so on.  \n  \n The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public members in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \n  \n-   `BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n To get the class initializer (.cctor) using this method overload, you must specify \".cctor\" for `name`, and <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic) for `bindingAttr`. You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.  \n  \n> [!NOTE]\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","nodes":[{"pos":[0,49],"content":"This method can be overridden by a derived class.","nodes":[{"content":"This method can be overridden by a derived class.","pos":[0,49]}]},{"pos":[56,119],"content":"Members include properties, methods, fields, events, and so on.","nodes":[{"content":"Members include properties, methods, fields, events, and so on.","pos":[0,63]}]},{"pos":[126,355],"content":"The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.","pos":[0,229],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.","pos":[0,132],"source":"The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which members are returned, because that order varies.","pos":[133,229]}]}]},{"pos":[362,488],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:","pos":[0,126],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:"}]},{"pos":[498,596],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[606,676],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public members in the search.","source":"Specify `BindingFlags.Public` to include public members in the search."},{"pos":[686,815],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search."},{"pos":[825,997],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[1004,1114],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[1124,1179],"content":"<ph id=\"ph1\">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id=\"ph2\">`name`</ph>.","source":"`BindingFlags.IgnoreCase` to ignore the case of `name`."},{"pos":[1189,1319],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited."},{"pos":[1326,1414],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1421,1924],"content":"To get the class initializer (.cctor) using this method overload, you must specify \".cctor\" for `name`, and <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic) for `bindingAttr`. You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.","nodes":[{"content":"To get the class initializer (.cctor) using this method overload, you must specify \".cctor\" for <ph id=\"ph1\">`name`</ph>, and <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id=\"ph4\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph5\">`Or`</ph><ph id=\"ph6\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic) for <ph id=\"ph7\">`bindingAttr`</ph>.","pos":[0,406],"source":"To get the class initializer (.cctor) using this method overload, you must specify \".cctor\" for `name`, and <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic) for `bindingAttr`."},{"content":"You can also get the class initializer using the <ph id=\"ph1\">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.","pos":[407,503],"source":" You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property."}]},{"pos":[1931,2132],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,201],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[2139,2385],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> if there is no class constraint.","pos":[0,246],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint."}]},{"pos":[2393,2670],"content":"[!NOTE]\n For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","leadings":["","> "],"nodes":[{"content":" For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","pos":[8,275],"nodes":[{"content":"For generic methods, do not include the type arguments in <ph id=\"ph1\">`name`</ph>.","pos":[1,66],"source":" For generic methods, do not include the type arguments in `name`."},{"content":"For example, the C# code <ph id=\"ph1\">`GetMember(\"MyMethod&lt;int&gt;\")`</ph> searches for a member with the text name \"<ph id=\"ph2\">`MyMethod&lt;int&gt;`</ph>\", rather than for a method named <ph id=\"ph3\">`MyMethod`</ph> that has one generic argument of type <ph id=\"ph4\">`int`</ph>.","pos":[67,267],"source":" For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`."}]}]}],"pos":[242927,245637],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the members to get.","nodes":[{"pos":[0,53],"content":"The string containing the name of the members to get.","nodes":[{"content":"The string containing the name of the members to get.","pos":[0,53]}]}],"pos":[246334,246388],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return an empty array.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,177],"content":"Zero, to return an empty array.","nodes":[{"content":"Zero, to return an empty array.","pos":[0,31]}]}],"pos":[246472,246658],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing the public members with the specified name, if found; otherwise, an empty array.","nodes":[{"pos":[0,163],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MemberInfo\"&gt;&lt;/xref&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.","source":"An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing the public members with the specified name, if found; otherwise, an empty array."}],"pos":[246732,246896],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[247047,247076],"yaml":true},{"content":"Searches for the specified members of the specified member type, using the specified binding constraints.","nodes":[{"pos":[0,105],"content":"Searches for the specified members of the specified member type, using the specified binding constraints.","nodes":[{"content":"Searches for the specified members of the specified member type, using the specified binding constraints.","pos":[0,105]}]}],"pos":[248425,248531],"yaml":true},{"content":"Members include properties, methods, fields, events, and so on.  \n  \n The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public members in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \n  \n-   `BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n To get the class initializer (.cctor) using this method overload, you must specify \".cctor\" for `name`, <xref:System.Reflection.MemberTypes?displayProperty=fullName> for `type`, and  <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic) for `bindingAttr`. You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.  \n  \n> [!NOTE]\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","nodes":[{"pos":[0,63],"content":"Members include properties, methods, fields, events, and so on.","nodes":[{"content":"Members include properties, methods, fields, events, and so on.","pos":[0,63]}]},{"pos":[70,299],"content":"The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.","pos":[0,229],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetMember%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.","pos":[0,132],"source":"The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which members are returned, because that order varies.","pos":[133,229]}]}]},{"pos":[306,432],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:","pos":[0,126],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:"}]},{"pos":[442,540],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[550,620],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public members in the search.","source":"Specify `BindingFlags.Public` to include public members in the search."},{"pos":[630,759],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search."},{"pos":[769,941],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[948,1058],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[1068,1123],"content":"<ph id=\"ph1\">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id=\"ph2\">`name`</ph>.","source":"`BindingFlags.IgnoreCase` to ignore the case of `name`."},{"pos":[1133,1263],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited."},{"pos":[1270,1358],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1365,1943],"content":"To get the class initializer (.cctor) using this method overload, you must specify \".cctor\" for `name`, <xref:System.Reflection.MemberTypes?displayProperty=fullName> for `type`, and  <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic) for `bindingAttr`. You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.","nodes":[{"content":"To get the class initializer (.cctor) using this method overload, you must specify \".cctor\" for <ph id=\"ph1\">`name`</ph>, <ph id=\"ph2\">&lt;xref:System.Reflection.MemberTypes?displayProperty=fullName&gt;</ph> for <ph id=\"ph3\">`type`</ph>, and  <ph id=\"ph4\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph5\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id=\"ph6\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph7\">`Or`</ph><ph id=\"ph8\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic) for <ph id=\"ph9\">`bindingAttr`</ph>.","pos":[0,481],"source":"To get the class initializer (.cctor) using this method overload, you must specify \".cctor\" for `name`, <xref:System.Reflection.MemberTypes?displayProperty=fullName> for `type`, and  <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic) for `bindingAttr`."},{"content":"You can also get the class initializer using the <ph id=\"ph1\">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.","pos":[482,578],"source":" You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property."}]},{"pos":[1950,2151],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.MemberInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,201],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[2158,2404],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> if there is no class constraint.","pos":[0,246],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint."}]},{"pos":[2412,2689],"content":"[!NOTE]\n For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","leadings":["","> "],"nodes":[{"content":" For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","pos":[8,275],"nodes":[{"content":"For generic methods, do not include the type arguments in <ph id=\"ph1\">`name`</ph>.","pos":[1,66],"source":" For generic methods, do not include the type arguments in `name`."},{"content":"For example, the C# code <ph id=\"ph1\">`GetMember(\"MyMethod&lt;int&gt;\")`</ph> searches for a member with the text name \"<ph id=\"ph2\">`MyMethod&lt;int&gt;`</ph>\", rather than for a method named <ph id=\"ph3\">`MyMethod`</ph> that has one generic argument of type <ph id=\"ph4\">`int`</ph>.","pos":[67,267],"source":" For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`."}]}]}],"pos":[248542,251269],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the members to get.","nodes":[{"pos":[0,53],"content":"The string containing the name of the members to get.","nodes":[{"content":"The string containing the name of the members to get.","pos":[0,53]}]}],"pos":[251988,252042],"yaml":true},{"content":"The value to search for.","nodes":[{"pos":[0,24],"content":"The value to search for.","nodes":[{"content":"The value to search for.","pos":[0,24]}]}],"pos":[252118,252143],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return an empty array.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,177],"content":"Zero, to return an empty array.","nodes":[{"content":"Zero, to return an empty array.","pos":[0,31]}]}],"pos":[252227,252413],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing the public members with the specified name, if found; otherwise, an empty array.","nodes":[{"pos":[0,163],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MemberInfo\"&gt;&lt;/xref&gt;</ph> objects representing the public members with the specified name, if found; otherwise, an empty array.","source":"An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing the public members with the specified name, if found; otherwise, an empty array."}],"pos":[252487,252651],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[252802,252831],"yaml":true},{"content":"A derived class must provide an implementation.","nodes":[{"pos":[0,47],"content":"A derived class must provide an implementation.","nodes":[{"content":"A derived class must provide an implementation.","pos":[0,47]}]}],"pos":[252933,252981],"yaml":true},{"content":"Returns all the public members of the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,79],"content":"Returns all the public members of the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Returns all the public members of the current <xref href=\"System.Type\"></xref>."}],"pos":[254009,254089],"yaml":true},{"content":"Members include properties, methods, fields, events, and so on.  \n  \n The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  \n  \n This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). It will not find class initializers (.cctor). To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.","nodes":[{"pos":[0,63],"content":"Members include properties, methods, fields, events, and so on.","nodes":[{"content":"Members include properties, methods, fields, events, and so on.","pos":[0,63]}]},{"pos":[70,300],"content":"The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.","pos":[0,230],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.","pos":[0,133],"source":"The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which members are returned, because that order varies.","pos":[134,230]}]}]},{"pos":[307,1372],"content":"This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). It will not find class initializers (.cctor). To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.","nodes":[{"content":"This method overload calls the <ph id=\"ph1\">&lt;xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29&gt;</ph> method overload, with <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph4\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id=\"ph5\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph6\">`Or`</ph><ph id=\"ph7\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph8\">`Or`</ph><ph id=\"ph9\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).","pos":[0,535],"source":"This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic)."},{"content":"It will not find class initializers (.cctor).","pos":[536,581]},{"content":"To find class initializers, use an overload that takes <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph>, and specify <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id=\"ph4\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph5\">`Or`</ph><ph id=\"ph6\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).","pos":[582,968],"source":" To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic)."},{"content":"You can also get the class initializer using the <ph id=\"ph1\">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.","pos":[969,1065],"source":" You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property."}]},{"pos":[1379,1494],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[1501,1512],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[1513,1519],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[1520,1530],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[1588,1599],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[1600,1602],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1603,1605],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1610,1615],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[1616,1618],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1619,1669],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[1674,1679],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[1680,1694],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1695,1888],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1893,1899],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[1900,1902],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1903,1998],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[2003,2014],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[2015,2017],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2018,2020],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2025,2033],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[2034,2048],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[2049,2242],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[2253,2458],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[2468,2784],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[2794,2851],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[2858,3067],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.","pos":[0,209],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments."}]},{"pos":[3074,3320],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> if there is no class constraint.","pos":[0,246],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint."}]}],"pos":[254100,257448],"yaml":true,"extradata":"MT"},{"content":"An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing all the public members of the current <xref href=\"System.Type\"></xref>.  \n  \n -or-  \n  \n An empty array of type <xref href=\"System.Reflection.MemberInfo\"></xref>, if the current <xref href=\"System.Type\"></xref> does not have public members.","nodes":[{"pos":[0,154],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MemberInfo\"&gt;&lt;/xref&gt;</ph> objects representing all the public members of the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing all the public members of the current <xref href=\"System.Type\"></xref>."},{"pos":[161,165],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[172,323],"content":"An empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MemberInfo\"&gt;&lt;/xref&gt;</ph>, if the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> does not have public members.","source":"An empty array of type <xref href=\"System.Reflection.MemberInfo\"></xref>, if the current <xref href=\"System.Type\"></xref> does not have public members."}],"pos":[258174,258512],"yaml":true},{"content":"When overridden in a derived class, searches for the members defined for the current <xref href=\"System.Type\"></xref>, using the specified binding constraints.","nodes":[{"pos":[0,159],"content":"When overridden in a derived class, searches for the members defined for the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, using the specified binding constraints.","source":"When overridden in a derived class, searches for the members defined for the current <xref href=\"System.Type\"></xref>, using the specified binding constraints."}],"pos":[259725,259885],"yaml":true},{"content":"Members include properties, methods, fields, events, and so on.  \n  \n The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public members in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search. Only protected and internal members on base classes are returned; private members on base classes are not returned.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.  \n  \n Calling this method with only the `Public` flag or only the `NonPublic` flag will return the specified members and does not require any other flags.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \n  \n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.","nodes":[{"pos":[0,63],"content":"Members include properties, methods, fields, events, and so on.","nodes":[{"content":"Members include properties, methods, fields, events, and so on.","pos":[0,63]}]},{"pos":[70,300],"content":"The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.","pos":[0,230],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetMembers%2A&gt;</ph> method does not return members in a particular order, such as alphabetical or declaration order.","pos":[0,133],"source":"The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which members are returned, because that order varies.","pos":[134,230]}]}]},{"pos":[307,433],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:","pos":[0,126],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:"}]},{"pos":[443,541],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[551,621],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public members in the search.","source":"Specify `BindingFlags.Public` to include public members in the search."},{"pos":[631,876],"content":"Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search. Only protected and internal members on base classes are returned; private members on base classes are not returned.","nodes":[{"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.","pos":[0,129],"source":"Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search."},{"content":"Only protected and internal members on base classes are returned; private members on base classes are not returned.","pos":[130,245]}]},{"pos":[886,1058],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[1065,1175],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[1185,1315],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited."},{"pos":[1322,1470],"content":"Calling this method with only the <ph id=\"ph1\">`Public`</ph> flag or only the <ph id=\"ph2\">`NonPublic`</ph> flag will return the specified members and does not require any other flags.","source":"Calling this method with only the `Public` flag or only the `NonPublic` flag will return the specified members and does not require any other flags."},{"pos":[1477,1565],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1572,2032],"content":"To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.","nodes":[{"content":"To get the class initializer (.cctor) using this method overload, you must specify <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (<ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph4\">`Or`</ph><ph id=\"ph5\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in Visual Basic).","pos":[0,363],"source":"To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic)."},{"content":"You can also get the class initializer using the <ph id=\"ph1\">&lt;xref:System.Type.TypeInitializer%2A&gt;</ph> property.","pos":[364,460],"source":" You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property."}]},{"pos":[2039,2243],"content":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current T:System.Type represents a constructed generic type, this method returns the <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.","pos":[0,204],"source":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments."}]},{"pos":[2250,2496],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> if there is no class constraint.","pos":[0,246],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint."}]}],"pos":[259896,262421],"yaml":true,"extradata":"MT"},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero (<xref href=\"System.Reflection.BindingFlags.Default\"></xref>), to return an empty array.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,239],"content":"Zero (<ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags.Default\"&gt;&lt;/xref&gt;</ph>), to return an empty array.","source":"Zero (<xref href=\"System.Reflection.BindingFlags.Default\"></xref>), to return an empty array."}],"pos":[263250,263500],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing all members defined for the current <xref href=\"System.Type\"></xref> that match the specified binding constraints.  \n  \n -or-  \n  \n An empty array of type <xref href=\"System.Reflection.MemberInfo\"></xref>, if no members are defined for the current <xref href=\"System.Type\"></xref>, or if none of the defined members match the binding constraints.","nodes":[{"pos":[0,197],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MemberInfo\"&gt;&lt;/xref&gt;</ph> objects representing all members defined for the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints.","source":"An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing all members defined for the current <xref href=\"System.Type\"></xref> that match the specified binding constraints."},{"pos":[204,208],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[215,429],"content":"An empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MemberInfo\"&gt;&lt;/xref&gt;</ph>, if no members are defined for the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, or if none of the defined members match the binding constraints.","source":"An empty array of type <xref href=\"System.Reflection.MemberInfo\"></xref>, if no members are defined for the current <xref href=\"System.Type\"></xref>, or if none of the defined members match the binding constraints."}],"pos":[263574,264018],"yaml":true},{"content":"Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.","nodes":[{"pos":[0,178],"content":"Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.","nodes":[{"content":"Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.","pos":[0,178]}]}],"pos":[265804,265983],"yaml":true},{"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \n  \n The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public methods in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \n  \n-   `BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n> [!NOTE]\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \n  \n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.  \n  \n> [!NOTE]\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","nodes":[{"pos":[0,389],"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.","nodes":[{"content":"Although the default binder does not process <ph id=\"ph1\">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id=\"ph2\">`modifiers`</ph> parameter), you can use the abstract <ph id=\"ph3\">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id=\"ph4\">`modifiers`</ph>.","pos":[0,260],"source":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`."},{"content":"<ph id=\"ph1\">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.","pos":[261,389],"source":"`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled."}]},{"pos":[396,514],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`GetXXX`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type."},{"pos":[521,532],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[533,539],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[540,550],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[608,619],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[620,622],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[623,625],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[630,635],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[636,638],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[639,689],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[694,699],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[700,714],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[715,908],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[913,919],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[920,922],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[923,1018],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[1023,1034],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[1035,1037],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1038,1040],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1045,1053],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[1054,1068],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1069,1262],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1273,1478],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[1488,1804],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[1814,1871],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[1878,2004],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:","pos":[0,126],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:"}]},{"pos":[2014,2112],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[2122,2192],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public methods in the search.","source":"Specify `BindingFlags.Public` to include public methods in the search."},{"pos":[2202,2330],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include nonpublic methods (that is, private, internal, and protected methods) in the search.","source":"Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search."},{"pos":[2340,2512],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[2519,2629],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[2639,2694],"content":"<ph id=\"ph1\">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id=\"ph2\">`name`</ph>.","source":"`BindingFlags.IgnoreCase` to ignore the case of `name`."},{"pos":[2704,2834],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited."},{"pos":[2841,2929],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[2937,3060],"content":"[!NOTE]\n You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","leadings":["","> "],"nodes":[{"content":" You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","pos":[8,121],"nodes":[{"content":"You cannot omit parameters when looking up constructors and methods.","pos":[1,69]},{"content":"You can only omit parameters when invoking.","pos":[70,113]}]}]},{"pos":[3067,3263],"content":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current T:System.Type represents a constructed generic type, this method returns the <ph id=\"ph1\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,196],"source":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[3270,3516],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> if there is no class constraint.","pos":[0,246],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint."}]},{"pos":[3524,3801],"content":"[!NOTE]\n For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","leadings":["","> "],"nodes":[{"content":" For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","pos":[8,275],"nodes":[{"content":"For generic methods, do not include the type arguments in <ph id=\"ph1\">`name`</ph>.","pos":[1,66],"source":" For generic methods, do not include the type arguments in `name`."},{"content":"For example, the C# code <ph id=\"ph1\">`GetMember(\"MyMethod&lt;int&gt;\")`</ph> searches for a member with the text name \"<ph id=\"ph2\">`MyMethod&lt;int&gt;`</ph>\", rather than for a method named <ph id=\"ph3\">`MyMethod`</ph> that has one generic argument of type <ph id=\"ph4\">`int`</ph>.","pos":[67,267],"source":" For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`."}]}]}],"pos":[265994,269847],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the method to get.","nodes":[{"pos":[0,52],"content":"The string containing the name of the method to get.","nodes":[{"content":"The string containing the name of the method to get.","pos":[0,52]}]}],"pos":[270849,270902],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[270986,271164],"yaml":true},{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \n  \n -or-  \n  \n A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>.","nodes":[{"pos":[0,191],"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","nodes":[{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","pos":[0,191]}]},{"pos":[198,202],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[209,313],"content":"A null reference (<ph id=\"ph1\">`Nothing`</ph> in Visual Basic), to use the <ph id=\"ph2\">&lt;xref href=\"System.Type.DefaultBinder\"&gt;&lt;/xref&gt;</ph>.","source":"A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>."}],"pos":[271237,271559],"yaml":true},{"content":"The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.","nodes":[{"pos":[0,198],"content":"The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.","nodes":[{"content":"The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.","pos":[0,198]}]}],"pos":[271652,271851],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the method to get.  \n  \n -or-  \n  \n An empty array of <xref href=\"System.Type\"></xref> objects (as provided by the <xref href=\"System.Type.EmptyTypes\"></xref> field) to get a method that takes no parameters.","nodes":[{"pos":[0,134],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the method to get."},{"pos":[141,145],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[152,323],"content":"An empty array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects (as provided by the <ph id=\"ph2\">&lt;xref href=\"System.Type.EmptyTypes\"&gt;&lt;/xref&gt;</ph> field) to get a method that takes no parameters.","source":"An empty array of <xref href=\"System.Type\"></xref> objects (as provided by the <xref href=\"System.Type.EmptyTypes\"></xref> field) to get a method that takes no parameters."}],"pos":[271912,272248],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.","nodes":[{"pos":[0,343],"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.","nodes":[{"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ParameterModifier\"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> array.","pos":[0,179],"source":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array."},{"content":"To be only used when calling through COM interop, and only parameters that are passed by reference are handled.","pos":[180,291]},{"content":"The default binder does not process this parameter.","pos":[292,343]}]}],"pos":[272337,272681],"yaml":true},{"content":"An object representing the method that matches the specified requirements, if found; otherwise, `null`.","nodes":[{"pos":[0,103],"content":"An object representing the method that matches the specified requirements, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the method that matches the specified requirements, if found; otherwise, `null`."}],"pos":[272753,272857],"yaml":true},{"content":"More than one method is found with the specified name and matching the specified binding constraints.","nodes":[{"pos":[0,101],"content":"More than one method is found with the specified name and matching the specified binding constraints.","nodes":[{"content":"More than one method is found with the specified name and matching the specified binding constraints.","pos":[0,101]}]}],"pos":[273034,273136],"yaml":true},{"content":"<code>name</code> is `null`.  \n  \n -or-  \n  \n <code>types</code> is `null`.  \n  \n -or-  \n  \n One of the elements in <code>types</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."},{"pos":[35,39],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[46,75],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>types</code> is `null`."},{"pos":[82,86],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[93,145],"content":"One of the elements in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"One of the elements in <code>types</code> is `null`."}],"pos":[273238,273394],"yaml":true},{"content":"<code>types</code> is multidimensional.  \n  \n -or-  \n  \n <code>modifiers</code> is multidimensional.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.","source":"<code>types</code> is multidimensional."},{"pos":[46,50],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[57,100],"content":"<ph id=\"ph1\">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.","source":"<code>modifiers</code> is multidimensional."}],"pos":[273488,273595],"yaml":true},{"content":"Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.","nodes":[{"pos":[0,141],"content":"Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.","nodes":[{"content":"Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.","pos":[0,141]}]}],"pos":[275157,275299],"yaml":true},{"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public methods in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \n  \n-   `BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n> [!NOTE]\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \n  \n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.  \n  \n> [!NOTE]\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","nodes":[{"pos":[0,389],"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.","nodes":[{"content":"Although the default binder does not process <ph id=\"ph1\">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id=\"ph2\">`modifiers`</ph> parameter), you can use the abstract <ph id=\"ph3\">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id=\"ph4\">`modifiers`</ph>.","pos":[0,260],"source":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`."},{"content":"<ph id=\"ph1\">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.","pos":[261,389],"source":"`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled."}]},{"pos":[396,522],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:","pos":[0,126],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:"}]},{"pos":[532,630],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[640,710],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public methods in the search.","source":"Specify `BindingFlags.Public` to include public methods in the search."},{"pos":[720,848],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include nonpublic methods (that is, private, internal, and protected methods) in the search.","source":"Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search."},{"pos":[858,1030],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[1037,1147],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[1157,1212],"content":"<ph id=\"ph1\">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id=\"ph2\">`name`</ph>.","source":"`BindingFlags.IgnoreCase` to ignore the case of `name`."},{"pos":[1222,1352],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited."},{"pos":[1359,1447],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1455,1578],"content":"[!NOTE]\n You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","leadings":["","> "],"nodes":[{"content":" You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","pos":[8,121],"nodes":[{"content":"You cannot omit parameters when looking up constructors and methods.","pos":[1,69]},{"content":"You can only omit parameters when invoking.","pos":[70,113]}]}]},{"pos":[1585,1781],"content":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current T:System.Type represents a constructed generic type, this method returns the <ph id=\"ph1\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,196],"source":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[1788,2034],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> if there is no class constraint.","pos":[0,246],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint."}]},{"pos":[2042,2319],"content":"[!NOTE]\n For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","leadings":["","> "],"nodes":[{"content":" For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","pos":[8,275],"nodes":[{"content":"For generic methods, do not include the type arguments in <ph id=\"ph1\">`name`</ph>.","pos":[1,66],"source":" For generic methods, do not include the type arguments in `name`."},{"content":"For example, the C# code <ph id=\"ph1\">`GetMember(\"MyMethod&lt;int&gt;\")`</ph> searches for a member with the text name \"<ph id=\"ph2\">`MyMethod&lt;int&gt;`</ph>\", rather than for a method named <ph id=\"ph3\">`MyMethod`</ph> that has one generic argument of type <ph id=\"ph4\">`int`</ph>.","pos":[67,267],"source":" For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`."}]}]}],"pos":[275310,277664],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the method to get.","nodes":[{"pos":[0,52],"content":"The string containing the name of the method to get.","nodes":[{"content":"The string containing the name of the method to get.","pos":[0,52]}]}],"pos":[278591,278644],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[278728,278906],"yaml":true},{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \n  \n -or-  \n  \n A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>.","nodes":[{"pos":[0,191],"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","nodes":[{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","pos":[0,191]}]},{"pos":[198,202],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[209,313],"content":"A null reference (<ph id=\"ph1\">`Nothing`</ph> in Visual Basic), to use the <ph id=\"ph2\">&lt;xref href=\"System.Type.DefaultBinder\"&gt;&lt;/xref&gt;</ph>.","source":"A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>."}],"pos":[278979,279301],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the method to get.  \n  \n -or-  \n  \n An empty array of <xref href=\"System.Type\"></xref> objects (as provided by the <xref href=\"System.Type.EmptyTypes\"></xref> field) to get a method that takes no parameters.","nodes":[{"pos":[0,134],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the method to get."},{"pos":[141,145],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[152,323],"content":"An empty array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects (as provided by the <ph id=\"ph2\">&lt;xref href=\"System.Type.EmptyTypes\"&gt;&lt;/xref&gt;</ph> field) to get a method that takes no parameters.","source":"An empty array of <xref href=\"System.Type\"></xref> objects (as provided by the <xref href=\"System.Type.EmptyTypes\"></xref> field) to get a method that takes no parameters."}],"pos":[279362,279698],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.","nodes":[{"pos":[0,343],"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.","nodes":[{"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ParameterModifier\"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> array.","pos":[0,179],"source":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array."},{"content":"To be only used when calling through COM interop, and only parameters that are passed by reference are handled.","pos":[180,291]},{"content":"The default binder does not process this parameter.","pos":[292,343]}]}],"pos":[279787,280131],"yaml":true},{"content":"An object representing the method that matches the specified requirements, if found; otherwise, `null`.","nodes":[{"pos":[0,103],"content":"An object representing the method that matches the specified requirements, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the method that matches the specified requirements, if found; otherwise, `null`."}],"pos":[280203,280307],"yaml":true},{"content":"More than one method is found with the specified name and matching the specified binding constraints.","nodes":[{"pos":[0,101],"content":"More than one method is found with the specified name and matching the specified binding constraints.","nodes":[{"content":"More than one method is found with the specified name and matching the specified binding constraints.","pos":[0,101]}]}],"pos":[280484,280586],"yaml":true},{"content":"<code>name</code> is `null`.  \n  \n -or-  \n  \n <code>types</code> is `null`.  \n  \n -or-  \n  \n One of the elements in <code>types</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."},{"pos":[35,39],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[46,75],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>types</code> is `null`."},{"pos":[82,86],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[93,145],"content":"One of the elements in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"One of the elements in <code>types</code> is `null`."}],"pos":[280688,280844],"yaml":true},{"content":"<code>types</code> is multidimensional.  \n  \n -or-  \n  \n <code>modifiers</code> is multidimensional.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.","source":"<code>types</code> is multidimensional."},{"pos":[46,50],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[57,100],"content":"<ph id=\"ph1\">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.","source":"<code>modifiers</code> is multidimensional."}],"pos":[280938,281045],"yaml":true},{"content":"Searches for the specified public method whose parameters match the specified argument types and modifiers.","nodes":[{"pos":[0,107],"content":"Searches for the specified public method whose parameters match the specified argument types and modifiers.","nodes":[{"content":"Searches for the specified public method whose parameters match the specified argument types and modifiers.","pos":[0,107]}]}],"pos":[282373,282481],"yaml":true},{"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \n  \n The search for `name` is case-sensitive. The search includes public static and public instance methods.  \n  \n> [!NOTE]\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \n  \n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.  \n  \n> [!NOTE]\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMethod(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`. Instead, use `GetMethod(\"MyMethod\")` with the appropriate parameter in the `types` array.","nodes":[{"pos":[0,389],"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.","nodes":[{"content":"Although the default binder does not process <ph id=\"ph1\">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id=\"ph2\">`modifiers`</ph> parameter), you can use the abstract <ph id=\"ph3\">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id=\"ph4\">`modifiers`</ph>.","pos":[0,260],"source":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`."},{"content":"<ph id=\"ph1\">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.","pos":[261,389],"source":"`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled."}]},{"pos":[396,499],"content":"The search for `name` is case-sensitive. The search includes public static and public instance methods.","nodes":[{"content":"The search for <ph id=\"ph1\">`name`</ph> is case-sensitive.","pos":[0,40],"source":"The search for `name` is case-sensitive."},{"content":"The search includes public static and public instance methods.","pos":[41,103]}]},{"pos":[507,630],"content":"[!NOTE]\n You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","leadings":["","> "],"nodes":[{"content":" You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","pos":[8,121],"nodes":[{"content":"You cannot omit parameters when looking up constructors and methods.","pos":[1,69]},{"content":"You can only omit parameters when invoking.","pos":[70,113]}]}]},{"pos":[637,833],"content":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current T:System.Type represents a constructed generic type, this method returns the <ph id=\"ph1\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,196],"source":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[840,1086],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> if there is no class constraint.","pos":[0,246],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint."}]},{"pos":[1094,1461],"content":"[!NOTE]\n For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMethod(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`. Instead, use `GetMethod(\"MyMethod\")` with the appropriate parameter in the `types` array.","leadings":["","> "],"nodes":[{"content":" For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMethod(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`. Instead, use `GetMethod(\"MyMethod\")` with the appropriate parameter in the `types` array.","pos":[8,365],"nodes":[{"content":"For generic methods, do not include the type arguments in <ph id=\"ph1\">`name`</ph>.","pos":[1,66],"source":" For generic methods, do not include the type arguments in `name`."},{"content":"For example, the C# code <ph id=\"ph1\">`GetMethod(\"MyMethod&lt;int&gt;\")`</ph> searches for a member with the text name \"<ph id=\"ph2\">`MyMethod&lt;int&gt;`</ph>\", rather than for a method named <ph id=\"ph3\">`MyMethod`</ph> that has one generic argument of type <ph id=\"ph4\">`int`</ph>.","pos":[67,267],"source":" For example, the C# code `GetMethod(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`."},{"content":"Instead, use <ph id=\"ph1\">`GetMethod(\"MyMethod\")`</ph> with the appropriate parameter in the <ph id=\"ph2\">`types`</ph> array.","pos":[268,357],"source":" Instead, use `GetMethod(\"MyMethod\")` with the appropriate parameter in the `types` array."}]}]}],"pos":[282492,283974],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the public method to get.","nodes":[{"pos":[0,59],"content":"The string containing the name of the public method to get.","nodes":[{"content":"The string containing the name of the public method to get.","pos":[0,59]}]}],"pos":[284197,284257],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the method to get.  \n  \n -or-  \n  \n An empty array of <xref href=\"System.Type\"></xref> objects (as provided by the <xref href=\"System.Type.EmptyTypes\"></xref> field) to get a method that takes no parameters.","nodes":[{"pos":[0,134],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the method to get."},{"pos":[141,145],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[152,323],"content":"An empty array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects (as provided by the <ph id=\"ph2\">&lt;xref href=\"System.Type.EmptyTypes\"&gt;&lt;/xref&gt;</ph> field) to get a method that takes no parameters.","source":"An empty array of <xref href=\"System.Type\"></xref> objects (as provided by the <xref href=\"System.Type.EmptyTypes\"></xref> field) to get a method that takes no parameters."}],"pos":[284318,284654],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.","nodes":[{"pos":[0,343],"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.","nodes":[{"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ParameterModifier\"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> array.","pos":[0,179],"source":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array."},{"content":"To be only used when calling through COM interop, and only parameters that are passed by reference are handled.","pos":[180,291]},{"content":"The default binder does not process this parameter.","pos":[292,343]}]}],"pos":[284743,285087],"yaml":true},{"content":"An object representing the public method that matches the specified requirements, if found; otherwise, `null`.","nodes":[{"pos":[0,110],"content":"An object representing the public method that matches the specified requirements, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the public method that matches the specified requirements, if found; otherwise, `null`."}],"pos":[285159,285270],"yaml":true},{"content":"More than one method is found with the specified name and specified parameters.","nodes":[{"pos":[0,79],"content":"More than one method is found with the specified name and specified parameters.","nodes":[{"content":"More than one method is found with the specified name and specified parameters.","pos":[0,79]}]}],"pos":[285447,285527],"yaml":true},{"content":"<code>name</code> is `null`.  \n  \n -or-  \n  \n <code>types</code> is `null`.  \n  \n -or-  \n  \n One of the elements in <code>types</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."},{"pos":[35,39],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[46,75],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>types</code> is `null`."},{"pos":[82,86],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[93,145],"content":"One of the elements in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"One of the elements in <code>types</code> is `null`."}],"pos":[285629,285785],"yaml":true},{"content":"<code>types</code> is multidimensional.  \n  \n -or-  \n  \n <code>modifiers</code> is multidimensional.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.","source":"<code>types</code> is multidimensional."},{"pos":[46,50],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[57,100],"content":"<ph id=\"ph1\">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.","source":"<code>modifiers</code> is multidimensional."}],"pos":[285879,285986],"yaml":true},{"content":"Searches for the public method with the specified name.","nodes":[{"pos":[0,55],"content":"Searches for the public method with the specified name.","nodes":[{"content":"Searches for the public method with the specified name.","pos":[0,55]}]}],"pos":[287071,287127],"yaml":true},{"content":"The search for `name` is case-sensitive. The search includes public static and public instance methods.  \n  \n If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception. In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=fullName> method.  On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=fullName> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.  \n  \n [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]\n [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  \n  \n You can do one of the following to retrieve a specific method:  \n  \n-   Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method. For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName>.  \n  \n-   Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.  \n  \n-   Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type. You can then iterate it to identify the duplicate methods named `name`.  \n  \n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.  \n  \n> [!NOTE]\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","nodes":[{"pos":[0,103],"content":"The search for `name` is case-sensitive. The search includes public static and public instance methods.","nodes":[{"content":"The search for <ph id=\"ph1\">`name`</ph> is case-sensitive.","pos":[0,40],"source":"The search for `name` is case-sensitive."},{"content":"The search includes public static and public instance methods.","pos":[41,103]}]},{"pos":[110,755],"content":"If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception. In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=fullName> method.  On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=fullName> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.","nodes":[{"content":"If a method is overloaded and has more than one public method, the <ph id=\"ph1\">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> method throws an <ph id=\"ph2\">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.","pos":[0,191],"source":"If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception."},{"content":"In the following example, an exception is thrown because there is more than one public overload of the <ph id=\"ph1\">&lt;xref:System.Int32.ToString%2A?displayProperty=fullName&gt;</ph> method.","pos":[192,359],"source":" In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=fullName> method."},{"content":"On the other hand, because the <ph id=\"ph1\">`Person.ToString`</ph> method overrides  <ph id=\"ph2\">&lt;xref:System.Object.ToString%2A?displayProperty=fullName&gt;</ph> and therefore is not overloaded, the <ph id=\"ph3\">&lt;xref:System.Type.GetMethod%28System.String%29&gt;</ph> method is able to retrieve the <ph id=\"ph4\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object.","pos":[361,645],"source":"  On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=fullName> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object."}]},{"pos":[762,1051],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Type.GetMethod#3<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Type.GetMethod#3<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]\n [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]"},{"pos":[1058,1120],"content":"You can do one of the following to retrieve a specific method:","nodes":[{"content":"You can do one of the following to retrieve a specific method:","pos":[0,62]}]},{"pos":[1130,1570],"content":"Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method. For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName>.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method and specify a <ph id=\"ph2\">`bindingAttr`</ph> argument that uniquely identifies the method.","pos":[0,170],"source":"Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method."},{"content":"For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  <ph id=\"ph1\">`bindingAttr`</ph> argument  of <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph><ph id=\"ph3\">`Or`</ph><ph id=\"ph4\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph>.","pos":[171,440],"source":" For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName>."}]},{"pos":[1580,1728],"content":"Call an overload of the <ph id=\"ph1\">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method that includes a <ph id=\"ph2\">`types`</ph> parameter which defines the types of the method's parameters.","source":"Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters."},{"pos":[1738,1934],"content":"Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type. You can then iterate it to identify the duplicate methods named `name`.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Type.GetMethods&gt;</ph> method to retrieve an array containing all of the public methods belonging to a type.","pos":[0,124],"source":"Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type."},{"content":"You can then iterate it to identify the duplicate methods named <ph id=\"ph1\">`name`</ph>.","pos":[125,196],"source":" You can then iterate it to identify the duplicate methods named `name`."}]},{"pos":[1941,2137],"content":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current T:System.Type represents a constructed generic type, this method returns the <ph id=\"ph1\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,196],"source":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[2144,2390],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> if there is no class constraint.","pos":[0,246],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint."}]},{"pos":[2398,2675],"content":"[!NOTE]\n For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","leadings":["","> "],"nodes":[{"content":" For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","pos":[8,275],"nodes":[{"content":"For generic methods, do not include the type arguments in <ph id=\"ph1\">`name`</ph>.","pos":[1,66],"source":" For generic methods, do not include the type arguments in `name`."},{"content":"For example, the C# code <ph id=\"ph1\">`GetMember(\"MyMethod&lt;int&gt;\")`</ph> searches for a member with the text name \"<ph id=\"ph2\">`MyMethod&lt;int&gt;`</ph>\", rather than for a method named <ph id=\"ph3\">`MyMethod`</ph> that has one generic argument of type <ph id=\"ph4\">`int`</ph>.","pos":[67,267],"source":" For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`."}]}]}],"pos":[287138,289840],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the public method to get.","nodes":[{"pos":[0,59],"content":"The string containing the name of the public method to get.","nodes":[{"content":"The string containing the name of the public method to get.","pos":[0,59]}]}],"pos":[290430,290490],"yaml":true},{"content":"An object that represents the public method with the specified name, if found; otherwise, `null`.","nodes":[{"pos":[0,97],"content":"An object that represents the public method with the specified name, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object that represents the public method with the specified name, if found; otherwise, `null`."}],"pos":[290562,290660],"yaml":true},{"content":"More than one method is found with the specified name.","nodes":[{"pos":[0,54],"content":"More than one method is found with the specified name.","nodes":[{"content":"More than one method is found with the specified name.","pos":[0,54]}]}],"pos":[290837,290892],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[290994,291023],"yaml":true},{"content":"Searches for the specified method, using the specified binding constraints.","nodes":[{"pos":[0,75],"content":"Searches for the specified method, using the specified binding constraints.","nodes":[{"content":"Searches for the specified method, using the specified binding constraints.","pos":[0,75]}]}],"pos":[292243,292319],"yaml":true},{"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:  \n  \n-   You must specify either <xref:System.Reflection.BindingFlags?displayProperty=fullName> or <xref:System.Reflection.BindingFlags?displayProperty=fullName> in order to get a return.  \n  \n-   Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include public methods in the search.  \n  \n-   Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include non-public methods (that is, private, internal, and protected methods) in the search.  \n  \n-   Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   <xref:System.Reflection.BindingFlags?displayProperty=fullName> to ignore the case of `name`.  \n  \n-   <xref:System.Reflection.BindingFlags?displayProperty=fullName> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception. In the following example, an exception is thrown because:  \n  \n-   The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`.  \n  \n-   The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`.  \n  \n [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]\n [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  \n  \n You can do one of the following to retrieve a specific method:  \n  \n-   Change the binding constraints. In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.  \n  \n-   Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.  \n  \n-   Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes. You can then iterate it to identify the duplicate methods named `name`. This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.  \n  \n> [!NOTE]\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","nodes":[{"pos":[0,126],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:","pos":[0,126],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:"}]},{"pos":[136,314],"content":"You must specify either <xref:System.Reflection.BindingFlags?displayProperty=fullName> or <xref:System.Reflection.BindingFlags?displayProperty=fullName> in order to get a return.","nodes":[{"content":"You must specify either <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> in order to get a return.","pos":[0,178],"source":"You must specify either <xref:System.Reflection.BindingFlags?displayProperty=fullName> or <xref:System.Reflection.BindingFlags?displayProperty=fullName> in order to get a return."}]},{"pos":[324,435],"content":"Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include public methods in the search.","nodes":[{"content":"Specify <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to include public methods in the search.","pos":[0,111],"source":"Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include public methods in the search."}]},{"pos":[445,612],"content":"Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include non-public methods (that is, private, internal, and protected methods) in the search.","nodes":[{"content":"Specify <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.","pos":[0,167],"source":"Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include non-public methods (that is, private, internal, and protected methods) in the search."}]},{"pos":[622,825],"content":"Specify <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[832,942],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[952,1044],"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to ignore the case of <ph id=\"ph2\">`name`</ph>.","source":"<xref:System.Reflection.BindingFlags?displayProperty=fullName> to ignore the case of `name`."},{"pos":[1054,1219],"content":"<xref:System.Reflection.BindingFlags?displayProperty=fullName> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to search only the methods declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.","pos":[0,165],"source":"<xref:System.Reflection.BindingFlags?displayProperty=fullName> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited."}]},{"pos":[1226,1314],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1321,1575],"content":"If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception. In the following example, an exception is thrown because:","nodes":[{"content":"If a method is overloaded and more than one overload meets the constraints specified by the <ph id=\"ph1\">`bindingAttr`</ph> argument, the method throws an <ph id=\"ph2\">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.","pos":[0,196],"source":"If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception."},{"content":"In the following example, an exception is thrown because:","pos":[197,254]}]},{"pos":[1585,1730],"content":"The <ph id=\"ph1\">`TestClass`</ph> type has two public instance overloads of the <ph id=\"ph2\">`DisplayValue`</ph> method, <ph id=\"ph3\">`DisplayValue(String)`</ph> and <ph id=\"ph4\">`DisplayValue(String, Object[])`</ph>.","source":"The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`."},{"pos":[1740,1914],"content":"The <ph id=\"ph1\">`TestClass`</ph> type has two public instance overloads of the <ph id=\"ph2\">`Equals`</ph> method,  one of which is inherited from <ph id=\"ph3\">&lt;xref:System.Object&gt;</ph>: <ph id=\"ph4\">`Equals(TestClass)`</ph> and <ph id=\"ph5\">`Equals(Object)`</ph>.","source":"The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`."},{"pos":[1921,2210],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Type.GetMethod#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Type.GetMethod#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)</ept><ept id=\"p3\">]</ept>","leadings":[""," "],"source":"[!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]\n[!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]"},{"pos":[2217,2279],"content":"You can do one of the following to retrieve a specific method:","nodes":[{"content":"You can do one of the following to retrieve a specific method:","pos":[0,62]}]},{"pos":[2289,2493],"content":"Change the binding constraints. In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.","nodes":[{"content":"Change the binding constraints.","pos":[0,31]},{"content":"In the previous example, attempting to retrieve a public instance <ph id=\"ph1\">`Equals`</ph> method that is declared by the type and not inherited successfully retrieves <ph id=\"ph2\">`Equals(TestClass)`</ph>.","pos":[32,204],"source":" In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`."}]},{"pos":[2503,2651],"content":"Call an overload of the <ph id=\"ph1\">&lt;xref:System.Type.GetMethod%2A&gt;</ph> method that includes a <ph id=\"ph2\">`types`</ph> parameter which defines the types of the method's parameters.","source":"Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters."},{"pos":[2661,3060],"content":"Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes. You can then iterate it to identify the duplicate methods named `name`. This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29&gt;</ph> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.","pos":[0,196],"source":"Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes."},{"content":"You can then iterate it to identify the duplicate methods named <ph id=\"ph1\">`name`</ph>.","pos":[197,268],"source":" You can then iterate it to identify the duplicate methods named `name`."},{"content":"This approach is illustrated in the previous example's handler for the <ph id=\"ph1\">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> exception.","pos":[269,399],"source":" This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception."}]},{"pos":[3067,3268],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,201],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[3275,3521],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> if there is no class constraint.","pos":[0,246],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint."}]},{"pos":[3529,3806],"content":"[!NOTE]\n For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","leadings":["","> "],"nodes":[{"content":" For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`.","pos":[8,275],"nodes":[{"content":"For generic methods, do not include the type arguments in <ph id=\"ph1\">`name`</ph>.","pos":[1,66],"source":" For generic methods, do not include the type arguments in `name`."},{"content":"For example, the C# code <ph id=\"ph1\">`GetMember(\"MyMethod&lt;int&gt;\")`</ph> searches for a member with the text name \"<ph id=\"ph2\">`MyMethod&lt;int&gt;`</ph>\", rather than for a method named <ph id=\"ph3\">`MyMethod`</ph> that has one generic argument of type <ph id=\"ph4\">`int`</ph>.","pos":[67,267],"source":" For example, the C# code `GetMember(\"MyMethod<int>\")` searches for a member with the text name \"`MyMethod<int>`\", rather than for a method named `MyMethod` that has one generic argument of type `int`."}]}]}],"pos":[292330,296183],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the method to get.","nodes":[{"pos":[0,52],"content":"The string containing the name of the method to get.","nodes":[{"content":"The string containing the name of the method to get.","pos":[0,52]}]}],"pos":[296844,296897],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[296981,297159],"yaml":true},{"content":"An object representing the method that matches the specified requirements, if found; otherwise, `null`.","nodes":[{"pos":[0,103],"content":"An object representing the method that matches the specified requirements, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the method that matches the specified requirements, if found; otherwise, `null`."}],"pos":[297231,297335],"yaml":true},{"content":"More than one method is found with the specified name and matching the specified binding constraints.","nodes":[{"pos":[0,101],"content":"More than one method is found with the specified name and matching the specified binding constraints.","nodes":[{"content":"More than one method is found with the specified name and matching the specified binding constraints.","pos":[0,101]}]}],"pos":[297512,297614],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[297716,297745],"yaml":true},{"content":"Searches for the specified public method whose parameters match the specified argument types.","nodes":[{"pos":[0,93],"content":"Searches for the specified public method whose parameters match the specified argument types.","nodes":[{"content":"Searches for the specified public method whose parameters match the specified argument types.","pos":[0,93]}]}],"pos":[298896,298990],"yaml":true},{"content":"The search for `name` is case-sensitive. The search includes public static and public instance methods.  \n  \n> [!NOTE]\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.  \n  \n> [!NOTE]\n>  The `name` parameter cannot include type arguments. For example, the C# code `GetMethod(\"MyGenericMethod<int>\")` searches for a method with the text name \"`MyGenericMethod<int>`\", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`. Instead, use `GetMethod(\"MyGenericMethod\")` with the appropriate parameter in the `types` array.","nodes":[{"pos":[0,103],"content":"The search for `name` is case-sensitive. The search includes public static and public instance methods.","nodes":[{"content":"The search for <ph id=\"ph1\">`name`</ph> is case-sensitive.","pos":[0,40],"source":"The search for `name` is case-sensitive."},{"content":"The search includes public static and public instance methods.","pos":[41,103]}]},{"pos":[111,234],"content":"[!NOTE]\n You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","leadings":["","> "],"nodes":[{"content":" You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","pos":[8,121],"nodes":[{"content":"You cannot omit parameters when looking up constructors and methods.","pos":[1,69]},{"content":"You can only omit parameters when invoking.","pos":[70,113]}]}]},{"pos":[241,442],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,201],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[449,695],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> if there is no class constraint.","pos":[0,246],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint."}]},{"pos":[703,1084],"content":"[!NOTE]\n The `name` parameter cannot include type arguments. For example, the C# code `GetMethod(\"MyGenericMethod<int>\")` searches for a method with the text name \"`MyGenericMethod<int>`\", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`. Instead, use `GetMethod(\"MyGenericMethod\")` with the appropriate parameter in the `types` array.","leadings":["","> "],"nodes":[{"content":" The `name` parameter cannot include type arguments. For example, the C# code `GetMethod(\"MyGenericMethod<int>\")` searches for a method with the text name \"`MyGenericMethod<int>`\", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`. Instead, use `GetMethod(\"MyGenericMethod\")` with the appropriate parameter in the `types` array.","pos":[8,379],"nodes":[{"content":"The <ph id=\"ph1\">`name`</ph> parameter cannot include type arguments.","pos":[1,52],"source":" The `name` parameter cannot include type arguments."},{"content":"For example, the C# code <ph id=\"ph1\">`GetMethod(\"MyGenericMethod&lt;int&gt;\")`</ph> searches for a method with the text name \"<ph id=\"ph2\">`MyGenericMethod&lt;int&gt;`</ph>\", rather than for a method named <ph id=\"ph3\">`MyGenericMethod`</ph> that has one generic argument of type <ph id=\"ph4\">`int`</ph>.","pos":[53,274],"source":" For example, the C# code `GetMethod(\"MyGenericMethod<int>\")` searches for a method with the text name \"`MyGenericMethod<int>`\", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`."},{"content":"Instead, use <ph id=\"ph1\">`GetMethod(\"MyGenericMethod\")`</ph> with the appropriate parameter in the <ph id=\"ph2\">`types`</ph> array.","pos":[275,371],"source":" Instead, use `GetMethod(\"MyGenericMethod\")` with the appropriate parameter in the `types` array."}]}]}],"pos":[299001,300104],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the public method to get.","nodes":[{"pos":[0,59],"content":"The string containing the name of the public method to get.","nodes":[{"content":"The string containing the name of the public method to get.","pos":[0,59]}]}],"pos":[301915,301975],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the method to get.  \n  \n -or-  \n  \n An empty array of <xref href=\"System.Type\"></xref> objects (as provided by the <xref href=\"System.Type.EmptyTypes\"></xref> field) to get a method that takes no parameters.","nodes":[{"pos":[0,134],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the method to get."},{"pos":[141,145],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[152,323],"content":"An empty array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects (as provided by the <ph id=\"ph2\">&lt;xref href=\"System.Type.EmptyTypes\"&gt;&lt;/xref&gt;</ph> field) to get a method that takes no parameters.","source":"An empty array of <xref href=\"System.Type\"></xref> objects (as provided by the <xref href=\"System.Type.EmptyTypes\"></xref> field) to get a method that takes no parameters."}],"pos":[302036,302372],"yaml":true},{"content":"An object representing the public method whose parameters match the specified argument types, if found; otherwise, `null`.","nodes":[{"pos":[0,122],"content":"An object representing the public method whose parameters match the specified argument types, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the public method whose parameters match the specified argument types, if found; otherwise, `null`."}],"pos":[302444,302567],"yaml":true},{"content":"More than one method is found with the specified name and specified parameters.","nodes":[{"pos":[0,79],"content":"More than one method is found with the specified name and specified parameters.","nodes":[{"content":"More than one method is found with the specified name and specified parameters.","pos":[0,79]}]}],"pos":[302744,302824],"yaml":true},{"content":"<code>name</code> is `null`.  \n  \n -or-  \n  \n <code>types</code> is `null`.  \n  \n -or-  \n  \n One of the elements in <code>types</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."},{"pos":[35,39],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[46,75],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>types</code> is `null`."},{"pos":[82,86],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[93,145],"content":"One of the elements in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"One of the elements in <code>types</code> is `null`."}],"pos":[302926,303082],"yaml":true},{"content":"<code>types</code> is multidimensional.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.","source":"<code>types</code> is multidimensional."}],"pos":[303176,303216],"yaml":true},{"content":"When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.","nodes":[{"pos":[0,214],"content":"When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.","nodes":[{"content":"When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.","pos":[0,214]}]}],"pos":[304973,305188],"yaml":true},{"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \n  \n If `types` is `null`, arguments are not matched.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public methods in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \n  \n-   `BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"pos":[0,389],"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.","nodes":[{"content":"Although the default binder does not process <ph id=\"ph1\">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id=\"ph2\">`modifiers`</ph> parameter), you can use the abstract <ph id=\"ph3\">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id=\"ph4\">`modifiers`</ph>.","pos":[0,260],"source":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`."},{"content":"<ph id=\"ph1\">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.","pos":[261,389],"source":"`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled."}]},{"pos":[396,444],"content":"If <ph id=\"ph1\">`types`</ph> is <ph id=\"ph2\">`null`</ph>, arguments are not matched.","source":"If `types` is `null`, arguments are not matched."},{"pos":[451,577],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:","pos":[0,126],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:"}]},{"pos":[587,685],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[695,765],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public methods in the search.","source":"Specify `BindingFlags.Public` to include public methods in the search."},{"pos":[775,904],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search."},{"pos":[914,1086],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[1093,1203],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[1213,1268],"content":"<ph id=\"ph1\">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id=\"ph2\">`name`</ph>.","source":"`BindingFlags.IgnoreCase` to ignore the case of `name`."},{"pos":[1278,1408],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited."},{"pos":[1415,1503],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]}],"pos":[305199,306725],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the method to get.","nodes":[{"pos":[0,52],"content":"The string containing the name of the method to get.","nodes":[{"content":"The string containing the name of the method to get.","pos":[0,52]}]}],"pos":[307094,307147],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[307231,307409],"yaml":true},{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \n  \n -or-  \n  \n A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>.","nodes":[{"pos":[0,191],"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","nodes":[{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","pos":[0,191]}]},{"pos":[198,202],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[209,313],"content":"A null reference (<ph id=\"ph1\">`Nothing`</ph> in Visual Basic), to use the <ph id=\"ph2\">&lt;xref href=\"System.Type.DefaultBinder\"&gt;&lt;/xref&gt;</ph>.","source":"A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>."}],"pos":[307482,307804],"yaml":true},{"content":"The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.","nodes":[{"pos":[0,203],"content":"The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.","nodes":[{"content":"The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.","pos":[0,203]}]}],"pos":[307897,308101],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the method to get.  \n  \n -or-  \n  \n An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.  \n  \n -or-  \n  \n `null`. If <code>types</code> is `null`, arguments are not matched.","nodes":[{"pos":[0,134],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the method to get.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the method to get."},{"pos":[141,145],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[152,291],"content":"An empty array of the type <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.","source":"An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a method that takes no parameters."},{"pos":[298,302],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[309,376],"content":"`null`. If <code>types</code> is `null`, arguments are not matched.","nodes":[{"content":"<ph id=\"ph1\">`null`</ph>.","pos":[0,7],"source":"`null`."},{"content":"If <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>, arguments are not matched.","pos":[8,67],"source":" If <code>types</code> is `null`, arguments are not matched."}]}],"pos":[308162,308553],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.","nodes":[{"pos":[0,231],"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.","nodes":[{"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ParameterModifier\"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> array.","pos":[0,179],"source":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array."},{"content":"The default binder does not process this parameter.","pos":[180,231]}]}],"pos":[308642,308874],"yaml":true},{"content":"An object representing the method that matches the specified requirements, if found; otherwise, `null`.","nodes":[{"pos":[0,103],"content":"An object representing the method that matches the specified requirements, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the method that matches the specified requirements, if found; otherwise, `null`."}],"pos":[308946,309050],"yaml":true},{"content":"More than one method is found with the specified name and matching the specified binding constraints.","nodes":[{"pos":[0,101],"content":"More than one method is found with the specified name and matching the specified binding constraints.","nodes":[{"content":"More than one method is found with the specified name and matching the specified binding constraints.","pos":[0,101]}]}],"pos":[309231,309333],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[309435,309464],"yaml":true},{"content":"<code>types</code> is multidimensional.  \n  \n -or-  \n  \n <code>modifiers</code> is multidimensional.  \n  \n -or-  \n  \n <code>types</code> and <code>modifiers</code> do not have the same length.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.","source":"<code>types</code> is multidimensional."},{"pos":[46,50],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[57,100],"content":"<ph id=\"ph1\">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.","source":"<code>modifiers</code> is multidimensional."},{"pos":[107,111],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[118,192],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.","source":"<code>types</code> and <code>modifiers</code> do not have the same length."}],"pos":[309558,309761],"yaml":true},{"content":"The current type is a <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref> or <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\"></xref>.","nodes":[{"pos":[0,153],"content":"The current type is a <ph id=\"ph1\">&lt;xref href=\"System.Reflection.Emit.TypeBuilder\"&gt;&lt;/xref&gt;</ph> or <ph id=\"ph2\">&lt;xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\"&gt;&lt;/xref&gt;</ph>.","source":"The current type is a <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref> or <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\"></xref>."}],"pos":[309863,310017],"yaml":true},{"content":"Returns all the public methods of the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,79],"content":"Returns all the public methods of the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Returns all the public methods of the current <xref href=\"System.Type\"></xref>."}],"pos":[311045,311125],"yaml":true},{"content":"The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which methods are returned, because that order varies.  \n  \n Constructors are not included in the array of methods returned by this call. Make a separate call to `GetConstructors()` to get the constructor methods.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n> [!NOTE]\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \n  \n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.","nodes":[{"pos":[0,230],"content":"The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which methods are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which methods are returned, because that order varies.","pos":[0,230],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetMethods%2A&gt;</ph> method does not return methods in a particular order, such as alphabetical or declaration order.","pos":[0,133],"source":"The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which methods are returned, because that order varies.","pos":[134,230]}]}]},{"pos":[237,389],"content":"Constructors are not included in the array of methods returned by this call. Make a separate call to `GetConstructors()` to get the constructor methods.","nodes":[{"content":"Constructors are not included in the array of methods returned by this call.","pos":[0,76]},{"content":"Make a separate call to <ph id=\"ph1\">`GetConstructors()`</ph> to get the constructor methods.","pos":[77,152],"source":" Make a separate call to `GetConstructors()` to get the constructor methods."}]},{"pos":[396,511],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[518,529],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[530,536],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[537,547],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[605,616],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[617,619],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[620,622],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[627,632],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[633,635],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[636,686],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[691,696],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[697,711],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[712,905],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[910,916],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[917,919],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[920,1015],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[1020,1031],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[1032,1034],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1035,1037],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1042,1050],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[1051,1065],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1066,1259],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1270,1475],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[1485,1801],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[1811,1868],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[1876,1999],"content":"[!NOTE]\n You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","leadings":["","> "],"nodes":[{"content":" You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","pos":[8,121],"nodes":[{"content":"You cannot omit parameters when looking up constructors and methods.","pos":[1,69]},{"content":"You can only omit parameters when invoking.","pos":[70,113]}]}]},{"pos":[2006,2210],"content":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current T:System.Type represents a constructed generic type, this method returns the <ph id=\"ph1\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.","pos":[0,204],"source":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments."}]},{"pos":[2217,2463],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> if there is no class constraint.","pos":[0,246],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint."}]}],"pos":[311136,313628],"yaml":true,"extradata":"MT"},{"content":"An array of <xref href=\"System.Reflection.MethodInfo\"></xref> objects representing all the public methods defined for the current <xref href=\"System.Type\"></xref>.  \n  \n -or-  \n  \n An empty array of type <xref href=\"System.Reflection.MethodInfo\"></xref>, if no public methods are defined for the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,163],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MethodInfo\"&gt;&lt;/xref&gt;</ph> objects representing all the public methods defined for the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"An array of <xref href=\"System.Reflection.MethodInfo\"></xref> objects representing all the public methods defined for the current <xref href=\"System.Type\"></xref>."},{"pos":[170,174],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[181,337],"content":"An empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MethodInfo\"&gt;&lt;/xref&gt;</ph>, if no public methods are defined for the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"An empty array of type <xref href=\"System.Reflection.MethodInfo\"></xref>, if no public methods are defined for the current <xref href=\"System.Type\"></xref>."}],"pos":[313797,314149],"yaml":true},{"content":"When overridden in a derived class, searches for the methods defined for the current <xref href=\"System.Type\"></xref>, using the specified binding constraints.","nodes":[{"pos":[0,159],"content":"When overridden in a derived class, searches for the methods defined for the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, using the specified binding constraints.","source":"When overridden in a derived class, searches for the methods defined for the current <xref href=\"System.Type\"></xref>, using the specified binding constraints."}],"pos":[315362,315522],"yaml":true},{"content":"The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which methods are returned, because that order varies.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public methods in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search. Only protected and internal methods on base classes are returned; private methods on base classes are not returned.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n> [!NOTE]\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \n  \n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.","nodes":[{"pos":[0,230],"content":"The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which methods are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which methods are returned, because that order varies.","pos":[0,230],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetMethods%2A&gt;</ph> method does not return methods in a particular order, such as alphabetical or declaration order.","pos":[0,133],"source":"The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which methods are returned, because that order varies.","pos":[134,230]}]}]},{"pos":[237,363],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which methods to include in the search:","pos":[0,126],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:"}]},{"pos":[373,471],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[481,551],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public methods in the search.","source":"Specify `BindingFlags.Public` to include public methods in the search."},{"pos":[561,806],"content":"Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search. Only protected and internal methods on base classes are returned; private methods on base classes are not returned.","nodes":[{"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public methods (that is, private, internal, and protected methods) in the search.","pos":[0,129],"source":"Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search."},{"content":"Only protected and internal methods on base classes are returned; private methods on base classes are not returned.","pos":[130,245]}]},{"pos":[816,988],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[995,1105],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[1115,1245],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the methods declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not methods that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited."},{"pos":[1252,1340],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1348,1471],"content":"[!NOTE]\n You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","leadings":["","> "],"nodes":[{"content":" You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.","pos":[8,121],"nodes":[{"content":"You cannot omit parameters when looking up constructors and methods.","pos":[1,69]},{"content":"You can only omit parameters when invoking.","pos":[70,113]}]}]},{"pos":[1478,1682],"content":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current T:System.Type represents a constructed generic type, this method returns the <ph id=\"ph1\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.","pos":[0,204],"source":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments."}]},{"pos":[1689,1935],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <ph id=\"ph2\">&lt;xref:System.Object&gt;</ph> if there is no class constraint.","pos":[0,246],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint."}]}],"pos":[315533,317494],"yaml":true,"extradata":"MT"},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[318317,318495],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.MethodInfo\"></xref> objects representing all methods defined for the current <xref href=\"System.Type\"></xref> that match the specified binding constraints.  \n  \n -or-  \n  \n An empty array of type <xref href=\"System.Reflection.MethodInfo\"></xref>, if no methods are defined for the current <xref href=\"System.Type\"></xref>, or if none of the defined methods match the binding constraints.","nodes":[{"pos":[0,197],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MethodInfo\"&gt;&lt;/xref&gt;</ph> objects representing all methods defined for the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints.","source":"An array of <xref href=\"System.Reflection.MethodInfo\"></xref> objects representing all methods defined for the current <xref href=\"System.Type\"></xref> that match the specified binding constraints."},{"pos":[204,208],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[215,429],"content":"An empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MethodInfo\"&gt;&lt;/xref&gt;</ph>, if no methods are defined for the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, or if none of the defined methods match the binding constraints.","source":"An empty array of type <xref href=\"System.Reflection.MethodInfo\"></xref>, if no methods are defined for the current <xref href=\"System.Type\"></xref>, or if none of the defined methods match the binding constraints."}],"pos":[318569,319013],"yaml":true},{"content":"When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.","nodes":[{"pos":[0,116],"content":"When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.","nodes":[{"content":"When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.","pos":[0,116]}]}],"pos":[320310,320427],"yaml":true},{"content":"Use the simple name of the nested class for `name`. Do not qualify it with the name of the outer class. For a generic nested class, use the mangled name  that is, append a grave accent and the number of generic parameters. For example, use the string \"Inner\\`1\" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic). Do not include language-specific syntax for type parameters.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:  \n  \n-   You must specify either <xref:System.Reflection.BindingFlags?displayProperty=fullName> or <xref:System.Reflection.BindingFlags?displayProperty=fullName> to get a return.  \n  \n-   Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include public nested types in the search.  \n  \n-   Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include non-public nested types (that is, private, internal, and protected nested types) in the search.  \n  \n This method returns only the nested types of the current type. It does not search the base classes of the current type. To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.  \n  \n <xref:System.Reflection.BindingFlags?displayProperty=fullName> and <xref:System.Reflection.BindingFlags?displayProperty=fullName> are ignored.  \n  \n Calling this method with only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag or only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag will return the specified nested types and does not require any other flags.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.  \n  \n If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.  \n  \n> [!NOTE]\n>  If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  \n  \n For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.","nodes":[{"pos":[0,399],"content":"Use the simple name of the nested class for `name`. Do not qualify it with the name of the outer class. For a generic nested class, use the mangled name  that is, append a grave accent and the number of generic parameters. For example, use the string \"Inner\\`1\" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic). Do not include language-specific syntax for type parameters.","nodes":[{"content":"Use the simple name of the nested class for <ph id=\"ph1\">`name`</ph>.","pos":[0,51],"source":"Use the simple name of the nested class for `name`."},{"content":"Do not qualify it with the name of the outer class.","pos":[52,103]},{"content":"For a generic nested class, use the mangled name  that is, append a grave accent and the number of generic parameters.","pos":[104,223]},{"content":"For example, use the string \"Inner<ph id=\"ph1\">\\`</ph>1\" to get the generic nested class <ph id=\"ph2\">`Inner&lt;T&gt;`</ph> (<ph id=\"ph3\">`Inner(Of T)`</ph> in Visual Basic).","pos":[224,338],"source":" For example, use the string \"Inner\\`1\" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic)."},{"content":"Do not include language-specific syntax for type parameters.","pos":[339,399]}]},{"pos":[406,537],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:","pos":[0,131],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:"}]},{"pos":[547,716],"content":"You must specify either <xref:System.Reflection.BindingFlags?displayProperty=fullName> or <xref:System.Reflection.BindingFlags?displayProperty=fullName> to get a return.","nodes":[{"content":"You must specify either <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to get a return.","pos":[0,169],"source":"You must specify either <xref:System.Reflection.BindingFlags?displayProperty=fullName> or <xref:System.Reflection.BindingFlags?displayProperty=fullName> to get a return."}]},{"pos":[726,842],"content":"Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include public nested types in the search.","nodes":[{"content":"Specify <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to include public nested types in the search.","pos":[0,116],"source":"Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include public nested types in the search."}]},{"pos":[852,1029],"content":"Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include non-public nested types (that is, private, internal, and protected nested types) in the search.","nodes":[{"content":"Specify <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to include non-public nested types (that is, private, internal, and protected nested types) in the search.","pos":[0,177],"source":"Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include non-public nested types (that is, private, internal, and protected nested types) in the search."}]},{"pos":[1036,1302],"content":"This method returns only the nested types of the current type. It does not search the base classes of the current type. To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.","nodes":[{"content":"This method returns only the nested types of the current type. It does not search the base classes of the current type. To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.","pos":[0,266],"nodes":[{"content":"This method returns only the nested types of the current type.","pos":[0,62]},{"content":"It does not search the base classes of the current type.","pos":[63,119]},{"content":"To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <ph id=\"ph1\">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> at each level.","pos":[120,266],"source":" To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level."}]}]},{"pos":[1309,1451],"content":"<xref:System.Reflection.BindingFlags?displayProperty=fullName> and <xref:System.Reflection.BindingFlags?displayProperty=fullName> are ignored.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> are ignored.","pos":[0,142],"source":"<xref:System.Reflection.BindingFlags?displayProperty=fullName> and <xref:System.Reflection.BindingFlags?displayProperty=fullName> are ignored."}]},{"pos":[1458,1716],"content":"Calling this method with only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag or only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag will return the specified nested types and does not require any other flags.","nodes":[{"content":"Calling this method with only the <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> flag or only the <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> flag will return the specified nested types and does not require any other flags.","pos":[0,258],"source":"Calling this method with only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag or only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag will return the specified nested types and does not require any other flags."}]},{"pos":[1723,1811],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1818,1997],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.","pos":[0,179],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint."}]},{"pos":[2004,2159],"content":"If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.","nodes":[{"content":"If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.","pos":[0,155],"nodes":[{"content":"If a nested type is generic, this method returns its generic type definition.","pos":[0,77]},{"content":"This is true even if the enclosing generic type is a closed constructed type.","pos":[78,155]}]}]},{"pos":[2167,2535],"content":"[!NOTE]\n If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).","leadings":["","> "],"nodes":[{"content":" If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).","pos":[8,366],"nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.","pos":[1,184],"source":" If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own."},{"content":"This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id=\"p1\">[</bpt>Ilasm.exe (IL Assembler)<ept id=\"p1\">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.","pos":[185,358],"source":" This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)."}]}]},{"pos":[2542,2703],"content":"For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.","nodes":[{"content":"For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id=\"ph1\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.","pos":[0,161],"source":"For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>."}]}],"pos":[320438,323172],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the nested type to get.","nodes":[{"pos":[0,57],"content":"The string containing the name of the nested type to get.","nodes":[{"content":"The string containing the name of the nested type to get.","pos":[0,57]}]}],"pos":[323365,323423],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[323507,323685],"yaml":true},{"content":"An object representing the nested type that matches the specified requirements, if found; otherwise, `null`.","nodes":[{"pos":[0,108],"content":"An object representing the nested type that matches the specified requirements, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the nested type that matches the specified requirements, if found; otherwise, `null`."}],"pos":[323740,323849],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[324004,324033],"yaml":true},{"content":"Searches for the public nested type with the specified name.","nodes":[{"pos":[0,60],"content":"Searches for the public nested type with the specified name.","nodes":[{"content":"Searches for the public nested type with the specified name.","pos":[0,60]}]}],"pos":[325142,325203],"yaml":true},{"content":"The search for `name` is case-sensitive.  \n  \n Use the simple name of the nested class for `name`. Do not qualify it with the name of the outer class. For a generic nested class, use the mangled name  that is, append a grave accent and the number of generic arguments. For example, use the string \"Inner\\`1\" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic). Do not include language-specific syntax for type parameters.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.  \n  \n If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.  \n  \n> [!NOTE]\n>  If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  \n  \n For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.","nodes":[{"pos":[0,40],"content":"The search for <ph id=\"ph1\">`name`</ph> is case-sensitive.","source":"The search for `name` is case-sensitive."},{"pos":[47,445],"content":"Use the simple name of the nested class for `name`. Do not qualify it with the name of the outer class. For a generic nested class, use the mangled name  that is, append a grave accent and the number of generic arguments. For example, use the string \"Inner\\`1\" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic). Do not include language-specific syntax for type parameters.","nodes":[{"content":"Use the simple name of the nested class for <ph id=\"ph1\">`name`</ph>.","pos":[0,51],"source":"Use the simple name of the nested class for `name`."},{"content":"Do not qualify it with the name of the outer class.","pos":[52,103]},{"content":"For a generic nested class, use the mangled name  that is, append a grave accent and the number of generic arguments.","pos":[104,222]},{"content":"For example, use the string \"Inner<ph id=\"ph1\">\\`</ph>1\" to get the generic nested class <ph id=\"ph2\">`Inner&lt;T&gt;`</ph> (<ph id=\"ph3\">`Inner(Of T)`</ph> in Visual Basic).","pos":[223,337],"source":" For example, use the string \"Inner\\`1\" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic)."},{"content":"Do not include language-specific syntax for type parameters.","pos":[338,398]}]},{"pos":[452,567],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[574,585],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[586,592],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[593,603],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[661,672],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[673,675],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[676,678],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[683,688],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[689,691],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[692,742],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[747,752],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[753,767],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[768,961],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[966,972],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[973,975],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[976,1071],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[1076,1087],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[1088,1090],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1091,1093],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1098,1106],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[1107,1121],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1122,1315],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1326,1531],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[1541,1857],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[1867,1924],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[1931,2110],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.","pos":[0,179],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint."}]},{"pos":[2117,2272],"content":"If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.","nodes":[{"content":"If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.","pos":[0,155],"nodes":[{"content":"If a nested type is generic, this method returns its generic type definition.","pos":[0,77]},{"content":"This is true even if the enclosing generic type is a closed constructed type.","pos":[78,155]}]}]},{"pos":[2280,2648],"content":"[!NOTE]\n If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).","leadings":["","> "],"nodes":[{"content":" If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).","pos":[8,366],"nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.","pos":[1,184],"source":" If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own."},{"content":"This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id=\"p1\">[</bpt>Ilasm.exe (IL Assembler)<ept id=\"p1\">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.","pos":[185,358],"source":" This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)."}]}]},{"pos":[2655,2816],"content":"For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.","nodes":[{"content":"For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id=\"ph1\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.","pos":[0,161],"source":"For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>."}]}],"pos":[325214,328064],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the nested type to get.","nodes":[{"pos":[0,57],"content":"The string containing the name of the nested type to get.","nodes":[{"content":"The string containing the name of the nested type to get.","pos":[0,57]}]}],"pos":[328204,328262],"yaml":true},{"content":"An object representing the public nested type with the specified name, if found; otherwise, `null`.","nodes":[{"pos":[0,99],"content":"An object representing the public nested type with the specified name, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the public nested type with the specified name, if found; otherwise, `null`."}],"pos":[328317,328417],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[328572,328601],"yaml":true},{"content":"When overridden in a derived class, searches for the types nested in the current <xref href=\"System.Type\"></xref>, using the specified binding constraints.","nodes":[{"pos":[0,155],"content":"When overridden in a derived class, searches for the types nested in the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, using the specified binding constraints.","source":"When overridden in a derived class, searches for the types nested in the current <xref href=\"System.Type\"></xref>, using the specified binding constraints."}],"pos":[329785,329941],"yaml":true},{"content":"The search for nested types is not recursive.  \n  \n The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which types are returned, because that order varies.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:  \n  \n-   You must specify either <xref:System.Reflection.BindingFlags?displayProperty=fullName> or <xref:System.Reflection.BindingFlags?displayProperty=fullName> to get a return.  \n  \n-   Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include public nested types in the search.  \n  \n-   Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include non-public nested types (that is, private, internal, and protected nested types) in the search.  \n  \n This method returns only the nested types of the current type. It does not search the base classes of the current type. To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.  \n  \n <xref:System.Reflection.BindingFlags?displayProperty=fullName> and <xref:System.Reflection.BindingFlags?displayProperty=fullName> are ignored.  \n  \n Calling this method with only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag or only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag will return the specified nested types and does not require any other flags.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.  \n  \n If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.  \n  \n> [!NOTE]\n>  If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  \n  \n For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.","nodes":[{"pos":[0,45],"content":"The search for nested types is not recursive.","nodes":[{"content":"The search for nested types is not recursive.","pos":[0,45]}]},{"pos":[52,282],"content":"The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which types are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which types are returned, because that order varies.","pos":[0,230],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> method does not return types in a particular order, such as alphabetical or declaration order.","pos":[0,135],"source":"The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which types are returned, because that order varies.","pos":[136,230]}]}]},{"pos":[289,420],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:","pos":[0,131],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:"}]},{"pos":[430,599],"content":"You must specify either <xref:System.Reflection.BindingFlags?displayProperty=fullName> or <xref:System.Reflection.BindingFlags?displayProperty=fullName> to get a return.","nodes":[{"content":"You must specify either <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to get a return.","pos":[0,169],"source":"You must specify either <xref:System.Reflection.BindingFlags?displayProperty=fullName> or <xref:System.Reflection.BindingFlags?displayProperty=fullName> to get a return."}]},{"pos":[609,725],"content":"Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include public nested types in the search.","nodes":[{"content":"Specify <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to include public nested types in the search.","pos":[0,116],"source":"Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include public nested types in the search."}]},{"pos":[735,912],"content":"Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include non-public nested types (that is, private, internal, and protected nested types) in the search.","nodes":[{"content":"Specify <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to include non-public nested types (that is, private, internal, and protected nested types) in the search.","pos":[0,177],"source":"Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include non-public nested types (that is, private, internal, and protected nested types) in the search."}]},{"pos":[919,1186],"content":"This method returns only the nested types of the current type. It does not search the base classes of the current type. To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.","nodes":[{"content":"This method returns only the nested types of the current type. It does not search the base classes of the current type. To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.","pos":[0,267],"nodes":[{"content":"This method returns only the nested types of the current type.","pos":[0,62]},{"content":"It does not search the base classes of the current type.","pos":[63,119]},{"content":"To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <ph id=\"ph1\">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> at each level.","pos":[120,267],"source":" To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level."}]}]},{"pos":[1193,1335],"content":"<xref:System.Reflection.BindingFlags?displayProperty=fullName> and <xref:System.Reflection.BindingFlags?displayProperty=fullName> are ignored.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> are ignored.","pos":[0,142],"source":"<xref:System.Reflection.BindingFlags?displayProperty=fullName> and <xref:System.Reflection.BindingFlags?displayProperty=fullName> are ignored."}]},{"pos":[1342,1600],"content":"Calling this method with only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag or only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag will return the specified nested types and does not require any other flags.","nodes":[{"content":"Calling this method with only the <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> flag or only the <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> flag will return the specified nested types and does not require any other flags.","pos":[0,258],"source":"Calling this method with only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag or only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag will return the specified nested types and does not require any other flags."}]},{"pos":[1607,1695],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1702,1881],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.","pos":[0,179],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint."}]},{"pos":[1888,2043],"content":"If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.","nodes":[{"content":"If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.","pos":[0,155],"nodes":[{"content":"If a nested type is generic, this method returns its generic type definition.","pos":[0,77]},{"content":"This is true even if the enclosing generic type is a closed constructed type.","pos":[78,155]}]}]},{"pos":[2051,2419],"content":"[!NOTE]\n If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).","leadings":["","> "],"nodes":[{"content":" If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).","pos":[8,366],"nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.","pos":[1,184],"source":" If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own."},{"content":"This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id=\"p1\">[</bpt>Ilasm.exe (IL Assembler)<ept id=\"p1\">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.","pos":[185,358],"source":" This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)."}]}]},{"pos":[2426,2587],"content":"For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.","nodes":[{"content":"For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id=\"ph1\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.","pos":[0,161],"source":"For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>."}]}],"pos":[329952,332569],"yaml":true,"extradata":"MT"},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[333407,333585],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing all the types nested in the current <xref href=\"System.Type\"></xref> that match the specified binding constraints (the search is not recursive), or an empty array of type <xref href=\"System.Type\"></xref>, if no nested types are found that match the binding constraints.","nodes":[{"pos":[0,335],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing all the types nested in the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints (the search is not recursive), or an empty array of type <ph id=\"ph3\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, if no nested types are found that match the binding constraints.","source":"An array of <xref href=\"System.Type\"></xref> objects representing all the types nested in the current <xref href=\"System.Type\"></xref> that match the specified binding constraints (the search is not recursive), or an empty array of type <xref href=\"System.Type\"></xref>, if no nested types are found that match the binding constraints."}],"pos":[333642,333978],"yaml":true},{"content":"Returns the public types nested in the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,80],"content":"Returns the public types nested in the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Returns the public types nested in the current <xref href=\"System.Type\"></xref>."}],"pos":[335087,335168],"yaml":true},{"content":"The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which types are returned, because that order varies.  \n  \n Only the public types immediately nested in the current type are returned; the search is not recursive.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.  \n  \n If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.  \n  \n> [!NOTE]\n>  If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  \n  \n For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.","nodes":[{"pos":[0,230],"content":"The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which types are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which types are returned, because that order varies.","pos":[0,230],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetNestedTypes%2A&gt;</ph> method does not return types in a particular order, such as alphabetical or declaration order.","pos":[0,135],"source":"The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which types are returned, because that order varies.","pos":[136,230]}]}]},{"pos":[237,340],"content":"Only the public types immediately nested in the current type are returned; the search is not recursive.","nodes":[{"content":"Only the public types immediately nested in the current type are returned; the search is not recursive.","pos":[0,103]}]},{"pos":[347,462],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[469,480],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[481,487],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[488,498],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[556,567],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[568,570],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[571,573],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[578,583],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[584,586],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[587,637],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[642,647],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[648,662],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[663,856],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[861,867],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[868,870],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[871,966],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[971,982],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[983,985],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[986,988],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[993,1001],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[1002,1016],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1017,1210],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1221,1426],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[1436,1752],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[1762,1819],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[1826,2005],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.","pos":[0,179],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint."}]},{"pos":[2012,2167],"content":"If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.","nodes":[{"content":"If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.","pos":[0,155],"nodes":[{"content":"If a nested type is generic, this method returns its generic type definition.","pos":[0,77]},{"content":"This is true even if the enclosing generic type is a closed constructed type.","pos":[78,155]}]}]},{"pos":[2175,2543],"content":"[!NOTE]\n If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).","leadings":["","> "],"nodes":[{"content":" If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).","pos":[8,366],"nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.","pos":[1,184],"source":" If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own."},{"content":"This is not necessarily true of nested types defined in dynamic assemblies or compiled with the <bpt id=\"p1\">[</bpt>Ilasm.exe (IL Assembler)<ept id=\"p1\">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.","pos":[185,358],"source":" This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)."}]}]},{"pos":[2550,2711],"content":"For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.","nodes":[{"content":"For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <ph id=\"ph1\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph>.","pos":[0,161],"source":"For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>."}]}],"pos":[335179,337921],"yaml":true,"extradata":"MT"},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the public types nested in the current <xref href=\"System.Type\"></xref> (the search is not recursive), or an empty array of type <xref href=\"System.Type\"></xref> if no public types are nested in the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,306],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the public types nested in the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> (the search is not recursive), or an empty array of type <ph id=\"ph3\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> if no public types are nested in the current <ph id=\"ph4\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the public types nested in the current <xref href=\"System.Type\"></xref> (the search is not recursive), or an empty array of type <xref href=\"System.Type\"></xref> if no public types are nested in the current <xref href=\"System.Type\"></xref>."}],"pos":[338614,338921],"yaml":true},{"content":"Returns all the public properties of the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,82],"content":"Returns all the public properties of the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Returns all the public properties of the current <xref href=\"System.Type\"></xref>."}],"pos":[340024,340107],"yaml":true},{"content":"Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic. It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.  \n  \n A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \n  \n The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","nodes":[{"pos":[0,519],"content":"Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic. It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.","nodes":[{"content":"Calling this overload is equivalent to calling the <ph id=\"ph1\">&lt;xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29&gt;</ph> overload with a <ph id=\"ph2\">`bindingAttr`</ph> argument equal to <ph id=\"ph3\">`BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public`</ph> in C# and  <ph id=\"ph4\">`BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public`</ph> in Visual Basic.","pos":[0,333],"source":"Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic."},{"content":"It returns all public instance and static properties, both those defined by the type represented by the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object as well as those inherited from its base types.","pos":[334,519],"source":" It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types."}]},{"pos":[526,945],"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.","nodes":[{"content":"A property is considered public to reflection if it has at least one accessor that is public.","pos":[0,93]},{"content":"Otherwise the property is considered private, and you must use <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id=\"ph4\">`Or`</ph>) to get it.","pos":[94,419],"source":" Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it."}]},{"pos":[952,1191],"content":"The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies.","pos":[0,239],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetProperties%2A&gt;</ph> method does not return properties in a particular order, such as alphabetical or declaration order.","pos":[0,139],"source":"The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which properties are returned, because that order varies.","pos":[140,239]}]}]},{"pos":[1198,1313],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[1320,1331],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[1332,1338],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[1339,1349],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[1407,1418],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[1419,1421],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1422,1424],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1429,1434],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[1435,1437],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1438,1488],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[1493,1498],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[1499,1513],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1514,1707],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1712,1718],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[1719,1721],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1722,1817],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[1822,1833],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[1834,1836],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1837,1839],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1844,1852],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[1853,1867],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1868,2061],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[2072,2277],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[2287,2603],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[2613,2670],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[2677,2883],"content":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current T:System.Type represents a constructed generic type, this method returns the <ph id=\"ph1\">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.","pos":[0,206],"source":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments."}]},{"pos":[2890,3067],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","pos":[0,177],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint."}]}],"pos":[340118,343213],"yaml":true,"extradata":"MT"},{"content":"An array of <xref href=\"System.Reflection.PropertyInfo\"></xref> objects representing all public properties of the current <xref href=\"System.Type\"></xref>.  \n  \n -or-  \n  \n An empty array of type <xref href=\"System.Reflection.PropertyInfo\"></xref>, if the current <xref href=\"System.Type\"></xref> does not have public properties.","nodes":[{"pos":[0,155],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.PropertyInfo\"&gt;&lt;/xref&gt;</ph> objects representing all public properties of the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"An array of <xref href=\"System.Reflection.PropertyInfo\"></xref> objects representing all public properties of the current <xref href=\"System.Type\"></xref>."},{"pos":[162,166],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[173,329],"content":"An empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Reflection.PropertyInfo\"&gt;&lt;/xref&gt;</ph>, if the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> does not have public properties.","source":"An empty array of type <xref href=\"System.Reflection.PropertyInfo\"></xref>, if the current <xref href=\"System.Type\"></xref> does not have public properties."}],"pos":[343849,344193],"yaml":true},{"content":"When overridden in a derived class, searches for the properties of the current <xref href=\"System.Type\"></xref>, using the specified binding constraints.","nodes":[{"pos":[0,153],"content":"When overridden in a derived class, searches for the properties of the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>, using the specified binding constraints.","source":"When overridden in a derived class, searches for the properties of the current <xref href=\"System.Type\"></xref>, using the specified binding constraints."}],"pos":[345427,345581],"yaml":true},{"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \n  \n The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public properties in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search. Only protected and internal properties on base classes are returned; private properties on base classes are not returned.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \n  \n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","nodes":[{"pos":[0,419],"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.","nodes":[{"content":"A property is considered public to reflection if it has at least one accessor that is public.","pos":[0,93]},{"content":"Otherwise the property is considered private, and you must use <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id=\"ph4\">`Or`</ph>) to get it.","pos":[94,419],"source":" Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it."}]},{"pos":[426,665],"content":"The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies.","nodes":[{"content":"The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies.","pos":[0,239],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetProperties%2A&gt;</ph> method does not return properties in a particular order, such as alphabetical or declaration order.","pos":[0,139],"source":"The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order."},{"content":"Your code must not depend on the order in which properties are returned, because that order varies.","pos":[140,239]}]}]},{"pos":[672,803],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which nested types to include in the search:","pos":[0,131],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:"}]},{"pos":[813,911],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[921,994],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public properties in the search.","source":"Specify `BindingFlags.Public` to include public properties in the search."},{"pos":[1004,1261],"content":"Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search. Only protected and internal properties on base classes are returned; private properties on base classes are not returned.","nodes":[{"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.","pos":[0,135],"source":"Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search."},{"content":"Only protected and internal properties on base classes are returned; private properties on base classes are not returned.","pos":[136,257]}]},{"pos":[1271,1443],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[1450,1560],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[1570,1706],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited."},{"pos":[1713,1801],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1808,2227],"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.","nodes":[{"content":"A property is considered public to reflection if it has at least one accessor that is public.","pos":[0,93]},{"content":"Otherwise the property is considered private, and you must use <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id=\"ph4\">`Or`</ph>) to get it.","pos":[94,419],"source":" Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it."}]},{"pos":[2234,2440],"content":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current T:System.Type represents a constructed generic type, this method returns the <ph id=\"ph1\">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> objects with the type parameters replaced by the appropriate type arguments.","pos":[0,206],"source":"If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments."}]},{"pos":[2447,2624],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","pos":[0,177],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint."}]}],"pos":[345592,348243],"yaml":true,"extradata":"MT"},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[349362,349540],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.PropertyInfo\"></xref> objects representing all properties of the current <xref href=\"System.Type\"></xref> that match the specified binding constraints.  \n  \n -or-  \n  \n An empty array of type <xref href=\"System.Reflection.PropertyInfo\"></xref>, if the current <xref href=\"System.Type\"></xref> does not have properties, or if none of the properties match the binding constraints.","nodes":[{"pos":[0,193],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.PropertyInfo\"&gt;&lt;/xref&gt;</ph> objects representing all properties of the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> that match the specified binding constraints.","source":"An array of <xref href=\"System.Reflection.PropertyInfo\"></xref> objects representing all properties of the current <xref href=\"System.Type\"></xref> that match the specified binding constraints."},{"pos":[200,204],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[211,420],"content":"An empty array of type <ph id=\"ph1\">&lt;xref href=\"System.Reflection.PropertyInfo\"&gt;&lt;/xref&gt;</ph>, if the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> does not have properties, or if none of the properties match the binding constraints.","source":"An empty array of type <xref href=\"System.Reflection.PropertyInfo\"></xref>, if the current <xref href=\"System.Type\"></xref> does not have properties, or if none of the properties match the binding constraints."}],"pos":[349616,350051],"yaml":true},{"content":"Searches for the public property with the specified name.","nodes":[{"pos":[0,57],"content":"Searches for the public property with the specified name.","nodes":[{"content":"Searches for the public property with the specified name.","pos":[0,57]}]}],"pos":[351204,351262],"yaml":true},{"content":"The search for `name` is case-sensitive. The search includes public static and public instance properties.  \n  \n A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  \n  \n Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:  \n  \n-   A type contains two indexed properties that have the same name but different numbers of parameters. To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.  \n  \n-   A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic). To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag to restrict the search to members that are not inherited.  \n  \n## Indexers and Default Properties  \n [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.  \n  \n In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.  \n  \n To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","nodes":[{"pos":[0,106],"content":"The search for `name` is case-sensitive. The search includes public static and public instance properties.","nodes":[{"content":"The search for <ph id=\"ph1\">`name`</ph> is case-sensitive.","pos":[0,40],"source":"The search for `name` is case-sensitive."},{"content":"The search includes public static and public instance properties.","pos":[41,106]}]},{"pos":[113,532],"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.","nodes":[{"content":"A property is considered public to reflection if it has at least one accessor that is public.","pos":[0,93]},{"content":"Otherwise the property is considered private, and you must use <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id=\"ph4\">`Or`</ph>) to get it.","pos":[94,419],"source":" Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it."}]},{"pos":[539,742],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,203],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[749,926],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","pos":[0,177],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint."}]},{"pos":[933,1031],"content":"Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:","nodes":[{"content":"Situations in which <ph id=\"ph1\">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> occurs include the following:","pos":[0,98],"source":"Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:"}]},{"pos":[1041,1262],"content":"A type contains two indexed properties that have the same name but different numbers of parameters. To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.","nodes":[{"content":"A type contains two indexed properties that have the same name but different numbers of parameters. To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.","pos":[0,221],"nodes":[{"content":"A type contains two indexed properties that have the same name but different numbers of parameters.","pos":[0,99]},{"content":"To resolve the ambiguity, use an overload of the <ph id=\"ph1\">&lt;xref:System.Type.GetProperty%2A&gt;</ph> method that specifies parameter types.","pos":[100,221],"source":" To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types."}]}]},{"pos":[1272,1687],"content":"A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic). To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag to restrict the search to members that are not inherited.","nodes":[{"content":"A derived type declares a property that hides an inherited property with the same name, by using the <ph id=\"ph1\">`new`</ph> modifier (<ph id=\"ph2\">`Shadows`</ph> in Visual Basic).","pos":[0,144],"source":"A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic)."},{"content":"To resolve the ambiguity, use the <ph id=\"ph1\">&lt;xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29&gt;</ph> method overload and add the <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> flag to restrict the search to members that are not inherited.","pos":[145,415],"source":" To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag to restrict the search to members that are not inherited."}]},{"pos":[1696,1727],"content":"Indexers and Default Properties","linkify":"Indexers and Default Properties","nodes":[{"content":"Indexers and Default Properties","pos":[0,31]}]},{"pos":[1731,2224],"content":"[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.","nodes":[{"content":"<ph id=\"ph1\">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id=\"ph2\">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id=\"ph3\">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.","pos":[0,278],"source":"[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type."},{"content":"For example, if the variable <ph id=\"ph1\">`myList`</ph> refers to an <ph id=\"ph2\">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id=\"ph3\">`myList[3]`</ph> (<ph id=\"ph4\">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.","pos":[279,462],"source":" For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3."},{"content":"You can overload the property.","pos":[463,493]}]},{"pos":[2231,2749],"content":"In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.","nodes":[{"content":"In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.","pos":[0,518],"nodes":[{"content":"In C#, this feature is called an indexer and cannot be refered to by name.","pos":[0,74]},{"content":"By default, a C# indexer appears in metadata as an indexed property named \"Item\".","pos":[75,156]},{"content":"However, a class library developer can use the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.","pos":[157,324],"source":" However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata."},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id=\"ph2\">&lt;xref:System.String.Chars%2A&gt;</ph>.","pos":[325,420],"source":" For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>."},{"content":"Indexed properties created using languages other than C# can have names other than Item, as well.","pos":[421,518]}]}]},{"pos":[2756,3169],"content":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","nodes":[{"content":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","pos":[0,413],"nodes":[{"content":"To determine whether a type has a default property, use the <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id=\"ph2\">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.","pos":[0,231],"source":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute."},{"content":"If the type has <ph id=\"ph1\">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.","pos":[232,413],"source":" If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property."}]}]}],"pos":[351273,354466],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the public property to get.","nodes":[{"pos":[0,61],"content":"The string containing the name of the public property to get.","nodes":[{"content":"The string containing the name of the public property to get.","pos":[0,61]}]}],"pos":[355396,355458],"yaml":true},{"content":"An object representing the public property with the specified name, if found; otherwise, `null`.","nodes":[{"pos":[0,96],"content":"An object representing the public property with the specified name, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the public property with the specified name, if found; otherwise, `null`."}],"pos":[355532,355629],"yaml":true},{"content":"More than one property is found with the specified name.","nodes":[{"pos":[0,56],"content":"More than one property is found with the specified name.","nodes":[{"content":"More than one property is found with the specified name.","pos":[0,56]}]}],"pos":[355808,355865],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[355967,355996],"yaml":true},{"content":"Searches for the specified property, using the specified binding constraints.","nodes":[{"pos":[0,77],"content":"Searches for the specified property, using the specified binding constraints.","nodes":[{"content":"Searches for the specified property, using the specified binding constraints.","pos":[0,77]}]}],"pos":[357228,357306],"yaml":true},{"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public properties in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \n  \n-   `BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  \n  \n Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:  \n  \n-   A type contains two indexed properties that have the same name but different numbers of parameters. To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.  \n  \n-   A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic). To resolve the ambiguity, include <xref:System.Reflection.BindingFlags?displayProperty=fullName> to restrict the search to members that are not inherited.  \n  \n## Indexers and Default Properties  \n [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.  \n  \n In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.  \n  \n To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","nodes":[{"pos":[0,419],"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.","nodes":[{"content":"A property is considered public to reflection if it has at least one accessor that is public.","pos":[0,93]},{"content":"Otherwise the property is considered private, and you must use <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id=\"ph4\">`Or`</ph>) to get it.","pos":[94,419],"source":" Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it."}]},{"pos":[426,555],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:","pos":[0,129],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:"}]},{"pos":[565,663],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[673,746],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public properties in the search.","source":"Specify `BindingFlags.Public` to include public properties in the search."},{"pos":[756,891],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search."},{"pos":[901,1073],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[1080,1190],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[1200,1255],"content":"<ph id=\"ph1\">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id=\"ph2\">`name`</ph>.","source":"`BindingFlags.IgnoreCase` to ignore the case of `name`."},{"pos":[1265,1401],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited."},{"pos":[1408,1496],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1503,1706],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,203],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[1713,1890],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","pos":[0,177],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint."}]},{"pos":[1897,1995],"content":"Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:","nodes":[{"content":"Situations in which <ph id=\"ph1\">&lt;xref:System.Reflection.AmbiguousMatchException&gt;</ph> occurs include the following:","pos":[0,98],"source":"Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:"}]},{"pos":[2005,2226],"content":"A type contains two indexed properties that have the same name but different numbers of parameters. To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.","nodes":[{"content":"A type contains two indexed properties that have the same name but different numbers of parameters. To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.","pos":[0,221],"nodes":[{"content":"A type contains two indexed properties that have the same name but different numbers of parameters.","pos":[0,99]},{"content":"To resolve the ambiguity, use an overload of the <ph id=\"ph1\">&lt;xref:System.Type.GetProperty%2A&gt;</ph> method that specifies parameter types.","pos":[100,221],"source":" To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types."}]}]},{"pos":[2236,2532],"content":"A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic). To resolve the ambiguity, include <xref:System.Reflection.BindingFlags?displayProperty=fullName> to restrict the search to members that are not inherited.","nodes":[{"content":"A derived type declares a property that hides an inherited property with the same name, using the <ph id=\"ph1\">`new`</ph> modifier (<ph id=\"ph2\">`Shadows`</ph> in Visual Basic).","pos":[0,141],"source":"A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic)."},{"content":"To resolve the ambiguity, include <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to restrict the search to members that are not inherited.","pos":[142,296],"source":" To resolve the ambiguity, include <xref:System.Reflection.BindingFlags?displayProperty=fullName> to restrict the search to members that are not inherited."}]},{"pos":[2541,2572],"content":"Indexers and Default Properties","linkify":"Indexers and Default Properties","nodes":[{"content":"Indexers and Default Properties","pos":[0,31]}]},{"pos":[2576,3069],"content":"[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.","nodes":[{"content":"<ph id=\"ph1\">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id=\"ph2\">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id=\"ph3\">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.","pos":[0,278],"source":"[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type."},{"content":"For example, if the variable <ph id=\"ph1\">`myList`</ph> refers to an <ph id=\"ph2\">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id=\"ph3\">`myList[3]`</ph> (<ph id=\"ph4\">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.","pos":[279,462],"source":" For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3."},{"content":"You can overload the property.","pos":[463,493]}]},{"pos":[3076,3594],"content":"In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.","nodes":[{"content":"In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.","pos":[0,518],"nodes":[{"content":"In C#, this feature is called an indexer and cannot be refered to by name.","pos":[0,74]},{"content":"By default, a C# indexer appears in metadata as an indexed property named \"Item\".","pos":[75,156]},{"content":"However, a class library developer can use the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.","pos":[157,324],"source":" However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata."},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id=\"ph2\">&lt;xref:System.String.Chars%2A&gt;</ph>.","pos":[325,420],"source":" For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>."},{"content":"Indexed properties created using languages other than C# can have names other than Item, as well.","pos":[421,518]}]}]},{"pos":[3601,4014],"content":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","nodes":[{"content":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","pos":[0,413],"nodes":[{"content":"To determine whether a type has a default property, use the <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id=\"ph2\">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.","pos":[0,231],"source":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute."},{"content":"If the type has <ph id=\"ph1\">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.","pos":[232,413],"source":" If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property."}]}]}],"pos":[357317,361371],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the property to get.","nodes":[{"pos":[0,54],"content":"The string containing the name of the property to get.","nodes":[{"content":"The string containing the name of the property to get.","pos":[0,54]}]}],"pos":[362160,362215],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[362299,362477],"yaml":true},{"content":"An object representing the property that matches the specified requirements, if found; otherwise, `null`.","nodes":[{"pos":[0,105],"content":"An object representing the property that matches the specified requirements, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the property that matches the specified requirements, if found; otherwise, `null`."}],"pos":[362551,362657],"yaml":true},{"content":"More than one property is found with the specified name and matching the specified binding constraints.","nodes":[{"pos":[0,103],"content":"More than one property is found with the specified name and matching the specified binding constraints.","nodes":[{"content":"More than one property is found with the specified name and matching the specified binding constraints.","pos":[0,103]}]}],"pos":[362836,362940],"yaml":true},{"content":"<code>name</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."}],"pos":[363042,363071],"yaml":true},{"content":"Searches for the public property with the specified name and return type.","nodes":[{"pos":[0,73],"content":"Searches for the public property with the specified name and return type.","nodes":[{"content":"Searches for the public property with the specified name and return type.","pos":[0,73]}]}],"pos":[364222,364296],"yaml":true},{"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \n  \n The search for `name` is case-sensitive. The search includes public static and public instance properties.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  \n  \n## Indexers and Default Properties  \n [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.  \n  \n In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.  \n  \n To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","nodes":[{"pos":[0,419],"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.","nodes":[{"content":"A property is considered public to reflection if it has at least one accessor that is public.","pos":[0,93]},{"content":"Otherwise the property is considered private, and you must use <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id=\"ph4\">`Or`</ph>) to get it.","pos":[94,419],"source":" Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it."}]},{"pos":[426,532],"content":"The search for `name` is case-sensitive. The search includes public static and public instance properties.","nodes":[{"content":"The search for <ph id=\"ph1\">`name`</ph> is case-sensitive.","pos":[0,40],"source":"The search for `name` is case-sensitive."},{"content":"The search includes public static and public instance properties.","pos":[41,106]}]},{"pos":[539,742],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,203],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[749,926],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","pos":[0,177],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint."}]},{"pos":[935,966],"content":"Indexers and Default Properties","linkify":"Indexers and Default Properties","nodes":[{"content":"Indexers and Default Properties","pos":[0,31]}]},{"pos":[970,1463],"content":"[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.","nodes":[{"content":"<ph id=\"ph1\">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id=\"ph2\">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id=\"ph3\">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.","pos":[0,278],"source":"[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type."},{"content":"For example, if the variable <ph id=\"ph1\">`myList`</ph> refers to an <ph id=\"ph2\">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id=\"ph3\">`myList[3]`</ph> (<ph id=\"ph4\">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.","pos":[279,462],"source":" For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3."},{"content":"You can overload the property.","pos":[463,493]}]},{"pos":[1470,1988],"content":"In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.","nodes":[{"content":"In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.","pos":[0,518],"nodes":[{"content":"In C#, this feature is called an indexer and cannot be refered to by name.","pos":[0,74]},{"content":"By default, a C# indexer appears in metadata as an indexed property named \"Item\".","pos":[75,156]},{"content":"However, a class library developer can use the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.","pos":[157,324],"source":" However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata."},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id=\"ph2\">&lt;xref:System.String.Chars%2A&gt;</ph>.","pos":[325,420],"source":" For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>."},{"content":"Indexed properties created using languages other than C# can have names other than Item, as well.","pos":[421,518]}]}]},{"pos":[1995,2408],"content":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","nodes":[{"content":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","pos":[0,413],"nodes":[{"content":"To determine whether a type has a default property, use the <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id=\"ph2\">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.","pos":[0,231],"source":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute."},{"content":"If the type has <ph id=\"ph1\">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.","pos":[232,413],"source":" If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property."}]}]}],"pos":[364307,366733],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the public property to get.","nodes":[{"pos":[0,61],"content":"The string containing the name of the public property to get.","nodes":[{"content":"The string containing the name of the public property to get.","pos":[0,61]}]}],"pos":[367459,367521],"yaml":true},{"content":"The return type of the property.","nodes":[{"pos":[0,32],"content":"The return type of the property.","nodes":[{"content":"The return type of the property.","pos":[0,32]}]}],"pos":[367585,367618],"yaml":true},{"content":"An object representing the public property with the specified name, if found; otherwise, `null`.","nodes":[{"pos":[0,96],"content":"An object representing the public property with the specified name, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the public property with the specified name, if found; otherwise, `null`."}],"pos":[367692,367789],"yaml":true},{"content":"More than one property is found with the specified name.","nodes":[{"pos":[0,56],"content":"More than one property is found with the specified name.","nodes":[{"content":"More than one property is found with the specified name.","pos":[0,56]}]}],"pos":[367968,368025],"yaml":true},{"content":"<code>name</code> is `null`, or <code>returnType</code> is `null`.","nodes":[{"pos":[0,66],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>, or <ph id=\"ph3\">&lt;code&gt;returnType&lt;/code&gt;</ph> is <ph id=\"ph4\">`null`</ph>.","source":"<code>name</code> is `null`, or <code>returnType</code> is `null`."}],"pos":[368127,368194],"yaml":true},{"content":"Searches for the specified public property whose parameters match the specified argument types.","nodes":[{"pos":[0,95],"content":"Searches for the specified public property whose parameters match the specified argument types.","nodes":[{"content":"Searches for the specified public property whose parameters match the specified argument types.","pos":[0,95]}]}],"pos":[369357,369453],"yaml":true},{"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \n  \n The search for `name` is case-sensitive. The search includes public static and public instance properties.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  \n  \n## Indexers and Default Properties  \n [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.  \n  \n In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.  \n  \n To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","nodes":[{"pos":[0,419],"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.","nodes":[{"content":"A property is considered public to reflection if it has at least one accessor that is public.","pos":[0,93]},{"content":"Otherwise the property is considered private, and you must use <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id=\"ph4\">`Or`</ph>) to get it.","pos":[94,419],"source":" Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it."}]},{"pos":[426,532],"content":"The search for `name` is case-sensitive. The search includes public static and public instance properties.","nodes":[{"content":"The search for <ph id=\"ph1\">`name`</ph> is case-sensitive.","pos":[0,40],"source":"The search for `name` is case-sensitive."},{"content":"The search includes public static and public instance properties.","pos":[41,106]}]},{"pos":[539,742],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,203],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[749,926],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","pos":[0,177],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint."}]},{"pos":[935,966],"content":"Indexers and Default Properties","linkify":"Indexers and Default Properties","nodes":[{"content":"Indexers and Default Properties","pos":[0,31]}]},{"pos":[970,1463],"content":"[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.","nodes":[{"content":"<ph id=\"ph1\">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id=\"ph2\">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id=\"ph3\">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.","pos":[0,278],"source":"[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type."},{"content":"For example, if the variable <ph id=\"ph1\">`myList`</ph> refers to an <ph id=\"ph2\">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id=\"ph3\">`myList[3]`</ph> (<ph id=\"ph4\">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.","pos":[279,462],"source":" For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3."},{"content":"You can overload the property.","pos":[463,493]}]},{"pos":[1470,1988],"content":"In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.","nodes":[{"content":"In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.","pos":[0,518],"nodes":[{"content":"In C#, this feature is called an indexer and cannot be refered to by name.","pos":[0,74]},{"content":"By default, a C# indexer appears in metadata as an indexed property named \"Item\".","pos":[75,156]},{"content":"However, a class library developer can use the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.","pos":[157,324],"source":" However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata."},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id=\"ph2\">&lt;xref:System.String.Chars%2A&gt;</ph>.","pos":[325,420],"source":" For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>."},{"content":"Indexed properties created using languages other than C# can have names other than Item, as well.","pos":[421,518]}]}]},{"pos":[1995,2408],"content":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","nodes":[{"content":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","pos":[0,413],"nodes":[{"content":"To determine whether a type has a default property, use the <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id=\"ph2\">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.","pos":[0,231],"source":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute."},{"content":"If the type has <ph id=\"ph1\">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.","pos":[232,413],"source":" If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property."}]}]}],"pos":[369464,371890],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the public property to get.","nodes":[{"pos":[0,61],"content":"The string containing the name of the public property to get.","nodes":[{"content":"The string containing the name of the public property to get.","pos":[0,61]}]}],"pos":[372687,372749],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get.  \n  \n -or-  \n  \n An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed.","nodes":[{"pos":[0,144],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get."},{"pos":[151,155],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[162,298],"content":"An empty array of the type <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.","source":"An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed."}],"pos":[372810,373119],"yaml":true},{"content":"An object representing the public property whose parameters match the specified argument types, if found; otherwise, `null`.","nodes":[{"pos":[0,124],"content":"An object representing the public property whose parameters match the specified argument types, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the public property whose parameters match the specified argument types, if found; otherwise, `null`."}],"pos":[373193,373318],"yaml":true},{"content":"More than one property is found with the specified name and matching the specified argument types.","nodes":[{"pos":[0,98],"content":"More than one property is found with the specified name and matching the specified argument types.","nodes":[{"content":"More than one property is found with the specified name and matching the specified argument types.","pos":[0,98]}]}],"pos":[373497,373596],"yaml":true},{"content":"<code>name</code> is `null`.  \n  \n -or-  \n  \n <code>types</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."},{"pos":[35,39],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[46,75],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>types</code> is `null`."}],"pos":[373698,373780],"yaml":true},{"content":"<code>types</code> is multidimensional.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.","source":"<code>types</code> is multidimensional."}],"pos":[373874,373914],"yaml":true},{"content":"An element of <code>types</code> is `null`.","nodes":[{"pos":[0,43],"content":"An element of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"An element of <code>types</code> is `null`."}],"pos":[374018,374062],"yaml":true},{"content":"Searches for the specified public property whose parameters match the specified argument types.","nodes":[{"pos":[0,95],"content":"Searches for the specified public property whose parameters match the specified argument types.","nodes":[{"content":"Searches for the specified public property whose parameters match the specified argument types.","pos":[0,95]}]}],"pos":[375279,375375],"yaml":true},{"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \n  \n The search for `name` is case-sensitive. The search includes public static and public instance properties.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  \n  \n## Indexers and Default Properties  \n [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.  \n  \n In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.  \n  \n To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","nodes":[{"pos":[0,419],"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.","nodes":[{"content":"A property is considered public to reflection if it has at least one accessor that is public.","pos":[0,93]},{"content":"Otherwise the property is considered private, and you must use <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id=\"ph4\">`Or`</ph>) to get it.","pos":[94,419],"source":" Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it."}]},{"pos":[426,532],"content":"The search for `name` is case-sensitive. The search includes public static and public instance properties.","nodes":[{"content":"The search for <ph id=\"ph1\">`name`</ph> is case-sensitive.","pos":[0,40],"source":"The search for `name` is case-sensitive."},{"content":"The search includes public static and public instance properties.","pos":[41,106]}]},{"pos":[539,742],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,203],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[749,926],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","pos":[0,177],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint."}]},{"pos":[935,966],"content":"Indexers and Default Properties","linkify":"Indexers and Default Properties","nodes":[{"content":"Indexers and Default Properties","pos":[0,31]}]},{"pos":[970,1463],"content":"[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.","nodes":[{"content":"<ph id=\"ph1\">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id=\"ph2\">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id=\"ph3\">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.","pos":[0,278],"source":"[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type."},{"content":"For example, if the variable <ph id=\"ph1\">`myList`</ph> refers to an <ph id=\"ph2\">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id=\"ph3\">`myList[3]`</ph> (<ph id=\"ph4\">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.","pos":[279,462],"source":" For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3."},{"content":"You can overload the property.","pos":[463,493]}]},{"pos":[1470,1988],"content":"In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.","nodes":[{"content":"In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.","pos":[0,518],"nodes":[{"content":"In C#, this feature is called an indexer and cannot be refered to by name.","pos":[0,74]},{"content":"By default, a C# indexer appears in metadata as an indexed property named \"Item\".","pos":[75,156]},{"content":"However, a class library developer can use the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.","pos":[157,324],"source":" However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata."},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id=\"ph2\">&lt;xref:System.String.Chars%2A&gt;</ph>.","pos":[325,420],"source":" For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>."},{"content":"Indexed properties created using languages other than C# can have names other than Item, as well.","pos":[421,518]}]}]},{"pos":[1995,2408],"content":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","nodes":[{"content":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","pos":[0,413],"nodes":[{"content":"To determine whether a type has a default property, use the <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id=\"ph2\">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.","pos":[0,231],"source":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute."},{"content":"If the type has <ph id=\"ph1\">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.","pos":[232,413],"source":" If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property."}]}]}],"pos":[375386,377812],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the public property to get.","nodes":[{"pos":[0,61],"content":"The string containing the name of the public property to get.","nodes":[{"content":"The string containing the name of the public property to get.","pos":[0,61]}]}],"pos":[378007,378069],"yaml":true},{"content":"The return type of the property.","nodes":[{"pos":[0,32],"content":"The return type of the property.","nodes":[{"content":"The return type of the property.","pos":[0,32]}]}],"pos":[378133,378166],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get.  \n  \n -or-  \n  \n An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed.","nodes":[{"pos":[0,144],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get."},{"pos":[151,155],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[162,298],"content":"An empty array of the type <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.","source":"An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed."}],"pos":[378227,378536],"yaml":true},{"content":"An object representing the public property whose parameters match the specified argument types, if found; otherwise, `null`.","nodes":[{"pos":[0,124],"content":"An object representing the public property whose parameters match the specified argument types, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the public property whose parameters match the specified argument types, if found; otherwise, `null`."}],"pos":[378610,378735],"yaml":true},{"content":"More than one property is found with the specified name and matching the specified argument types.","nodes":[{"pos":[0,98],"content":"More than one property is found with the specified name and matching the specified argument types.","nodes":[{"content":"More than one property is found with the specified name and matching the specified argument types.","pos":[0,98]}]}],"pos":[378914,379013],"yaml":true},{"content":"<code>name</code> is `null`.  \n  \n -or-  \n  \n <code>types</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."},{"pos":[35,39],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[46,75],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>types</code> is `null`."}],"pos":[379115,379197],"yaml":true},{"content":"<code>types</code> is multidimensional.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.","source":"<code>types</code> is multidimensional."}],"pos":[379291,379331],"yaml":true},{"content":"An element of <code>types</code> is `null`.","nodes":[{"pos":[0,43],"content":"An element of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"An element of <code>types</code> is `null`."}],"pos":[379435,379479],"yaml":true},{"content":"Searches for the specified public property whose parameters match the specified argument types and modifiers.","nodes":[{"pos":[0,109],"content":"Searches for the specified public property whose parameters match the specified argument types and modifiers.","nodes":[{"content":"Searches for the specified public property whose parameters match the specified argument types and modifiers.","pos":[0,109]}]}],"pos":[380873,380983],"yaml":true},{"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \n  \n Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \n  \n The search for `name` is case-sensitive. The search includes public static and public instance properties.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  \n  \n## Indexers and Default Properties  \n [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.  \n  \n In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.  \n  \n To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","nodes":[{"pos":[0,419],"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.","nodes":[{"content":"A property is considered public to reflection if it has at least one accessor that is public.","pos":[0,93]},{"content":"Otherwise the property is considered private, and you must use <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id=\"ph4\">`Or`</ph>) to get it.","pos":[94,419],"source":" Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it."}]},{"pos":[426,815],"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.","nodes":[{"content":"Although the default binder does not process <ph id=\"ph1\">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id=\"ph2\">`modifiers`</ph> parameter), you can use the abstract <ph id=\"ph3\">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id=\"ph4\">`modifiers`</ph>.","pos":[0,260],"source":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`."},{"content":"<ph id=\"ph1\">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.","pos":[261,389],"source":"`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled."}]},{"pos":[822,928],"content":"The search for `name` is case-sensitive. The search includes public static and public instance properties.","nodes":[{"content":"The search for <ph id=\"ph1\">`name`</ph> is case-sensitive.","pos":[0,40],"source":"The search for `name` is case-sensitive."},{"content":"The search includes public static and public instance properties.","pos":[41,106]}]},{"pos":[935,1138],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,203],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[1145,1322],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","pos":[0,177],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint."}]},{"pos":[1331,1362],"content":"Indexers and Default Properties","linkify":"Indexers and Default Properties","nodes":[{"content":"Indexers and Default Properties","pos":[0,31]}]},{"pos":[1366,1859],"content":"[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.","nodes":[{"content":"<ph id=\"ph1\">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id=\"ph2\">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id=\"ph3\">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.","pos":[0,278],"source":"[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type."},{"content":"For example, if the variable <ph id=\"ph1\">`myList`</ph> refers to an <ph id=\"ph2\">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id=\"ph3\">`myList[3]`</ph> (<ph id=\"ph4\">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.","pos":[279,462],"source":" For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3."},{"content":"You can overload the property.","pos":[463,493]}]},{"pos":[1866,2384],"content":"In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.","nodes":[{"content":"In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.","pos":[0,518],"nodes":[{"content":"In C#, this feature is called an indexer and cannot be refered to by name.","pos":[0,74]},{"content":"By default, a C# indexer appears in metadata as an indexed property named \"Item\".","pos":[75,156]},{"content":"However, a class library developer can use the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.","pos":[157,324],"source":" However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata."},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id=\"ph2\">&lt;xref:System.String.Chars%2A&gt;</ph>.","pos":[325,420],"source":" For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>."},{"content":"Indexed properties created using languages other than C# can have names other than Item, as well.","pos":[421,518]}]}]},{"pos":[2391,2804],"content":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","nodes":[{"content":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","pos":[0,413],"nodes":[{"content":"To determine whether a type has a default property, use the <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id=\"ph2\">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.","pos":[0,231],"source":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute."},{"content":"If the type has <ph id=\"ph1\">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.","pos":[232,413],"source":" If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property."}]}]}],"pos":[380994,383818],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the public property to get.","nodes":[{"pos":[0,61],"content":"The string containing the name of the public property to get.","nodes":[{"content":"The string containing the name of the public property to get.","pos":[0,61]}]}],"pos":[384647,384709],"yaml":true},{"content":"The return type of the property.","nodes":[{"pos":[0,32],"content":"The return type of the property.","nodes":[{"content":"The return type of the property.","pos":[0,32]}]}],"pos":[384773,384806],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get.  \n  \n -or-  \n  \n An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed.","nodes":[{"pos":[0,144],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get."},{"pos":[151,155],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[162,298],"content":"An empty array of the type <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.","source":"An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed."}],"pos":[384867,385176],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.","nodes":[{"pos":[0,231],"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.","nodes":[{"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ParameterModifier\"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> array.","pos":[0,179],"source":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array."},{"content":"The default binder does not process this parameter.","pos":[180,231]}]}],"pos":[385265,385497],"yaml":true},{"content":"An object representing the public property that matches the specified requirements, if found; otherwise, `null`.","nodes":[{"pos":[0,112],"content":"An object representing the public property that matches the specified requirements, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the public property that matches the specified requirements, if found; otherwise, `null`."}],"pos":[385571,385684],"yaml":true},{"content":"More than one property is found with the specified name and matching the specified argument types and modifiers.","nodes":[{"pos":[0,112],"content":"More than one property is found with the specified name and matching the specified argument types and modifiers.","nodes":[{"content":"More than one property is found with the specified name and matching the specified argument types and modifiers.","pos":[0,112]}]}],"pos":[385863,385976],"yaml":true},{"content":"<code>name</code> is `null`.  \n  \n -or-  \n  \n <code>types</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."},{"pos":[35,39],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[46,75],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>types</code> is `null`."}],"pos":[386078,386160],"yaml":true},{"content":"<code>types</code> is multidimensional.  \n  \n -or-  \n  \n <code>modifiers</code> is multidimensional.  \n  \n -or-  \n  \n <code>types</code> and <code>modifiers</code> do not have the same length.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.","source":"<code>types</code> is multidimensional."},{"pos":[46,50],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[57,100],"content":"<ph id=\"ph1\">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.","source":"<code>modifiers</code> is multidimensional."},{"pos":[107,111],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[118,192],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.","source":"<code>types</code> and <code>modifiers</code> do not have the same length."}],"pos":[386254,386457],"yaml":true},{"content":"An element of <code>types</code> is `null`.","nodes":[{"pos":[0,43],"content":"An element of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"An element of <code>types</code> is `null`."}],"pos":[386561,386605],"yaml":true},{"content":"Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.","nodes":[{"pos":[0,143],"content":"Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.","nodes":[{"content":"Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.","pos":[0,143]}]}],"pos":[388233,388377],"yaml":true},{"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \n  \n Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public properties in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \n  \n-   `BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  \n  \n## Indexers and Default Properties  \n [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.  \n  \n In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.  \n  \n To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","nodes":[{"pos":[0,419],"content":"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.","nodes":[{"content":"A property is considered public to reflection if it has at least one accessor that is public.","pos":[0,93]},{"content":"Otherwise the property is considered private, and you must use <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> &amp;#124; <ph id=\"ph3\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> (in Visual Basic, combine the values using <ph id=\"ph4\">`Or`</ph>) to get it.","pos":[94,419],"source":" Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it."}]},{"pos":[426,815],"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.","nodes":[{"content":"Although the default binder does not process <ph id=\"ph1\">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id=\"ph2\">`modifiers`</ph> parameter), you can use the abstract <ph id=\"ph3\">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id=\"ph4\">`modifiers`</ph>.","pos":[0,260],"source":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`."},{"content":"<ph id=\"ph1\">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.","pos":[261,389],"source":"`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled."}]},{"pos":[822,937],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[944,955],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[956,962],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[963,973],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[1031,1042],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[1043,1045],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1046,1048],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1053,1058],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[1059,1061],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1062,1112],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[1117,1122],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[1123,1137],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1138,1331],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1336,1342],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[1343,1345],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1346,1441],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[1446,1457],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[1458,1460],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1461,1463],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[1468,1476],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[1477,1491],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[1492,1685],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[1696,1901],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[1911,2227],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[2237,2294],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[2301,2430],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:","pos":[0,129],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:"}]},{"pos":[2440,2538],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[2548,2621],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public properties in the search.","source":"Specify `BindingFlags.Public` to include public properties in the search."},{"pos":[2631,2766],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search."},{"pos":[2776,2948],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[2955,3065],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[3075,3130],"content":"<ph id=\"ph1\">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id=\"ph2\">`name`</ph>.","source":"`BindingFlags.IgnoreCase` to ignore the case of `name`."},{"pos":[3140,3276],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited."},{"pos":[3283,3371],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[3378,3581],"content":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this method returns the <ph id=\"ph2\">&lt;xref:System.Reflection.PropertyInfo&gt;</ph> with the type parameters replaced by the appropriate type arguments.","pos":[0,203],"source":"If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments."}]},{"pos":[3588,3765],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.","pos":[0,177],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint."}]},{"pos":[3774,3805],"content":"Indexers and Default Properties","linkify":"Indexers and Default Properties","nodes":[{"content":"Indexers and Default Properties","pos":[0,31]}]},{"pos":[3809,4302],"content":"[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.","nodes":[{"content":"<ph id=\"ph1\">[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]</ph>, <ph id=\"ph2\">[!INCLUDE[csprcslong](~/includes/csprcslong-md.md)]</ph>, and <ph id=\"ph3\">[!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)]</ph> have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.","pos":[0,278],"source":"[!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type."},{"content":"For example, if the variable <ph id=\"ph1\">`myList`</ph> refers to an <ph id=\"ph2\">&lt;xref:System.Collections.ArrayList&gt;</ph>, the syntax <ph id=\"ph3\">`myList[3]`</ph> (<ph id=\"ph4\">`myList(3)`</ph> in Visual Basic) retrieves the element with the index of 3.","pos":[279,462],"source":" For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3."},{"content":"You can overload the property.","pos":[463,493]}]},{"pos":[4309,4827],"content":"In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.","nodes":[{"content":"In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \"Item\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.","pos":[0,518],"nodes":[{"content":"In C#, this feature is called an indexer and cannot be refered to by name.","pos":[0,74]},{"content":"By default, a C# indexer appears in metadata as an indexed property named \"Item\".","pos":[75,156]},{"content":"However, a class library developer can use the <ph id=\"ph1\">&lt;xref:System.Runtime.CompilerServices.IndexerNameAttribute&gt;</ph> attribute to change the name of the indexer in the metadata.","pos":[157,324],"source":" However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata."},{"content":"For example, the <ph id=\"ph1\">&lt;xref:System.String&gt;</ph> class has an indexer named <ph id=\"ph2\">&lt;xref:System.String.Chars%2A&gt;</ph>.","pos":[325,420],"source":" For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>."},{"content":"Indexed properties created using languages other than C# can have names other than Item, as well.","pos":[421,518]}]}]},{"pos":[4834,5247],"content":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","nodes":[{"content":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.","pos":[0,413],"nodes":[{"content":"To determine whether a type has a default property, use the <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29&gt;</ph> method to test for the <ph id=\"ph2\">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph> attribute.","pos":[0,231],"source":"To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute."},{"content":"If the type has <ph id=\"ph1\">&lt;xref:System.Reflection.DefaultMemberAttribute&gt;</ph>, the <ph id=\"ph2\">&lt;xref:System.Reflection.DefaultMemberAttribute.MemberName%2A&gt;</ph> property returns the name of the default property.","pos":[232,413],"source":" If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property."}]}]}],"pos":[388388,393688],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the property to get.","nodes":[{"pos":[0,54],"content":"The string containing the name of the property to get.","nodes":[{"content":"The string containing the name of the property to get.","pos":[0,54]}]}],"pos":[394009,394064],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[394148,394326],"yaml":true},{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \n  \n -or-  \n  \n A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>.","nodes":[{"pos":[0,191],"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","nodes":[{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","pos":[0,191]}]},{"pos":[198,202],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[209,313],"content":"A null reference (<ph id=\"ph1\">`Nothing`</ph> in Visual Basic), to use the <ph id=\"ph2\">&lt;xref href=\"System.Type.DefaultBinder\"&gt;&lt;/xref&gt;</ph>.","source":"A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>."}],"pos":[394399,394721],"yaml":true},{"content":"The return type of the property.","nodes":[{"pos":[0,32],"content":"The return type of the property.","nodes":[{"content":"The return type of the property.","pos":[0,32]}]}],"pos":[394785,394818],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get.  \n  \n -or-  \n  \n An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed.","nodes":[{"pos":[0,144],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get."},{"pos":[151,155],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[162,298],"content":"An empty array of the type <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.","source":"An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed."}],"pos":[394879,395188],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.","nodes":[{"pos":[0,231],"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.","nodes":[{"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ParameterModifier\"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> array.","pos":[0,179],"source":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array."},{"content":"The default binder does not process this parameter.","pos":[180,231]}]}],"pos":[395277,395509],"yaml":true},{"content":"An object representing the property that matches the specified requirements, if found; otherwise, `null`.","nodes":[{"pos":[0,105],"content":"An object representing the property that matches the specified requirements, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the property that matches the specified requirements, if found; otherwise, `null`."}],"pos":[395583,395689],"yaml":true},{"content":"More than one property is found with the specified name and matching the specified binding constraints.","nodes":[{"pos":[0,103],"content":"More than one property is found with the specified name and matching the specified binding constraints.","nodes":[{"content":"More than one property is found with the specified name and matching the specified binding constraints.","pos":[0,103]}]}],"pos":[395868,395972],"yaml":true},{"content":"<code>name</code> is `null`.  \n  \n -or-  \n  \n <code>types</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."},{"pos":[35,39],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[46,75],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>types</code> is `null`."}],"pos":[396074,396156],"yaml":true},{"content":"<code>types</code> is multidimensional.  \n  \n -or-  \n  \n <code>modifiers</code> is multidimensional.  \n  \n -or-  \n  \n <code>types</code> and <code>modifiers</code> do not have the same length.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.","source":"<code>types</code> is multidimensional."},{"pos":[46,50],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[57,100],"content":"<ph id=\"ph1\">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.","source":"<code>modifiers</code> is multidimensional."},{"pos":[107,111],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[118,192],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.","source":"<code>types</code> and <code>modifiers</code> do not have the same length."}],"pos":[396250,396453],"yaml":true},{"content":"An element of <code>types</code> is `null`.","nodes":[{"pos":[0,43],"content":"An element of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"An element of <code>types</code> is `null`."}],"pos":[396557,396601],"yaml":true},{"content":"When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.","nodes":[{"pos":[0,179],"content":"When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.","nodes":[{"content":"When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.","pos":[0,179]}]}],"pos":[398253,398433],"yaml":true},{"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:  \n  \n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \n  \n-   Specify `BindingFlags.Public` to include public properties in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \n  \n-   `BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"pos":[0,389],"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.","nodes":[{"content":"Although the default binder does not process <ph id=\"ph1\">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> (the <ph id=\"ph2\">`modifiers`</ph> parameter), you can use the abstract <ph id=\"ph3\">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id=\"ph4\">`modifiers`</ph>.","pos":[0,260],"source":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`."},{"content":"<ph id=\"ph1\">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.","pos":[261,389],"source":"`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled."}]},{"pos":[396,525],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which properties to include in the search:","pos":[0,129],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:"}]},{"pos":[535,633],"content":"You must specify either <ph id=\"ph1\">`BindingFlags.Instance`</ph> or <ph id=\"ph2\">`BindingFlags.Static`</ph> in order to get a return.","source":"You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return."},{"pos":[643,716],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public properties in the search.","source":"Specify `BindingFlags.Public` to include public properties in the search."},{"pos":[726,861],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public properties (that is, private, internal, and protected properties) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search."},{"pos":[871,1043],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include <ph id=\"ph2\">`public`</ph> and <ph id=\"ph3\">`protected`</ph> static members up the hierarchy; <ph id=\"ph4\">`private`</ph> static members in inherited classes are not included.","source":"Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included."},{"pos":[1050,1160],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[1170,1225],"content":"<ph id=\"ph1\">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id=\"ph2\">`name`</ph>.","source":"`BindingFlags.IgnoreCase` to ignore the case of `name`."},{"pos":[1235,1371],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the properties declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not properties that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited."},{"pos":[1378,1466],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]}],"pos":[398444,399931],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the property to get.","nodes":[{"pos":[0,54],"content":"The string containing the name of the property to get.","nodes":[{"content":"The string containing the name of the property to get.","pos":[0,54]}]}],"pos":[400268,400323],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted.  \n  \n -or-  \n  \n Zero, to return `null`.","nodes":[{"pos":[0,128],"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"pos":[135,139],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[146,169],"content":"Zero, to return <ph id=\"ph1\">`null`</ph>.","source":"Zero, to return `null`."}],"pos":[400407,400585],"yaml":true},{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.  \n  \n -or-  \n  \n A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>.","nodes":[{"pos":[0,191],"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.","nodes":[{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.","pos":[0,191]}]},{"pos":[198,202],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[209,313],"content":"A null reference (<ph id=\"ph1\">`Nothing`</ph> in Visual Basic), to use the <ph id=\"ph2\">&lt;xref href=\"System.Type.DefaultBinder\"&gt;&lt;/xref&gt;</ph>.","source":"A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>."}],"pos":[400658,400980],"yaml":true},{"content":"The return type of the property.","nodes":[{"pos":[0,32],"content":"The return type of the property.","nodes":[{"content":"The return type of the property.","pos":[0,32]}]}],"pos":[401044,401077],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get.  \n  \n -or-  \n  \n An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed.","nodes":[{"pos":[0,144],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the number, order, and type of the parameters for the indexed property to get.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get."},{"pos":[151,155],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[162,298],"content":"An empty array of the type <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> (that is, Type[] types = new Type[0]) to get a property that is not indexed.","source":"An empty array of the type <xref href=\"System.Type\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed."}],"pos":[401138,401447],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.","nodes":[{"pos":[0,231],"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.","nodes":[{"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ParameterModifier\"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> array.","pos":[0,179],"source":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array."},{"content":"The default binder does not process this parameter.","pos":[180,231]}]}],"pos":[401536,401768],"yaml":true},{"content":"An object representing the property that matches the specified requirements, if found; otherwise, `null`.","nodes":[{"pos":[0,105],"content":"An object representing the property that matches the specified requirements, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"An object representing the property that matches the specified requirements, if found; otherwise, `null`."}],"pos":[401842,401948],"yaml":true},{"content":"More than one property is found with the specified name and matching the specified binding constraints.","nodes":[{"pos":[0,103],"content":"More than one property is found with the specified name and matching the specified binding constraints.","nodes":[{"content":"More than one property is found with the specified name and matching the specified binding constraints.","pos":[0,103]}]}],"pos":[402131,402235],"yaml":true},{"content":"<code>name</code> is `null`.  \n  \n -or-  \n  \n <code>types</code> is `null`.  \n  \n -or-  \n  \n One of the elements in <code>types</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>name</code> is `null`."},{"pos":[35,39],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[46,75],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>types</code> is `null`."},{"pos":[82,86],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[93,145],"content":"One of the elements in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">types</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"One of the elements in <code>types</code> is `null`."}],"pos":[402337,402493],"yaml":true},{"content":"<code>types</code> is multidimensional.  \n  \n -or-  \n  \n <code>modifiers</code> is multidimensional.  \n  \n -or-  \n  \n <code>types</code> and <code>modifiers</code> do not have the same length.","nodes":[{"pos":[0,39],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> is multidimensional.","source":"<code>types</code> is multidimensional."},{"pos":[46,50],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[57,100],"content":"<ph id=\"ph1\">&lt;code&gt;modifiers&lt;/code&gt;</ph> is multidimensional.","source":"<code>modifiers</code> is multidimensional."},{"pos":[107,111],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[118,192],"content":"<ph id=\"ph1\">&lt;code&gt;types&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.","source":"<code>types</code> and <code>modifiers</code> do not have the same length."}],"pos":[402587,402790],"yaml":true},{"content":"The current type is a <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref>, <xref href=\"System.Reflection.Emit.EnumBuilder\"></xref>, or <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\"></xref>.","nodes":[{"pos":[0,211],"content":"The current type is a <ph id=\"ph1\">&lt;xref href=\"System.Reflection.Emit.TypeBuilder\"&gt;&lt;/xref&gt;</ph>, <ph id=\"ph2\">&lt;xref href=\"System.Reflection.Emit.EnumBuilder\"&gt;&lt;/xref&gt;</ph>, or <ph id=\"ph3\">&lt;xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\"&gt;&lt;/xref&gt;</ph>.","source":"The current type is a <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref>, <xref href=\"System.Reflection.Emit.EnumBuilder\"></xref>, or <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\"></xref>."}],"pos":[402892,403104],"yaml":true},{"content":"Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.","nodes":[{"pos":[0,230],"content":"Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.","nodes":[{"content":"Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.","pos":[0,230]}]}],"pos":[404972,405203],"yaml":true},{"content":"Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations. By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:  \n  \n-   Control which version of an assembly a type is loaded from.  \n  \n-   Provide another place to look for a type name that does not include an assembly name.  \n  \n-   Load assemblies using partial assembly names.  \n  \n-   Return subclasses of <xref:System.Type?displayProperty=fullName> that are not created by the common language runtime (CLR).  \n  \n For example, in version-tolerant serialization this method enables you to search for a \"best fit\" assembly by using a partial name. Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.  \n  \n Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=fullName> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.  \n  \n<a name=\"usage_notes\"></a>   \n## Usage Notes  \n This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names. Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.  \n  \n> [!NOTE]\n>  If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.  \n  \n If `typeName` is not an assembly-qualified name, assembly resolution is skipped. Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter. The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.  \n  \n General usage notes:  \n  \n-   Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers. Use only methods that you provide or that you are familiar with.  \n  \n    > [!CAUTION]\n    >  Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.  \n  \n-   If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution.  \n  \n-   If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`.  \n  \n-   This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`. You are responsible for any exceptions that are thrown by the resolver methods.  \n  \n<a name=\"resolving_assemblies\"></a>   \n### Resolving Assemblies  \n The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`. If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.  \n  \n If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly. If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.  \n  \n The `assemblyResolver` method should return `null` if the assembly cannot be resolved. If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.  \n  \n If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`. For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`. If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied. The `assemblyResolver` method can use or ignore all parts of the assembly name.  \n  \n The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.  \n  \n<a name=\"resolving_types\"></a>   \n### Resolving Types  \n If `typeName` does not specify an assembly name, `typeResolver` is always called. If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved. If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.  \n  \n The `typeResolver` method receives three arguments:  \n  \n-   The assembly to search or `null` if `typeName` does not contain an assembly name.  \n  \n-   The simple name of the type. In the case of a nested type, this is the outermost containing type. In the case of a generic type, this is the simple name of the generic type.  \n  \n-   A Boolean value that is `true` if the case of type names is to be ignored.  \n  \n The implementation determines the way these arguments are used. The `typeResolver` method should return `null` if it cannot resolve the type. If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.  \n  \n The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.  \n  \n#### Resolving Nested Types  \n If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`. When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.  \n  \n#### Resolving Generic Types  \n The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments. If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.  \n  \n The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion. For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`. Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic). You might pass the following generic type name:  \n  \n```  \n\"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]\"  \n```  \n  \n Notice that `MyType` is the only assembly-qualified type argument. The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified. Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>. It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:  \n  \n [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  \n  \n The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.  \n  \n Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:  \n  \n```  \n\"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]\"  \n```  \n  \n Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name. Because your `assemblyResolve` will be called recursively, it must be able to handle this case. Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.  \n  \n [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  \n  \n Back to [Usage Notes](#usage_notes).  \n  \n#### Resolving Type Names with Special Characters  \n Certain characters have special meanings in assembly-qualified names. If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name. To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method. For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\\]Type`.  \n  \n> [!NOTE]\n>  Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.  \n  \n The following table shows the special characters for type names.  \n  \n|Character|Meaning|  \n|---------------|-------------|  \n|, (comma)|Delimiter for assembly-qualified names.|  \n|[] (square brackets)|As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.|  \n|& (ampersand)|As a suffix, indicates that a type is a reference type.|  \n|* (asterisk)|As a suffix, indicates that a type is a pointer type.|  \n|+ (plus)|Delimiter for nested types.|  \n|\\ (backslash)|Escape character.|  \n  \n Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings. You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method. In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods. If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.  \n  \n Back to [Usage Notes](#usage_notes).  \n  \n<a name=\"mixed_name_resolution\"></a>   \n## Mixed Name Resolution  \n The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:  \n  \n|Contents of type name|Assembly resolver method|Type resolver method|Result|  \n|---------------------------|------------------------------|--------------------------|------------|  \n|type, assembly|null|null|Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> method overload.|  \n|type, assembly|provided|null|`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly. If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.|  \n|type, assembly|null|provided|Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=fullName> method overload to get the assembly. If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.|  \n|type, assembly|provided|provided|`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly. If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.|  \n|type|null, provided|null|Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> method overload. Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched. If `assemblyResolver` is provided, it is ignored.|  \n|type|null, provided|provided|`typeResolver` is called, and `null` is passed for the assembly. `typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose. If `assemblyResolver` is provided, it is ignored.|  \n|assembly|null, provided|null, provided|A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name. This results in an invalid assembly name.|  \n  \n Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types).","nodes":[{"pos":[0,761],"content":"Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations. By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:","nodes":[{"content":"Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations. By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:","pos":[0,761],"nodes":[{"content":"Use this method overload and its associated overloads (<ph id=\"ph1\">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29&gt;</ph>) to replace the default implementation of the <ph id=\"ph3\">&lt;xref:System.Type.GetType%2A&gt;</ph> method with more flexible implementations.","pos":[0,630],"source":"Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations."},{"content":"By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:","pos":[631,761]}]}]},{"pos":[771,830],"content":"Control which version of an assembly a type is loaded from.","nodes":[{"content":"Control which version of an assembly a type is loaded from.","pos":[0,59]}]},{"pos":[840,925],"content":"Provide another place to look for a type name that does not include an assembly name.","nodes":[{"content":"Provide another place to look for a type name that does not include an assembly name.","pos":[0,85]}]},{"pos":[935,980],"content":"Load assemblies using partial assembly names.","nodes":[{"content":"Load assemblies using partial assembly names.","pos":[0,45]}]},{"pos":[990,1113],"content":"Return subclasses of <xref:System.Type?displayProperty=fullName> that are not created by the common language runtime (CLR).","nodes":[{"content":"Return subclasses of <ph id=\"ph1\">&lt;xref:System.Type?displayProperty=fullName&gt;</ph> that are not created by the common language runtime (CLR).","pos":[0,123],"source":"Return subclasses of <xref:System.Type?displayProperty=fullName> that are not created by the common language runtime (CLR)."}]},{"pos":[1120,1387],"content":"For example, in version-tolerant serialization this method enables you to search for a \"best fit\" assembly by using a partial name. Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.","nodes":[{"content":"For example, in version-tolerant serialization this method enables you to search for a \"best fit\" assembly by using a partial name. Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.","pos":[0,267],"nodes":[{"content":"For example, in version-tolerant serialization this method enables you to search for a \"best fit\" assembly by using a partial name.","pos":[0,131]},{"content":"Other overloads of the <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> method require an assembly-qualified type name, which includes the version number.","pos":[132,267],"source":" Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number."}]}]},{"pos":[1394,1658],"content":"Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=fullName> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.","nodes":[{"content":"Alternate implementations of the type system may need to return subclasses of <ph id=\"ph1\">&lt;xref:System.Type?displayProperty=fullName&gt;</ph> that are not created by the CLR; all types that are returned by other overloads of the <ph id=\"ph2\">&lt;xref:System.Type.GetType%2A&gt;</ph> method are runtime types.","pos":[0,264],"source":"Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=fullName> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types."}]},{"pos":[1697,1708],"content":"Usage Notes","linkify":"Usage Notes","nodes":[{"content":"Usage Notes","pos":[0,11]}]},{"pos":[1712,2002],"content":"This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names. Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.","nodes":[{"content":"This method overload and its associated overloads parse <ph id=\"ph1\">`typeName`</ph> into the name of a type and the name of an assembly, and then resolve the names.","pos":[0,147],"source":"This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names."},{"content":"Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.","pos":[148,290]}]},{"pos":[2010,2155],"content":"[!NOTE]\n If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.","leadings":["","> "],"nodes":[{"content":"If you are unfamiliar with the concept of assembly-qualified type names, see the <ph id=\"ph1\">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property.","pos":[9,143],"source":" If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property."}]},{"pos":[2162,2607],"content":"If `typeName` is not an assembly-qualified name, assembly resolution is skipped. Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter. The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.","nodes":[{"content":"If <ph id=\"ph1\">`typeName`</ph> is not an assembly-qualified name, assembly resolution is skipped.","pos":[0,80],"source":"If `typeName` is not an assembly-qualified name, assembly resolution is skipped."},{"content":"Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the <ph id=\"ph1\">`typeResolver`</ph> parameter.","pos":[81,262],"source":" Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter."},{"content":"The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the <bpt id=\"p1\">[</bpt>Mixed Name Resolution<ept id=\"p1\">](#mixed_name_resolution)</ept> section.","pos":[263,445],"source":" The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section."}]},{"pos":[2614,2634],"content":"General usage notes:","nodes":[{"content":"General usage notes:","pos":[0,20]}]},{"pos":[2644,2816],"content":"Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers. Use only methods that you provide or that you are familiar with.","nodes":[{"content":"Do not pass methods to <ph id=\"ph1\">`assemblyResolver`</ph> or <ph id=\"ph2\">`typeResolver`</ph> if they come from unknown or untrusted callers.","pos":[0,107],"source":"Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers."},{"content":"Use only methods that you provide or that you are familiar with.","pos":[108,172]}]},{"pos":[2828,2952],"content":"[!CAUTION]\nUsing methods from unknown or untrusted callers could result in elevation of privilege for malicious code.","leadings":["","    >  "],"nodes":[{"content":"Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.","pos":[11,117]}]},{"pos":[2962,3134],"content":"If you omit the <ph id=\"ph1\">`assemblyResolver`</ph> and/or <ph id=\"ph2\">`typeResolver`</ph> parameters, the value of the <ph id=\"ph3\">`throwOnError`</ph> parameter is passed to the methods that perform the default resolution.","source":"If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution."},{"pos":[3144,3346],"content":"If <ph id=\"ph1\">`throwOnError`</ph> is <ph id=\"ph2\">`true`</ph>, this method throws a <ph id=\"ph3\">&lt;xref:System.TypeLoadException&gt;</ph> when <ph id=\"ph4\">`typeResolver`</ph> returns <ph id=\"ph5\">`null`</ph>, and a <ph id=\"ph6\">&lt;xref:System.IO.FileNotFoundException&gt;</ph> when <ph id=\"ph7\">`assemblyResolver`</ph> returns <ph id=\"ph8\">`null`</ph>.","source":"If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`."},{"pos":[3356,3522],"content":"This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`. You are responsible for any exceptions that are thrown by the resolver methods.","nodes":[{"content":"This method does not catch exceptions thrown by <ph id=\"ph1\">`assemblyResolver`</ph> and <ph id=\"ph2\">`typeResolver`</ph>.","pos":[0,86],"source":"This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`."},{"content":"You are responsible for any exceptions that are thrown by the resolver methods.","pos":[87,166]}]},{"pos":[3571,3591],"content":"Resolving Assemblies","linkify":"Resolving Assemblies","nodes":[{"content":"Resolving Assemblies","pos":[0,20]}]},{"pos":[3595,3890],"content":"The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`. If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.","nodes":[{"content":"The <ph id=\"ph1\">`assemblyResolver`</ph> method receives an <ph id=\"ph2\">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object, which is produced by parsing the string assembly name that is included in <ph id=\"ph3\">`typeName`</ph>.","pos":[0,173],"source":"The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`."},{"content":"If <ph id=\"ph1\">`typeName`</ph> does not contain an assembly name, <ph id=\"ph2\">`assemblyResolver`</ph> is not called and <ph id=\"ph3\">`null`</ph> is passed to <ph id=\"ph4\">`typeResolver`</ph>.","pos":[174,295],"source":" If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`."}]},{"pos":[3897,4203],"content":"If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly. If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.","nodes":[{"content":"If <ph id=\"ph1\">`assemblyResolver`</ph> is not supplied, standard assembly probing is used to locate the assembly.","pos":[0,96],"source":"If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly."},{"content":"If <ph id=\"ph1\">`assemblyResolver`</ph> is provided, the <ph id=\"ph2\">&lt;xref:System.Type.GetType%2A&gt;</ph> method does not do standard probing; in that case you must ensure that your <ph id=\"ph3\">`assemblyResolver`</ph> can handle all the assemblies you pass to it.","pos":[97,306],"source":" If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it."}]},{"pos":[4210,4492],"content":"The `assemblyResolver` method should return `null` if the assembly cannot be resolved. If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.","nodes":[{"content":"The <ph id=\"ph1\">`assemblyResolver`</ph> method should return <ph id=\"ph2\">`null`</ph> if the assembly cannot be resolved.","pos":[0,86],"source":"The `assemblyResolver` method should return `null` if the assembly cannot be resolved."},{"content":"If <ph id=\"ph1\">`assemblyResolver`</ph> returns <ph id=\"ph2\">`null`</ph>, <ph id=\"ph3\">`typeResolver`</ph> is not called and no further processing occurs; additionally, if <ph id=\"ph4\">`throwOnError`</ph> is <ph id=\"ph5\">`true`</ph>, a <ph id=\"ph6\">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.","pos":[87,282],"source":" If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown."}]},{"pos":[4499,5106],"content":"If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`. For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`. If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied. The `assemblyResolver` method can use or ignore all parts of the assembly name.","nodes":[{"content":"If the <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblyName&gt;</ph> that is passed to <ph id=\"ph2\">`assemblyResolver`</ph> is a partial name, one or more of its parts are <ph id=\"ph3\">`null`</ph>.","pos":[0,137],"source":"If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`."},{"content":"For example, if it has no version, the <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> property is <ph id=\"ph2\">`null`</ph>.","pos":[138,245],"source":" For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`."},{"content":"If the <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblyName.Version%2A&gt;</ph> property, the <ph id=\"ph2\">&lt;xref:System.Reflection.AssemblyName.CultureInfo%2A&gt;</ph> property, and the <ph id=\"ph3\">&lt;xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A&gt;</ph> method all return <ph id=\"ph4\">`null`</ph>, then only the simple name of the assembly was supplied.","pos":[246,527],"source":" If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied."},{"content":"The <ph id=\"ph1\">`assemblyResolver`</ph> method can use or ignore all parts of the assembly name.","pos":[528,607],"source":" The `assemblyResolver` method can use or ignore all parts of the assembly name."}]},{"pos":[5113,5300],"content":"The effects of different assembly resolution options are displayed as a table in the <bpt id=\"p1\">[</bpt>Mixed Name Resolution<ept id=\"p1\">](#mixed_name_resolution)</ept> section, for simple and assembly-qualified type names.","source":"The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names."},{"pos":[5344,5359],"content":"Resolving Types","linkify":"Resolving Types","nodes":[{"content":"Resolving Types","pos":[0,15]}]},{"pos":[5363,5662],"content":"If `typeName` does not specify an assembly name, `typeResolver` is always called. If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved. If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.","nodes":[{"content":"If <ph id=\"ph1\">`typeName`</ph> does not specify an assembly name, <ph id=\"ph2\">`typeResolver`</ph> is always called.","pos":[0,81],"source":"If `typeName` does not specify an assembly name, `typeResolver` is always called."},{"content":"If <ph id=\"ph1\">`typeName`</ph> specifies an assembly name, <ph id=\"ph2\">`typeResolver`</ph> is called only when the assembly name is successfully resolved.","pos":[82,202],"source":" If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved."},{"content":"If <ph id=\"ph1\">`assemblyResolver`</ph> or standard assembly probing returns <ph id=\"ph2\">`null`</ph>, <ph id=\"ph3\">`typeResolver`</ph> is not called.","pos":[203,299],"source":" If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called."}]},{"pos":[5669,5720],"content":"The <ph id=\"ph1\">`typeResolver`</ph> method receives three arguments:","source":"The `typeResolver` method receives three arguments:"},{"pos":[5730,5811],"content":"The assembly to search or <ph id=\"ph1\">`null`</ph> if <ph id=\"ph2\">`typeName`</ph> does not contain an assembly name.","source":"The assembly to search or `null` if `typeName` does not contain an assembly name."},{"pos":[5821,5994],"content":"The simple name of the type. In the case of a nested type, this is the outermost containing type. In the case of a generic type, this is the simple name of the generic type.","nodes":[{"content":"The simple name of the type. In the case of a nested type, this is the outermost containing type. In the case of a generic type, this is the simple name of the generic type.","pos":[0,173],"nodes":[{"content":"The simple name of the type.","pos":[0,28]},{"content":"In the case of a nested type, this is the outermost containing type.","pos":[29,97]},{"content":"In the case of a generic type, this is the simple name of the generic type.","pos":[98,173]}]}]},{"pos":[6004,6078],"content":"A Boolean value that is <ph id=\"ph1\">`true`</ph> if the case of type names is to be ignored.","source":"A Boolean value that is `true` if the case of type names is to be ignored."},{"pos":[6085,6378],"content":"The implementation determines the way these arguments are used. The `typeResolver` method should return `null` if it cannot resolve the type. If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.","nodes":[{"content":"The implementation determines the way these arguments are used.","pos":[0,63]},{"content":"The <ph id=\"ph1\">`typeResolver`</ph> method should return <ph id=\"ph2\">`null`</ph> if it cannot resolve the type.","pos":[64,141],"source":" The `typeResolver` method should return `null` if it cannot resolve the type."},{"content":"If <ph id=\"ph1\">`typeResolver`</ph> returns <ph id=\"ph2\">`null`</ph> and <ph id=\"ph3\">`throwOnError`</ph> is <ph id=\"ph4\">`true`</ph>, this overload of <ph id=\"ph5\">&lt;xref:System.Type.GetType%2A&gt;</ph> throws a <ph id=\"ph6\">&lt;xref:System.TypeLoadException&gt;</ph>.","pos":[142,293],"source":" If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>."}]},{"pos":[6385,6568],"content":"The effects of different type resolution options are displayed as a table in the <bpt id=\"p1\">[</bpt>Mixed Name Resolution<ept id=\"p1\">](#mixed_name_resolution)</ept> section, for simple and assembly-qualified type names.","source":"The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names."},{"pos":[6579,6601],"content":"Resolving Nested Types","linkify":"Resolving Nested Types","nodes":[{"content":"Resolving Nested Types","pos":[0,22]}]},{"pos":[6605,6871],"content":"If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`. When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.","nodes":[{"content":"If <ph id=\"ph1\">`typeName`</ph> is a nested type, only the name of the outermost containing type is passed to <ph id=\"ph2\">`typeResolver`</ph>.","pos":[0,107],"source":"If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`."},{"content":"When <ph id=\"ph1\">`typeResolver`</ph> returns this type, the <ph id=\"ph2\">&lt;xref:System.Type.GetNestedType%2A&gt;</ph> method is called recursively until the innermost nested type has been resolved.","pos":[108,266],"source":" When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved."}]},{"pos":[6882,6905],"content":"Resolving Generic Types","linkify":"Resolving Generic Types","nodes":[{"content":"Resolving Generic Types","pos":[0,23]}]},{"pos":[6909,7197],"content":"The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments. If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.","nodes":[{"content":"The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments. If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.","pos":[0,288],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.","pos":[0,163],"source":"The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments."},{"content":"If a type argument is generic, <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> is called recursively to resolve its type arguments, and so on.","pos":[164,288],"source":" If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on."}]}]},{"pos":[7204,7606],"content":"The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion. For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`. Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic). You might pass the following generic type name:","nodes":[{"content":"The combination of <ph id=\"ph1\">`assemblyResolver`</ph> and <ph id=\"ph2\">`typeResolver`</ph> that you provide must be capable of resolving all levels of this recursion.","pos":[0,132],"source":"The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion."},{"content":"For example, suppose you supply an <ph id=\"ph1\">`assemblyResolver`</ph> that controls the loading of <ph id=\"ph2\">`MyAssembly`</ph>.","pos":[133,229],"source":" For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`."},{"content":"Suppose you want to resolve the generic type <ph id=\"ph1\">`Dictionary&lt;string, MyType&gt;`</ph> (<ph id=\"ph2\">`Dictionary(Of String, MyType)`</ph> in Visual Basic).","pos":[230,354],"source":" Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic)."},{"content":"You might pass the following generic type name:","pos":[355,402]}]},{"pos":[7720,8269],"content":"Notice that `MyType` is the only assembly-qualified type argument. The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified. Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>. It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:","nodes":[{"content":"Notice that <ph id=\"ph1\">`MyType`</ph> is the only assembly-qualified type argument.","pos":[0,66],"source":"Notice that `MyType` is the only assembly-qualified type argument."},{"content":"The names of the <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.String&gt;</ph> classes are not assembly-qualified.","pos":[67,193],"source":" The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified."},{"content":"Your <ph id=\"ph1\">`typeResolver`</ph> must be able handle either an assembly or <ph id=\"ph2\">`null`</ph>, because it will receive <ph id=\"ph3\">`null`</ph> for <ph id=\"ph4\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> and <ph id=\"ph5\">&lt;xref:System.String&gt;</ph>.","pos":[194,373],"source":" Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>."},{"content":"It can handle that case by calling an overload of the <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:","pos":[374,549],"source":" It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:"}]},{"pos":[8276,8387],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>GetTypeOnSteroids#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]"},{"pos":[8394,8535],"content":"The <ph id=\"ph1\">`assemblyResolver`</ph> method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.","source":"The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified."},{"pos":[8542,8654],"content":"Now suppose that instead of <ph id=\"ph1\">`System.String`</ph>, the first generic argument type is <ph id=\"ph2\">`YourType`</ph>, from <ph id=\"ph3\">`YourAssembly`</ph>:","source":"Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:"},{"pos":[8849,9260],"content":"Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name. Because your `assemblyResolve` will be called recursively, it must be able to handle this case. Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.","nodes":[{"content":"Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve <ph id=\"ph1\">`YourType`</ph> without an assembly-qualified name.","pos":[0,149],"source":"Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name."},{"content":"Because your <ph id=\"ph1\">`assemblyResolve`</ph> will be called recursively, it must be able to handle this case.","pos":[150,245],"source":" Because your `assemblyResolve` will be called recursively, it must be able to handle this case."},{"content":"Instead of returning <ph id=\"ph1\">`null`</ph> for assemblies other than <ph id=\"ph2\">`MyAssembly`</ph>, it now performs an assembly load using the supplied <ph id=\"ph3\">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object.","pos":[246,411],"source":" Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object."}]},{"pos":[9267,9378],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>GetTypeOnSteroids#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)</ept><ept id=\"p1\">]</ept>","source":"[!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]"},{"pos":[9385,9421],"content":"Back to <bpt id=\"p1\">[</bpt>Usage Notes<ept id=\"p1\">](#usage_notes)</ept>.","source":"Back to [Usage Notes](#usage_notes)."},{"pos":[9432,9476],"content":"Resolving Type Names with Special Characters","linkify":"Resolving Type Names with Special Characters","nodes":[{"content":"Resolving Type Names with Special Characters","pos":[0,44]}]},{"pos":[9480,10012],"content":"Certain characters have special meanings in assembly-qualified names. If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name. To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method. For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\\]Type`.","nodes":[{"content":"Certain characters have special meanings in assembly-qualified names.","pos":[0,69]},{"content":"If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.","pos":[70,214]},{"content":"To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> method.","pos":[215,392],"source":" To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method."},{"content":"For example, if a type is named <ph id=\"ph1\">`Strange]Type`</ph>, the escape character must be added ahead of the square bracket as follows: <ph id=\"ph2\">`Strange\\]Type`</ph>.","pos":[393,532],"source":" For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\\]Type`."}]},{"pos":[10020,10208],"content":"[!NOTE]\n Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.","leadings":["","> "],"nodes":[{"content":"Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.","pos":[9,186]}]},{"pos":[10215,10279],"content":"The following table shows the special characters for type names.","nodes":[{"content":"The following table shows the special characters for type names.","pos":[0,64]}]},{"pos":[10286,10295],"content":"Character","nodes":[{"content":"Character","pos":[0,9]}]},{"pos":[10296,10303],"content":"Meaning","nodes":[{"content":"Meaning","pos":[0,7]}]},{"pos":[10342,10351],"content":", (comma)","nodes":[{"content":", (comma)","pos":[0,9]}]},{"pos":[10352,10391],"content":"Delimiter for assembly-qualified names.","nodes":[{"content":"Delimiter for assembly-qualified names.","pos":[0,39]}]},{"pos":[10396,10416],"content":"[] (square brackets)","nodes":[{"content":"[] (square brackets)","pos":[0,20]}]},{"pos":[10417,10542],"content":"As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.","nodes":[{"content":"As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.","pos":[0,125]}]},{"pos":[10547,10560],"content":"& (ampersand)","nodes":[{"content":"&amp; (ampersand)","pos":[0,13],"source":"& (ampersand)"}]},{"pos":[10561,10616],"content":"As a suffix, indicates that a type is a reference type.","nodes":[{"content":"As a suffix, indicates that a type is a reference type.","pos":[0,55]}]},{"pos":[10621,10633],"content":"* (asterisk)","nodes":[{"content":"* (asterisk)","pos":[0,12]}]},{"pos":[10634,10687],"content":"As a suffix, indicates that a type is a pointer type.","nodes":[{"content":"As a suffix, indicates that a type is a pointer type.","pos":[0,53]}]},{"pos":[10692,10700],"content":"+ (plus)","nodes":[{"content":"+ (plus)","pos":[0,8]}]},{"pos":[10701,10728],"content":"Delimiter for nested types.","nodes":[{"content":"Delimiter for nested types.","pos":[0,27]}]},{"pos":[10733,10746],"content":"\\ (backslash)","nodes":[{"content":"\\ (backslash)","pos":[0,13]}]},{"pos":[10747,10764],"content":"Escape character.","nodes":[{"content":"Escape character.","pos":[0,17]}]},{"pos":[10772,11205],"content":"Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings. You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method. In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods. If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.","nodes":[{"content":"Properties such as <ph id=\"ph1\">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> return correctly escaped strings.","pos":[0,96],"source":"Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings."},{"content":"You must pass correctly escaped strings to the <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> method.","pos":[97,181],"source":" You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method."},{"content":"In turn, the <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> method passes correctly escaped names to <ph id=\"ph2\">`typeResolver`</ph> and to the default type resolution methods.","pos":[182,324],"source":" In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods."},{"content":"If you need to compare a name to an unescaped name in <ph id=\"ph1\">`typeResolver`</ph>, you must remove the escape characters.","pos":[325,433],"source":" If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters."}]},{"pos":[11212,11248],"content":"Back to <bpt id=\"p1\">[</bpt>Usage Notes<ept id=\"p1\">](#usage_notes)</ept>.","source":"Back to [Usage Notes](#usage_notes)."},{"pos":[11297,11318],"content":"Mixed Name Resolution","linkify":"Mixed Name Resolution","nodes":[{"content":"Mixed Name Resolution","pos":[0,21]}]},{"pos":[11322,11509],"content":"The following table summarizes the interactions between <ph id=\"ph1\">`assemblyResolver`</ph>, <ph id=\"ph2\">`typeResolver`</ph>, and default name resolution, for all combinations of type name and assembly name in <ph id=\"ph3\">`typeName`</ph>:","source":"The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:"},{"pos":[11516,11537],"content":"Contents of type name","nodes":[{"content":"Contents of type name","pos":[0,21]}]},{"pos":[11538,11562],"content":"Assembly resolver method","nodes":[{"content":"Assembly resolver method","pos":[0,24]}]},{"pos":[11563,11583],"content":"Type resolver method","nodes":[{"content":"Type resolver method","pos":[0,20]}]},{"pos":[11584,11590],"content":"Result","nodes":[{"content":"Result","pos":[0,6]}]},{"pos":[11698,11712],"content":"type, assembly","nodes":[{"content":"type, assembly","pos":[0,14]}]},{"pos":[11713,11717],"content":"null","nodes":[{"content":"null","pos":[0,4]}]},{"pos":[11718,11722],"content":"null","nodes":[{"content":"null","pos":[0,4]}]},{"pos":[11723,11870],"content":"Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> method overload.","nodes":[{"content":"Equivalent to calling the <ph id=\"ph1\">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> method overload.","pos":[0,147],"source":"Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> method overload."}]},{"pos":[11875,11889],"content":"type, assembly","nodes":[{"content":"type, assembly","pos":[0,14]}]},{"pos":[11890,11898],"content":"provided","nodes":[{"content":"provided","pos":[0,8]}]},{"pos":[11899,11903],"content":"null","nodes":[{"content":"null","pos":[0,4]}]},{"pos":[11904,12261],"content":"`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly. If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.","nodes":[{"content":"<ph id=\"ph1\">`assemblyResolver`</ph> returns the assembly or returns <ph id=\"ph2\">`null`</ph> if it cannot resolve the assembly.","pos":[0,92],"source":"`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly."},{"content":"If the assembly is resolved, the <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.","pos":[93,357],"source":" If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type."}]},{"pos":[12266,12280],"content":"type, assembly","nodes":[{"content":"type, assembly","pos":[0,14]}]},{"pos":[12281,12285],"content":"null","nodes":[{"content":"null","pos":[0,4]}]},{"pos":[12286,12294],"content":"provided","nodes":[{"content":"provided","pos":[0,8]}]},{"pos":[12295,12695],"content":"Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=fullName> method overload to get the assembly. If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.","nodes":[{"content":"Equivalent to converting the assembly name to an <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and calling the <ph id=\"ph2\">&lt;xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=fullName&gt;</ph> method overload to get the assembly.","pos":[0,246],"source":"Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=fullName> method overload to get the assembly."},{"content":"If the assembly is resolved, it is passed to <ph id=\"ph1\">`typeResolver`</ph>; otherwise, <ph id=\"ph2\">`typeResolver`</ph> is not called and there is no further attempt to resolve the type.","pos":[247,400],"source":" If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type."}]},{"pos":[12700,12714],"content":"type, assembly","nodes":[{"content":"type, assembly","pos":[0,14]}]},{"pos":[12715,12723],"content":"provided","nodes":[{"content":"provided","pos":[0,8]}]},{"pos":[12724,12732],"content":"provided","nodes":[{"content":"provided","pos":[0,8]}]},{"pos":[12733,12979],"content":"`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly. If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.","nodes":[{"content":"<ph id=\"ph1\">`assemblyResolver`</ph> returns the assembly or returns <ph id=\"ph2\">`null`</ph> if it cannot resolve the assembly.","pos":[0,92],"source":"`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly."},{"content":"If the assembly is resolved, it is passed to <ph id=\"ph1\">`typeResolver`</ph>; otherwise, <ph id=\"ph2\">`typeResolver`</ph> is not called and there is no further attempt to resolve the type.","pos":[93,246],"source":" If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type."}]},{"pos":[12984,12988],"content":"type","nodes":[{"content":"type","pos":[0,4]}]},{"pos":[12989,13003],"content":"null, provided","nodes":[{"content":"null, provided","pos":[0,14]}]},{"pos":[13004,13008],"content":"null","nodes":[{"content":"null","pos":[0,4]}]},{"pos":[13009,13318],"content":"Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> method overload. Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched. If `assemblyResolver` is provided, it is ignored.","nodes":[{"content":"Equivalent to calling the <ph id=\"ph1\">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName&gt;</ph> method overload.","pos":[0,147],"source":"Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> method overload."},{"content":"Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.","pos":[148,259]},{"content":"If <ph id=\"ph1\">`assemblyResolver`</ph> is provided, it is ignored.","pos":[260,309],"source":" If `assemblyResolver` is provided, it is ignored."}]},{"pos":[13323,13327],"content":"type","nodes":[{"content":"type","pos":[0,4]}]},{"pos":[13328,13342],"content":"null, provided","nodes":[{"content":"null, provided","pos":[0,14]}]},{"pos":[13343,13351],"content":"provided","nodes":[{"content":"provided","pos":[0,8]}]},{"pos":[13352,13566],"content":"`typeResolver` is called, and `null` is passed for the assembly. `typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose. If `assemblyResolver` is provided, it is ignored.","nodes":[{"content":"<ph id=\"ph1\">`typeResolver`</ph> is called, and <ph id=\"ph2\">`null`</ph> is passed for the assembly.","pos":[0,64],"source":"`typeResolver` is called, and `null` is passed for the assembly."},{"content":"<ph id=\"ph1\">`typeResolver`</ph> can provide a type from any assembly, including assemblies it loads for the purpose.","pos":[65,164],"source":"`typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose."},{"content":"If <ph id=\"ph1\">`assemblyResolver`</ph> is provided, it is ignored.","pos":[165,214],"source":" If `assemblyResolver` is provided, it is ignored."}]},{"pos":[13571,13579],"content":"assembly","nodes":[{"content":"assembly","pos":[0,8]}]},{"pos":[13580,13594],"content":"null, provided","nodes":[{"content":"null, provided","pos":[0,14]}]},{"pos":[13595,13609],"content":"null, provided","nodes":[{"content":"null, provided","pos":[0,14]}]},{"pos":[13610,13782],"content":"A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name. This results in an invalid assembly name.","nodes":[{"content":"A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name. This results in an invalid assembly name.","pos":[0,172],"nodes":[{"content":"A <ph id=\"ph1\">&lt;xref:System.IO.FileLoadException&gt;</ph> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.","pos":[0,130],"source":"A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name."},{"content":"This results in an invalid assembly name.","pos":[131,172]}]}]},{"pos":[13790,13911],"content":"Back to: <bpt id=\"p1\">[</bpt>Usage Notes<ept id=\"p1\">](#usage_notes)</ept>, <bpt id=\"p2\">[</bpt>Resolving Assemblies<ept id=\"p2\">](#resolving_assemblies)</ept>, <bpt id=\"p3\">[</bpt>Resolving Types<ept id=\"p3\">](#resolving_types)</ept>.","source":"Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types)."}],"pos":[405214,419273],"yaml":true,"extradata":"MT"},{"content":"The name of the type to get. If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving. If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <xref href=\"System.Type.AssemblyQualifiedName\"></xref>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.","nodes":[{"pos":[0,548],"content":"The name of the type to get. If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving. If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <xref href=\"System.Type.AssemblyQualifiedName\"></xref>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.","nodes":[{"content":"The name of the type to get.","pos":[0,28]},{"content":"If the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeResolver</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is provided, the type name can be any string that <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">typeResolver</ph><ept id=\"p2\">&lt;/code&gt;</ept> is capable of resolving.","pos":[29,172],"source":" If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving."},{"content":"If the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">assemblyResolver</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">typeName</ph><ept id=\"p2\">&lt;/code&gt;</ept> must be an assembly-qualified name (see <ph id=\"ph3\">&lt;xref href=\"System.Type.AssemblyQualifiedName\"&gt;&lt;/xref&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.","pos":[173,548],"source":" If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <xref href=\"System.Type.AssemblyQualifiedName\"></xref>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace."}]}],"pos":[419604,420153],"yaml":true},{"content":"A method that locates and returns the assembly that is specified in <code>typeName</code>. The assembly name is passed to <code>assemblyResolver</code> as an <xref href=\"System.Reflection.AssemblyName\"></xref> object. If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called. If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed.  \n  \n Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.","nodes":[{"pos":[0,422],"content":"A method that locates and returns the assembly that is specified in <code>typeName</code>. The assembly name is passed to <code>assemblyResolver</code> as an <xref href=\"System.Reflection.AssemblyName\"></xref> object. If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called. If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed.","nodes":[{"content":"A method that locates and returns the assembly that is specified in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","pos":[0,90],"source":"A method that locates and returns the assembly that is specified in <code>typeName</code>."},{"content":"The assembly name is passed to <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">assemblyResolver</ph><ept id=\"p1\">&lt;/code&gt;</ept> as an <ph id=\"ph2\">&lt;xref href=\"System.Reflection.AssemblyName\"&gt;&lt;/xref&gt;</ph> object.","pos":[91,217],"source":" The assembly name is passed to <code>assemblyResolver</code> as an <xref href=\"System.Reflection.AssemblyName\"></xref> object."},{"content":"If <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept> does not contain the name of an assembly, <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">assemblyResolver</ph><ept id=\"p2\">&lt;/code&gt;</ept> is not called.","pos":[218,329],"source":" If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called."},{"content":"If <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">assemblyResolver</ph><ept id=\"p1\">&lt;/code&gt;</ept> is not supplied, standard assembly resolution is performed.","pos":[330,422],"source":" If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed."}]},{"pos":[429,626],"content":"Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.","nodes":[{"content":"Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.","pos":[0,197],"nodes":[{"content":"Caution   Do not pass methods from unknown or untrusted callers.","pos":[0,64]},{"content":"Doing so could result in elevation of privilege for malicious code.","pos":[65,132]},{"content":"Use only methods that you provide or that you are familiar with.","pos":[133,197]}]}]}],"pos":[420282,420915],"yaml":true},{"content":"A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution. If no assembly is provided, the method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <code>ignoreCase</code> is passed to that parameter.  \n  \n Caution   Do not pass methods from unknown or untrusted callers.","nodes":[{"pos":[0,406],"content":"A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution. If no assembly is provided, the method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <code>ignoreCase</code> is passed to that parameter.","nodes":[{"content":"A method that locates and returns the type that is specified by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept> from the assembly that is returned by <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">assemblyResolver</ph><ept id=\"p2\">&lt;/code&gt;</ept> or by standard assembly resolution.","pos":[0,189],"source":"A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution."},{"content":"If no assembly is provided, the method can provide one.","pos":[190,245]},{"content":"The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">ignoreCase</ph><ept id=\"p1\">&lt;/code&gt;</ept> is passed to that parameter.","pos":[246,406],"source":" The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <code>ignoreCase</code> is passed to that parameter."}]},{"pos":[413,477],"content":"Caution   Do not pass methods from unknown or untrusted callers.","nodes":[{"content":"Caution   Do not pass methods from unknown or untrusted callers.","pos":[0,64]}]}],"pos":[421050,421532],"yaml":true},{"content":"`true` to throw an exception if the type cannot be found; `false` to return `null`. Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.","nodes":[{"pos":[0,200],"content":"`true` to throw an exception if the type cannot be found; `false` to return `null`. Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> to throw an exception if the type cannot be found; <ph id=\"ph2\">`false`</ph> to return <ph id=\"ph3\">`null`</ph>.","pos":[0,83],"source":"`true` to throw an exception if the type cannot be found; `false` to return `null`."},{"content":"Specifying <ph id=\"ph1\">`false`</ph> also suppresses some other exception conditions, but not all of them.","pos":[84,172],"source":" Specifying `false` also suppresses some other exception conditions, but not all of them."},{"content":"See the Exceptions section.","pos":[173,200]}]}],"pos":[421601,421804],"yaml":true},{"content":"`true` to perform a case-insensitive search for <code>typeName</code>, `false` to perform a case-sensitive search for <code>typeName</code>.","nodes":[{"pos":[0,140],"content":"<ph id=\"ph1\">`true`</ph> to perform a case-insensitive search for <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept>, <ph id=\"ph3\">`false`</ph> to perform a case-sensitive search for <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph4\">typeName</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","source":"`true` to perform a case-insensitive search for <code>typeName</code>, `false` to perform a case-sensitive search for <code>typeName</code>."}],"pos":[421871,422014],"yaml":true},{"content":"The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.","nodes":[{"pos":[0,283],"content":"The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.","nodes":[{"content":"The type with the specified name.","pos":[0,33]},{"content":"If the type is not found, the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">throwOnError</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter specifies whether <ph id=\"ph2\">`null`</ph> is returned or an exception is thrown.","pos":[34,163],"source":" If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown."},{"content":"In some cases, an exception is thrown regardless of the value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">throwOnError</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","pos":[164,255],"source":" In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>."},{"content":"See the Exceptions section.","pos":[256,283]}]}],"pos":[422069,422353],"yaml":true},{"content":"<code>typeName</code> is `null`.","nodes":[{"pos":[0,32],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>typeName</code> is `null`."}],"pos":[422502,422535],"yaml":true},{"content":"A class initializer is invoked and throws an exception.","nodes":[{"pos":[0,55],"content":"A class initializer is invoked and throws an exception.","nodes":[{"content":"A class initializer is invoked and throws an exception.","pos":[0,55]}]}],"pos":[422667,422723],"yaml":true},{"content":"<code>throwOnError</code> is `true` and the type is not found.  \n  \n -or-  \n  \n <code>throwOnError</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab.  \n  \n -or-  \n  \n <code>throwOnError</code> is `true` and <code>typeName</code> is an empty string.  \n  \n -or-  \n  \n <code>throwOnError</code> is `true` and <code>typeName</code> represents an array type with an invalid size.  \n  \n -or-  \n  \n <code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref>.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and the type is not found.","source":"<code>throwOnError</code> is `true` and the type is not found."},{"pos":[69,73],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[80,195],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid characters, such as an embedded tab.","source":"<code>throwOnError</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab."},{"pos":[202,206],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[213,294],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> is an empty string.","source":"<code>throwOnError</code> is `true` and <code>typeName</code> is an empty string."},{"pos":[301,305],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[312,420],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array type with an invalid size.","source":"<code>throwOnError</code> is `true` and <code>typeName</code> represents an array type with an invalid size."},{"pos":[427,431],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[438,526],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array of <ph id=\"ph2\">&lt;xref href=\"System.TypedReference\"&gt;&lt;/xref&gt;</ph>.","source":"<code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref>."}],"pos":[422817,423364],"yaml":true},{"content":"An error occurs when <code>typeName</code> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).  \n  \n -or-  \n  \n <code>throwOnError</code> is `true` and <code>typeName</code> contains invalid syntax (for example, \"MyType[,*,]\").  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\"System.Void\"></xref> as one of its type arguments.  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.","nodes":[{"pos":[0,172],"content":"An error occurs when <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).","source":"An error occurs when <code>typeName</code> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character)."},{"pos":[179,183],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[190,305],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid syntax (for example, \"MyType[,*,]\").","source":"<code>throwOnError</code> is `true` and <code>typeName</code> contains invalid syntax (for example, \"MyType[,*,]\")."},{"pos":[312,316],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[323,477],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has a pointer type, a <ph id=\"ph2\">`ByRef`</ph> type, or <ph id=\"ph3\">&lt;xref href=\"System.Void\"&gt;&lt;/xref&gt;</ph> as one of its type arguments.","source":"<code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\"System.Void\"></xref> as one of its type arguments."},{"pos":[484,488],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[495,590],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has an incorrect number of type arguments.","source":"<code>typeName</code> represents a generic type that has an incorrect number of type arguments."},{"pos":[597,601],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[608,757],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.","source":"<code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter."}],"pos":[423458,424238],"yaml":true},{"content":"<code>throwOnError</code> is `true` and the assembly or one of its dependencies was not found.","nodes":[{"pos":[0,94],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and the assembly or one of its dependencies was not found.","source":"<code>throwOnError</code> is `true` and the assembly or one of its dependencies was not found."}],"pos":[424346,424441],"yaml":true},{"content":"The assembly or one of its dependencies was found, but could not be loaded.  \n  \n -or-  \n  \n <code>typeName</code> contains an invalid assembly name.  \n  \n -or-  \n  \n <code>typeName</code> is a valid assembly name without a type name.","nodes":[{"pos":[0,75],"content":"The assembly or one of its dependencies was found, but could not be loaded.","nodes":[{"content":"The assembly or one of its dependencies was found, but could not be loaded.","pos":[0,75]}]},{"pos":[82,86],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[93,149],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> contains an invalid assembly name.","source":"<code>typeName</code> contains an invalid assembly name."},{"pos":[156,160],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[167,234],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> is a valid assembly name without a type name.","source":"<code>typeName</code> is a valid assembly name without a type name."}],"pos":[424541,424786],"yaml":true},{"content":"The assembly or one of its dependencies is not valid.  \n  \n -or-  \n  \n The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.","nodes":[{"pos":[0,53],"content":"The assembly or one of its dependencies is not valid.","nodes":[{"content":"The assembly or one of its dependencies is not valid.","pos":[0,53]}]},{"pos":[60,64],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[71,191],"content":"The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.","nodes":[{"content":"The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.","pos":[0,120]}]}],"pos":[424892,425090],"yaml":true},{"content":"Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.","nodes":[{"pos":[0,183],"content":"Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.","nodes":[{"content":"Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.","pos":[0,183]}]}],"pos":[426886,427070],"yaml":true},{"content":"Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.  \n  \n Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter.","nodes":[{"pos":[0,391],"content":"Usage scenarios for this method and details about the <ph id=\"ph1\">`assemblyResolver`</ph> and <ph id=\"ph2\">`typeResolver`</ph> parameters can be found in the <ph id=\"ph3\">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.","source":"Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload."},{"pos":[398,776],"content":"Calling this method overload is the same as calling the <ph id=\"ph1\">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id=\"ph2\">`false`</ph> for the <ph id=\"ph3\">`ignoreCase`</ph> parameter.","source":"Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter."}],"pos":[427081,427862],"yaml":true,"extradata":"MT"},{"content":"The name of the type to get. If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving. If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <xref href=\"System.Type.AssemblyQualifiedName\"></xref>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.","nodes":[{"pos":[0,548],"content":"The name of the type to get. If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving. If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <xref href=\"System.Type.AssemblyQualifiedName\"></xref>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.","nodes":[{"content":"The name of the type to get.","pos":[0,28]},{"content":"If the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeResolver</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is provided, the type name can be any string that <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">typeResolver</ph><ept id=\"p2\">&lt;/code&gt;</ept> is capable of resolving.","pos":[29,172],"source":" If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving."},{"content":"If the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">assemblyResolver</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">typeName</ph><ept id=\"p2\">&lt;/code&gt;</ept> must be an assembly-qualified name (see <ph id=\"ph3\">&lt;xref href=\"System.Type.AssemblyQualifiedName\"&gt;&lt;/xref&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.","pos":[173,548],"source":" If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <xref href=\"System.Type.AssemblyQualifiedName\"></xref>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace."}]}],"pos":[428176,428725],"yaml":true},{"content":"A method that locates and returns the assembly that is specified in <code>typeName</code>. The assembly name is passed to <code>assemblyResolver</code> as an <xref href=\"System.Reflection.AssemblyName\"></xref> object. If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called. If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed.  \n  \n Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.","nodes":[{"pos":[0,422],"content":"A method that locates and returns the assembly that is specified in <code>typeName</code>. The assembly name is passed to <code>assemblyResolver</code> as an <xref href=\"System.Reflection.AssemblyName\"></xref> object. If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called. If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed.","nodes":[{"content":"A method that locates and returns the assembly that is specified in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","pos":[0,90],"source":"A method that locates and returns the assembly that is specified in <code>typeName</code>."},{"content":"The assembly name is passed to <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">assemblyResolver</ph><ept id=\"p1\">&lt;/code&gt;</ept> as an <ph id=\"ph2\">&lt;xref href=\"System.Reflection.AssemblyName\"&gt;&lt;/xref&gt;</ph> object.","pos":[91,217],"source":" The assembly name is passed to <code>assemblyResolver</code> as an <xref href=\"System.Reflection.AssemblyName\"></xref> object."},{"content":"If <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept> does not contain the name of an assembly, <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">assemblyResolver</ph><ept id=\"p2\">&lt;/code&gt;</ept> is not called.","pos":[218,329],"source":" If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called."},{"content":"If <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">assemblyResolver</ph><ept id=\"p1\">&lt;/code&gt;</ept> is not supplied, standard assembly resolution is performed.","pos":[330,422],"source":" If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed."}]},{"pos":[429,626],"content":"Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.","nodes":[{"content":"Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.","pos":[0,197],"nodes":[{"content":"Caution   Do not pass methods from unknown or untrusted callers.","pos":[0,64]},{"content":"Doing so could result in elevation of privilege for malicious code.","pos":[65,132]},{"content":"Use only methods that you provide or that you are familiar with.","pos":[133,197]}]}]}],"pos":[428854,429487],"yaml":true},{"content":"A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution. If no assembly is provided, the method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; `false` is passed to that parameter.  \n  \n Caution   Do not pass methods from unknown or untrusted callers.","nodes":[{"pos":[0,377],"content":"A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution. If no assembly is provided, the method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; `false` is passed to that parameter.","nodes":[{"content":"A method that locates and returns the type that is specified by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept> from the assembly that is returned by <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">assemblyResolver</ph><ept id=\"p2\">&lt;/code&gt;</ept> or by standard assembly resolution.","pos":[0,189],"source":"A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution."},{"content":"If no assembly is provided, the method can provide one.","pos":[190,245]},{"content":"The method also takes a parameter that specifies whether to perform a case-insensitive search; <ph id=\"ph1\">`false`</ph> is passed to that parameter.","pos":[246,377],"source":" The method also takes a parameter that specifies whether to perform a case-insensitive search; `false` is passed to that parameter."}]},{"pos":[384,448],"content":"Caution   Do not pass methods from unknown or untrusted callers.","nodes":[{"content":"Caution   Do not pass methods from unknown or untrusted callers.","pos":[0,64]}]}],"pos":[429622,430075],"yaml":true},{"content":"`true` to throw an exception if the type cannot be found; `false` to return `null`. Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.","nodes":[{"pos":[0,200],"content":"`true` to throw an exception if the type cannot be found; `false` to return `null`. Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> to throw an exception if the type cannot be found; <ph id=\"ph2\">`false`</ph> to return <ph id=\"ph3\">`null`</ph>.","pos":[0,83],"source":"`true` to throw an exception if the type cannot be found; `false` to return `null`."},{"content":"Specifying <ph id=\"ph1\">`false`</ph> also suppresses some other exception conditions, but not all of them.","pos":[84,172],"source":" Specifying `false` also suppresses some other exception conditions, but not all of them."},{"content":"See the Exceptions section.","pos":[173,200]}]}],"pos":[430144,430347],"yaml":true},{"content":"The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.","nodes":[{"pos":[0,283],"content":"The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.","nodes":[{"content":"The type with the specified name.","pos":[0,33]},{"content":"If the type is not found, the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">throwOnError</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter specifies whether <ph id=\"ph2\">`null`</ph> is returned or an exception is thrown.","pos":[34,163],"source":" If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown."},{"content":"In some cases, an exception is thrown regardless of the value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">throwOnError</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","pos":[164,255],"source":" In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>."},{"content":"See the Exceptions section.","pos":[256,283]}]}],"pos":[430402,430686],"yaml":true},{"content":"<code>typeName</code> is `null`.","nodes":[{"pos":[0,32],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>typeName</code> is `null`."}],"pos":[430835,430868],"yaml":true},{"content":"A class initializer is invoked and throws an exception.","nodes":[{"pos":[0,55],"content":"A class initializer is invoked and throws an exception.","nodes":[{"content":"A class initializer is invoked and throws an exception.","pos":[0,55]}]}],"pos":[431000,431056],"yaml":true},{"content":"<code>throwOnError</code> is `true` and the type is not found.  \n  \n -or-  \n  \n <code>throwOnError</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab.  \n  \n -or-  \n  \n <code>throwOnError</code> is `true` and <code>typeName</code> is an empty string.  \n  \n -or-  \n  \n <code>throwOnError</code> is `true` and <code>typeName</code> represents an array type with an invalid size.  \n  \n -or-  \n  \n <code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref>.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and the type is not found.","source":"<code>throwOnError</code> is `true` and the type is not found."},{"pos":[69,73],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[80,195],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid characters, such as an embedded tab.","source":"<code>throwOnError</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab."},{"pos":[202,206],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[213,294],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> is an empty string.","source":"<code>throwOnError</code> is `true` and <code>typeName</code> is an empty string."},{"pos":[301,305],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[312,420],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array type with an invalid size.","source":"<code>throwOnError</code> is `true` and <code>typeName</code> represents an array type with an invalid size."},{"pos":[427,431],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[438,526],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array of <ph id=\"ph2\">&lt;xref href=\"System.TypedReference\"&gt;&lt;/xref&gt;</ph>.","source":"<code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref>."}],"pos":[431150,431697],"yaml":true},{"content":"An error occurs when <code>typeName</code> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).  \n  \n -or-  \n  \n <code>throwOnError</code> is `true` and <code>typeName</code> contains invalid syntax (for example, \"MyType[,*,]\").  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\"System.Void\"></xref> as one of its type arguments.  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.","nodes":[{"pos":[0,172],"content":"An error occurs when <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).","source":"An error occurs when <code>typeName</code> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character)."},{"pos":[179,183],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[190,305],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid syntax (for example, \"MyType[,*,]\").","source":"<code>throwOnError</code> is `true` and <code>typeName</code> contains invalid syntax (for example, \"MyType[,*,]\")."},{"pos":[312,316],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[323,477],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has a pointer type, a <ph id=\"ph2\">`ByRef`</ph> type, or <ph id=\"ph3\">&lt;xref href=\"System.Void\"&gt;&lt;/xref&gt;</ph> as one of its type arguments.","source":"<code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\"System.Void\"></xref> as one of its type arguments."},{"pos":[484,488],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[495,590],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has an incorrect number of type arguments.","source":"<code>typeName</code> represents a generic type that has an incorrect number of type arguments."},{"pos":[597,601],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[608,757],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.","source":"<code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter."}],"pos":[431791,432571],"yaml":true},{"content":"<code>throwOnError</code> is `true` and the assembly or one of its dependencies was not found.  \n  \n -or-  \n  \n <code>typeName</code> contains an invalid assembly name.  \n  \n -or-  \n  \n <code>typeName</code> is a valid assembly name without a type name.","nodes":[{"pos":[0,94],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and the assembly or one of its dependencies was not found.","source":"<code>throwOnError</code> is `true` and the assembly or one of its dependencies was not found."},{"pos":[101,105],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[112,168],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> contains an invalid assembly name.","source":"<code>typeName</code> contains an invalid assembly name."},{"pos":[175,179],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[186,253],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> is a valid assembly name without a type name.","source":"<code>typeName</code> is a valid assembly name without a type name."}],"pos":[432679,432943],"yaml":true},{"content":"The assembly or one of its dependencies was found, but could not be loaded.","nodes":[{"pos":[0,75],"content":"The assembly or one of its dependencies was found, but could not be loaded.","nodes":[{"content":"The assembly or one of its dependencies was found, but could not be loaded.","pos":[0,75]}]}],"pos":[433043,433119],"yaml":true},{"content":"The assembly or one of its dependencies is not valid.  \n  \n -or-  \n  \n The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.","nodes":[{"pos":[0,53],"content":"The assembly or one of its dependencies is not valid.","nodes":[{"content":"The assembly or one of its dependencies is not valid.","pos":[0,53]}]},{"pos":[60,64],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[71,191],"content":"The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.","nodes":[{"content":"The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.","pos":[0,120]}]}],"pos":[433225,433423],"yaml":true},{"content":"Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.","nodes":[{"pos":[0,112],"content":"Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.","nodes":[{"content":"Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.","pos":[0,112]}]}],"pos":[435147,435260],"yaml":true},{"content":"Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.  \n  \n> [!NOTE]\n>  If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`. It does not throw an exception. To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.  \n  \n Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters.","nodes":[{"pos":[0,391],"content":"Usage scenarios for this method and details about the <ph id=\"ph1\">`assemblyResolver`</ph> and <ph id=\"ph2\">`typeResolver`</ph> parameters can be found in the <ph id=\"ph3\">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.","source":"Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload."},{"pos":[399,870],"content":"[!NOTE]\n If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`. It does not throw an exception. To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.","leadings":["","> "],"nodes":[{"content":" If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`. It does not throw an exception. To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.","pos":[8,469],"nodes":[{"content":"If <ph id=\"ph1\">`typeName`</ph> cannot be found, the call to the <ph id=\"ph2\">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29&gt;</ph> method returns <ph id=\"ph3\">`null`</ph>.","pos":[1,288],"source":" If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`."},{"content":"It does not throw an exception.","pos":[289,320]},{"content":"To control whether an exception is thrown, call an overload of the <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> method that has a <ph id=\"ph2\">`throwOnError`</ph> parameter.","pos":[321,461],"source":" To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter."}]}]},{"pos":[877,1275],"content":"Calling this method overload is the same as calling the <ph id=\"ph1\">&lt;xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload and specifying <ph id=\"ph2\">`false`</ph> for the <ph id=\"ph3\">`throwOnError`</ph> and <ph id=\"ph4\">`ignoreCase`</ph> parameters.","source":"Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters."}],"pos":[435271,436554],"yaml":true,"extradata":"MT"},{"content":"The name of the type to get. If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving. If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <xref href=\"System.Type.AssemblyQualifiedName\"></xref>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.","nodes":[{"pos":[0,548],"content":"The name of the type to get. If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving. If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <xref href=\"System.Type.AssemblyQualifiedName\"></xref>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.","nodes":[{"content":"The name of the type to get.","pos":[0,28]},{"content":"If the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeResolver</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is provided, the type name can be any string that <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">typeResolver</ph><ept id=\"p2\">&lt;/code&gt;</ept> is capable of resolving.","pos":[29,172],"source":" If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving."},{"content":"If the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">assemblyResolver</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter is provided or if standard type resolution is used, <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">typeName</ph><ept id=\"p2\">&lt;/code&gt;</ept> must be an assembly-qualified name (see <ph id=\"ph3\">&lt;xref href=\"System.Type.AssemblyQualifiedName\"&gt;&lt;/xref&gt;</ph>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.","pos":[173,548],"source":" If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <xref href=\"System.Type.AssemblyQualifiedName\"></xref>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace."}]}],"pos":[436849,437398],"yaml":true},{"content":"A method that locates and returns the assembly that is specified in <code>typeName</code>. The assembly name is passed to <code>assemblyResolver</code> as an <xref href=\"System.Reflection.AssemblyName\"></xref> object. If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called. If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed.  \n  \n Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.","nodes":[{"pos":[0,422],"content":"A method that locates and returns the assembly that is specified in <code>typeName</code>. The assembly name is passed to <code>assemblyResolver</code> as an <xref href=\"System.Reflection.AssemblyName\"></xref> object. If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called. If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed.","nodes":[{"content":"A method that locates and returns the assembly that is specified in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","pos":[0,90],"source":"A method that locates and returns the assembly that is specified in <code>typeName</code>."},{"content":"The assembly name is passed to <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">assemblyResolver</ph><ept id=\"p1\">&lt;/code&gt;</ept> as an <ph id=\"ph2\">&lt;xref href=\"System.Reflection.AssemblyName\"&gt;&lt;/xref&gt;</ph> object.","pos":[91,217],"source":" The assembly name is passed to <code>assemblyResolver</code> as an <xref href=\"System.Reflection.AssemblyName\"></xref> object."},{"content":"If <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept> does not contain the name of an assembly, <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">assemblyResolver</ph><ept id=\"p2\">&lt;/code&gt;</ept> is not called.","pos":[218,329],"source":" If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called."},{"content":"If <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">assemblyResolver</ph><ept id=\"p1\">&lt;/code&gt;</ept> is not supplied, standard assembly resolution is performed.","pos":[330,422],"source":" If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed."}]},{"pos":[429,626],"content":"Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.","nodes":[{"content":"Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.","pos":[0,197],"nodes":[{"content":"Caution   Do not pass methods from unknown or untrusted callers.","pos":[0,64]},{"content":"Doing so could result in elevation of privilege for malicious code.","pos":[65,132]},{"content":"Use only methods that you provide or that you are familiar with.","pos":[133,197]}]}]}],"pos":[437527,438160],"yaml":true},{"content":"A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution. If no assembly is provided, the <code>typeResolver</code> method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; `false` is passed to that parameter.  \n  \n Caution   Do not pass methods from unknown or untrusted callers.","nodes":[{"pos":[0,403],"content":"A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution. If no assembly is provided, the <code>typeResolver</code> method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; `false` is passed to that parameter.","nodes":[{"content":"A method that locates and returns the type that is specified by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept> from the assembly that is returned by <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph2\">assemblyResolver</ph><ept id=\"p2\">&lt;/code&gt;</ept> or by standard assembly resolution.","pos":[0,189],"source":"A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution."},{"content":"If no assembly is provided, the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeResolver</ph><ept id=\"p1\">&lt;/code&gt;</ept> method can provide one.","pos":[190,271],"source":" If no assembly is provided, the <code>typeResolver</code> method can provide one."},{"content":"The method also takes a parameter that specifies whether to perform a case-insensitive search; <ph id=\"ph1\">`false`</ph> is passed to that parameter.","pos":[272,403],"source":" The method also takes a parameter that specifies whether to perform a case-insensitive search; `false` is passed to that parameter."}]},{"pos":[410,474],"content":"Caution   Do not pass methods from unknown or untrusted callers.","nodes":[{"content":"Caution   Do not pass methods from unknown or untrusted callers.","pos":[0,64]}]}],"pos":[438295,438774],"yaml":true},{"content":"The type with the specified name, or `null` if the type is not found.","nodes":[{"pos":[0,69],"content":"The type with the specified name, or <ph id=\"ph1\">`null`</ph> if the type is not found.","source":"The type with the specified name, or `null` if the type is not found."}],"pos":[438829,438899],"yaml":true},{"content":"<code>typeName</code> is `null`.","nodes":[{"pos":[0,32],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>typeName</code> is `null`."}],"pos":[439048,439081],"yaml":true},{"content":"A class initializer is invoked and throws an exception.","nodes":[{"pos":[0,55],"content":"A class initializer is invoked and throws an exception.","nodes":[{"content":"A class initializer is invoked and throws an exception.","pos":[0,55]}]}],"pos":[439213,439269],"yaml":true},{"content":"An error occurs when <code>typeName</code> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\"System.Void\"></xref> as one of its type arguments.  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.","nodes":[{"pos":[0,172],"content":"An error occurs when <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).","source":"An error occurs when <code>typeName</code> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character)."},{"pos":[179,183],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[190,344],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has a pointer type, a <ph id=\"ph2\">`ByRef`</ph> type, or <ph id=\"ph3\">&lt;xref href=\"System.Void\"&gt;&lt;/xref&gt;</ph> as one of its type arguments.","source":"<code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\"System.Void\"></xref> as one of its type arguments."},{"pos":[351,355],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[362,457],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has an incorrect number of type arguments.","source":"<code>typeName</code> represents a generic type that has an incorrect number of type arguments."},{"pos":[464,468],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[475,624],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.","source":"<code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter."}],"pos":[439363,440004],"yaml":true},{"content":"<code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref>.","nodes":[{"pos":[0,88],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array of <ph id=\"ph2\">&lt;xref href=\"System.TypedReference\"&gt;&lt;/xref&gt;</ph>.","source":"<code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref>."}],"pos":[440098,440187],"yaml":true},{"content":"The assembly or one of its dependencies was found, but could not be loaded.  \n  \n -or-  \n  \n <code>typeName</code> contains an invalid assembly name.  \n  \n -or-  \n  \n <code>typeName</code> is a valid assembly name without a type name.","nodes":[{"pos":[0,75],"content":"The assembly or one of its dependencies was found, but could not be loaded.","nodes":[{"content":"The assembly or one of its dependencies was found, but could not be loaded.","pos":[0,75]}]},{"pos":[82,86],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[93,149],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> contains an invalid assembly name.","source":"<code>typeName</code> contains an invalid assembly name."},{"pos":[156,160],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[167,234],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> is a valid assembly name without a type name.","source":"<code>typeName</code> is a valid assembly name without a type name."}],"pos":[440287,440532],"yaml":true},{"content":"The assembly or one of its dependencies is not valid.  \n  \n -or-  \n  \n The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.","nodes":[{"pos":[0,53],"content":"The assembly or one of its dependencies is not valid.","nodes":[{"content":"The assembly or one of its dependencies is not valid.","pos":[0,53]}]},{"pos":[60,64],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[71,191],"content":"The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.","nodes":[{"content":"The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.","pos":[0,120]}]}],"pos":[440638,440836],"yaml":true},{"content":"Gets the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,50],"content":"Gets the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Gets the current <xref href=\"System.Type\"></xref>."}],"pos":[441846,441897],"yaml":true},{"content":"The current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,45],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"The current <xref href=\"System.Type\"></xref>."}],"pos":[442018,442064],"yaml":true},{"content":"A class initializer is invoked and throws an exception.","nodes":[{"pos":[0,55],"content":"A class initializer is invoked and throws an exception.","nodes":[{"content":"A class initializer is invoked and throws an exception.","pos":[0,55]}]}],"pos":[442243,442299],"yaml":true},{"content":"Gets the <xref href=\"System.Type\"></xref> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.","nodes":[{"pos":[0,172],"content":"Gets the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.","source":"Gets the <xref href=\"System.Type\"></xref> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found."}],"pos":[443444,443617],"yaml":true},{"content":"You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace-qualified name. <xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`. You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.  \n  \n `GetType` only works on assemblies loaded from disk. If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> enumeration. If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when `GetType` is called, the method returns `null`. `GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.  \n  \n To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> event and call `GetType` before saving. Otherwise, you will get two copies of the assembly in memory.  \n  \n The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of `throwOnError`. For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.  \n  \n `typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <xref:System.Type.AssemblyQualifiedName%2A>.  \n  \n If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.  \n  \n The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  \n  \n> [!NOTE]\n>  In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \"ProcessorArchitecture=msil\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method. You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly. See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.  \n  \n|Delimiter|Meaning|  \n|---------------|-------------|  \n|Backslash (\\\\)|Escape character.|  \n|Backtick (`)|Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.|  \n|Brackets ([])|Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.|  \n|Comma (,)|Precedes the Assembly name.|  \n|Period (.)|Denotes namespace identifiers.|  \n|Plus sign (+)|Precedes a nested class.|  \n  \n For example, the fully qualified name for a class might look like this:  \n  \n```  \nTopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  \n```  \n  \n If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:  \n  \n```  \nTopNamespace.Sub\\+Namespace.ContainingClass+NestedClass,MyAssembly  \n```  \n  \n A \"++\" becomes \"\\\\+\\\\+\", and a \"\\\\\" becomes \"\\\\\\\\\".  \n  \n This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.  \n  \n Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.  \n  \n Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.  \n  \n The name of a generic type ends with a backtick (\\`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\\<T0, T1>` in Visual C#.  \n  \n For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters. A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:  \n  \n```  \nSystem.Collections.Generic.Dictionary`2[System.String,MyType]  \n```  \n  \n To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:  \n  \n```  \nType.GetType(\"System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]\")  \n```  \n  \n> [!NOTE]\n>  An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.  \n  \n Nullable types are a special case of generic types. For example, a nullable <xref:System.Int32> is represented by the string \"System.Nullable`1[System.Int32]\".  \n  \n> [!NOTE]\n>  In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.  \n  \n The following table shows the syntax you use with `GetType` for various types.  \n  \n|To Get|Use|  \n|------------|---------|  \n|A nullable <xref:System.Int32>|`Type.GetType(\"System.Nullable`1[System.Int32]\")`|  \n|An unmanaged pointer to `MyType`|`Type.GetType(\"MyType*\")`|  \n|An unmanaged pointer to a pointer to `MyType`|`Type.GetType(\"MyType**\")`|  \n|A managed pointer or reference to `MyType`|`Type.GetType(\"MyType&\")`. Note that unlike pointers, references are limited to one level.|  \n|A parent class and a nested class|`Type.GetType(\"MyParentClass+MyNestedClass\")`|  \n|A one-dimensional array with a lower bound of 0|`Type.GetType(\"MyArray[]\")`|  \n|A one-dimensional array with an unknown lower bound|`Type.GetType(\"MyArray[*]\")`|  \n|An n-dimensional array|A comma (,) inside the brackets a total of n-1 times. For example, `System.Object[,,]` represents a three-dimensional `Object` array.|  \n|A two-dimensional array's array|`Type.GetType(\"MyArray[][]\")`|  \n|A rectangular two-dimensional array with unknown lower bounds|`Type.GetType(\"MyArray[,]\")`|  \n|A generic type with one type argument|`Type.GetType(\"MyGenericType`1[MyType]\")`|  \n|A generic type with two type arguments|`Type.GetType(\"MyGenericType`2[MyType,AnotherType]\")`|  \n|A generic type with two assembly-qualified type arguments|`Type.GetType(\"MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]\")`|  \n|An assembly-qualified generic type with an assembly-qualified type argument|`Type.GetType(\"MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly\")`|  \n|A generic type whose type argument is a generic type with two type arguments|`Type.GetType(\"MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]\")`|","nodes":[{"pos":[0,708],"content":"You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace-qualified name. <xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`. You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.","nodes":[{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if the you know its namespace-qualified name.","pos":[0,168],"source":"You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace-qualified name."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id=\"ph2\">`typeName`</ph>.","pos":[169,254],"source":" <xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`."},{"content":"You can also load an assembly using the <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id=\"ph2\">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id=\"ph4\">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id=\"ph5\">&lt;xref:System.Type&gt;</ph> objects.","pos":[255,530],"source":" You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects."},{"content":"If a type is in an assembly known to your program at compile time, it is more efficient to use <ph id=\"ph1\">`typeof`</ph> in C#, <ph id=\"ph2\">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or <ph id=\"ph3\">`typeid`</ph> in C++.","pos":[531,708],"source":" If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++."}]},{"pos":[715,1616],"content":"`GetType` only works on assemblies loaded from disk. If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> enumeration. If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when `GetType` is called, the method returns `null`. `GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.","nodes":[{"content":"<ph id=\"ph1\">`GetType`</ph> only works on assemblies loaded from disk.","pos":[0,52],"source":"`GetType` only works on assemblies loaded from disk."},{"content":"If you call <ph id=\"ph1\">`GetType`</ph> to look up a type defined in a dynamic assembly defined using the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.","pos":[53,217],"source":" If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior."},{"content":"The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id=\"ph1\">`RunAndSave`</ph> or <ph id=\"ph2\">`Save`</ph> access modes of the <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName&gt;</ph> enumeration.","pos":[218,445],"source":" The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> enumeration."},{"content":"If the dynamic assembly is persistent and has been written to disk before <ph id=\"ph1\">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.","pos":[446,649],"source":" If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly."},{"content":"If the assembly has not been saved to disk when <ph id=\"ph1\">`GetType`</ph> is called, the method returns <ph id=\"ph2\">`null`</ph>.","pos":[650,745],"source":" If the assembly has not been saved to disk when `GetType` is called, the method returns `null`."},{"content":"<ph id=\"ph1\">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id=\"ph2\">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id=\"ph3\">`null`</ph>.","pos":[746,901],"source":"`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`."}]},{"pos":[1623,1844],"content":"To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> event and call `GetType` before saving. Otherwise, you will get two copies of the assembly in memory.","nodes":[{"content":"To use <ph id=\"ph1\">`GetType`</ph> on a dynamic module, subscribe to the <ph id=\"ph2\">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=fullName&gt;</ph> event and call <ph id=\"ph3\">`GetType`</ph> before saving.","pos":[0,159],"source":"To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> event and call `GetType` before saving."},{"content":"Otherwise, you will get two copies of the assembly in memory.","pos":[160,221]}]},{"pos":[1851,2231],"content":"The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of `throwOnError`. For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.","nodes":[{"content":"The <ph id=\"ph1\">`throwOnError`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.","pos":[0,175],"source":"The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section."},{"content":"Some exceptions are thrown regardless of the value of <ph id=\"ph1\">`throwOnError`</ph>.","pos":[176,245],"source":" Some exceptions are thrown regardless of the value of `throwOnError`."},{"content":"For example, if the type is found but cannot be loaded, a <ph id=\"ph1\">&lt;xref:System.TypeLoadException&gt;</ph> is thrown even if <ph id=\"ph2\">`throwOnError`</ph> is <ph id=\"ph3\">`false`</ph>.","pos":[246,380],"source":" For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`."}]},{"pos":[2238,2353],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[2360,2371],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[2372,2378],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[2379,2389],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[2447,2458],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[2459,2461],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2462,2464],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2469,2474],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[2475,2477],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2478,2528],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[2533,2538],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[2539,2553],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[2554,2747],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[2752,2758],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[2759,2761],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2762,2857],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[2862,2873],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[2874,2876],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2877,2879],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2884,2892],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[2893,2907],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[2908,3101],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[3112,3317],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[3327,3643],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[3653,3710],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[3717,3831],"content":"Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.","nodes":[{"content":"Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.","pos":[0,114]}]},{"pos":[3838,4021],"content":"`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <xref:System.Type.AssemblyQualifiedName%2A>.","nodes":[{"content":"<ph id=\"ph1\">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.","pos":[0,134],"source":"`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification."},{"content":"See <ph id=\"ph1\">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.","pos":[135,183],"source":" See <xref:System.Type.AssemblyQualifiedName%2A>."}]},{"pos":[4028,4376],"content":"If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.","nodes":[{"content":"If <ph id=\"ph1\">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.","pos":[0,152],"source":"If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order."},{"content":"If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.","pos":[153,275]},{"content":"If the assembly has a strong name, a complete assembly name is required.","pos":[276,348]}]},{"pos":[4383,4742],"content":"The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.","nodes":[{"content":"The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.","pos":[0,359],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.","pos":[0,158],"source":"The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments."},{"content":"All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.","pos":[159,359]}]}]},{"pos":[4750,5498],"content":"[!NOTE]\n In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \"ProcessorArchitecture=msil\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method. You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly. See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.","leadings":["","> "],"nodes":[{"content":" In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \"ProcessorArchitecture=msil\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method. You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly. See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.","pos":[8,746],"nodes":[{"content":"In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.","pos":[1,144]},{"content":"For example, \"ProcessorArchitecture=msil\".","pos":[145,187]},{"content":"However, it is not included in the string returned by the <ph id=\"ph1\">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.","pos":[188,326],"source":" However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons."},{"content":"You can also load types by creating an <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id=\"ph2\">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.","pos":[327,509],"source":" You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method."},{"content":"You can then use the <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> method to load types from the assembly.","pos":[510,640],"source":" You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly."},{"content":"See also <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName&gt;</ph>.","pos":[641,738],"source":" See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>."}]}]},{"pos":[5505,5514],"content":"Delimiter","nodes":[{"content":"Delimiter","pos":[0,9]}]},{"pos":[5515,5522],"content":"Meaning","nodes":[{"content":"Meaning","pos":[0,7]}]},{"pos":[5561,5575],"content":"Backslash (\\\\)","nodes":[{"content":"Backslash (<ph id=\"ph1\">\\\\</ph>)","pos":[0,14],"source":"Backslash (\\\\)"}]},{"pos":[5576,5593],"content":"Escape character.","nodes":[{"content":"Escape character.","pos":[0,17]}]},{"pos":[5598,5610],"content":"Backtick (`)","nodes":[{"content":"Backtick (`)","pos":[0,12]}]},{"pos":[5611,5732],"content":"Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.","nodes":[{"content":"Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.","pos":[0,121]}]},{"pos":[5737,5750],"content":"Brackets ([])","nodes":[{"content":"Brackets ([])","pos":[0,13]}]},{"pos":[5751,5885],"content":"Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.","nodes":[{"content":"Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.","pos":[0,134]}]},{"pos":[5890,5899],"content":"Comma (,)","nodes":[{"content":"Comma (,)","pos":[0,9]}]},{"pos":[5900,5927],"content":"Precedes the Assembly name.","nodes":[{"content":"Precedes the Assembly name.","pos":[0,27]}]},{"pos":[5932,5942],"content":"Period (.)","nodes":[{"content":"Period (.)","pos":[0,10]}]},{"pos":[5943,5973],"content":"Denotes namespace identifiers.","nodes":[{"content":"Denotes namespace identifiers.","pos":[0,30]}]},{"pos":[5978,5991],"content":"Plus sign (+)","nodes":[{"content":"Plus sign (+)","pos":[0,13]}]},{"pos":[5992,6016],"content":"Precedes a nested class.","nodes":[{"content":"Precedes a nested class.","pos":[0,24]}]},{"pos":[6024,6095],"content":"For example, the fully qualified name for a class might look like this:","nodes":[{"content":"For example, the fully qualified name for a class might look like this:","pos":[0,71]}]},{"pos":[6184,6421],"content":"If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:","nodes":[{"content":"If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:","pos":[0,237],"nodes":[{"content":"If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id=\"ph1\">\\\\</ph>) to prevent it from being interpreted as a nesting separator.","pos":[0,196],"source":"If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\) to prevent it from being interpreted as a nesting separator."},{"content":"Reflection emits this string as follows:","pos":[197,237]}]}]},{"pos":[6512,6563],"content":"A \"++\" becomes \"\\\\+\\\\+\", and a \"\\\\\" becomes \"\\\\\\\\\".","nodes":[{"content":"A \"++\" becomes \"<ph id=\"ph1\">\\\\</ph><ph id=\"ph2\">+</ph><ph id=\"ph3\">\\\\</ph>+\", and a \"<ph id=\"ph4\">\\\\</ph>\" becomes \"<ph id=\"ph5\">\\\\</ph><ph id=\"ph6\">\\\\</ph>\".","pos":[0,51],"source":"A \"++\" becomes \"\\\\+\\\\+\", and a \"\\\\\" becomes \"\\\\\\\\\"."}]},{"pos":[6570,7076],"content":"This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.","nodes":[{"content":"This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.","pos":[0,506],"nodes":[{"content":"This qualified name can be persisted and later used to load the <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph>.","pos":[0,83],"source":"This qualified name can be persisted and later used to load the <xref:System.Type>."},{"content":"To search for and load a <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph>, use <ph id=\"ph2\">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.","pos":[84,235],"source":" To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.","pos":[236,384],"source":" <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> in any assembly.","pos":[385,506],"source":" <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly."}]}]},{"pos":[7083,7376],"content":"Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.","nodes":[{"content":"Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.","pos":[0,172]},{"content":"To retrieve the type name without these trailing characters, use <ph id=\"ph1\">`t.GetElementType().ToString()`</ph>, where <ph id=\"ph2\">`t`</ph> is the type.","pos":[173,293],"source":" To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type."}]},{"pos":[7383,7572],"content":"Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.","nodes":[{"content":"Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.","pos":[0,189],"nodes":[{"content":"Spaces are relevant in all type name components except the assembly name.","pos":[0,73]},{"content":"In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.","pos":[74,189]}]}]},{"pos":[7579,8079],"content":"The name of a generic type ends with a backtick (\\`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\\<T0, T1>` in Visual C#.","nodes":[{"content":"The name of a generic type ends with a backtick (<ph id=\"ph1\">\\`</ph>) followed by digits representing the number of generic type arguments.","pos":[0,122],"source":"The name of a generic type ends with a backtick (\\`) followed by digits representing the number of generic type arguments."},{"content":"The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.","pos":[123,298]},{"content":"For example, reflection returns the mangled names <ph id=\"ph1\">`Tuple`</ph>1<ph id=\"ph2\">` and `</ph>Tuple<ph id=\"ph3\">`2`</ph> from the generic methods <ph id=\"ph4\">`Tuple(Of T)`</ph> and <ph id=\"ph5\">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id=\"ph6\">`Tuple&lt;T&gt;`</ph> and Tuple<ph id=\"ph7\">`\\&lt;T0, T1&gt;`</ph> in Visual C#.","pos":[299,500],"source":" For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\\<T0, T1>` in Visual C#."}]},{"pos":[8086,8432],"content":"For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters. A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:","nodes":[{"content":"For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.","pos":[0,114]},{"content":"For example, a generic <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.","pos":[115,211],"source":" For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters."},{"content":"A <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id=\"ph2\">`MyType`</ph> with keys of type <ph id=\"ph3\">&lt;xref:System.String&gt;</ph> might be represented as follows:","pos":[212,346],"source":" A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:"}]},{"pos":[8518,8939],"content":"To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:","nodes":[{"content":"To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.","pos":[0,119]},{"content":"Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.","pos":[120,253]},{"content":"For example, a <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id=\"ph2\">`MyType`</ph> from MyAssembly.dll, with keys of type <ph id=\"ph3\">&lt;xref:System.String&gt;</ph>, might be specified as follows:","pos":[254,421],"source":" For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:"}]},{"pos":[9055,9340],"content":"[!NOTE]\n An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.","leadings":["","> "],"nodes":[{"content":" An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.","pos":[8,283],"nodes":[{"content":"An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.","pos":[1,106]},{"content":"The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.","pos":[107,275]}]}]},{"pos":[9347,9506],"content":"Nullable types are a special case of generic types. For example, a nullable <xref:System.Int32> is represented by the string \"System.Nullable`1[System.Int32]\".","nodes":[{"content":"Nullable types are a special case of generic types. For example, a nullable <xref:System.Int32> is represented by the string \"System.Nullable`1[System.Int32]\".","pos":[0,159],"nodes":[{"content":"Nullable types are a special case of generic types.","pos":[0,51]},{"content":"For example, a nullable <ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph> is represented by the string \"System.Nullable`1[System.Int32]\".","pos":[52,159],"source":" For example, a nullable <xref:System.Int32> is represented by the string \"System.Nullable`1[System.Int32]\"."}]}]},{"pos":[9514,9802],"content":"[!NOTE]\n In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.","leadings":["","> "],"nodes":[{"content":" In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.","pos":[8,286],"nodes":[{"content":"In C#, C++, and Visual Basic you can also get nullable types using type operators.","pos":[1,83]},{"content":"For example, the nullable <ph id=\"ph1\">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id=\"ph2\">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id=\"ph3\">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id=\"ph4\">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.","pos":[84,278],"source":" For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic."}]}]},{"pos":[9809,9887],"content":"The following table shows the syntax you use with <ph id=\"ph1\">`GetType`</ph> for various types.","source":"The following table shows the syntax you use with `GetType` for various types."},{"pos":[9894,9900],"content":"To Get","nodes":[{"content":"To Get","pos":[0,6]}]},{"pos":[9901,9904],"content":"Use","nodes":[{"content":"Use","pos":[0,3]}]},{"pos":[9936,9966],"content":"A nullable <xref:System.Int32>","nodes":[{"content":"A nullable <ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph>","pos":[0,30],"source":"A nullable <xref:System.Int32>"}]},{"pos":[9967,10016],"content":"<ph id=\"ph1\">`Type.GetType(\"System.Nullable`</ph>1[System.Int32]\")`","source":"`Type.GetType(\"System.Nullable`1[System.Int32]\")`"},{"pos":[10021,10053],"content":"An unmanaged pointer to <ph id=\"ph1\">`MyType`</ph>","source":"An unmanaged pointer to `MyType`"},{"pos":[10084,10129],"content":"An unmanaged pointer to a pointer to <ph id=\"ph1\">`MyType`</ph>","source":"An unmanaged pointer to a pointer to `MyType`"},{"pos":[10161,10203],"content":"A managed pointer or reference to <ph id=\"ph1\">`MyType`</ph>","source":"A managed pointer or reference to `MyType`"},{"pos":[10204,10294],"content":"`Type.GetType(\"MyType&\")`. Note that unlike pointers, references are limited to one level.","nodes":[{"content":"<ph id=\"ph1\">`Type.GetType(\"MyType&amp;\")`</ph>.","pos":[0,26],"source":"`Type.GetType(\"MyType&\")`."},{"content":"Note that unlike pointers, references are limited to one level.","pos":[27,90]}]},{"pos":[10299,10332],"content":"A parent class and a nested class","nodes":[{"content":"A parent class and a nested class","pos":[0,33]}]},{"pos":[10383,10430],"content":"A one-dimensional array with a lower bound of 0","nodes":[{"content":"A one-dimensional array with a lower bound of 0","pos":[0,47]}]},{"pos":[10463,10514],"content":"A one-dimensional array with an unknown lower bound","nodes":[{"content":"A one-dimensional array with an unknown lower bound","pos":[0,51]}]},{"pos":[10548,10570],"content":"An n-dimensional array","nodes":[{"content":"An n-dimensional array","pos":[0,22]}]},{"pos":[10571,10704],"content":"A comma (,) inside the brackets a total of n-1 times. For example, `System.Object[,,]` represents a three-dimensional `Object` array.","nodes":[{"content":"A comma (,) inside the brackets a total of n-1 times.","pos":[0,53]},{"content":"For example, <ph id=\"ph1\">`System.Object[,,]`</ph> represents a three-dimensional <ph id=\"ph2\">`Object`</ph> array.","pos":[54,133],"source":" For example, `System.Object[,,]` represents a three-dimensional `Object` array."}]},{"pos":[10709,10740],"content":"A two-dimensional array's array","nodes":[{"content":"A two-dimensional array's array","pos":[0,31]}]},{"pos":[10775,10836],"content":"A rectangular two-dimensional array with unknown lower bounds","nodes":[{"content":"A rectangular two-dimensional array with unknown lower bounds","pos":[0,61]}]},{"pos":[10870,10907],"content":"A generic type with one type argument","nodes":[{"content":"A generic type with one type argument","pos":[0,37]}]},{"pos":[10908,10949],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>1[MyType]\")`","source":"`Type.GetType(\"MyGenericType`1[MyType]\")`"},{"pos":[10954,10992],"content":"A generic type with two type arguments","nodes":[{"content":"A generic type with two type arguments","pos":[0,38]}]},{"pos":[10993,11046],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>2[MyType,AnotherType]\")`","source":"`Type.GetType(\"MyGenericType`2[MyType,AnotherType]\")`"},{"pos":[11051,11108],"content":"A generic type with two assembly-qualified type arguments","nodes":[{"content":"A generic type with two assembly-qualified type arguments","pos":[0,57]}]},{"pos":[11109,11193],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]\")`","source":"`Type.GetType(\"MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]\")`"},{"pos":[11198,11273],"content":"An assembly-qualified generic type with an assembly-qualified type argument","nodes":[{"content":"An assembly-qualified generic type with an assembly-qualified type argument","pos":[0,75]}]},{"pos":[11274,11350],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly\")`","source":"`Type.GetType(\"MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly\")`"},{"pos":[11355,11431],"content":"A generic type whose type argument is a generic type with two type arguments","nodes":[{"content":"A generic type whose type argument is a generic type with two type arguments","pos":[0,76]}]},{"pos":[11432,11507],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>1[AnotherGenericType<ph id=\"ph2\">`2[MyType,AnotherType]]\")`</ph>","source":"`Type.GetType(\"MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]\")`"}],"pos":[443628,455303],"yaml":true,"extradata":"MT"},{"content":"The assembly-qualified name of the type to get. See <xref href=\"System.Type.AssemblyQualifiedName\"></xref>. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.","nodes":[{"pos":[0,247],"content":"The assembly-qualified name of the type to get. See <xref href=\"System.Type.AssemblyQualifiedName\"></xref>. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.","nodes":[{"content":"The assembly-qualified name of the type to get.","pos":[0,47]},{"content":"See <ph id=\"ph1\">&lt;xref href=\"System.Type.AssemblyQualifiedName\"&gt;&lt;/xref&gt;</ph>.","pos":[48,107],"source":" See <xref href=\"System.Type.AssemblyQualifiedName\"></xref>."},{"content":"If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.","pos":[108,247]}]}],"pos":[456074,456322],"yaml":true},{"content":"`true` to throw an exception if the type cannot be found; `false` to return `null`. Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.","nodes":[{"pos":[0,200],"content":"`true` to throw an exception if the type cannot be found; `false` to return `null`. Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> to throw an exception if the type cannot be found; <ph id=\"ph2\">`false`</ph> to return <ph id=\"ph3\">`null`</ph>.","pos":[0,83],"source":"`true` to throw an exception if the type cannot be found; `false` to return `null`."},{"content":"Specifying <ph id=\"ph1\">`false`</ph> also suppresses some other exception conditions, but not all of them.","pos":[84,172],"source":" Specifying `false` also suppresses some other exception conditions, but not all of them."},{"content":"See the Exceptions section.","pos":[173,200]}]}],"pos":[456391,456594],"yaml":true},{"content":"The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.","nodes":[{"pos":[0,283],"content":"The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.","nodes":[{"content":"The type with the specified name.","pos":[0,33]},{"content":"If the type is not found, the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">throwOnError</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter specifies whether <ph id=\"ph2\">`null`</ph> is returned or an exception is thrown.","pos":[34,163],"source":" If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown."},{"content":"In some cases, an exception is thrown regardless of the value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">throwOnError</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","pos":[164,255],"source":" In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>."},{"content":"See the Exceptions section.","pos":[256,283]}]}],"pos":[456649,456933],"yaml":true},{"content":"<code>typeName</code> is `null`.","nodes":[{"pos":[0,32],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>typeName</code> is `null`."}],"pos":[457082,457115],"yaml":true},{"content":"A class initializer is invoked and throws an exception.","nodes":[{"pos":[0,55],"content":"A class initializer is invoked and throws an exception.","nodes":[{"content":"A class initializer is invoked and throws an exception.","pos":[0,55]}]}],"pos":[457247,457303],"yaml":true},{"content":"<code>throwOnError</code> is `true` and the type is not found.  \n  \n -or-  \n  \n <code>throwOnError</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab.  \n  \n -or-  \n  \n <code>throwOnError</code> is `true` and <code>typeName</code> is an empty string.  \n  \n -or-  \n  \n <code>throwOnError</code> is `true` and <code>typeName</code> represents an array type with an invalid size.  \n  \n -or-  \n  \n <code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref>.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and the type is not found.","source":"<code>throwOnError</code> is `true` and the type is not found."},{"pos":[69,73],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[80,195],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid characters, such as an embedded tab.","source":"<code>throwOnError</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab."},{"pos":[202,206],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[213,294],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> is an empty string.","source":"<code>throwOnError</code> is `true` and <code>typeName</code> is an empty string."},{"pos":[301,305],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[312,420],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array type with an invalid size.","source":"<code>throwOnError</code> is `true` and <code>typeName</code> represents an array type with an invalid size."},{"pos":[427,431],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[438,526],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array of <ph id=\"ph2\">&lt;xref href=\"System.TypedReference\"&gt;&lt;/xref&gt;</ph>.","source":"<code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref>."}],"pos":[457397,457944],"yaml":true},{"content":"<code>throwOnError</code> is `true` and <code>typeName</code> contains invalid syntax. For example, \"MyType[,*,]\".  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\"System.Void\"></xref> as one of its type arguments.  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.","nodes":[{"pos":[0,114],"content":"<code>throwOnError</code> is `true` and <code>typeName</code> contains invalid syntax. For example, \"MyType[,*,]\".","nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid syntax.","pos":[0,86],"source":"<code>throwOnError</code> is `true` and <code>typeName</code> contains invalid syntax."},{"content":"For example, \"MyType[,*,]\".","pos":[87,114]}]},{"pos":[121,125],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[132,286],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has a pointer type, a <ph id=\"ph2\">`ByRef`</ph> type, or <ph id=\"ph3\">&lt;xref href=\"System.Void\"&gt;&lt;/xref&gt;</ph> as one of its type arguments.","source":"<code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\"System.Void\"></xref> as one of its type arguments."},{"pos":[293,297],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[304,399],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has an incorrect number of type arguments.","source":"<code>typeName</code> represents a generic type that has an incorrect number of type arguments."},{"pos":[406,410],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[417,566],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.","source":"<code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter."}],"pos":[458038,458623],"yaml":true},{"content":"<code>throwOnError</code> is `true` and the assembly or one of its dependencies was not found.","nodes":[{"pos":[0,94],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and the assembly or one of its dependencies was not found.","source":"<code>throwOnError</code> is `true` and the assembly or one of its dependencies was not found."}],"pos":[458731,458826],"yaml":true},{"content":"<block subset=\"none\" type=\"note\">\n      <p>  \n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.IO.IOException\"></xref>, instead.  \n  \n</p>\n    </block>  \n  \n The assembly or one of its dependencies was found, but could not be loaded.","nodes":[{"pos":[0,342],"content":"<block subset=\"none\" type=\"note\">\n      <p>  \n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.IO.IOException\"></xref>, instead.","nodes":[{"content":"In the <bpt id=\"p1\">[</bpt>.NET for Windows Store apps<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id=\"p2\">[</bpt>Portable Class Library<ept id=\"p2\">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id=\"ph1\">&lt;xref href=\"System.IO.IOException\"&gt;&lt;/xref&gt;</ph>, instead.","pos":[47,342],"source":" In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.IO.IOException\"></xref>, instead."}]},{"pos":[348,365],"content":"</p>\n    </block>","nodes":[]},{"pos":[372,447],"content":"The assembly or one of its dependencies was found, but could not be loaded.","nodes":[{"content":"The assembly or one of its dependencies was found, but could not be loaded.","pos":[0,75]}]}],"pos":[458926,459389],"yaml":true},{"content":"The assembly or one of its dependencies is not valid.  \n  \n -or-  \n  \n Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.","nodes":[{"pos":[0,53],"content":"The assembly or one of its dependencies is not valid.","nodes":[{"content":"The assembly or one of its dependencies is not valid.","pos":[0,53]}]},{"pos":[60,64],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[71,195],"content":"Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.","nodes":[{"content":"Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.","pos":[0,124]}]}],"pos":[459495,459697],"yaml":true},{"content":"Gets the <xref href=\"System.Type\"></xref> with the specified name, performing a case-sensitive search.","nodes":[{"pos":[0,102],"content":"Gets the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> with the specified name, performing a case-sensitive search.","source":"Gets the <xref href=\"System.Type\"></xref> with the specified name, performing a case-sensitive search."}],"pos":[461114,461217],"yaml":true},{"content":"You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its namespace-qualified name. <xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`. You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <xref:System.Type.GetType%2A> in Visual Basic, or  in C++.  \n  \n> [!NOTE]\n>  If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`. It does not throw an exception. To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.  \n  \n <xref:System.Type.GetType%2A>GetType only works on assemblies loaded from disk. If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> enumeration. If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when `GetType` is called, the method returns `null`. `GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.  \n  \n To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> event and call `GetType` before saving. Otherwise, you will get two copies of the assembly in memory.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.  \n  \n `typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <xref:System.Type.AssemblyQualifiedName%2A>.  \n  \n If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.  \n  \n The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  \n  \n> [!NOTE]\n>  In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \"ProcessorArchitecture=msil\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method. You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly. See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.  \n  \n|Delimiter|Meaning|  \n|---------------|-------------|  \n|Backslash (\\\\)|Escape character.|  \n|Backtick (`)|Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.|  \n|Brackets ([])|Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.|  \n|Comma (,)|Precedes the Assembly name.|  \n|Period (.)|Denotes namespace identifiers.|  \n|Plus sign (+)|Precedes a nested class.|  \n  \n For example, the fully qualified name for a class might look like this:  \n  \n```  \nTopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  \n```  \n  \n If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:  \n  \n```  \nTopNamespace.Sub\\+Namespace.ContainingClass+NestedClass,MyAssembly  \n```  \n  \n A \"++\" becomes \"\\\\+\\\\+\", and a \"\\\\\" becomes \"\\\\\\\\\".  \n  \n This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.  \n  \n Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.  \n  \n Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.  \n  \n The name of a generic type ends with a backtick (\\`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\\<T0, T1>` in Visual C#.  \n  \n For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters. A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:  \n  \n```  \nSystem.Collections.Generic.Dictionary`2[System.String,MyType]  \n```  \n  \n To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:  \n  \n```  \nType.GetType(\"System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]\")  \n```  \n  \n> [!NOTE]\n>  An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.  \n  \n Nullable types are a special case of generic types. For example, a nullable <xref:System.Int32> is represented by the string \"System.Nullable`1[System.Int32]\".  \n  \n> [!NOTE]\n>  In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.  \n  \n The following table shows the syntax you use with `GetType` for various types.  \n  \n|To Get|Use|  \n|------------|---------|  \n|A nullable <xref:System.Int32>|`Type.GetType(\"System.Nullable`1[System.Int32]\")`|  \n|An unmanaged pointer to `MyType`|`Type.GetType(\"MyType*\")`|  \n|An unmanaged pointer to a pointer to `MyType`|`Type.GetType(\"MyType**\")`|  \n|A managed pointer or reference to `MyType`|`Type.GetType(\"MyType&\")`. Note that unlike pointers, references are limited to one level.|  \n|A parent class and a nested class|`Type.GetType(\"MyParentClass+MyNestedClass\")`|  \n|A one-dimensional array with a lower bound of 0|`Type.GetType(\"MyType[]\")`|  \n|A one-dimensional array with an unknown lower bound|`Type.GetType(\"MyType[*]\")`|  \n|An n-dimensional array|A comma (,) inside the brackets a total of n-1 times. For example, `System.Object[,,]` represents a three-dimensional `Object` array.|  \n|An array of one-dimensional arrays|`Type.GetType(\"MyType[][]\")`|  \n|A rectangular two-dimensional array with unknown lower bounds|`Type.GetType(\"MyType[,]\")`|  \n|A generic type with one type argument|`Type.GetType(\"MyGenericType`1[MyType]\")`|  \n|A generic type with two type arguments|`Type.GetType(\"MyGenericType`2[MyType,AnotherType]\")`|  \n|A generic type with two assembly-qualified type arguments|`Type.GetType(\"MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]\")`|  \n|An assembly-qualified generic type with an assembly-qualified type argument|`Type.GetType(\"MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly\")`|  \n|A generic type whose type argument is a generic type with two type arguments|`Type.GetType(\"MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]\")`|","nodes":[{"pos":[0,688],"content":"You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its namespace-qualified name. <xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`. You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <xref:System.Type.GetType%2A> in Visual Basic, or  in C++.","nodes":[{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if you know its namespace-qualified name.","pos":[0,164],"source":"You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its namespace-qualified name."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id=\"ph2\">`typeName`</ph>.","pos":[165,250],"source":" <xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`."},{"content":"You can also load an assembly using the <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method, and then use the <ph id=\"ph2\">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id=\"ph4\">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id=\"ph5\">&lt;xref:System.Type&gt;</ph> objects.","pos":[251,526],"source":" You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects."},{"content":"If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or  in C++.","pos":[527,688],"source":" If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <xref:System.Type.GetType%2A> in Visual Basic, or  in C++."}]},{"pos":[696,995],"content":"[!NOTE]\n If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`. It does not throw an exception. To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.","leadings":["","> "],"nodes":[{"content":" If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`. It does not throw an exception. To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.","pos":[8,297],"nodes":[{"content":"If <ph id=\"ph1\">`typeName`</ph> cannot be found, the call to the <ph id=\"ph2\">&lt;xref:System.Type.GetType%28System.String%29&gt;</ph> method returns <ph id=\"ph3\">`null`</ph>.","pos":[1,116],"source":" If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`."},{"content":"It does not throw an exception.","pos":[117,148]},{"content":"To control whether an exception is thrown, call an overload of the <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> method that has a <ph id=\"ph2\">`throwOnError`</ph> parameter.","pos":[149,289],"source":" To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter."}]}]},{"pos":[1002,1950],"content":"<xref:System.Type.GetType%2A>GetType only works on assemblies loaded from disk. If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> enumeration. If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when `GetType` is called, the method returns `null`. `GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph>GetType only works on assemblies loaded from disk.","pos":[0,79],"source":"<xref:System.Type.GetType%2A>GetType only works on assemblies loaded from disk."},{"content":"If you call <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> to look up a type defined in a dynamic assembly defined using the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.","pos":[80,264],"source":" If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior."},{"content":"The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id=\"ph1\">`RunAndSave`</ph> or <ph id=\"ph2\">`Save`</ph> access modes of the <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName&gt;</ph> enumeration.","pos":[265,492],"source":" The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> enumeration."},{"content":"If the dynamic assembly is persistent and has been written to disk before <ph id=\"ph1\">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.","pos":[493,696],"source":" If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly."},{"content":"If the assembly has not been saved to disk when <ph id=\"ph1\">`GetType`</ph> is called, the method returns <ph id=\"ph2\">`null`</ph>.","pos":[697,792],"source":" If the assembly has not been saved to disk when `GetType` is called, the method returns `null`."},{"content":"<ph id=\"ph1\">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id=\"ph2\">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id=\"ph3\">`null`</ph>.","pos":[793,948],"source":"`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`."}]},{"pos":[1957,2178],"content":"To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> event and call `GetType` before saving. Otherwise, you will get two copies of the assembly in memory.","nodes":[{"content":"To use <ph id=\"ph1\">`GetType`</ph> on a dynamic module, subscribe to the <ph id=\"ph2\">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=fullName&gt;</ph> event and call <ph id=\"ph3\">`GetType`</ph> before saving.","pos":[0,159],"source":"To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> event and call `GetType` before saving."},{"content":"Otherwise, you will get two copies of the assembly in memory.","pos":[160,221]}]},{"pos":[2185,2300],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[2307,2318],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[2319,2325],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[2326,2336],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[2394,2405],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[2406,2408],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2409,2411],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2416,2421],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[2422,2424],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2425,2475],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[2480,2485],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[2486,2500],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[2501,2694],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[2699,2705],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[2706,2708],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2709,2804],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[2809,2820],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[2821,2823],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2824,2826],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2831,2839],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[2840,2854],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[2855,3048],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[3059,3264],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[3274,3590],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[3600,3657],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[3664,3778],"content":"Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.","nodes":[{"content":"Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.","pos":[0,114]}]},{"pos":[3785,3968],"content":"`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <xref:System.Type.AssemblyQualifiedName%2A>.","nodes":[{"content":"<ph id=\"ph1\">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.","pos":[0,134],"source":"`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification."},{"content":"See <ph id=\"ph1\">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.","pos":[135,183],"source":" See <xref:System.Type.AssemblyQualifiedName%2A>."}]},{"pos":[3975,4323],"content":"If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.","nodes":[{"content":"If <ph id=\"ph1\">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.","pos":[0,152],"source":"If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order."},{"content":"If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.","pos":[153,275]},{"content":"If the assembly has a strong name, a complete assembly name is required.","pos":[276,348]}]},{"pos":[4330,4694],"content":"The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.","nodes":[{"content":"The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.","pos":[0,364],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.","pos":[0,163],"source":"The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments."},{"content":"All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.","pos":[164,364]}]}]},{"pos":[4702,5450],"content":"[!NOTE]\n In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \"ProcessorArchitecture=msil\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method. You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly. See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.","leadings":["","> "],"nodes":[{"content":" In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \"ProcessorArchitecture=msil\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method. You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly. See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.","pos":[8,746],"nodes":[{"content":"In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.","pos":[1,144]},{"content":"For example, \"ProcessorArchitecture=msil\".","pos":[145,187]},{"content":"However, it is not included in the string returned by the <ph id=\"ph1\">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.","pos":[188,326],"source":" However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons."},{"content":"You can also load types by creating an <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id=\"ph2\">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.","pos":[327,509],"source":" You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method."},{"content":"You can then use the <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> method to load types from the assembly.","pos":[510,640],"source":" You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly."},{"content":"See also <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName&gt;</ph>.","pos":[641,738],"source":" See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>."}]}]},{"pos":[5457,5466],"content":"Delimiter","nodes":[{"content":"Delimiter","pos":[0,9]}]},{"pos":[5467,5474],"content":"Meaning","nodes":[{"content":"Meaning","pos":[0,7]}]},{"pos":[5513,5527],"content":"Backslash (\\\\)","nodes":[{"content":"Backslash (<ph id=\"ph1\">\\\\</ph>)","pos":[0,14],"source":"Backslash (\\\\)"}]},{"pos":[5528,5545],"content":"Escape character.","nodes":[{"content":"Escape character.","pos":[0,17]}]},{"pos":[5550,5562],"content":"Backtick (`)","nodes":[{"content":"Backtick (`)","pos":[0,12]}]},{"pos":[5563,5684],"content":"Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.","nodes":[{"content":"Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.","pos":[0,121]}]},{"pos":[5689,5702],"content":"Brackets ([])","nodes":[{"content":"Brackets ([])","pos":[0,13]}]},{"pos":[5703,5837],"content":"Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.","nodes":[{"content":"Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.","pos":[0,134]}]},{"pos":[5842,5851],"content":"Comma (,)","nodes":[{"content":"Comma (,)","pos":[0,9]}]},{"pos":[5852,5879],"content":"Precedes the Assembly name.","nodes":[{"content":"Precedes the Assembly name.","pos":[0,27]}]},{"pos":[5884,5894],"content":"Period (.)","nodes":[{"content":"Period (.)","pos":[0,10]}]},{"pos":[5895,5925],"content":"Denotes namespace identifiers.","nodes":[{"content":"Denotes namespace identifiers.","pos":[0,30]}]},{"pos":[5930,5943],"content":"Plus sign (+)","nodes":[{"content":"Plus sign (+)","pos":[0,13]}]},{"pos":[5944,5968],"content":"Precedes a nested class.","nodes":[{"content":"Precedes a nested class.","pos":[0,24]}]},{"pos":[5976,6047],"content":"For example, the fully qualified name for a class might look like this:","nodes":[{"content":"For example, the fully qualified name for a class might look like this:","pos":[0,71]}]},{"pos":[6136,6373],"content":"If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:","nodes":[{"content":"If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:","pos":[0,237],"nodes":[{"content":"If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id=\"ph1\">\\\\</ph>) to prevent it from being interpreted as a nesting separator.","pos":[0,196],"source":"If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\) to prevent it from being interpreted as a nesting separator."},{"content":"Reflection emits this string as follows:","pos":[197,237]}]}]},{"pos":[6464,6515],"content":"A \"++\" becomes \"\\\\+\\\\+\", and a \"\\\\\" becomes \"\\\\\\\\\".","nodes":[{"content":"A \"++\" becomes \"<ph id=\"ph1\">\\\\</ph><ph id=\"ph2\">+</ph><ph id=\"ph3\">\\\\</ph>+\", and a \"<ph id=\"ph4\">\\\\</ph>\" becomes \"<ph id=\"ph5\">\\\\</ph><ph id=\"ph6\">\\\\</ph>\".","pos":[0,51],"source":"A \"++\" becomes \"\\\\+\\\\+\", and a \"\\\\\" becomes \"\\\\\\\\\"."}]},{"pos":[6522,7028],"content":"This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.","nodes":[{"content":"This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.","pos":[0,506],"nodes":[{"content":"This qualified name can be persisted and later used to load the <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph>.","pos":[0,83],"source":"This qualified name can be persisted and later used to load the <xref:System.Type>."},{"content":"To search for and load a <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph>, use <ph id=\"ph2\">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.","pos":[84,235],"source":" To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.","pos":[236,384],"source":" <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> in any assembly.","pos":[385,506],"source":" <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly."}]}]},{"pos":[7035,7328],"content":"Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.","nodes":[{"content":"Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.","pos":[0,172]},{"content":"To retrieve the type name without these trailing characters, use <ph id=\"ph1\">`t.GetElementType().ToString()`</ph>, where <ph id=\"ph2\">`t`</ph> is the type.","pos":[173,293],"source":" To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type."}]},{"pos":[7335,7524],"content":"Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.","nodes":[{"content":"Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.","pos":[0,189],"nodes":[{"content":"Spaces are relevant in all type name components except the assembly name.","pos":[0,73]},{"content":"In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.","pos":[74,189]}]}]},{"pos":[7531,8031],"content":"The name of a generic type ends with a backtick (\\`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\\<T0, T1>` in Visual C#.","nodes":[{"content":"The name of a generic type ends with a backtick (<ph id=\"ph1\">\\`</ph>) followed by digits representing the number of generic type arguments.","pos":[0,122],"source":"The name of a generic type ends with a backtick (\\`) followed by digits representing the number of generic type arguments."},{"content":"The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.","pos":[123,298]},{"content":"For example, reflection returns the mangled names <ph id=\"ph1\">`Tuple`</ph>1<ph id=\"ph2\">` and `</ph>Tuple<ph id=\"ph3\">`2`</ph> from the generic methods <ph id=\"ph4\">`Tuple(Of T)`</ph> and <ph id=\"ph5\">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id=\"ph6\">`Tuple&lt;T&gt;`</ph> and Tuple<ph id=\"ph7\">`\\&lt;T0, T1&gt;`</ph> in Visual C#.","pos":[299,500],"source":" For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\\<T0, T1>` in Visual C#."}]},{"pos":[8038,8384],"content":"For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters. A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:","nodes":[{"content":"For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.","pos":[0,114]},{"content":"For example, a generic <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.","pos":[115,211],"source":" For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters."},{"content":"A <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id=\"ph2\">`MyType`</ph> with keys of type <ph id=\"ph3\">&lt;xref:System.String&gt;</ph> might be represented as follows:","pos":[212,346],"source":" A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:"}]},{"pos":[8470,8890],"content":"To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:","nodes":[{"content":"To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.","pos":[0,119]},{"content":"Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.","pos":[120,253]},{"content":"For example, a <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id=\"ph2\">`MyType`</ph> fromMyAssembly.dll, with keys of type <ph id=\"ph3\">&lt;xref:System.String&gt;</ph>, might be specified as follows:","pos":[254,420],"source":" For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:"}]},{"pos":[9006,9291],"content":"[!NOTE]\n An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.","leadings":["","> "],"nodes":[{"content":" An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.","pos":[8,283],"nodes":[{"content":"An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.","pos":[1,106]},{"content":"The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.","pos":[107,275]}]}]},{"pos":[9298,9457],"content":"Nullable types are a special case of generic types. For example, a nullable <xref:System.Int32> is represented by the string \"System.Nullable`1[System.Int32]\".","nodes":[{"content":"Nullable types are a special case of generic types. For example, a nullable <xref:System.Int32> is represented by the string \"System.Nullable`1[System.Int32]\".","pos":[0,159],"nodes":[{"content":"Nullable types are a special case of generic types.","pos":[0,51]},{"content":"For example, a nullable <ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph> is represented by the string \"System.Nullable`1[System.Int32]\".","pos":[52,159],"source":" For example, a nullable <xref:System.Int32> is represented by the string \"System.Nullable`1[System.Int32]\"."}]}]},{"pos":[9465,9753],"content":"[!NOTE]\n In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.","leadings":["","> "],"nodes":[{"content":" In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.","pos":[8,286],"nodes":[{"content":"In C#, C++, and Visual Basic you can also get nullable types using type operators.","pos":[1,83]},{"content":"For example, the nullable <ph id=\"ph1\">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id=\"ph2\">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id=\"ph3\">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id=\"ph4\">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.","pos":[84,278],"source":" For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic."}]}]},{"pos":[9760,9838],"content":"The following table shows the syntax you use with <ph id=\"ph1\">`GetType`</ph> for various types.","source":"The following table shows the syntax you use with `GetType` for various types."},{"pos":[9845,9851],"content":"To Get","nodes":[{"content":"To Get","pos":[0,6]}]},{"pos":[9852,9855],"content":"Use","nodes":[{"content":"Use","pos":[0,3]}]},{"pos":[9887,9917],"content":"A nullable <xref:System.Int32>","nodes":[{"content":"A nullable <ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph>","pos":[0,30],"source":"A nullable <xref:System.Int32>"}]},{"pos":[9918,9967],"content":"<ph id=\"ph1\">`Type.GetType(\"System.Nullable`</ph>1[System.Int32]\")`","source":"`Type.GetType(\"System.Nullable`1[System.Int32]\")`"},{"pos":[9972,10004],"content":"An unmanaged pointer to <ph id=\"ph1\">`MyType`</ph>","source":"An unmanaged pointer to `MyType`"},{"pos":[10035,10080],"content":"An unmanaged pointer to a pointer to <ph id=\"ph1\">`MyType`</ph>","source":"An unmanaged pointer to a pointer to `MyType`"},{"pos":[10112,10154],"content":"A managed pointer or reference to <ph id=\"ph1\">`MyType`</ph>","source":"A managed pointer or reference to `MyType`"},{"pos":[10155,10245],"content":"`Type.GetType(\"MyType&\")`. Note that unlike pointers, references are limited to one level.","nodes":[{"content":"<ph id=\"ph1\">`Type.GetType(\"MyType&amp;\")`</ph>.","pos":[0,26],"source":"`Type.GetType(\"MyType&\")`."},{"content":"Note that unlike pointers, references are limited to one level.","pos":[27,90]}]},{"pos":[10250,10283],"content":"A parent class and a nested class","nodes":[{"content":"A parent class and a nested class","pos":[0,33]}]},{"pos":[10334,10381],"content":"A one-dimensional array with a lower bound of 0","nodes":[{"content":"A one-dimensional array with a lower bound of 0","pos":[0,47]}]},{"pos":[10413,10464],"content":"A one-dimensional array with an unknown lower bound","nodes":[{"content":"A one-dimensional array with an unknown lower bound","pos":[0,51]}]},{"pos":[10497,10519],"content":"An n-dimensional array","nodes":[{"content":"An n-dimensional array","pos":[0,22]}]},{"pos":[10520,10653],"content":"A comma (,) inside the brackets a total of n-1 times. For example, `System.Object[,,]` represents a three-dimensional `Object` array.","nodes":[{"content":"A comma (,) inside the brackets a total of n-1 times.","pos":[0,53]},{"content":"For example, <ph id=\"ph1\">`System.Object[,,]`</ph> represents a three-dimensional <ph id=\"ph2\">`Object`</ph> array.","pos":[54,133],"source":" For example, `System.Object[,,]` represents a three-dimensional `Object` array."}]},{"pos":[10658,10692],"content":"An array of one-dimensional arrays","nodes":[{"content":"An array of one-dimensional arrays","pos":[0,34]}]},{"pos":[10726,10787],"content":"A rectangular two-dimensional array with unknown lower bounds","nodes":[{"content":"A rectangular two-dimensional array with unknown lower bounds","pos":[0,61]}]},{"pos":[10820,10857],"content":"A generic type with one type argument","nodes":[{"content":"A generic type with one type argument","pos":[0,37]}]},{"pos":[10858,10899],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>1[MyType]\")`","source":"`Type.GetType(\"MyGenericType`1[MyType]\")`"},{"pos":[10904,10942],"content":"A generic type with two type arguments","nodes":[{"content":"A generic type with two type arguments","pos":[0,38]}]},{"pos":[10943,10996],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>2[MyType,AnotherType]\")`","source":"`Type.GetType(\"MyGenericType`2[MyType,AnotherType]\")`"},{"pos":[11001,11058],"content":"A generic type with two assembly-qualified type arguments","nodes":[{"content":"A generic type with two assembly-qualified type arguments","pos":[0,57]}]},{"pos":[11059,11143],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]\")`","source":"`Type.GetType(\"MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]\")`"},{"pos":[11148,11223],"content":"An assembly-qualified generic type with an assembly-qualified type argument","nodes":[{"content":"An assembly-qualified generic type with an assembly-qualified type argument","pos":[0,75]}]},{"pos":[11224,11300],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly\")`","source":"`Type.GetType(\"MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly\")`"},{"pos":[11305,11381],"content":"A generic type whose type argument is a generic type with two type arguments","nodes":[{"content":"A generic type whose type argument is a generic type with two type arguments","pos":[0,76]}]},{"pos":[11382,11457],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>1[AnotherGenericType<ph id=\"ph2\">`2[MyType,AnotherType]]\")`</ph>","source":"`Type.GetType(\"MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]\")`"}],"pos":[461228,472854],"yaml":true,"extradata":"MT"},{"content":"The assembly-qualified name of the type to get. See <xref href=\"System.Type.AssemblyQualifiedName\"></xref>. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.","nodes":[{"pos":[0,247],"content":"The assembly-qualified name of the type to get. See <xref href=\"System.Type.AssemblyQualifiedName\"></xref>. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.","nodes":[{"content":"The assembly-qualified name of the type to get.","pos":[0,47]},{"content":"See <ph id=\"ph1\">&lt;xref href=\"System.Type.AssemblyQualifiedName\"&gt;&lt;/xref&gt;</ph>.","pos":[48,107],"source":" See <xref href=\"System.Type.AssemblyQualifiedName\"></xref>."},{"content":"If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.","pos":[108,247]}]}],"pos":[473512,473760],"yaml":true},{"content":"The type with the specified name, if found; otherwise, `null`.","nodes":[{"pos":[0,62],"content":"The type with the specified name, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","source":"The type with the specified name, if found; otherwise, `null`."}],"pos":[473815,473878],"yaml":true},{"content":"<code>typeName</code> is `null`.","nodes":[{"pos":[0,32],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>typeName</code> is `null`."}],"pos":[474027,474060],"yaml":true},{"content":"A class initializer is invoked and throws an exception.","nodes":[{"pos":[0,55],"content":"A class initializer is invoked and throws an exception.","nodes":[{"content":"A class initializer is invoked and throws an exception.","pos":[0,55]}]}],"pos":[474192,474248],"yaml":true},{"content":"<code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\"System.Void\"></xref> as one of its type arguments.  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.","nodes":[{"pos":[0,154],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has a pointer type, a <ph id=\"ph2\">`ByRef`</ph> type, or <ph id=\"ph3\">&lt;xref href=\"System.Void\"&gt;&lt;/xref&gt;</ph> as one of its type arguments.","source":"<code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\"System.Void\"></xref> as one of its type arguments."},{"pos":[161,165],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[172,267],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has an incorrect number of type arguments.","source":"<code>typeName</code> represents a generic type that has an incorrect number of type arguments."},{"pos":[274,278],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[285,434],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.","source":"<code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter."}],"pos":[474342,474789],"yaml":true},{"content":"<code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref>.","nodes":[{"pos":[0,88],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array of <ph id=\"ph2\">&lt;xref href=\"System.TypedReference\"&gt;&lt;/xref&gt;</ph>.","source":"<code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref>."}],"pos":[474883,474972],"yaml":true},{"content":"<block subset=\"none\" type=\"note\">\n      <p>  \n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.IO.IOException\"></xref>, instead.  \n  \n</p>\n    </block>  \n  \n The assembly or one of its dependencies was found, but could not be loaded.","nodes":[{"pos":[0,342],"content":"<block subset=\"none\" type=\"note\">\n      <p>  \n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.IO.IOException\"></xref>, instead.","nodes":[{"content":"In the <bpt id=\"p1\">[</bpt>.NET for Windows Store apps<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=247912)</ept> or the <bpt id=\"p2\">[</bpt>Portable Class Library<ept id=\"p2\">](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md)</ept>, catch the base class exception, <ph id=\"ph1\">&lt;xref href=\"System.IO.IOException\"&gt;&lt;/xref&gt;</ph>, instead.","pos":[47,342],"source":" In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\"System.IO.IOException\"></xref>, instead."}]},{"pos":[348,365],"content":"</p>\n    </block>","nodes":[]},{"pos":[372,447],"content":"The assembly or one of its dependencies was found, but could not be loaded.","nodes":[{"content":"The assembly or one of its dependencies was found, but could not be loaded.","pos":[0,75]}]}],"pos":[475072,475535],"yaml":true},{"content":"The assembly or one of its dependencies is not valid.  \n  \n -or-  \n  \n Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.","nodes":[{"pos":[0,53],"content":"The assembly or one of its dependencies is not valid.","nodes":[{"content":"The assembly or one of its dependencies is not valid.","pos":[0,53]}]},{"pos":[60,64],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[71,195],"content":"Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.","nodes":[{"content":"Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.","pos":[0,124]}]}],"pos":[475641,475843],"yaml":true},{"content":"Gets the <xref href=\"System.Type\"></xref> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.","nodes":[{"pos":[0,180],"content":"Gets the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.","source":"Gets the <xref href=\"System.Type\"></xref> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search."}],"pos":[477404,477585],"yaml":true},{"content":"You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace-qualified name. <xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`. You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A>method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.  \n  \n `GetType` only works on assemblies loaded from disk. If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> enumeration. If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when `GetType` is called, the method returns `null`. `GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.  \n  \n To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> event and call `GetType` before saving. Otherwise, you will get two copies of the assembly in memory.  \n  \n The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of `throwOnError`. For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.  \n  \n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \n  \n|Member Type|Static|Non-Static|  \n|-----------------|------------|-----------------|  \n|Constructor|No|No|  \n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \n|Nested Type|No|No|  \n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \n  \n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \n  \n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \n  \n3.  Custom attributes are not part of the common type system.  \n  \n Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.  \n  \n `typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <xref:System.Type.AssemblyQualifiedName%2A>.  \n  \n If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.  \n  \n The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  \n  \n> [!NOTE]\n>  In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \"ProcessorArchitecture=msil\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method. You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly. See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.  \n  \n|Delimiter|Meaning|  \n|---------------|-------------|  \n|Backslash (\\\\)|Escape character.|  \n|Backtick (`)|Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.|  \n|Brackets ([])|Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.|  \n|Comma (,)|Precedes the Assembly name.|  \n|Period (.)|Denotes namespace identifiers.|  \n|Plus sign (+)|Precedes a nested class.|  \n  \n For example, the fully qualified name for a class might look like this:  \n  \n```  \nTopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  \n```  \n  \n If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:  \n  \n```  \nTopNamespace.Sub\\+Namespace.ContainingClass+NestedClass,MyAssembly  \n```  \n  \n A \"++\" becomes \"\\\\+\\\\+\", and a \"\\\\\" becomes \"\\\\\\\\\".  \n  \n This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.  \n  \n Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.  \n  \n Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.  \n  \n The name of a generic type ends with a backtick (\\`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\\<T0, T1>` in Visual C#.  \n  \n For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters. A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:  \n  \n```  \nSystem.Collections.Generic.Dictionary`2[System.String,MyType]  \n```  \n  \n To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:  \n  \n```  \nType.GetType(\"System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]\")  \n```  \n  \n> [!NOTE]\n>  An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.  \n  \n Nullable types are a special case of generic types. For example, a nullable <xref:System.Int32> is represented by the string \"System.Nullable`1[System.Int32]\".  \n  \n> [!NOTE]\n>  In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.  \n  \n The following table shows the syntax you use with `GetType` for various types.  \n  \n|To Get|Use|  \n|------------|---------|  \n|A nullable <xref:System.Int32>|`Type.GetType(\"System.Nullable`1[System.Int32]\")`|  \n|An unmanaged pointer to `MyType`|`Type.GetType(\"MyType*\")`|  \n|An unmanaged pointer to a pointer to `MyType`|`Type.GetType(\"MyType**\")`|  \n|A managed pointer or reference to `MyType`|`Type.GetType(\"MyType&\")`. Note that unlike pointers, references are limited to one level.|  \n|A parent class and a nested class|`Type.GetType(\"MyParentClass+MyNestedClass\")`|  \n|A one-dimensional array with a lower bound of 0|`Type.GetType(\"MyArray[]\")`|  \n|A one-dimensional array with an unknown lower bound|`Type.GetType(\"MyArray[*]\")`|  \n|An n-dimensional array|A comma (,) inside the brackets a total of n-1 times. For example, `System.Object[,,]` represents a three-dimensional `Object` array.|  \n|A two-dimensional array's array|`Type.GetType(\"MyArray[][]\")`|  \n|A rectangular two-dimensional array with unknown lower bounds|`Type.GetType(\"MyArray[,]\")`|  \n|A generic type with one type argument|`Type.GetType(\"MyGenericType`1[MyType]\")`|  \n|A generic type with two type arguments|`Type.GetType(\"MyGenericType`2[MyType,AnotherType]\")`|  \n|A generic type with two assembly-qualified type arguments|`Type.GetType(\"MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]\")`|  \n|An assembly-qualified generic type with an assembly-qualified type argument|`Type.GetType(\"MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly\")`|  \n|A generic type whose type argument is a generic type with two type arguments|`Type.GetType(\"MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]\")`|","nodes":[{"pos":[0,707],"content":"You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace-qualified name. <xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`. You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A>method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.","nodes":[{"content":"You can use the <ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> method to obtain a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object for a type in another assembly, if the you know its namespace-qualified name.","pos":[0,168],"source":"You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace-qualified name."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> causes loading of the assembly specified in <ph id=\"ph2\">`typeName`</ph>.","pos":[169,254],"source":" <xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`."},{"content":"You can also load an assembly using the <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph>method, and then use the <ph id=\"ph2\">&lt;xref:System.Type.GetType%2A&gt;</ph> or <ph id=\"ph3\">&lt;xref:System.Reflection.Assembly.GetTypes%2A&gt;</ph> methods of the <ph id=\"ph4\">&lt;xref:System.Reflection.Assembly&gt;</ph> class to get <ph id=\"ph5\">&lt;xref:System.Type&gt;</ph> objects.","pos":[255,529],"source":" You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A>method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects."},{"content":"If a type is in an assembly known to your program at compile time, it is more efficient to use <ph id=\"ph1\">`typeof`</ph> in C#, <ph id=\"ph2\">&lt;xref:System.Type.GetType%2A&gt;</ph> in Visual Basic, or <ph id=\"ph3\">`typeid`</ph> in C++.","pos":[530,707],"source":" If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++."}]},{"pos":[714,1615],"content":"`GetType` only works on assemblies loaded from disk. If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> enumeration. If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when `GetType` is called, the method returns `null`. `GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.","nodes":[{"content":"<ph id=\"ph1\">`GetType`</ph> only works on assemblies loaded from disk.","pos":[0,52],"source":"`GetType` only works on assemblies loaded from disk."},{"content":"If you call <ph id=\"ph1\">`GetType`</ph> to look up a type defined in a dynamic assembly defined using the <ph id=\"ph2\">&lt;xref:System.Reflection.Emit&gt;</ph> services, you might get inconsistent behavior.","pos":[53,217],"source":" If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior."},{"content":"The behavior depends on whether the dynamic assembly is persistent, that is, created using the <ph id=\"ph1\">`RunAndSave`</ph> or <ph id=\"ph2\">`Save`</ph> access modes of the <ph id=\"ph3\">&lt;xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName&gt;</ph> enumeration.","pos":[218,445],"source":" The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> enumeration."},{"content":"If the dynamic assembly is persistent and has been written to disk before <ph id=\"ph1\">`GetType`</ph> is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.","pos":[446,649],"source":" If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly."},{"content":"If the assembly has not been saved to disk when <ph id=\"ph1\">`GetType`</ph> is called, the method returns <ph id=\"ph2\">`null`</ph>.","pos":[650,745],"source":" If the assembly has not been saved to disk when `GetType` is called, the method returns `null`."},{"content":"<ph id=\"ph1\">`GetType`</ph> does not understand transient dynamic assemblies; therefore, calling <ph id=\"ph2\">`GetType`</ph> to retrieve a type in a transient dynamic assembly returns <ph id=\"ph3\">`null`</ph>.","pos":[746,901],"source":"`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`."}]},{"pos":[1622,1843],"content":"To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> event and call `GetType` before saving. Otherwise, you will get two copies of the assembly in memory.","nodes":[{"content":"To use <ph id=\"ph1\">`GetType`</ph> on a dynamic module, subscribe to the <ph id=\"ph2\">&lt;xref:System.AppDomain.AssemblyResolve?displayProperty=fullName&gt;</ph> event and call <ph id=\"ph3\">`GetType`</ph> before saving.","pos":[0,159],"source":"To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> event and call `GetType` before saving."},{"content":"Otherwise, you will get two copies of the assembly in memory.","pos":[160,221]}]},{"pos":[1850,2230],"content":"The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of `throwOnError`. For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.","nodes":[{"content":"The <ph id=\"ph1\">`throwOnError`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.","pos":[0,175],"source":"The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section."},{"content":"Some exceptions are thrown regardless of the value of <ph id=\"ph1\">`throwOnError`</ph>.","pos":[176,245],"source":" Some exceptions are thrown regardless of the value of `throwOnError`."},{"content":"For example, if the type is found but cannot be loaded, a <ph id=\"ph1\">&lt;xref:System.TypeLoadException&gt;</ph> is thrown even if <ph id=\"ph2\">`throwOnError`</ph> is <ph id=\"ph3\">`false`</ph>.","pos":[246,380],"source":" For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`."}]},{"pos":[2237,2352],"content":"The following table shows what members of a base class are returned by the <ph id=\"ph1\">`Get`</ph> methods when reflecting on a type.","source":"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type."},{"pos":[2359,2370],"content":"Member Type","nodes":[{"content":"Member Type","pos":[0,11]}]},{"pos":[2371,2377],"content":"Static","nodes":[{"content":"Static","pos":[0,6]}]},{"pos":[2378,2388],"content":"Non-Static","nodes":[{"content":"Non-Static","pos":[0,10]}]},{"pos":[2446,2457],"content":"Constructor","nodes":[{"content":"Constructor","pos":[0,11]}]},{"pos":[2458,2460],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2461,2463],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2468,2473],"content":"Field","nodes":[{"content":"Field","pos":[0,5]}]},{"pos":[2474,2476],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2477,2527],"content":"Yes. A field is always hide-by-name-and-signature.","nodes":[{"content":"Yes. A field is always hide-by-name-and-signature.","pos":[0,50],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A field is always hide-by-name-and-signature.","pos":[5,50]}]}]},{"pos":[2532,2537],"content":"Event","nodes":[{"content":"Event","pos":[0,5]}]},{"pos":[2538,2552],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[2553,2746],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[2751,2757],"content":"Method","nodes":[{"content":"Method","pos":[0,6]}]},{"pos":[2758,2760],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2761,2856],"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","nodes":[{"content":"Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[0,95],"nodes":[{"content":"Yes.","pos":[0,4]},{"content":"A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.","pos":[5,95]}]}]},{"pos":[2861,2872],"content":"Nested Type","nodes":[{"content":"Nested Type","pos":[0,11]}]},{"pos":[2873,2875],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2876,2878],"content":"No","nodes":[{"content":"No","pos":[0,2]}]},{"pos":[2883,2891],"content":"Property","nodes":[{"content":"Property","pos":[0,8]}]},{"pos":[2892,2906],"content":"Not applicable","nodes":[{"content":"Not applicable","pos":[0,14]}]},{"pos":[2907,3100],"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.","pos":[0,193],"nodes":[{"content":"The common type system rule is that the inheritance is the same as that of the methods that implement the property.","pos":[0,115]},{"content":"Reflection treats properties as hide-by-name-and-signature.","pos":[116,175]},{"content":"See note 2 below.","pos":[176,193]}]}]},{"pos":[3111,3316],"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.","pos":[0,205],"nodes":[{"content":"Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.","pos":[0,176]},{"content":"This is a binary comparison.","pos":[177,205]}]}]},{"pos":[3326,3642],"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[0,316],"nodes":[{"content":"For reflection, properties and events are hide-by-name-and-signature.","pos":[0,69]},{"content":"If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.","pos":[70,316]}]}]},{"pos":[3652,3709],"content":"Custom attributes are not part of the common type system.","nodes":[{"content":"Custom attributes are not part of the common type system.","pos":[0,57]}]},{"pos":[3716,3830],"content":"Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.","nodes":[{"content":"Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.","pos":[0,114]}]},{"pos":[3837,4020],"content":"`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <xref:System.Type.AssemblyQualifiedName%2A>.","nodes":[{"content":"<ph id=\"ph1\">`typeName`</ph> can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.","pos":[0,134],"source":"`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification."},{"content":"See <ph id=\"ph1\">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph>.","pos":[135,183],"source":" See <xref:System.Type.AssemblyQualifiedName%2A>."}]},{"pos":[4027,4375],"content":"If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.","nodes":[{"content":"If <ph id=\"ph1\">`typeName`</ph> includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.","pos":[0,152],"source":"If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order."},{"content":"If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.","pos":[153,275]},{"content":"If the assembly has a strong name, a complete assembly name is required.","pos":[276,348]}]},{"pos":[4382,4738],"content":"The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.","nodes":[{"content":"The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.","pos":[0,356],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property returns a fully qualified type name including nested types, the assembly name, and type arguments.","pos":[0,155],"source":"The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments."},{"content":"All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.","pos":[156,356]}]}]},{"pos":[4746,5494],"content":"[!NOTE]\n In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \"ProcessorArchitecture=msil\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method. You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly. See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.","leadings":["","> "],"nodes":[{"content":" In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \"ProcessorArchitecture=msil\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method. You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly. See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.","pos":[8,746],"nodes":[{"content":"In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.","pos":[1,144]},{"content":"For example, \"ProcessorArchitecture=msil\".","pos":[145,187]},{"content":"However, it is not included in the string returned by the <ph id=\"ph1\">&lt;xref:System.Type.AssemblyQualifiedName%2A&gt;</ph> property, for compatibility reasons.","pos":[188,326],"source":" However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons."},{"content":"You can also load types by creating an <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblyName&gt;</ph> object and passing it to an appropriate overload of the <ph id=\"ph2\">&lt;xref:System.Reflection.Assembly.Load%2A&gt;</ph> method.","pos":[327,509],"source":" You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method."},{"content":"You can then use the <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> method to load types from the assembly.","pos":[510,640],"source":" You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly."},{"content":"See also <ph id=\"ph1\">&lt;xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName&gt;</ph>.","pos":[641,738],"source":" See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>."}]}]},{"pos":[5501,5510],"content":"Delimiter","nodes":[{"content":"Delimiter","pos":[0,9]}]},{"pos":[5511,5518],"content":"Meaning","nodes":[{"content":"Meaning","pos":[0,7]}]},{"pos":[5557,5571],"content":"Backslash (\\\\)","nodes":[{"content":"Backslash (<ph id=\"ph1\">\\\\</ph>)","pos":[0,14],"source":"Backslash (\\\\)"}]},{"pos":[5572,5589],"content":"Escape character.","nodes":[{"content":"Escape character.","pos":[0,17]}]},{"pos":[5594,5606],"content":"Backtick (`)","nodes":[{"content":"Backtick (`)","pos":[0,12]}]},{"pos":[5607,5728],"content":"Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.","nodes":[{"content":"Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.","pos":[0,121]}]},{"pos":[5733,5746],"content":"Brackets ([])","nodes":[{"content":"Brackets ([])","pos":[0,13]}]},{"pos":[5747,5881],"content":"Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.","nodes":[{"content":"Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.","pos":[0,134]}]},{"pos":[5886,5895],"content":"Comma (,)","nodes":[{"content":"Comma (,)","pos":[0,9]}]},{"pos":[5896,5923],"content":"Precedes the Assembly name.","nodes":[{"content":"Precedes the Assembly name.","pos":[0,27]}]},{"pos":[5928,5938],"content":"Period (.)","nodes":[{"content":"Period (.)","pos":[0,10]}]},{"pos":[5939,5969],"content":"Denotes namespace identifiers.","nodes":[{"content":"Denotes namespace identifiers.","pos":[0,30]}]},{"pos":[5974,5987],"content":"Plus sign (+)","nodes":[{"content":"Plus sign (+)","pos":[0,13]}]},{"pos":[5988,6012],"content":"Precedes a nested class.","nodes":[{"content":"Precedes a nested class.","pos":[0,24]}]},{"pos":[6020,6091],"content":"For example, the fully qualified name for a class might look like this:","nodes":[{"content":"For example, the fully qualified name for a class might look like this:","pos":[0,71]}]},{"pos":[6180,6417],"content":"If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:","nodes":[{"content":"If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:","pos":[0,237],"nodes":[{"content":"If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (<ph id=\"ph1\">\\\\</ph>) to prevent it from being interpreted as a nesting separator.","pos":[0,196],"source":"If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\) to prevent it from being interpreted as a nesting separator."},{"content":"Reflection emits this string as follows:","pos":[197,237]}]}]},{"pos":[6508,6559],"content":"A \"++\" becomes \"\\\\+\\\\+\", and a \"\\\\\" becomes \"\\\\\\\\\".","nodes":[{"content":"A \"++\" becomes \"<ph id=\"ph1\">\\\\</ph><ph id=\"ph2\">+</ph><ph id=\"ph3\">\\\\</ph>+\", and a \"<ph id=\"ph4\">\\\\</ph>\" becomes \"<ph id=\"ph5\">\\\\</ph><ph id=\"ph6\">\\\\</ph>\".","pos":[0,51],"source":"A \"++\" becomes \"\\\\+\\\\+\", and a \"\\\\\" becomes \"\\\\\\\\\"."}]},{"pos":[6566,7072],"content":"This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.","nodes":[{"content":"This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.","pos":[0,506],"nodes":[{"content":"This qualified name can be persisted and later used to load the <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph>.","pos":[0,83],"source":"This qualified name can be persisted and later used to load the <xref:System.Type>."},{"content":"To search for and load a <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph>, use <ph id=\"ph2\">&lt;xref:System.Type.GetType%2A&gt;</ph> either with the type name only or with the assembly qualified type name.","pos":[84,235],"source":" To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> with the type name only will look for the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> in the caller's assembly and then in the System assembly.","pos":[236,384],"source":" <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.GetType%2A&gt;</ph> with the assembly qualified type name will look for the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> in any assembly.","pos":[385,506],"source":" <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly."}]}]},{"pos":[7079,7372],"content":"Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.","nodes":[{"content":"Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.","pos":[0,172]},{"content":"To retrieve the type name without these trailing characters, use <ph id=\"ph1\">`t.GetElementType().ToString()`</ph>, where <ph id=\"ph2\">`t`</ph> is the type.","pos":[173,293],"source":" To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type."}]},{"pos":[7379,7568],"content":"Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.","nodes":[{"content":"Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.","pos":[0,189],"nodes":[{"content":"Spaces are relevant in all type name components except the assembly name.","pos":[0,73]},{"content":"In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.","pos":[74,189]}]}]},{"pos":[7575,8075],"content":"The name of a generic type ends with a backtick (\\`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\\<T0, T1>` in Visual C#.","nodes":[{"content":"The name of a generic type ends with a backtick (<ph id=\"ph1\">\\`</ph>) followed by digits representing the number of generic type arguments.","pos":[0,122],"source":"The name of a generic type ends with a backtick (\\`) followed by digits representing the number of generic type arguments."},{"content":"The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.","pos":[123,298]},{"content":"For example, reflection returns the mangled names <ph id=\"ph1\">`Tuple`</ph>1<ph id=\"ph2\">` and `</ph>Tuple<ph id=\"ph3\">`2`</ph> from the generic methods <ph id=\"ph4\">`Tuple(Of T)`</ph> and <ph id=\"ph5\">`Tuple(Of T0, T1)`</ph> in Visual Basic, or <ph id=\"ph6\">`Tuple&lt;T&gt;`</ph> and Tuple<ph id=\"ph7\">`\\&lt;T0, T1&gt;`</ph> in Visual C#.","pos":[299,500],"source":" For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\\<T0, T1>` in Visual C#."}]},{"pos":[8082,8428],"content":"For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters. A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:","nodes":[{"content":"For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.","pos":[0,114]},{"content":"For example, a generic <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> has two type parameters.","pos":[115,211],"source":" For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters."},{"content":"A <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id=\"ph2\">`MyType`</ph> with keys of type <ph id=\"ph3\">&lt;xref:System.String&gt;</ph> might be represented as follows:","pos":[212,346],"source":" A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:"}]},{"pos":[8514,8935],"content":"To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:","nodes":[{"content":"To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.","pos":[0,119]},{"content":"Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.","pos":[120,253]},{"content":"For example, a <ph id=\"ph1\">&lt;xref:System.Collections.Generic.Dictionary%602&gt;</ph> of <ph id=\"ph2\">`MyType`</ph> from MyAssembly.dll, with keys of type <ph id=\"ph3\">&lt;xref:System.String&gt;</ph>, might be specified as follows:","pos":[254,421],"source":" For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:"}]},{"pos":[9051,9336],"content":"[!NOTE]\n An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.","leadings":["","> "],"nodes":[{"content":" An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.","pos":[8,283],"nodes":[{"content":"An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.","pos":[1,106]},{"content":"The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.","pos":[107,275]}]}]},{"pos":[9343,9502],"content":"Nullable types are a special case of generic types. For example, a nullable <xref:System.Int32> is represented by the string \"System.Nullable`1[System.Int32]\".","nodes":[{"content":"Nullable types are a special case of generic types. For example, a nullable <xref:System.Int32> is represented by the string \"System.Nullable`1[System.Int32]\".","pos":[0,159],"nodes":[{"content":"Nullable types are a special case of generic types.","pos":[0,51]},{"content":"For example, a nullable <ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph> is represented by the string \"System.Nullable`1[System.Int32]\".","pos":[52,159],"source":" For example, a nullable <xref:System.Int32> is represented by the string \"System.Nullable`1[System.Int32]\"."}]}]},{"pos":[9510,9798],"content":"[!NOTE]\n In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.","leadings":["","> "],"nodes":[{"content":" In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.","pos":[8,286],"nodes":[{"content":"In C#, C++, and Visual Basic you can also get nullable types using type operators.","pos":[1,83]},{"content":"For example, the nullable <ph id=\"ph1\">&lt;xref:System.Boolean&gt;</ph> type is returned by <ph id=\"ph2\">`typeof(Nullable&lt;bool&gt;)`</ph> in C#, by <ph id=\"ph3\">`Nullable&lt;Boolean&gt;::typeid`</ph> in C++, and by <ph id=\"ph4\">`GetType(Nullable(Of Boolean))`</ph> in Visual Basic.","pos":[84,278],"source":" For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic."}]}]},{"pos":[9805,9883],"content":"The following table shows the syntax you use with <ph id=\"ph1\">`GetType`</ph> for various types.","source":"The following table shows the syntax you use with `GetType` for various types."},{"pos":[9890,9896],"content":"To Get","nodes":[{"content":"To Get","pos":[0,6]}]},{"pos":[9897,9900],"content":"Use","nodes":[{"content":"Use","pos":[0,3]}]},{"pos":[9932,9962],"content":"A nullable <xref:System.Int32>","nodes":[{"content":"A nullable <ph id=\"ph1\">&lt;xref:System.Int32&gt;</ph>","pos":[0,30],"source":"A nullable <xref:System.Int32>"}]},{"pos":[9963,10012],"content":"<ph id=\"ph1\">`Type.GetType(\"System.Nullable`</ph>1[System.Int32]\")`","source":"`Type.GetType(\"System.Nullable`1[System.Int32]\")`"},{"pos":[10017,10049],"content":"An unmanaged pointer to <ph id=\"ph1\">`MyType`</ph>","source":"An unmanaged pointer to `MyType`"},{"pos":[10080,10125],"content":"An unmanaged pointer to a pointer to <ph id=\"ph1\">`MyType`</ph>","source":"An unmanaged pointer to a pointer to `MyType`"},{"pos":[10157,10199],"content":"A managed pointer or reference to <ph id=\"ph1\">`MyType`</ph>","source":"A managed pointer or reference to `MyType`"},{"pos":[10200,10290],"content":"`Type.GetType(\"MyType&\")`. Note that unlike pointers, references are limited to one level.","nodes":[{"content":"<ph id=\"ph1\">`Type.GetType(\"MyType&amp;\")`</ph>.","pos":[0,26],"source":"`Type.GetType(\"MyType&\")`."},{"content":"Note that unlike pointers, references are limited to one level.","pos":[27,90]}]},{"pos":[10295,10328],"content":"A parent class and a nested class","nodes":[{"content":"A parent class and a nested class","pos":[0,33]}]},{"pos":[10379,10426],"content":"A one-dimensional array with a lower bound of 0","nodes":[{"content":"A one-dimensional array with a lower bound of 0","pos":[0,47]}]},{"pos":[10459,10510],"content":"A one-dimensional array with an unknown lower bound","nodes":[{"content":"A one-dimensional array with an unknown lower bound","pos":[0,51]}]},{"pos":[10544,10566],"content":"An n-dimensional array","nodes":[{"content":"An n-dimensional array","pos":[0,22]}]},{"pos":[10567,10700],"content":"A comma (,) inside the brackets a total of n-1 times. For example, `System.Object[,,]` represents a three-dimensional `Object` array.","nodes":[{"content":"A comma (,) inside the brackets a total of n-1 times.","pos":[0,53]},{"content":"For example, <ph id=\"ph1\">`System.Object[,,]`</ph> represents a three-dimensional <ph id=\"ph2\">`Object`</ph> array.","pos":[54,133],"source":" For example, `System.Object[,,]` represents a three-dimensional `Object` array."}]},{"pos":[10705,10736],"content":"A two-dimensional array's array","nodes":[{"content":"A two-dimensional array's array","pos":[0,31]}]},{"pos":[10771,10832],"content":"A rectangular two-dimensional array with unknown lower bounds","nodes":[{"content":"A rectangular two-dimensional array with unknown lower bounds","pos":[0,61]}]},{"pos":[10866,10903],"content":"A generic type with one type argument","nodes":[{"content":"A generic type with one type argument","pos":[0,37]}]},{"pos":[10904,10945],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>1[MyType]\")`","source":"`Type.GetType(\"MyGenericType`1[MyType]\")`"},{"pos":[10950,10988],"content":"A generic type with two type arguments","nodes":[{"content":"A generic type with two type arguments","pos":[0,38]}]},{"pos":[10989,11042],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>2[MyType,AnotherType]\")`","source":"`Type.GetType(\"MyGenericType`2[MyType,AnotherType]\")`"},{"pos":[11047,11104],"content":"A generic type with two assembly-qualified type arguments","nodes":[{"content":"A generic type with two assembly-qualified type arguments","pos":[0,57]}]},{"pos":[11105,11189],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]\")`","source":"`Type.GetType(\"MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]\")`"},{"pos":[11194,11269],"content":"An assembly-qualified generic type with an assembly-qualified type argument","nodes":[{"content":"An assembly-qualified generic type with an assembly-qualified type argument","pos":[0,75]}]},{"pos":[11270,11346],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>1[[MyType,MyAssembly]],MyGenericTypeAssembly\")`","source":"`Type.GetType(\"MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly\")`"},{"pos":[11351,11427],"content":"A generic type whose type argument is a generic type with two type arguments","nodes":[{"content":"A generic type whose type argument is a generic type with two type arguments","pos":[0,76]}]},{"pos":[11428,11503],"content":"<ph id=\"ph1\">`Type.GetType(\"MyGenericType`</ph>1[AnotherGenericType<ph id=\"ph2\">`2[MyType,AnotherType]]\")`</ph>","source":"`Type.GetType(\"MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]\")`"}],"pos":[477596,489267],"yaml":true,"extradata":"MT"},{"content":"The assembly-qualified name of the type to get. See <xref href=\"System.Type.AssemblyQualifiedName\"></xref>. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.","nodes":[{"pos":[0,247],"content":"The assembly-qualified name of the type to get. See <xref href=\"System.Type.AssemblyQualifiedName\"></xref>. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.","nodes":[{"content":"The assembly-qualified name of the type to get.","pos":[0,47]},{"content":"See <ph id=\"ph1\">&lt;xref href=\"System.Type.AssemblyQualifiedName\"&gt;&lt;/xref&gt;</ph>.","pos":[48,107],"source":" See <xref href=\"System.Type.AssemblyQualifiedName\"></xref>."},{"content":"If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.","pos":[108,247]}]}],"pos":[489452,489700],"yaml":true},{"content":"`true` to throw an exception if the type cannot be found; `false` to return `null`.Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.","nodes":[{"pos":[0,199],"content":"`true` to throw an exception if the type cannot be found; `false` to return `null`.Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> to throw an exception if the type cannot be found; <ph id=\"ph2\">`false`</ph> to return <ph id=\"ph3\">`null`</ph>.Specifying <ph id=\"ph4\">`false`</ph> also suppresses some other exception conditions, but not all of them.","pos":[0,171],"source":"`true` to throw an exception if the type cannot be found; `false` to return `null`.Specifying `false` also suppresses some other exception conditions, but not all of them."},{"content":"See the Exceptions section.","pos":[172,199]}]}],"pos":[489769,489971],"yaml":true},{"content":"`true` to perform a case-insensitive search for <code>typeName</code>, `false` to perform a case-sensitive search for <code>typeName</code>.","nodes":[{"pos":[0,140],"content":"<ph id=\"ph1\">`true`</ph> to perform a case-insensitive search for <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept>, <ph id=\"ph3\">`false`</ph> to perform a case-sensitive search for <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph4\">typeName</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","source":"`true` to perform a case-insensitive search for <code>typeName</code>, `false` to perform a case-sensitive search for <code>typeName</code>."}],"pos":[490038,490181],"yaml":true},{"content":"The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.","nodes":[{"pos":[0,283],"content":"The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.","nodes":[{"content":"The type with the specified name.","pos":[0,33]},{"content":"If the type is not found, the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">throwOnError</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter specifies whether <ph id=\"ph2\">`null`</ph> is returned or an exception is thrown.","pos":[34,163],"source":" If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown."},{"content":"In some cases, an exception is thrown regardless of the value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">throwOnError</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","pos":[164,255],"source":" In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>."},{"content":"See the Exceptions section.","pos":[256,283]}]}],"pos":[490236,490520],"yaml":true},{"content":"<code>typeName</code> is `null`.","nodes":[{"pos":[0,32],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>typeName</code> is `null`."}],"pos":[490669,490702],"yaml":true},{"content":"A class initializer is invoked and throws an exception.","nodes":[{"pos":[0,55],"content":"A class initializer is invoked and throws an exception.","nodes":[{"content":"A class initializer is invoked and throws an exception.","pos":[0,55]}]}],"pos":[490834,490890],"yaml":true},{"content":"<code>throwOnError</code> is `true` and the type is not found.  \n  \n -or-  \n  \n <code>throwOnError</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab.  \n  \n -or-  \n  \n <code>throwOnError</code> is `true` and <code>typeName</code> is an empty string.  \n  \n -or-  \n  \n <code>throwOnError</code> is `true` and <code>typeName</code> represents an array type with an invalid size.  \n  \n -or-  \n  \n <code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref>.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and the type is not found.","source":"<code>throwOnError</code> is `true` and the type is not found."},{"pos":[69,73],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[80,195],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid characters, such as an embedded tab.","source":"<code>throwOnError</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab."},{"pos":[202,206],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[213,294],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> is an empty string.","source":"<code>throwOnError</code> is `true` and <code>typeName</code> is an empty string."},{"pos":[301,305],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[312,420],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array type with an invalid size.","source":"<code>throwOnError</code> is `true` and <code>typeName</code> represents an array type with an invalid size."},{"pos":[427,431],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[438,526],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array of <ph id=\"ph2\">&lt;xref href=\"System.TypedReference\"&gt;&lt;/xref&gt;</ph>.","source":"<code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref>."}],"pos":[490984,491531],"yaml":true},{"content":"<code>throwOnError</code> is `true` and <code>typeName</code> contains invalid syntax. For example, \"MyType[,*,]\".  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\"System.Void\"></xref> as one of its type arguments.  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.","nodes":[{"pos":[0,114],"content":"<code>throwOnError</code> is `true` and <code>typeName</code> contains invalid syntax. For example, \"MyType[,*,]\".","nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid syntax.","pos":[0,86],"source":"<code>throwOnError</code> is `true` and <code>typeName</code> contains invalid syntax."},{"content":"For example, \"MyType[,*,]\".","pos":[87,114]}]},{"pos":[121,125],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[132,286],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has a pointer type, a <ph id=\"ph2\">`ByRef`</ph> type, or <ph id=\"ph3\">&lt;xref href=\"System.Void\"&gt;&lt;/xref&gt;</ph> as one of its type arguments.","source":"<code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\"System.Void\"></xref> as one of its type arguments."},{"pos":[293,297],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[304,399],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has an incorrect number of type arguments.","source":"<code>typeName</code> represents a generic type that has an incorrect number of type arguments."},{"pos":[406,410],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[417,566],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.","source":"<code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter."}],"pos":[491625,492210],"yaml":true},{"content":"<code>throwOnError</code> is `true` and the assembly or one of its dependencies was not found.","nodes":[{"pos":[0,94],"content":"<ph id=\"ph1\">&lt;code&gt;throwOnError&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and the assembly or one of its dependencies was not found.","source":"<code>throwOnError</code> is `true` and the assembly or one of its dependencies was not found."}],"pos":[492318,492413],"yaml":true},{"content":"The assembly or one of its dependencies was found, but could not be loaded.","nodes":[{"pos":[0,75],"content":"The assembly or one of its dependencies was found, but could not be loaded.","nodes":[{"content":"The assembly or one of its dependencies was found, but could not be loaded.","pos":[0,75]}]}],"pos":[492513,492589],"yaml":true},{"content":"The assembly or one of its dependencies is not valid.  \n  \n -or-  \n  \n Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.","nodes":[{"pos":[0,53],"content":"The assembly or one of its dependencies is not valid.","nodes":[{"content":"The assembly or one of its dependencies is not valid.","pos":[0,53]}]},{"pos":[60,64],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[71,195],"content":"Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.","nodes":[{"content":"Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.","pos":[0,124]}]}],"pos":[492695,492897],"yaml":true},{"content":"Gets the types of the objects in the specified array.","nodes":[{"pos":[0,53],"content":"Gets the types of the objects in the specified array.","nodes":[{"content":"Gets the types of the objects in the specified array.","pos":[0,53]}]}],"pos":[494236,494290],"yaml":true},{"content":"An array of objects whose types to determine.","nodes":[{"pos":[0,45],"content":"An array of objects whose types to determine.","nodes":[{"content":"An array of objects whose types to determine.","pos":[0,45]}]}],"pos":[494986,495032],"yaml":true},{"content":"An array of <xref href=\"System.Type\"></xref> objects representing the types of the corresponding elements in <code>args</code>.","nodes":[{"pos":[0,127],"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects representing the types of the corresponding elements in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">args</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"An array of <xref href=\"System.Type\"></xref> objects representing the types of the corresponding elements in <code>args</code>."}],"pos":[495089,495217],"yaml":true},{"content":"<code>args</code> is `null`.  \n  \n -or-  \n  \n One or more of the elements in <code>args</code> is `null`.","nodes":[{"pos":[0,28],"content":"<ph id=\"ph1\">&lt;code&gt;args&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>args</code> is `null`."},{"pos":[35,39],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[46,105],"content":"One or more of the elements in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">args</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"One or more of the elements in <code>args</code> is `null`."}],"pos":[495371,495483],"yaml":true},{"content":"The class initializers are invoked and at least one throws an exception.","nodes":[{"pos":[0,72],"content":"The class initializers are invoked and at least one throws an exception.","nodes":[{"content":"The class initializers are invoked and at least one throws an exception.","pos":[0,72]}]}],"pos":[495615,495688],"yaml":true},{"content":"Gets the underlying type code of the specified <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,80],"content":"Gets the underlying type code of the specified <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Gets the underlying type code of the specified <xref href=\"System.Type\"></xref>."}],"pos":[496773,496854],"yaml":true},{"content":"When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.","nodes":[{"pos":[0,148],"content":"When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.","nodes":[{"content":"When you inherit from <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph>, you can change the behavior of this method by overriding the <ph id=\"ph2\">&lt;xref:System.Type.GetTypeCodeImpl%2A&gt;</ph> method.","pos":[0,148],"source":"When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method."}]}],"pos":[496865,497014],"yaml":true,"extradata":"MT"},{"content":"The type whose underlying type code to get.","nodes":[{"pos":[0,43],"content":"The type whose underlying type code to get.","nodes":[{"content":"The type whose underlying type code to get.","pos":[0,43]}]}],"pos":[497832,497876],"yaml":true},{"content":"The code of the underlying type, or <xref href=\"System.TypeCode.Empty\"></xref> if <code>type</code> is `null`.","nodes":[{"pos":[0,110],"content":"The code of the underlying type, or <ph id=\"ph1\">&lt;xref href=\"System.TypeCode.Empty\"&gt;&lt;/xref&gt;</ph> if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">type</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph3\">`null`</ph>.","source":"The code of the underlying type, or <xref href=\"System.TypeCode.Empty\"></xref> if <code>type</code> is `null`."}],"pos":[497935,498046],"yaml":true},{"content":"Returns the underlying type code of this <xref href=\"System.Type\"></xref> instance.","nodes":[{"pos":[0,83],"content":"Returns the underlying type code of this <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> instance.","source":"Returns the underlying type code of this <xref href=\"System.Type\"></xref> instance."}],"pos":[499302,499386],"yaml":true},{"content":"This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method. When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.","nodes":[{"pos":[0,294],"content":"This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method. When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.","nodes":[{"content":"This method provides the implementation for the <ph id=\"ph1\">`static`</ph> (in C#) or <ph id=\"ph2\">`Shared`</ph> (in Visual Basic) <ph id=\"ph3\">&lt;xref:System.Type.GetTypeCode%28System.Type%29&gt;</ph> method.","pos":[0,150],"source":"This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method."},{"content":"When you inherit from <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph>, you can override this method to provide your own implementation of <ph id=\"ph2\">&lt;xref:System.Type.GetTypeCode%2A&gt;</ph>.","pos":[151,294],"source":" When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>."}]}],"pos":[499397,499692],"yaml":true,"extradata":"MT"},{"content":"The type code of the underlying type.","nodes":[{"pos":[0,37],"content":"The type code of the underlying type.","nodes":[{"content":"The type code of the underlying type.","pos":[0,37]}]}],"pos":[499840,499878],"yaml":true},{"content":"Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.","nodes":[{"pos":[0,179],"content":"Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.","nodes":[{"content":"Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.","pos":[0,179]}]}],"pos":[501189,501369],"yaml":true},{"content":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.  \n  \n> [!TIP]\n>  You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.  \n  \n Instantiating an unmanaged COM object from its CLSID is a two-step process:  \n  \n1.  Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.  \n  \n2.  Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object.  \n  \n Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.","nodes":[{"pos":[0,432],"content":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.","nodes":[{"content":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.","pos":[0,432],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).","pos":[0,183],"source":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID)."},{"content":"The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry.","pos":[185,284]},{"content":"You can retrieve the value of the <ph id=\"ph1\">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.","pos":[285,432],"source":" You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object."}]}]},{"pos":[440,599],"content":"[!TIP]\n You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.","leadings":["","> "],"nodes":[{"content":"You can call the <ph id=\"ph1\">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.","pos":[8,157],"source":" You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know."}]},{"pos":[606,681],"content":"Instantiating an unmanaged COM object from its CLSID is a two-step process:","nodes":[{"content":"Instantiating an unmanaged COM object from its CLSID is a two-step process:","pos":[0,75]}]},{"pos":[691,848],"content":"Get a <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object that represents the <ph id=\"ph2\">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id=\"ph3\">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.","source":"Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method."},{"pos":[858,985],"content":"Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName&gt;</ph> method to instantiate the COM object.","pos":[0,127],"source":"Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object."}]},{"pos":[992,1149],"content":"Exceptions such as <ph id=\"ph1\">&lt;xref:System.OutOfMemoryException&gt;</ph> will be thrown when specifying <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`throwOnError`</ph>, but it will not fail for unregistered CLSIDs.","source":"Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs."}],"pos":[501380,502544],"yaml":true,"extradata":"MT"},{"content":"The CLSID of the type to get.","nodes":[{"pos":[0,29],"content":"The CLSID of the type to get.","nodes":[{"content":"The CLSID of the type to get.","pos":[0,29]}]}],"pos":[503620,503650],"yaml":true},{"content":"The server from which to load the type. If the server name is `null`, this method automatically reverts to the local machine.","nodes":[{"pos":[0,125],"content":"The server from which to load the type. If the server name is `null`, this method automatically reverts to the local machine.","nodes":[{"content":"The server from which to load the type.","pos":[0,39]},{"content":"If the server name is <ph id=\"ph1\">`null`</ph>, this method automatically reverts to the local machine.","pos":[40,125],"source":" If the server name is `null`, this method automatically reverts to the local machine."}]}],"pos":[503712,503838],"yaml":true},{"content":"`true` to throw any exception that occurs.  \n  \n -or-  \n  \n `false` to ignore any exception that occurs.","nodes":[{"pos":[0,42],"content":"<ph id=\"ph1\">`true`</ph> to throw any exception that occurs.","source":"`true` to throw any exception that occurs."},{"pos":[49,53],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[60,104],"content":"<ph id=\"ph1\">`false`</ph> to ignore any exception that occurs.","source":"`false` to ignore any exception that occurs."}],"pos":[503907,504018],"yaml":true},{"content":"`System.__ComObject` regardless of whether the CLSID is valid.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">`System.__ComObject`</ph> regardless of whether the CLSID is valid.","source":"`System.__ComObject` regardless of whether the CLSID is valid."}],"pos":[504073,504138],"yaml":true},{"content":"Gets the type associated with the specified class identifier (CLSID) from the specified server.","nodes":[{"pos":[0,95],"content":"Gets the type associated with the specified class identifier (CLSID) from the specified server.","nodes":[{"content":"Gets the type associated with the specified class identifier (CLSID) from the specified server.","pos":[0,95]}]}],"pos":[505395,505491],"yaml":true},{"content":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.  \n  \n> [!TIP]\n>  You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.  \n  \n Instantiating an unmanaged COM object from its CLSID is a two-step process:  \n  \n1.  Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.  \n  \n2.  Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object.","nodes":[{"pos":[0,432],"content":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.","nodes":[{"content":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.","pos":[0,432],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).","pos":[0,183],"source":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID)."},{"content":"The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry.","pos":[185,284]},{"content":"You can retrieve the value of the <ph id=\"ph1\">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.","pos":[285,432],"source":" You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object."}]}]},{"pos":[440,599],"content":"[!TIP]\n You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.","leadings":["","> "],"nodes":[{"content":"You can call the <ph id=\"ph1\">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.","pos":[8,157],"source":" You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know."}]},{"pos":[606,681],"content":"Instantiating an unmanaged COM object from its CLSID is a two-step process:","nodes":[{"content":"Instantiating an unmanaged COM object from its CLSID is a two-step process:","pos":[0,75]}]},{"pos":[691,848],"content":"Get a <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object that represents the <ph id=\"ph2\">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id=\"ph3\">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.","source":"Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method."},{"pos":[858,985],"content":"Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName&gt;</ph> method to instantiate the COM object.","pos":[0,127],"source":"Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object."}]}],"pos":[505502,506500],"yaml":true,"extradata":"MT"},{"content":"The CLSID of the type to get.","nodes":[{"pos":[0,29],"content":"The CLSID of the type to get.","nodes":[{"content":"The CLSID of the type to get.","pos":[0,29]}]}],"pos":[507491,507521],"yaml":true},{"content":"The server from which to load the type. If the server name is `null`, this method automatically reverts to the local machine.","nodes":[{"pos":[0,125],"content":"The server from which to load the type. If the server name is `null`, this method automatically reverts to the local machine.","nodes":[{"content":"The server from which to load the type.","pos":[0,39]},{"content":"If the server name is <ph id=\"ph1\">`null`</ph>, this method automatically reverts to the local machine.","pos":[40,125],"source":" If the server name is `null`, this method automatically reverts to the local machine."}]}],"pos":[507583,507709],"yaml":true},{"content":"`System.__ComObject` regardless of whether the CLSID is valid.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">`System.__ComObject`</ph> regardless of whether the CLSID is valid.","source":"`System.__ComObject` regardless of whether the CLSID is valid."}],"pos":[507764,507829],"yaml":true},{"content":"Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.","nodes":[{"pos":[0,153],"content":"Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.","nodes":[{"content":"Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.","pos":[0,153]}]}],"pos":[509092,509246],"yaml":true},{"content":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.  \n  \n> [!TIP]\n>  You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.  \n  \n Instantiating an unmanaged COM object from its CLSID is a two-step process:  \n  \n1.  Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.  \n  \n2.  Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object.  \n  \n See the example for an illustration.  \n  \n Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.","nodes":[{"pos":[0,432],"content":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.","nodes":[{"content":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.","pos":[0,432],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).","pos":[0,183],"source":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID)."},{"content":"The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry.","pos":[185,284]},{"content":"You can retrieve the value of the <ph id=\"ph1\">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.","pos":[285,432],"source":" You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object."}]}]},{"pos":[440,599],"content":"[!TIP]\n You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.","leadings":["","> "],"nodes":[{"content":"You can call the <ph id=\"ph1\">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.","pos":[8,157],"source":" You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know."}]},{"pos":[606,681],"content":"Instantiating an unmanaged COM object from its CLSID is a two-step process:","nodes":[{"content":"Instantiating an unmanaged COM object from its CLSID is a two-step process:","pos":[0,75]}]},{"pos":[691,848],"content":"Get a <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object that represents the <ph id=\"ph2\">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id=\"ph3\">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.","source":"Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method."},{"pos":[858,985],"content":"Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName&gt;</ph> method to instantiate the COM object.","pos":[0,127],"source":"Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object."}]},{"pos":[992,1028],"content":"See the example for an illustration.","nodes":[{"content":"See the example for an illustration.","pos":[0,36]}]},{"pos":[1035,1192],"content":"Exceptions such as <ph id=\"ph1\">&lt;xref:System.OutOfMemoryException&gt;</ph> will be thrown when specifying <ph id=\"ph2\">`true`</ph> for <ph id=\"ph3\">`throwOnError`</ph>, but it will not fail for unregistered CLSIDs.","source":"Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs."}],"pos":[509257,510466],"yaml":true,"extradata":"MT"},{"content":"The CLSID of the type to get.","nodes":[{"pos":[0,29],"content":"The CLSID of the type to get.","nodes":[{"content":"The CLSID of the type to get.","pos":[0,29]}]}],"pos":[511476,511506],"yaml":true},{"content":"`true` to throw any exception that occurs.  \n  \n -or-  \n  \n `false` to ignore any exception that occurs.","nodes":[{"pos":[0,42],"content":"<ph id=\"ph1\">`true`</ph> to throw any exception that occurs.","source":"`true` to throw any exception that occurs."},{"pos":[49,53],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[60,104],"content":"<ph id=\"ph1\">`false`</ph> to ignore any exception that occurs.","source":"`false` to ignore any exception that occurs."}],"pos":[511575,511686],"yaml":true},{"content":"`System.__ComObject` regardless of whether the CLSID is valid.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">`System.__ComObject`</ph> regardless of whether the CLSID is valid.","source":"`System.__ComObject` regardless of whether the CLSID is valid."}],"pos":[511741,511806],"yaml":true},{"content":"Gets the type associated with the specified class identifier (CLSID).","nodes":[{"pos":[0,69],"content":"Gets the type associated with the specified class identifier (CLSID).","nodes":[{"content":"Gets the type associated with the specified class identifier (CLSID).","pos":[0,69]}]}],"pos":[512997,513067],"yaml":true},{"content":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.  \n  \n> [!TIP]\n>  You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.  \n  \n Instantiating an unmanaged COM object from its CLSID is a two-step process:  \n  \n1.  Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.  \n  \n2.  Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object.  \n  \n See the example for an illustration.  \n  \n The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument. Note that no exception is thrown if `clsid` is not found in the registry.","nodes":[{"pos":[0,432],"content":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.","nodes":[{"content":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.","pos":[0,432],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).","pos":[0,183],"source":"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID)."},{"content":"The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\CLSID key of the registry.","pos":[185,284]},{"content":"You can retrieve the value of the <ph id=\"ph1\">&lt;xref:System.Type.IsCOMObject%2A&gt;</ph> property to determine whether the type returned by this method is a COM object.","pos":[285,432],"source":" You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object."}]}]},{"pos":[440,599],"content":"[!TIP]\n You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.","leadings":["","> "],"nodes":[{"content":"You can call the <ph id=\"ph1\">&lt;xref:System.Type.GetTypeFromProgID%2A&gt;</ph> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.","pos":[8,157],"source":" You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know."}]},{"pos":[606,681],"content":"Instantiating an unmanaged COM object from its CLSID is a two-step process:","nodes":[{"content":"Instantiating an unmanaged COM object from its CLSID is a two-step process:","pos":[0,75]}]},{"pos":[691,847],"content":"Get a <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object that represents the<ph id=\"ph2\">`__ComObject`</ph> that corresponds to the CLSID by calling the <ph id=\"ph3\">&lt;xref:System.Type.GetTypeFromCLSID%2A&gt;</ph> method.","source":"Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method."},{"pos":[857,984],"content":"Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object.","nodes":[{"content":"Call the <ph id=\"ph1\">&lt;xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName&gt;</ph> method to instantiate the COM object.","pos":[0,127],"source":"Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object."}]},{"pos":[991,1027],"content":"See the example for an illustration.","nodes":[{"content":"See the example for an illustration.","pos":[0,36]}]},{"pos":[1034,1288],"content":"The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument. Note that no exception is thrown if `clsid` is not found in the registry.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.GetTypeFromCLSID%28System.Guid%29&gt;</ph> overload ignores any exception that may occur when instantiating a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object based on the <ph id=\"ph3\">`clsid`</ph> argument.","pos":[0,180],"source":"The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument."},{"content":"Note that no exception is thrown if <ph id=\"ph1\">`clsid`</ph> is not found in the registry.","pos":[181,254],"source":" Note that no exception is thrown if `clsid` is not found in the registry."}]}],"pos":[513078,514383],"yaml":true,"extradata":"MT"},{"content":"The CLSID of the type to get.","nodes":[{"pos":[0,29],"content":"The CLSID of the type to get.","nodes":[{"content":"The CLSID of the type to get.","pos":[0,29]}]}],"pos":[515302,515332],"yaml":true},{"content":"`System.__ComObject` regardless of whether the CLSID is valid.","nodes":[{"pos":[0,62],"content":"<ph id=\"ph1\">`System.__ComObject`</ph> regardless of whether the CLSID is valid.","source":"`System.__ComObject` regardless of whether the CLSID is valid."}],"pos":[515387,515452],"yaml":true},{"content":"Gets the type referenced by the specified type handle.","nodes":[{"pos":[0,54],"content":"Gets the type referenced by the specified type handle.","nodes":[{"content":"Gets the type referenced by the specified type handle.","pos":[0,54]}]}],"pos":[516727,516782],"yaml":true},{"content":"The handles are valid only in the application domain in which they were obtained.","nodes":[{"pos":[0,81],"content":"The handles are valid only in the application domain in which they were obtained.","nodes":[{"content":"The handles are valid only in the application domain in which they were obtained.","pos":[0,81]}]}],"pos":[516793,516875],"yaml":true,"extradata":"MT"},{"content":"The object that refers to the type.","nodes":[{"pos":[0,35],"content":"The object that refers to the type.","nodes":[{"content":"The object that refers to the type.","pos":[0,35]}]}],"pos":[517704,517740],"yaml":true},{"content":"The type referenced by the specified <xref href=\"System.RuntimeTypeHandle\"></xref>, or `null` if the <xref href=\"System.RuntimeTypeHandle.Value\"></xref> property of <code>handle</code> is `null`.","nodes":[{"pos":[0,195],"content":"The type referenced by the specified <ph id=\"ph1\">&lt;xref href=\"System.RuntimeTypeHandle\"&gt;&lt;/xref&gt;</ph>, or <ph id=\"ph2\">`null`</ph> if the <ph id=\"ph3\">&lt;xref href=\"System.RuntimeTypeHandle.Value\"&gt;&lt;/xref&gt;</ph> property of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph4\">handle</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph5\">`null`</ph>.","source":"The type referenced by the specified <xref href=\"System.RuntimeTypeHandle\"></xref>, or `null` if the <xref href=\"System.RuntimeTypeHandle.Value\"></xref> property of <code>handle</code> is `null`."}],"pos":[517795,517991],"yaml":true},{"content":"A class initializer is invoked and throws an exception.","nodes":[{"pos":[0,55],"content":"A class initializer is invoked and throws an exception.","nodes":[{"content":"A class initializer is invoked and throws an exception.","pos":[0,55]}]}],"pos":[518180,518236],"yaml":true},{"content":"Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,166],"content":"Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <xref href=\"System.Type\"></xref>."}],"pos":[519713,519880],"yaml":true},{"content":"This method is provided for COM support. ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.","nodes":[{"pos":[0,156],"content":"This method is provided for COM support. ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.","nodes":[{"content":"This method is provided for COM support. ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.","pos":[0,156],"nodes":[{"content":"This method is provided for COM support.","pos":[0,40]},{"content":"ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.","pos":[41,156]}]}]}],"pos":[519891,520048],"yaml":true,"extradata":"MT"},{"content":"The ProgID of the type to get.","nodes":[{"pos":[0,30],"content":"The ProgID of the type to get.","nodes":[{"content":"The ProgID of the type to get.","pos":[0,30]}]}],"pos":[520254,520285],"yaml":true},{"content":"The type associated with the specified ProgID, if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, `null`.","nodes":[{"pos":[0,155],"content":"The type associated with the specified ProgID, if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">progID</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a valid entry in the registry and a type is associated with it; otherwise, <ph id=\"ph2\">`null`</ph>.","source":"The type associated with the specified ProgID, if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, `null`."}],"pos":[520340,520496],"yaml":true},{"content":"<code>progID</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;progID&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>progID</code> is `null`."}],"pos":[520647,520678],"yaml":true},{"content":"Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.","nodes":[{"pos":[0,156],"content":"Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.","nodes":[{"content":"Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.","pos":[0,156]}]}],"pos":[521949,522106],"yaml":true},{"content":"This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.","nodes":[{"pos":[0,156],"content":"This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.","nodes":[{"content":"This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.","pos":[0,156],"nodes":[{"content":"This method is provided for COM support.","pos":[0,40]},{"content":"Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.","pos":[41,156]}]}]}],"pos":[522117,522274],"yaml":true,"extradata":"MT"},{"content":"The ProgID of the type to get.","nodes":[{"pos":[0,30],"content":"The ProgID of the type to get.","nodes":[{"content":"The ProgID of the type to get.","pos":[0,30]}]}],"pos":[523181,523212],"yaml":true},{"content":"`true` to throw any exception that occurs.  \n  \n -or-  \n  \n `false` to ignore any exception that occurs.","nodes":[{"pos":[0,42],"content":"<ph id=\"ph1\">`true`</ph> to throw any exception that occurs.","source":"`true` to throw any exception that occurs."},{"pos":[49,53],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[60,104],"content":"<ph id=\"ph1\">`false`</ph> to ignore any exception that occurs.","source":"`false` to ignore any exception that occurs."}],"pos":[523281,523392],"yaml":true},{"content":"The type associated with the specified program identifier (ProgID), if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, `null`.","nodes":[{"pos":[0,176],"content":"The type associated with the specified program identifier (ProgID), if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">progID</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a valid entry in the registry and a type is associated with it; otherwise, <ph id=\"ph2\">`null`</ph>.","source":"The type associated with the specified program identifier (ProgID), if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, `null`."}],"pos":[523447,523624],"yaml":true},{"content":"<code>progID</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;progID&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>progID</code> is `null`."}],"pos":[523775,523806],"yaml":true},{"content":"The specified ProgID is not registered.","nodes":[{"pos":[0,39],"content":"The specified ProgID is not registered.","nodes":[{"content":"The specified ProgID is not registered.","pos":[0,39]}]}],"pos":[523938,523978],"yaml":true},{"content":"Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.","nodes":[{"pos":[0,164],"content":"Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.","nodes":[{"content":"Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.","pos":[0,164]}]}],"pos":[525243,525408],"yaml":true},{"content":"This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.","nodes":[{"pos":[0,156],"content":"This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.","nodes":[{"content":"This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.","pos":[0,156],"nodes":[{"content":"This method is provided for COM support.","pos":[0,40]},{"content":"Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.","pos":[41,156]}]}]}],"pos":[525419,525576],"yaml":true,"extradata":"MT"},{"content":"The progID of the type to get.","nodes":[{"pos":[0,30],"content":"The progID of the type to get.","nodes":[{"content":"The progID of the type to get.","pos":[0,30]}]}],"pos":[526451,526482],"yaml":true},{"content":"The server from which to load the type. If the server name is `null`, this method automatically reverts to the local machine.","nodes":[{"pos":[0,125],"content":"The server from which to load the type. If the server name is `null`, this method automatically reverts to the local machine.","nodes":[{"content":"The server from which to load the type.","pos":[0,39]},{"content":"If the server name is <ph id=\"ph1\">`null`</ph>, this method automatically reverts to the local machine.","pos":[40,125],"source":" If the server name is `null`, this method automatically reverts to the local machine."}]}],"pos":[526544,526670],"yaml":true},{"content":"The type associated with the specified program identifier (progID), if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, `null`.","nodes":[{"pos":[0,176],"content":"The type associated with the specified program identifier (progID), if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">progID</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a valid entry in the registry and a type is associated with it; otherwise, <ph id=\"ph2\">`null`</ph>.","source":"The type associated with the specified program identifier (progID), if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, `null`."}],"pos":[526725,526902],"yaml":true},{"content":"<code>prodID</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;prodID&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>prodID</code> is `null`."}],"pos":[527053,527084],"yaml":true},{"content":"Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.","nodes":[{"pos":[0,182],"content":"Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.","nodes":[{"content":"Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.","pos":[0,182]}]}],"pos":[528421,528604],"yaml":true},{"content":"This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.","nodes":[{"pos":[0,156],"content":"This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.","nodes":[{"content":"This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.","pos":[0,156],"nodes":[{"content":"This method is provided for COM support.","pos":[0,40]},{"content":"Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.","pos":[41,156]}]}]}],"pos":[528615,528772],"yaml":true,"extradata":"MT"},{"content":"The progID of the <xref href=\"System.Type\"></xref> to get.","nodes":[{"pos":[0,58],"content":"The progID of the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> to get.","source":"The progID of the <xref href=\"System.Type\"></xref> to get."}],"pos":[529684,529743],"yaml":true},{"content":"The server from which to load the type. If the server name is `null`, this method automatically reverts to the local machine.","nodes":[{"pos":[0,125],"content":"The server from which to load the type. If the server name is `null`, this method automatically reverts to the local machine.","nodes":[{"content":"The server from which to load the type.","pos":[0,39]},{"content":"If the server name is <ph id=\"ph1\">`null`</ph>, this method automatically reverts to the local machine.","pos":[40,125],"source":" If the server name is `null`, this method automatically reverts to the local machine."}]}],"pos":[529805,529931],"yaml":true},{"content":"`true` to throw any exception that occurs.  \n  \n -or-  \n  \n `false` to ignore any exception that occurs.","nodes":[{"pos":[0,42],"content":"<ph id=\"ph1\">`true`</ph> to throw any exception that occurs.","source":"`true` to throw any exception that occurs."},{"pos":[49,53],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[60,104],"content":"<ph id=\"ph1\">`false`</ph> to ignore any exception that occurs.","source":"`false` to ignore any exception that occurs."}],"pos":[530000,530111],"yaml":true},{"content":"The type associated with the specified program identifier (progID), if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, `null`.","nodes":[{"pos":[0,176],"content":"The type associated with the specified program identifier (progID), if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">progID</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a valid entry in the registry and a type is associated with it; otherwise, <ph id=\"ph2\">`null`</ph>.","source":"The type associated with the specified program identifier (progID), if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, `null`."}],"pos":[530166,530343],"yaml":true},{"content":"<code>progID</code> is `null`.","nodes":[{"pos":[0,30],"content":"<ph id=\"ph1\">&lt;code&gt;progID&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>progID</code> is `null`."}],"pos":[530494,530525],"yaml":true},{"content":"The specified progID is not registered.","nodes":[{"pos":[0,39],"content":"The specified progID is not registered.","nodes":[{"content":"The specified progID is not registered.","pos":[0,39]}]}],"pos":[530657,530697],"yaml":true},{"content":"Gets the handle for the <xref href=\"System.Type\"></xref> of a specified object.","nodes":[{"pos":[0,79],"content":"Gets the handle for the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> of a specified object.","source":"Gets the handle for the <xref href=\"System.Type\"></xref> of a specified object."}],"pos":[531872,531952],"yaml":true},{"content":"The handles are valid only in the application domain in which they were obtained.","nodes":[{"pos":[0,81],"content":"The handles are valid only in the application domain in which they were obtained.","nodes":[{"content":"The handles are valid only in the application domain in which they were obtained.","pos":[0,81]}]}],"pos":[531963,532045],"yaml":true,"extradata":"MT"},{"content":"The object for which to get the type handle.","nodes":[{"pos":[0,44],"content":"The object for which to get the type handle.","nodes":[{"content":"The object for which to get the type handle.","pos":[0,44]}]}],"pos":[532727,532772],"yaml":true},{"content":"The handle for the <xref href=\"System.Type\"></xref> of the specified <xref href=\"System.Object\"></xref>.","nodes":[{"pos":[0,104],"content":"The handle for the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> of the specified <ph id=\"ph2\">&lt;xref href=\"System.Object\"&gt;&lt;/xref&gt;</ph>.","source":"The handle for the <xref href=\"System.Type\"></xref> of the specified <xref href=\"System.Object\"></xref>."}],"pos":[532840,532945],"yaml":true},{"content":"<code>o</code> is `null`.","nodes":[{"pos":[0,25],"content":"<ph id=\"ph1\">&lt;code&gt;o&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>o</code> is `null`."}],"pos":[533100,533126],"yaml":true},{"content":"Gets the GUID associated with the <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,67],"content":"Gets the GUID associated with the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Gets the GUID associated with the <xref href=\"System.Type\"></xref>."}],"pos":[534114,534182],"yaml":true},{"content":"A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.","nodes":[{"pos":[0,105],"content":"A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.","nodes":[{"content":"A GUID is associated with a type using the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.GuidAttribute&gt;</ph> attribute.","pos":[0,105],"source":"A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute."}]}],"pos":[534193,534299],"yaml":true,"extradata":"MT"},{"content":"The GUID associated with the <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,62],"content":"The GUID associated with the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"The GUID associated with the <xref href=\"System.Type\"></xref>."}],"pos":[534950,535013],"yaml":true},{"content":"Gets a value indicating whether the current <xref href=\"System.Type\"></xref> encompasses or refers to another type; that is, whether the current <xref href=\"System.Type\"></xref> is an array, a pointer, or is passed by reference.","nodes":[{"pos":[0,228],"content":"Gets a value indicating whether the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is an array, a pointer, or is passed by reference.","source":"Gets a value indicating whether the current <xref href=\"System.Type\"></xref> encompasses or refers to another type; that is, whether the current <xref href=\"System.Type\"></xref> is an array, a pointer, or is passed by reference."}],"pos":[536108,536337],"yaml":true},{"content":"For example, Type.GetType(\"Int32[]\").HasElementType returns `true`, but Type.GetType(\"Int32\").HasElementType returns `false`. HasElementType also returns `true` for \"Int32*\" and \"Int32&\".  \n  \n If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.","nodes":[{"pos":[0,187],"content":"For example, Type.GetType(\"Int32[]\").HasElementType returns `true`, but Type.GetType(\"Int32\").HasElementType returns `false`. HasElementType also returns `true` for \"Int32*\" and \"Int32&\".","nodes":[{"content":"For example, Type.GetType(\"Int32[]\").HasElementType returns <ph id=\"ph1\">`true`</ph>, but Type.GetType(\"Int32\").HasElementType returns <ph id=\"ph2\">`false`</ph>.","pos":[0,125],"source":"For example, Type.GetType(\"Int32[]\").HasElementType returns `true`, but Type.GetType(\"Int32\").HasElementType returns `false`."},{"content":"HasElementType also returns <ph id=\"ph1\">`true`</ph> for \"Int32*\" and \"Int32&amp;\".","pos":[126,187],"source":" HasElementType also returns `true` for \"Int32*\" and \"Int32&\"."}]},{"pos":[194,367],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`."}],"pos":[536348,536728],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is an array, a pointer, or is passed by reference; otherwise, `false`.","nodes":[{"pos":[0,117],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is an array, a pointer, or is passed by reference; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is an array, a pointer, or is passed by reference; otherwise, `false`."}],"pos":[537390,537510],"yaml":true},{"content":"When overridden in a derived class, implements the <xref href=\"System.Type.HasElementType\"></xref> property and determines whether the current <xref href=\"System.Type\"></xref> encompasses or refers to another type; that is, whether the current <xref href=\"System.Type\"></xref> is an array, a pointer, or is passed by reference.","nodes":[{"pos":[0,327],"content":"When overridden in a derived class, implements the <ph id=\"ph1\">&lt;xref href=\"System.Type.HasElementType\"&gt;&lt;/xref&gt;</ph> property and determines whether the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> encompasses or refers to another type; that is, whether the current <ph id=\"ph3\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is an array, a pointer, or is passed by reference.","source":"When overridden in a derived class, implements the <xref href=\"System.Type.HasElementType\"></xref> property and determines whether the current <xref href=\"System.Type\"></xref> encompasses or refers to another type; that is, whether the current <xref href=\"System.Type\"></xref> is an array, a pointer, or is passed by reference."}],"pos":[538987,539315],"yaml":true},{"content":"For example, Type.GetType(\"Int32[]\").HasElementTypeImpl returns `true`, but Type.GetType(\"Int32\").HasElementTypeImpl returns `false`. HasElementTypeImpl also returns `true` for \"Int32*\" and \"Int32&\".","nodes":[{"pos":[0,199],"content":"For example, Type.GetType(\"Int32[]\").HasElementTypeImpl returns `true`, but Type.GetType(\"Int32\").HasElementTypeImpl returns `false`. HasElementTypeImpl also returns `true` for \"Int32*\" and \"Int32&\".","nodes":[{"content":"For example, Type.GetType(\"Int32[]\").HasElementTypeImpl returns <ph id=\"ph1\">`true`</ph>, but Type.GetType(\"Int32\").HasElementTypeImpl returns <ph id=\"ph2\">`false`</ph>.","pos":[0,133],"source":"For example, Type.GetType(\"Int32[]\").HasElementTypeImpl returns `true`, but Type.GetType(\"Int32\").HasElementTypeImpl returns `false`."},{"content":"HasElementTypeImpl also returns <ph id=\"ph1\">`true`</ph> for \"Int32*\" and \"Int32&amp;\".","pos":[134,199],"source":" HasElementTypeImpl also returns `true` for \"Int32*\" and \"Int32&\"."}]}],"pos":[539326,539526],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is an array, a pointer, or is passed by reference; otherwise, `false`.","nodes":[{"pos":[0,117],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is an array, a pointer, or is passed by reference; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is an array, a pointer, or is passed by reference; otherwise, `false`."}],"pos":[540317,540437],"yaml":true},{"content":"When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.","nodes":[{"pos":[0,170],"content":"When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.","nodes":[{"content":"When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.","pos":[0,170]}]}],"pos":[542372,542543],"yaml":true},{"content":"`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.  \n  \n> [!NOTE]\n>  You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.  \n  \n When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format \"[DispID=##]\". For example, if the DispID of MyComMethod is 3, you can specify the string \"[DispID=3]\" instead of \"MyComMethod\". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.  \n  \n Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers` and `culture`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \n  \n Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array. If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.  \n  \n The `namedParameters` array can be used to change the order of arguments in an input array. For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, \"x\" }`, the input array can be passed unchanged to `args` if the array `{ \"b\", \"a\" }` is supplied for `namedParameters`.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  \n  \n-   Specify `BindingFlags.Public` to include public members in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \n  \n-   `BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.  \n  \n The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:  \n  \n-   `CreateInstance` to invoke a constructor. `name` is ignored. Not valid with other invocation flags.  \n  \n-   `InvokeMethod` to invoke a method, but not a constructor or a type initializer. Not valid with `SetField` or `SetProperty`. If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.  \n  \n-   `GetField` to get the value of a field. Not valid with `SetField`.  \n  \n-   `SetField` to set the value of a field. Not valid with `GetField`.  \n  \n-   `GetProperty` to get a property. Not valid with `SetProperty`.  \n  \n-   `SetProperty` to set a property. Not valid with `GetProperty`.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n A method will be invoked if both of the following conditions are true:  \n  \n-   The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).  \n  \n-   The type of each argument can be converted by the binder to the type of the parameter.  \n  \n The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.  \n  \n After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.  \n  \n `InvokeMember` can be used to invoke methods with parameters that have default values. To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags?displayProperty=fullName> to be specified. For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=fullName> to use the default value.  \n  \n For example, consider a method such as MyMethod(int x, float y = 2.0). To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument. Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method. If you must do so, use `InvokeMember` instead.  \n  \n Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.  \n  \n You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags?displayProperty=fullName>. For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:  \n  \n `typeof(C).InvokeMember(\"F\", BindingFlags.SetField, null, c, new Object[] {\"strings new value\"}, null, null, null);`  \n  \n If F is a `String[]`, you can use code such as:  \n  \n `typeof(C).InvokeMember(\"F\", BindingFlags.SetField, null, c, new Object[] {new String[]{\"a\",\"z\",\"c\",\"d\"}}, null, null, null);`  \n  \n which will initialize the field F to this new array. You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:  \n  \n `typeof(C).InvokeMember(\"F\", BindingFlags.SetField, null, c, new Object[] {1, \"b\"}, null, null, null);`  \n  \n This will change string \"z\" in the array that F holds to string \"b\".  \n  \n> [!NOTE]\n>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  \n>   \n>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.","nodes":[{"pos":[0,174],"content":"<ph id=\"ph1\">`InvokeMember`</ph> calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.","source":"`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member."},{"pos":[182,270],"content":"[!NOTE]\n You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.","leadings":["","> "],"nodes":[{"content":"You cannot use <ph id=\"ph1\">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.","pos":[9,86],"source":" You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method."}]},{"pos":[277,697],"content":"When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format \"[DispID=##]\". For example, if the DispID of MyComMethod is 3, you can specify the string \"[DispID=3]\" instead of \"MyComMethod\". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.","nodes":[{"content":"When you invoke an <ph id=\"ph1\">`IDispatch`</ph> member you can specify the DispID instead of the member name, using the string format \"[DispID=##]\".","pos":[0,131],"source":"When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format \"[DispID=##]\"."},{"content":"For example, if the DispID of MyComMethod is 3, you can specify the string \"[DispID=3]\" instead of \"MyComMethod\".","pos":[132,245]},{"content":"Invoking a member by DispID is faster than looking up the member by name.","pos":[246,319]},{"content":"In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.","pos":[320,420]}]},{"pos":[704,1165],"content":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers` and `culture`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.","nodes":[{"content":"Although the default binder does not process <ph id=\"ph1\">&lt;xref:System.Reflection.ParameterModifier&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (the <ph id=\"ph3\">`modifiers`</ph> and <ph id=\"ph4\">`culture`</ph> parameters), you can use the abstract <ph id=\"ph5\">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id=\"ph6\">`modifiers`</ph> and <ph id=\"ph7\">`culture`</ph>.","pos":[0,332],"source":"Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers` and `culture`."},{"content":"<ph id=\"ph1\">`ParameterModifier`</ph> is only used when calling through COM interop, and only parameters that are passed by reference are handled.","pos":[333,461],"source":"`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled."}]},{"pos":[1172,1406],"content":"Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array. If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.","nodes":[{"content":"Each parameter in the <ph id=\"ph1\">`namedParameters`</ph> array gets the value in the corresponding element in the <ph id=\"ph2\">`args`</ph> array.","pos":[0,110],"source":"Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array."},{"content":"If the length of <ph id=\"ph1\">`args`</ph> is greater than the length of <ph id=\"ph2\">`namedParameters`</ph>, the remaining argument values are passed in order.","pos":[111,234],"source":" If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order."}]},{"pos":[1413,1764],"content":"The `namedParameters` array can be used to change the order of arguments in an input array. For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, \"x\" }`, the input array can be passed unchanged to `args` if the array `{ \"b\", \"a\" }` is supplied for `namedParameters`.","nodes":[{"content":"The <ph id=\"ph1\">`namedParameters`</ph> array can be used to change the order of arguments in an input array.","pos":[0,91],"source":"The `namedParameters` array can be used to change the order of arguments in an input array."},{"content":"For example, given the method <ph id=\"ph1\">`M(string a, int b)`</ph> (<ph id=\"ph2\">`M(ByVal a As String, ByVal b As Integer)`</ph> in Visual Basic) and the input array <ph id=\"ph3\">`{ 42, \"x\" }`</ph>, the input array can be passed unchanged to <ph id=\"ph4\">`args`</ph> if the array <ph id=\"ph5\">`{ \"b\", \"a\" }`</ph> is supplied for <ph id=\"ph6\">`namedParameters`</ph>.","pos":[92,351],"source":" For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, \"x\" }`, the input array can be passed unchanged to `args` if the array `{ \"b\", \"a\" }` is supplied for `namedParameters`."}]},{"pos":[1771,1897],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:","pos":[0,126],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:"}]},{"pos":[1907,1977],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public members in the search.","source":"Specify `BindingFlags.Public` to include public members in the search."},{"pos":[1987,2116],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search."},{"pos":[2126,2209],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.","source":"Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy."},{"pos":[2216,2326],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[2336,2391],"content":"<ph id=\"ph1\">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id=\"ph2\">`name`</ph>.","source":"`BindingFlags.IgnoreCase` to ignore the case of `name`."},{"pos":[2401,2531],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited."},{"pos":[2538,2665],"content":"The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:","pos":[0,127],"source":"The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:"}]},{"pos":[2675,2774],"content":"`CreateInstance` to invoke a constructor. `name` is ignored. Not valid with other invocation flags.","nodes":[{"content":"<ph id=\"ph1\">`CreateInstance`</ph> to invoke a constructor.","pos":[0,41],"source":"`CreateInstance` to invoke a constructor."},{"content":"<ph id=\"ph1\">`name`</ph> is ignored.","pos":[42,60],"source":"`name` is ignored."},{"content":"Not valid with other invocation flags.","pos":[61,99]}]},{"pos":[2784,3051],"content":"`InvokeMethod` to invoke a method, but not a constructor or a type initializer. Not valid with `SetField` or `SetProperty`. If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.","nodes":[{"content":"<ph id=\"ph1\">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.","pos":[0,79],"source":"`InvokeMethod` to invoke a method, but not a constructor or a type initializer."},{"content":"Not valid with <ph id=\"ph1\">`SetField`</ph> or <ph id=\"ph2\">`SetProperty`</ph>.","pos":[80,123],"source":" Not valid with `SetField` or `SetProperty`."},{"content":"If <ph id=\"ph1\">`InvokeMethod`</ph> is specified by itself, <ph id=\"ph2\">`BindingFlags.Public`</ph>, <ph id=\"ph3\">`BindingFlags.Instance`</ph>, and <ph id=\"ph4\">`BindingFlags.Static`</ph> are automatically included.","pos":[124,267],"source":" If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included."}]},{"pos":[3061,3127],"content":"`GetField` to get the value of a field. Not valid with `SetField`.","nodes":[{"content":"<ph id=\"ph1\">`GetField`</ph> to get the value of a field.","pos":[0,39],"source":"`GetField` to get the value of a field."},{"content":"Not valid with <ph id=\"ph1\">`SetField`</ph>.","pos":[40,66],"source":" Not valid with `SetField`."}]},{"pos":[3137,3203],"content":"`SetField` to set the value of a field. Not valid with `GetField`.","nodes":[{"content":"<ph id=\"ph1\">`SetField`</ph> to set the value of a field.","pos":[0,39],"source":"`SetField` to set the value of a field."},{"content":"Not valid with <ph id=\"ph1\">`GetField`</ph>.","pos":[40,66],"source":" Not valid with `GetField`."}]},{"pos":[3213,3275],"content":"`GetProperty` to get a property. Not valid with `SetProperty`.","nodes":[{"content":"<ph id=\"ph1\">`GetProperty`</ph> to get a property.","pos":[0,32],"source":"`GetProperty` to get a property."},{"content":"Not valid with <ph id=\"ph1\">`SetProperty`</ph>.","pos":[33,62],"source":" Not valid with `SetProperty`."}]},{"pos":[3285,3347],"content":"`SetProperty` to set a property. Not valid with `GetProperty`.","nodes":[{"content":"<ph id=\"ph1\">`SetProperty`</ph> to set a property.","pos":[0,32],"source":"`SetProperty` to set a property."},{"content":"Not valid with <ph id=\"ph1\">`GetProperty`</ph>.","pos":[33,62],"source":" Not valid with `GetProperty`."}]},{"pos":[3354,3442],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[3449,3519],"content":"A method will be invoked if both of the following conditions are true:","nodes":[{"content":"A method will be invoked if both of the following conditions are true:","pos":[0,70]}]},{"pos":[3529,3737],"content":"The number of parameters in the method declaration equals the number of arguments in the <ph id=\"ph1\">`args`</ph> array (unless default arguments are defined on the member and <ph id=\"ph2\">`BindingFlags.OptionalParamBinding`</ph> is specified).","source":"The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified)."},{"pos":[3747,3833],"content":"The type of each argument can be converted by the binder to the type of the parameter.","nodes":[{"content":"The type of each argument can be converted by the binder to the type of the parameter.","pos":[0,86]}]},{"pos":[3840,4161],"content":"The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.","nodes":[{"content":"The binder will find all of the matching methods.","pos":[0,49]},{"content":"These methods are found based upon the type of binding requested (<ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id=\"ph2\">`InvokeMethod`</ph>, <ph id=\"ph3\">`GetProperty`</ph>, and so on).","pos":[50,203],"source":" These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on)."},{"content":"The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.","pos":[204,321]}]},{"pos":[4168,4612],"content":"After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.","nodes":[{"content":"After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.","pos":[0,444],"nodes":[{"content":"After the method is selected, it is invoked.","pos":[0,44]},{"content":"Accessibility is checked at that point.","pos":[45,84]},{"content":"The search may control which set of methods are searched based upon the accessibility attribute associated with the method.","pos":[85,208]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.","pos":[209,392],"source":" The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked."},{"content":"The default binder selects the most specific match.","pos":[393,444]}]}]},{"pos":[4619,5014],"content":"`InvokeMember` can be used to invoke methods with parameters that have default values. To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags?displayProperty=fullName> to be specified. For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=fullName> to use the default value.","nodes":[{"content":"<ph id=\"ph1\">`InvokeMember`</ph> can be used to invoke methods with parameters that have default values.","pos":[0,86],"source":"`InvokeMember` can be used to invoke methods with parameters that have default values."},{"content":"To bind to these methods, Reflection requires <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> to be specified.","pos":[87,212],"source":" To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags?displayProperty=fullName> to be specified."},{"content":"For a parameter that has a default value, you can either supply a different value, or supply <ph id=\"ph1\">&lt;xref:System.Reflection.Missing.Value?displayProperty=fullName&gt;</ph> to use the default value.","pos":[213,395],"source":" For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=fullName> to use the default value."}]},{"pos":[5021,5438],"content":"For example, consider a method such as MyMethod(int x, float y = 2.0). To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument. Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method. If you must do so, use `InvokeMember` instead.","nodes":[{"content":"For example, consider a method such as MyMethod(int x, float y = 2.0).","pos":[0,70]},{"content":"To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and <ph id=\"ph1\">`Missing.Value`</ph> for the second argument.","pos":[71,275],"source":" To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument."},{"content":"Unless you use <ph id=\"ph1\">`Missing.Value`</ph>, you may not omit optional parameters with the <ph id=\"ph2\">`Invoke`</ph> method.","pos":[276,370],"source":" Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method."},{"content":"If you must do so, use <ph id=\"ph1\">`InvokeMember`</ph> instead.","pos":[371,417],"source":" If you must do so, use `InvokeMember` instead."}]},{"pos":[5445,5660],"content":"Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.","nodes":[{"content":"Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <ph id=\"ph1\">&lt;xref:System.Reflection&gt;</ph> whenever the code is fully trusted.","pos":[0,215],"source":"Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted."}]},{"pos":[5667,5936],"content":"You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags?displayProperty=fullName>. For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:","nodes":[{"content":"You can use <ph id=\"ph1\">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph>.","pos":[0,146],"source":"You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags?displayProperty=fullName>."},{"content":"For example, if you want to set a public instance field named F on class C, and F is a <ph id=\"ph1\">`String`</ph>, you can use code such as:","pos":[147,269],"source":" For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:"}]},{"pos":[6066,6113],"content":"If F is a <ph id=\"ph1\">`String[]`</ph>, you can use code such as:","source":"If F is a `String[]`, you can use code such as:"},{"pos":[6253,6469],"content":"which will initialize the field F to this new array. You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:","nodes":[{"content":"which will initialize the field F to this new array.","pos":[0,52]},{"content":"You can also use <ph id=\"ph1\">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:","pos":[53,216],"source":" You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:"}]},{"pos":[6586,6654],"content":"This will change string \"z\" in the array that F holds to string \"b\".","nodes":[{"content":"This will change string \"z\" in the array that F holds to string \"b\".","pos":[0,68]}]},{"pos":[6662,7232],"content":"[!NOTE]\n Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)","leadings":["","> "],"nodes":[{"content":" Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)","pos":[8,568],"nodes":[{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id=\"ph2\">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof.","pos":[1,429],"source":" Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof."},{"content":"(See <bpt id=\"p1\">[</bpt>Security Considerations for Reflection<ept id=\"p1\">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)","pos":[430,560],"source":" (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)"}]}]},{"pos":[7243,7370],"content":"To use this functionality, your application should target the <ph id=\"ph1\">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.","source":"To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later."}],"pos":[542554,550037],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the constructor, method, property, or field member to invoke.  \n  \n -or-  \n  \n An empty string (\"\") to invoke the default member.  \n  \n -or-  \n  \n For `IDispatch` members, a string representing the DispID, for example \"[DispID=3]\".","nodes":[{"pos":[0,95],"content":"The string containing the name of the constructor, method, property, or field member to invoke.","nodes":[{"content":"The string containing the name of the constructor, method, property, or field member to invoke.","pos":[0,95]}]},{"pos":[102,106],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[113,163],"content":"An empty string (\"\") to invoke the default member.","nodes":[{"content":"An empty string (\"\") to invoke the default member.","pos":[0,50]}]},{"pos":[170,174],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[181,265],"content":"For <ph id=\"ph1\">`IDispatch`</ph> members, a string representing the DispID, for example \"[DispID=3]\".","source":"For `IDispatch` members, a string representing the DispID, for example \"[DispID=3]\"."}],"pos":[550410,550690],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted. The access can be one of the `BindingFlags` such as `Public`, `NonPublic`, `Private`, `InvokeMethod`, `GetField`, and so on. The type of lookup need not be specified. If the type of lookup is omitted, `BindingFlags.Public` | `BindingFlags.Instance` | `BindingFlags.Static` are used.","nodes":[{"pos":[0,411],"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted. The access can be one of the `BindingFlags` such as `Public`, `NonPublic`, `Private`, `InvokeMethod`, `GetField`, and so on. The type of lookup need not be specified. If the type of lookup is omitted, `BindingFlags.Public` | `BindingFlags.Instance` | `BindingFlags.Static` are used.","nodes":[{"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","pos":[0,128],"source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"content":"The access can be one of the <ph id=\"ph1\">`BindingFlags`</ph> such as <ph id=\"ph2\">`Public`</ph>, <ph id=\"ph3\">`NonPublic`</ph>, <ph id=\"ph4\">`Private`</ph>, <ph id=\"ph5\">`InvokeMethod`</ph>, <ph id=\"ph6\">`GetField`</ph>, and so on.","pos":[129,253],"source":" The access can be one of the `BindingFlags` such as `Public`, `NonPublic`, `Private`, `InvokeMethod`, `GetField`, and so on."},{"content":"The type of lookup need not be specified.","pos":[254,295]},{"content":"If the type of lookup is omitted, <ph id=\"ph1\">`BindingFlags.Public`</ph><ph id=\"ph2\"> | </ph><ph id=\"ph3\">`BindingFlags.Instance`</ph><ph id=\"ph4\"> | </ph><ph id=\"ph5\">`BindingFlags.Static`</ph> are used.","pos":[296,411],"source":" If the type of lookup is omitted, `BindingFlags.Public` | `BindingFlags.Instance` | `BindingFlags.Static` are used."}]}],"pos":[550773,551185],"yaml":true},{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \n  \n -or-  \n  \n A null reference (Nothing in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>. Note that explicitly defining a <xref href=\"System.Reflection.Binder\"></xref> object may be required for successfully invoking method overloads with variable arguments.","nodes":[{"pos":[0,191],"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","nodes":[{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","pos":[0,191]}]},{"pos":[198,202],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[209,480],"content":"A null reference (Nothing in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>. Note that explicitly defining a <xref href=\"System.Reflection.Binder\"></xref> object may be required for successfully invoking method overloads with variable arguments.","nodes":[{"content":"A null reference (Nothing in Visual Basic), to use the <ph id=\"ph1\">&lt;xref href=\"System.Type.DefaultBinder\"&gt;&lt;/xref&gt;</ph>.","pos":[0,102],"source":"A null reference (Nothing in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>."},{"content":"Note that explicitly defining a <ph id=\"ph1\">&lt;xref href=\"System.Reflection.Binder\"&gt;&lt;/xref&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.","pos":[103,271],"source":" Note that explicitly defining a <xref href=\"System.Reflection.Binder\"></xref> object may be required for successfully invoking method overloads with variable arguments."}]}],"pos":[551258,551749],"yaml":true},{"content":"The object on which to invoke the specified member.","nodes":[{"pos":[0,51],"content":"The object on which to invoke the specified member.","nodes":[{"content":"The object on which to invoke the specified member.","pos":[0,51]}]}],"pos":[551811,551863],"yaml":true},{"content":"An array containing the arguments to pass to the member to invoke.","nodes":[{"pos":[0,66],"content":"An array containing the arguments to pass to the member to invoke.","nodes":[{"content":"An array containing the arguments to pass to the member to invoke.","pos":[0,66]}]}],"pos":[551925,551992],"yaml":true},{"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>args</code> array. A parameter's associated attributes are stored in the member's signature.  \n  \n The default binder processes this parameter only when calling a COM component.","nodes":[{"pos":[0,252],"content":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>args</code> array. A parameter's associated attributes are stored in the member's signature.","nodes":[{"content":"An array of <ph id=\"ph1\">&lt;xref href=\"System.Reflection.ParameterModifier\"&gt;&lt;/xref&gt;</ph> objects representing the attributes associated with the corresponding element in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">args</ph><ept id=\"p1\">&lt;/code&gt;</ept> array.","pos":[0,178],"source":"An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>args</code> array."},{"content":"A parameter's associated attributes are stored in the member's signature.","pos":[179,252]}]},{"pos":[259,337],"content":"The default binder processes this parameter only when calling a COM component.","nodes":[{"content":"The default binder processes this parameter only when calling a COM component.","pos":[0,78]}]}],"pos":[552081,552425],"yaml":true},{"content":"The <xref href=\"System.Globalization.CultureInfo\"></xref> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.  \n  \n -or-  \n  \n A null reference (`Nothing` in Visual Basic) to use the current thread's <xref href=\"System.Globalization.CultureInfo\"></xref>.","nodes":[{"pos":[0,215],"content":"The <ph id=\"ph1\">&lt;xref href=\"System.Globalization.CultureInfo\"&gt;&lt;/xref&gt;</ph> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.","source":"The <xref href=\"System.Globalization.CultureInfo\"></xref> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double."},{"pos":[222,226],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[233,360],"content":"A null reference (<ph id=\"ph1\">`Nothing`</ph> in Visual Basic) to use the current thread's <ph id=\"ph2\">&lt;xref href=\"System.Globalization.CultureInfo\"&gt;&lt;/xref&gt;</ph>.","source":"A null reference (`Nothing` in Visual Basic) to use the current thread's <xref href=\"System.Globalization.CultureInfo\"></xref>."}],"pos":[552507,552878],"yaml":true},{"content":"An array containing the names of the parameters to which the values in the <code>args</code> array are passed.","nodes":[{"pos":[0,110],"content":"An array containing the names of the parameters to which the values in the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">args</ph><ept id=\"p1\">&lt;/code&gt;</ept> array are passed.","source":"An array containing the names of the parameters to which the values in the <code>args</code> array are passed."}],"pos":[552951,553062],"yaml":true},{"content":"An object representing the return value of the invoked member.","nodes":[{"pos":[0,62],"content":"An object representing the return value of the invoked member.","nodes":[{"content":"An object representing the return value of the invoked member.","pos":[0,62]}]}],"pos":[553119,553182],"yaml":true},{"content":"<code>invokeAttr</code> does not contain `CreateInstance` and <code>name</code> is `null`.","nodes":[{"pos":[0,90],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> does not contain <ph id=\"ph2\">`CreateInstance`</ph> and <ph id=\"ph3\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph4\">`null`</ph>.","source":"<code>invokeAttr</code> does not contain `CreateInstance` and <code>name</code> is `null`."}],"pos":[553336,553427],"yaml":true},{"content":"<code>args</code> and <code>modifiers</code> do not have the same length.  \n  \n -or-  \n  \n <code>invokeAttr</code> is not a valid <xref href=\"System.Reflection.BindingFlags\"></xref> attribute.  \n  \n -or-  \n  \n <code>invokeAttr</code> does not contain one of the following binding flags: `InvokeMethod`, `CreateInstance`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains `CreateInstance` combined with `InvokeMethod`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains both `GetField` and `SetField`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains both `GetProperty` and `SetProperty`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains `InvokeMethod` combined with `SetField` or `SetProperty`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains `SetField` and <code>args</code> has more than one element.  \n  \n -or-  \n  \n The named parameter array is larger than the argument array.  \n  \n -or-  \n  \n This method is called on a COM object and one of the following binding flags was not passed in: `BindingFlags.InvokeMethod`, `BindingFlags.GetProperty`, `BindingFlags.SetProperty`, `BindingFlags.PutDispProperty`, or `BindingFlags.PutRefDispProperty`.  \n  \n -or-  \n  \n One of the named parameter arrays contains a string that is `null`.","nodes":[{"pos":[0,73],"content":"<ph id=\"ph1\">&lt;code&gt;args&lt;/code&gt;</ph> and <ph id=\"ph2\">&lt;code&gt;modifiers&lt;/code&gt;</ph> do not have the same length.","source":"<code>args</code> and <code>modifiers</code> do not have the same length."},{"pos":[80,84],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[91,192],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> is not a valid <ph id=\"ph2\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> attribute.","source":"<code>invokeAttr</code> is not a valid <xref href=\"System.Reflection.BindingFlags\"></xref> attribute."},{"pos":[199,203],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[210,377],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> does not contain one of the following binding flags: <ph id=\"ph2\">`InvokeMethod`</ph>, <ph id=\"ph3\">`CreateInstance`</ph>, <ph id=\"ph4\">`GetField`</ph>, <ph id=\"ph5\">`SetField`</ph>, <ph id=\"ph6\">`GetProperty`</ph>, or <ph id=\"ph7\">`SetProperty`</ph>.","source":"<code>invokeAttr</code> does not contain one of the following binding flags: `InvokeMethod`, `CreateInstance`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`."},{"pos":[384,388],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[395,531],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id=\"ph2\">`CreateInstance`</ph> combined with <ph id=\"ph3\">`InvokeMethod`</ph>, <ph id=\"ph4\">`GetField`</ph>, <ph id=\"ph5\">`SetField`</ph>, <ph id=\"ph6\">`GetProperty`</ph>, or <ph id=\"ph7\">`SetProperty`</ph>.","source":"<code>invokeAttr</code> contains `CreateInstance` combined with `InvokeMethod`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`."},{"pos":[538,542],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[549,613],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains both <ph id=\"ph2\">`GetField`</ph> and <ph id=\"ph3\">`SetField`</ph>.","source":"<code>invokeAttr</code> contains both `GetField` and `SetField`."},{"pos":[620,624],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[631,701],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains both <ph id=\"ph2\">`GetProperty`</ph> and <ph id=\"ph3\">`SetProperty`</ph>.","source":"<code>invokeAttr</code> contains both `GetProperty` and `SetProperty`."},{"pos":[708,712],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[719,809],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id=\"ph2\">`InvokeMethod`</ph> combined with <ph id=\"ph3\">`SetField`</ph> or <ph id=\"ph4\">`SetProperty`</ph>.","source":"<code>invokeAttr</code> contains `InvokeMethod` combined with `SetField` or `SetProperty`."},{"pos":[816,820],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[827,919],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id=\"ph2\">`SetField`</ph> and <ph id=\"ph3\">&lt;code&gt;args&lt;/code&gt;</ph> has more than one element.","source":"<code>invokeAttr</code> contains `SetField` and <code>args</code> has more than one element."},{"pos":[926,930],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[937,997],"content":"The named parameter array is larger than the argument array.","nodes":[{"content":"The named parameter array is larger than the argument array.","pos":[0,60]}]},{"pos":[1004,1008],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[1015,1265],"content":"This method is called on a COM object and one of the following binding flags was not passed in: <ph id=\"ph1\">`BindingFlags.InvokeMethod`</ph>, <ph id=\"ph2\">`BindingFlags.GetProperty`</ph>, <ph id=\"ph3\">`BindingFlags.SetProperty`</ph>, <ph id=\"ph4\">`BindingFlags.PutDispProperty`</ph>, or <ph id=\"ph5\">`BindingFlags.PutRefDispProperty`</ph>.","source":"This method is called on a COM object and one of the following binding flags was not passed in: `BindingFlags.InvokeMethod`, `BindingFlags.GetProperty`, `BindingFlags.SetProperty`, `BindingFlags.PutDispProperty`, or `BindingFlags.PutRefDispProperty`."},{"pos":[1272,1276],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[1283,1350],"content":"One of the named parameter arrays contains a string that is <ph id=\"ph1\">`null`</ph>.","source":"One of the named parameter arrays contains a string that is `null`."}],"pos":[553521,554916],"yaml":true},{"content":"The specified member is a class initializer.","nodes":[{"pos":[0,44],"content":"The specified member is a class initializer.","nodes":[{"content":"The specified member is a class initializer.","pos":[0,44]}]}],"pos":[555018,555063],"yaml":true},{"content":"The field or property cannot be found.","nodes":[{"pos":[0,38],"content":"The field or property cannot be found.","nodes":[{"content":"The field or property cannot be found.","pos":[0,38]}]}],"pos":[555165,555204],"yaml":true},{"content":"No method can be found that matches the arguments in <code>args</code>.  \n  \n -or-  \n  \n No member can be found that has the argument names supplied in <code>namedParameters</code>.  \n  \n -or-  \n  \n The current <xref href=\"System.Type\"></xref> object represents a type that contains open type parameters, that is, <xref href=\"System.Type.ContainsGenericParameters\"></xref> returns `true`.","nodes":[{"pos":[0,71],"content":"No method can be found that matches the arguments in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">args</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"No method can be found that matches the arguments in <code>args</code>."},{"pos":[78,82],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[89,181],"content":"No member can be found that has the argument names supplied in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">namedParameters</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"No member can be found that has the argument names supplied in <code>namedParameters</code>."},{"pos":[188,192],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[199,388],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object represents a type that contains open type parameters, that is, <ph id=\"ph2\">&lt;xref href=\"System.Type.ContainsGenericParameters\"&gt;&lt;/xref&gt;</ph> returns <ph id=\"ph3\">`true`</ph>.","source":"The current <xref href=\"System.Type\"></xref> object represents a type that contains open type parameters, that is, <xref href=\"System.Type.ContainsGenericParameters\"></xref> returns `true`."}],"pos":[555308,555711],"yaml":true},{"content":"The specified member cannot be invoked on <code>target</code>.","nodes":[{"pos":[0,62],"content":"The specified member cannot be invoked on <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">target</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The specified member cannot be invoked on <code>target</code>."}],"pos":[555823,555886],"yaml":true},{"content":"More than one method matches the binding criteria.","nodes":[{"pos":[0,50],"content":"More than one method matches the binding criteria.","nodes":[{"content":"More than one method matches the binding criteria.","pos":[0,50]}]}],"pos":[556014,556065],"yaml":true},{"content":"The method represented by <code>name</code> has one or more unspecified generic type parameters. That is, the method's <xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"></xref> property returns `true`.","nodes":[{"pos":[0,219],"content":"The method represented by <code>name</code> has one or more unspecified generic type parameters. That is, the method's <xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"></xref> property returns `true`.","nodes":[{"content":"The method represented by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">name</ph><ept id=\"p1\">&lt;/code&gt;</ept> has one or more unspecified generic type parameters.","pos":[0,96],"source":"The method represented by <code>name</code> has one or more unspecified generic type parameters."},{"content":"That is, the method's <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"&gt;&lt;/xref&gt;</ph> property returns <ph id=\"ph2\">`true`</ph>.","pos":[97,219],"source":" That is, the method's <xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"></xref> property returns `true`."}]}],"pos":[556175,556395],"yaml":true},{"content":"Invokes the specified member, using the specified binding constraints and matching the specified argument list.","nodes":[{"pos":[0,111],"content":"Invokes the specified member, using the specified binding constraints and matching the specified argument list.","nodes":[{"content":"Invokes the specified member, using the specified binding constraints and matching the specified argument list.","pos":[0,111]}]}],"pos":[557876,557988],"yaml":true},{"content":"> [!NOTE]\n>  You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  \n  \n-   Specify `BindingFlags.Public` to include public members in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \n  \n-   `BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.  \n  \n The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:  \n  \n-   `CreateInstance` to invoke a constructor. `name` is ignored. Not valid with other invocation flags.  \n  \n-   `InvokeMethod` to invoke a method, but not a constructor or a type initializer. Not valid with `SetField` or `SetProperty`. If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.  \n  \n-   `GetField` to get the value of a field. Not valid with `SetField`.  \n  \n-   `SetField` to set the value of a field. Not valid with `GetField`.  \n  \n-   `GetProperty` to get a property. Not valid with `SetProperty`.  \n  \n-   `SetProperty` to set a property. Not valid with `GetProperty`.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n A method will be invoked if both of the following conditions are true:  \n  \n-   The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).  \n  \n-   The type of each argument can be converted by the binder to the type of the parameter.  \n  \n The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.  \n  \n After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.  \n  \n Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.  \n  \n You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags?displayProperty=fullName>. For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:  \n  \n `typeof(C).InvokeMember(\"F\", BindingFlags.SetField, null, c, new Object[] {\"strings new value\"});`  \n  \n If F is a `String[]`, you can use code such as:  \n  \n `typeof(C).InvokeMember(\"F\", BindingFlags.SetField, null, c, new Object[] {new String[]{\"a\",\"z\",\"c\",\"d\"}});`  \n  \n which will initialize the field F to this new array. You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:  \n  \n `typeof(C).InvokeMember(\"F\", BindingFlags.SetField, null, c, new Object[] {1, \"b\"});`  \n  \n This will change string \"z\" in the array that F holds to string \"b\".  \n  \n When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format \"[DispID=##]\". For example, if the DispID of MyComMethod is 3, you can specify the string \"[DispID=3]\" instead of \"MyComMethod\". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.  \n  \n> [!NOTE]\n>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  \n>   \n>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.","nodes":[{"pos":[2,90],"content":"[!NOTE]\n You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.","leadings":["","> "],"nodes":[{"content":"You cannot use <ph id=\"ph1\">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.","pos":[9,86],"source":" You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method."}]},{"pos":[97,223],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:","pos":[0,126],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:"}]},{"pos":[233,303],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public members in the search.","source":"Specify `BindingFlags.Public` to include public members in the search."},{"pos":[313,431],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private and protected members) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search."},{"pos":[441,524],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.","source":"Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy."},{"pos":[531,641],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[651,706],"content":"<ph id=\"ph1\">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id=\"ph2\">`name`</ph>.","source":"`BindingFlags.IgnoreCase` to ignore the case of `name`."},{"pos":[716,846],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited."},{"pos":[853,980],"content":"The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:","pos":[0,127],"source":"The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:"}]},{"pos":[990,1089],"content":"`CreateInstance` to invoke a constructor. `name` is ignored. Not valid with other invocation flags.","nodes":[{"content":"<ph id=\"ph1\">`CreateInstance`</ph> to invoke a constructor.","pos":[0,41],"source":"`CreateInstance` to invoke a constructor."},{"content":"<ph id=\"ph1\">`name`</ph> is ignored.","pos":[42,60],"source":"`name` is ignored."},{"content":"Not valid with other invocation flags.","pos":[61,99]}]},{"pos":[1099,1366],"content":"`InvokeMethod` to invoke a method, but not a constructor or a type initializer. Not valid with `SetField` or `SetProperty`. If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.","nodes":[{"content":"<ph id=\"ph1\">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.","pos":[0,79],"source":"`InvokeMethod` to invoke a method, but not a constructor or a type initializer."},{"content":"Not valid with <ph id=\"ph1\">`SetField`</ph> or <ph id=\"ph2\">`SetProperty`</ph>.","pos":[80,123],"source":" Not valid with `SetField` or `SetProperty`."},{"content":"If <ph id=\"ph1\">`InvokeMethod`</ph> is specified by itself, <ph id=\"ph2\">`BindingFlags.Public`</ph>, <ph id=\"ph3\">`BindingFlags.Instance`</ph>, and <ph id=\"ph4\">`BindingFlags.Static`</ph> are automatically included.","pos":[124,267],"source":" If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included."}]},{"pos":[1376,1442],"content":"`GetField` to get the value of a field. Not valid with `SetField`.","nodes":[{"content":"<ph id=\"ph1\">`GetField`</ph> to get the value of a field.","pos":[0,39],"source":"`GetField` to get the value of a field."},{"content":"Not valid with <ph id=\"ph1\">`SetField`</ph>.","pos":[40,66],"source":" Not valid with `SetField`."}]},{"pos":[1452,1518],"content":"`SetField` to set the value of a field. Not valid with `GetField`.","nodes":[{"content":"<ph id=\"ph1\">`SetField`</ph> to set the value of a field.","pos":[0,39],"source":"`SetField` to set the value of a field."},{"content":"Not valid with <ph id=\"ph1\">`GetField`</ph>.","pos":[40,66],"source":" Not valid with `GetField`."}]},{"pos":[1528,1590],"content":"`GetProperty` to get a property. Not valid with `SetProperty`.","nodes":[{"content":"<ph id=\"ph1\">`GetProperty`</ph> to get a property.","pos":[0,32],"source":"`GetProperty` to get a property."},{"content":"Not valid with <ph id=\"ph1\">`SetProperty`</ph>.","pos":[33,62],"source":" Not valid with `SetProperty`."}]},{"pos":[1600,1662],"content":"`SetProperty` to set a property. Not valid with `GetProperty`.","nodes":[{"content":"<ph id=\"ph1\">`SetProperty`</ph> to set a property.","pos":[0,32],"source":"`SetProperty` to set a property."},{"content":"Not valid with <ph id=\"ph1\">`GetProperty`</ph>.","pos":[33,62],"source":" Not valid with `GetProperty`."}]},{"pos":[1669,1757],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[1764,1834],"content":"A method will be invoked if both of the following conditions are true:","nodes":[{"content":"A method will be invoked if both of the following conditions are true:","pos":[0,70]}]},{"pos":[1844,2052],"content":"The number of parameters in the method declaration equals the number of arguments in the <ph id=\"ph1\">`args`</ph> array (unless default arguments are defined on the member and <ph id=\"ph2\">`BindingFlags.OptionalParamBinding`</ph> is specified).","source":"The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified)."},{"pos":[2062,2148],"content":"The type of each argument can be converted by the binder to the type of the parameter.","nodes":[{"content":"The type of each argument can be converted by the binder to the type of the parameter.","pos":[0,86]}]},{"pos":[2155,2476],"content":"The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.","nodes":[{"content":"The binder will find all of the matching methods.","pos":[0,49]},{"content":"These methods are found based upon the type of binding requested (<ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id=\"ph2\">`InvokeMethod`</ph>, <ph id=\"ph3\">`GetProperty`</ph>, and so on).","pos":[50,203],"source":" These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on)."},{"content":"The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.","pos":[204,321]}]},{"pos":[2483,2927],"content":"After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.","nodes":[{"content":"After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.","pos":[0,444],"nodes":[{"content":"After the method is selected, it is invoked.","pos":[0,44]},{"content":"Accessibility is checked at that point.","pos":[45,84]},{"content":"The search may control which set of methods are searched based upon the accessibility attribute associated with the method.","pos":[85,208]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.","pos":[209,392],"source":" The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked."},{"content":"The default binder selects the most specific match.","pos":[393,444]}]}]},{"pos":[2934,3149],"content":"Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.","nodes":[{"content":"Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <ph id=\"ph1\">&lt;xref:System.Reflection&gt;</ph> whenever the code is fully trusted.","pos":[0,215],"source":"Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted."}]},{"pos":[3156,3425],"content":"You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags?displayProperty=fullName>. For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:","nodes":[{"content":"You can use <ph id=\"ph1\">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph>.","pos":[0,146],"source":"You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags?displayProperty=fullName>."},{"content":"For example, if you want to set a public instance field named F on class C, and F is a <ph id=\"ph1\">`String`</ph>, you can use code such as:","pos":[147,269],"source":" For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:"}]},{"pos":[3537,3584],"content":"If F is a <ph id=\"ph1\">`String[]`</ph>, you can use code such as:","source":"If F is a `String[]`, you can use code such as:"},{"pos":[3706,3922],"content":"which will initialize the field F to this new array. You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:","nodes":[{"content":"which will initialize the field F to this new array.","pos":[0,52]},{"content":"You can also use <ph id=\"ph1\">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:","pos":[53,216],"source":" You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:"}]},{"pos":[4021,4089],"content":"This will change string \"z\" in the array that F holds to string \"b\".","nodes":[{"content":"This will change string \"z\" in the array that F holds to string \"b\".","pos":[0,68]}]},{"pos":[4096,4517],"content":"When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format \"[DispID=##]\". For example, if the DispID of MyComMethod is 3, you can specify the string \"[DispID=3]\" instead of \"MyComMethod\". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.","nodes":[{"content":"When you invoke an <ph id=\"ph1\">`IDispatch`</ph> member, you can specify the DispID instead of the member name, using the string format \"[DispID=##]\".","pos":[0,132],"source":"When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format \"[DispID=##]\"."},{"content":"For example, if the DispID of MyComMethod is 3, you can specify the string \"[DispID=3]\" instead of \"MyComMethod\".","pos":[133,246]},{"content":"Invoking a member by DispID is faster than looking up the member by name.","pos":[247,320]},{"content":"In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.","pos":[321,421]}]},{"pos":[4525,5095],"content":"[!NOTE]\n Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)","leadings":["","> "],"nodes":[{"content":" Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)","pos":[8,568],"nodes":[{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id=\"ph2\">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof.","pos":[1,429],"source":" Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof."},{"content":"(See <bpt id=\"p1\">[</bpt>Security Considerations for Reflection<ept id=\"p1\">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)","pos":[430,560],"source":" (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)"}]}]},{"pos":[5106,5233],"content":"To use this functionality, your application should target the <ph id=\"ph1\">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.","source":"To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later."}],"pos":[557999,563327],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the constructor, method, property, or field member to invoke.  \n  \n -or-  \n  \n An empty string (\"\") to invoke the default member.  \n  \n -or-  \n  \n For `IDispatch` members, a string representing the DispID, for example \"[DispID=3]\".","nodes":[{"pos":[0,95],"content":"The string containing the name of the constructor, method, property, or field member to invoke.","nodes":[{"content":"The string containing the name of the constructor, method, property, or field member to invoke.","pos":[0,95]}]},{"pos":[102,106],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[113,163],"content":"An empty string (\"\") to invoke the default member.","nodes":[{"content":"An empty string (\"\") to invoke the default member.","pos":[0,50]}]},{"pos":[170,174],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[181,265],"content":"For <ph id=\"ph1\">`IDispatch`</ph> members, a string representing the DispID, for example \"[DispID=3]\".","source":"For `IDispatch` members, a string representing the DispID, for example \"[DispID=3]\"."}],"pos":[563968,564248],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted. The access can be one of the `BindingFlags` such as `Public`, `NonPublic`, `Private`, `InvokeMethod`, `GetField`, and so on. The type of lookup need not be specified. If the type of lookup is omitted, `BindingFlags.Public` | `BindingFlags.Instance` | `BindingFlags.Static` are used.","nodes":[{"pos":[0,411],"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted. The access can be one of the `BindingFlags` such as `Public`, `NonPublic`, `Private`, `InvokeMethod`, `GetField`, and so on. The type of lookup need not be specified. If the type of lookup is omitted, `BindingFlags.Public` | `BindingFlags.Instance` | `BindingFlags.Static` are used.","nodes":[{"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","pos":[0,128],"source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"content":"The access can be one of the <ph id=\"ph1\">`BindingFlags`</ph> such as <ph id=\"ph2\">`Public`</ph>, <ph id=\"ph3\">`NonPublic`</ph>, <ph id=\"ph4\">`Private`</ph>, <ph id=\"ph5\">`InvokeMethod`</ph>, <ph id=\"ph6\">`GetField`</ph>, and so on.","pos":[129,253],"source":" The access can be one of the `BindingFlags` such as `Public`, `NonPublic`, `Private`, `InvokeMethod`, `GetField`, and so on."},{"content":"The type of lookup need not be specified.","pos":[254,295]},{"content":"If the type of lookup is omitted, <ph id=\"ph1\">`BindingFlags.Public`</ph><ph id=\"ph2\"> | </ph><ph id=\"ph3\">`BindingFlags.Instance`</ph><ph id=\"ph4\"> | </ph><ph id=\"ph5\">`BindingFlags.Static`</ph> are used.","pos":[296,411],"source":" If the type of lookup is omitted, `BindingFlags.Public` | `BindingFlags.Instance` | `BindingFlags.Static` are used."}]}],"pos":[564331,564743],"yaml":true},{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \n  \n -or-  \n  \n A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>. Note that explicitly defining a <xref href=\"System.Reflection.Binder\"></xref> object may be required for successfully invoking method overloads with variable arguments.","nodes":[{"pos":[0,191],"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","nodes":[{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","pos":[0,191]}]},{"pos":[198,202],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[209,482],"content":"A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>. Note that explicitly defining a <xref href=\"System.Reflection.Binder\"></xref> object may be required for successfully invoking method overloads with variable arguments.","nodes":[{"content":"A null reference (<ph id=\"ph1\">`Nothing`</ph> in Visual Basic), to use the <ph id=\"ph2\">&lt;xref href=\"System.Type.DefaultBinder\"&gt;&lt;/xref&gt;</ph>.","pos":[0,104],"source":"A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>."},{"content":"Note that explicitly defining a <ph id=\"ph1\">&lt;xref href=\"System.Reflection.Binder\"&gt;&lt;/xref&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.","pos":[105,273],"source":" Note that explicitly defining a <xref href=\"System.Reflection.Binder\"></xref> object may be required for successfully invoking method overloads with variable arguments."}]}],"pos":[564816,565309],"yaml":true},{"content":"The object on which to invoke the specified member.","nodes":[{"pos":[0,51],"content":"The object on which to invoke the specified member.","nodes":[{"content":"The object on which to invoke the specified member.","pos":[0,51]}]}],"pos":[565371,565423],"yaml":true},{"content":"An array containing the arguments to pass to the member to invoke.","nodes":[{"pos":[0,66],"content":"An array containing the arguments to pass to the member to invoke.","nodes":[{"content":"An array containing the arguments to pass to the member to invoke.","pos":[0,66]}]}],"pos":[565485,565552],"yaml":true},{"content":"An object representing the return value of the invoked member.","nodes":[{"pos":[0,62],"content":"An object representing the return value of the invoked member.","nodes":[{"content":"An object representing the return value of the invoked member.","pos":[0,62]}]}],"pos":[565609,565672],"yaml":true},{"content":"<code>invokeAttr</code> does not contain `CreateInstance` and <code>name</code> is `null`.","nodes":[{"pos":[0,90],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> does not contain <ph id=\"ph2\">`CreateInstance`</ph> and <ph id=\"ph3\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph4\">`null`</ph>.","source":"<code>invokeAttr</code> does not contain `CreateInstance` and <code>name</code> is `null`."}],"pos":[565826,565917],"yaml":true},{"content":"<code>invokeAttr</code> is not a valid <xref href=\"System.Reflection.BindingFlags\"></xref> attribute.  \n  \n -or-  \n  \n <code>invokeAttr</code> does not contain one of the following binding flags: `InvokeMethod`, `CreateInstance`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains `CreateInstance` combined with `InvokeMethod`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains both `GetField` and `SetField`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains both `GetProperty` and `SetProperty`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains `InvokeMethod` combined with `SetField` or `SetProperty`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains `SetField` and <code>args</code> has more than one element.  \n  \n -or-  \n  \n This method is called on a COM object and one of the following binding flags was not passed in: `BindingFlags.InvokeMethod`, `BindingFlags.GetProperty`, `BindingFlags.SetProperty`, `BindingFlags.PutDispProperty`, or `BindingFlags.PutRefDispProperty`.  \n  \n -or-  \n  \n One of the named parameter arrays contains a string that is `null`.","nodes":[{"pos":[0,101],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> is not a valid <ph id=\"ph2\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> attribute.","source":"<code>invokeAttr</code> is not a valid <xref href=\"System.Reflection.BindingFlags\"></xref> attribute."},{"pos":[108,112],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[119,286],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> does not contain one of the following binding flags: <ph id=\"ph2\">`InvokeMethod`</ph>, <ph id=\"ph3\">`CreateInstance`</ph>, <ph id=\"ph4\">`GetField`</ph>, <ph id=\"ph5\">`SetField`</ph>, <ph id=\"ph6\">`GetProperty`</ph>, or <ph id=\"ph7\">`SetProperty`</ph>.","source":"<code>invokeAttr</code> does not contain one of the following binding flags: `InvokeMethod`, `CreateInstance`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`."},{"pos":[293,297],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[304,440],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id=\"ph2\">`CreateInstance`</ph> combined with <ph id=\"ph3\">`InvokeMethod`</ph>, <ph id=\"ph4\">`GetField`</ph>, <ph id=\"ph5\">`SetField`</ph>, <ph id=\"ph6\">`GetProperty`</ph>, or <ph id=\"ph7\">`SetProperty`</ph>.","source":"<code>invokeAttr</code> contains `CreateInstance` combined with `InvokeMethod`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`."},{"pos":[447,451],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[458,522],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains both <ph id=\"ph2\">`GetField`</ph> and <ph id=\"ph3\">`SetField`</ph>.","source":"<code>invokeAttr</code> contains both `GetField` and `SetField`."},{"pos":[529,533],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[540,610],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains both <ph id=\"ph2\">`GetProperty`</ph> and <ph id=\"ph3\">`SetProperty`</ph>.","source":"<code>invokeAttr</code> contains both `GetProperty` and `SetProperty`."},{"pos":[617,621],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[628,718],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id=\"ph2\">`InvokeMethod`</ph> combined with <ph id=\"ph3\">`SetField`</ph> or <ph id=\"ph4\">`SetProperty`</ph>.","source":"<code>invokeAttr</code> contains `InvokeMethod` combined with `SetField` or `SetProperty`."},{"pos":[725,729],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[736,828],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id=\"ph2\">`SetField`</ph> and <ph id=\"ph3\">&lt;code&gt;args&lt;/code&gt;</ph> has more than one element.","source":"<code>invokeAttr</code> contains `SetField` and <code>args</code> has more than one element."},{"pos":[835,839],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[846,1096],"content":"This method is called on a COM object and one of the following binding flags was not passed in: <ph id=\"ph1\">`BindingFlags.InvokeMethod`</ph>, <ph id=\"ph2\">`BindingFlags.GetProperty`</ph>, <ph id=\"ph3\">`BindingFlags.SetProperty`</ph>, <ph id=\"ph4\">`BindingFlags.PutDispProperty`</ph>, or <ph id=\"ph5\">`BindingFlags.PutRefDispProperty`</ph>.","source":"This method is called on a COM object and one of the following binding flags was not passed in: `BindingFlags.InvokeMethod`, `BindingFlags.GetProperty`, `BindingFlags.SetProperty`, `BindingFlags.PutDispProperty`, or `BindingFlags.PutRefDispProperty`."},{"pos":[1103,1107],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[1114,1181],"content":"One of the named parameter arrays contains a string that is <ph id=\"ph1\">`null`</ph>.","source":"One of the named parameter arrays contains a string that is `null`."}],"pos":[566011,567229],"yaml":true},{"content":"The specified member is a class initializer.","nodes":[{"pos":[0,44],"content":"The specified member is a class initializer.","nodes":[{"content":"The specified member is a class initializer.","pos":[0,44]}]}],"pos":[567331,567376],"yaml":true},{"content":"The field or property cannot be found.","nodes":[{"pos":[0,38],"content":"The field or property cannot be found.","nodes":[{"content":"The field or property cannot be found.","pos":[0,38]}]}],"pos":[567478,567517],"yaml":true},{"content":"No method can be found that matches the arguments in <code>args</code>.  \n  \n -or-  \n  \n The current <xref href=\"System.Type\"></xref> object represents a type that contains open type parameters, that is, <xref href=\"System.Type.ContainsGenericParameters\"></xref> returns `true`.","nodes":[{"pos":[0,71],"content":"No method can be found that matches the arguments in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">args</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"No method can be found that matches the arguments in <code>args</code>."},{"pos":[78,82],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[89,278],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object represents a type that contains open type parameters, that is, <ph id=\"ph2\">&lt;xref href=\"System.Type.ContainsGenericParameters\"&gt;&lt;/xref&gt;</ph> returns <ph id=\"ph3\">`true`</ph>.","source":"The current <xref href=\"System.Type\"></xref> object represents a type that contains open type parameters, that is, <xref href=\"System.Type.ContainsGenericParameters\"></xref> returns `true`."}],"pos":[567621,567910],"yaml":true},{"content":"The specified member cannot be invoked on <code>target</code>.","nodes":[{"pos":[0,62],"content":"The specified member cannot be invoked on <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">target</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The specified member cannot be invoked on <code>target</code>."}],"pos":[568022,568085],"yaml":true},{"content":"More than one method matches the binding criteria.","nodes":[{"pos":[0,50],"content":"More than one method matches the binding criteria.","nodes":[{"content":"More than one method matches the binding criteria.","pos":[0,50]}]}],"pos":[568213,568264],"yaml":true},{"content":"The .NET Compact Framework does not currently support this method.","nodes":[{"pos":[0,66],"content":"The .NET Compact Framework does not currently support this method.","nodes":[{"content":"The .NET Compact Framework does not currently support this method.","pos":[0,66]}]}],"pos":[568366,568433],"yaml":true},{"content":"The method represented by <code>name</code> has one or more unspecified generic type parameters. That is, the method's <xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"></xref> property returns `true`.","nodes":[{"pos":[0,219],"content":"The method represented by <code>name</code> has one or more unspecified generic type parameters. That is, the method's <xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"></xref> property returns `true`.","nodes":[{"content":"The method represented by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">name</ph><ept id=\"p1\">&lt;/code&gt;</ept> has one or more unspecified generic type parameters.","pos":[0,96],"source":"The method represented by <code>name</code> has one or more unspecified generic type parameters."},{"content":"That is, the method's <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"&gt;&lt;/xref&gt;</ph> property returns <ph id=\"ph2\">`true`</ph>.","pos":[97,219],"source":" That is, the method's <xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"></xref> property returns `true`."}]}],"pos":[568543,568763],"yaml":true},{"content":"Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.","nodes":[{"pos":[0,123],"content":"Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.","nodes":[{"content":"Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.","pos":[0,123]}]}],"pos":[570399,570523],"yaml":true},{"content":"Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `culture`.  \n  \n> [!NOTE]\n>  You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.  \n  \n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  \n  \n-   Specify `BindingFlags.Public` to include public members in the search.  \n  \n-   Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.  \n  \n-   Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.  \n  \n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \n  \n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \n  \n-   `BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.  \n  \n The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:  \n  \n-   `CreateInstance` to invoke a constructor. `name` is ignored. Not valid with other invocation flags.  \n  \n-   `InvokeMethod` to invoke a method, but not a constructor or a type initializer. Not valid with `SetField` or `SetProperty`. If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.  \n  \n-   `GetField` to get the value of a field. Not valid with `SetField`.  \n  \n-   `SetField` to set the value of a field. Not valid with `GetField`.  \n  \n-   `GetProperty` to get a property. Not valid with `SetProperty`.  \n  \n-   `SetProperty` to set a property. Not valid with `GetProperty`.  \n  \n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \n  \n A method will be invoked if both of the following conditions are true:  \n  \n-   The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).  \n  \n-   The type of each argument can be converted by the binder to the type of the parameter.  \n  \n The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.  \n  \n After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.  \n  \n Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.  \n  \n You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags?displayProperty=fullName>. For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:  \n  \n `typeof(C).InvokeMember(\"F\", BindingFlags.SetField, null, c, new Object[] {\"strings new value\"}, null);`  \n  \n If F is a `String[]`, you can use code such as:  \n  \n `typeof(C).InvokeMember(\"F\", BindingFlags.SetField, null, c, new Object[] {new String[]{\"a\",\"z\",\"c\",\"d\"}}, null);`  \n  \n which will initialize the field F to this new array. You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:  \n  \n `typeof(C).InvokeMember(\"F\", BindingFlags.SetField, null, c, new Object[] {1, \"b\"}, null);`  \n  \n This will change string \"z\" in the array that F holds to string \"b\".  \n  \n When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format \"[DispID=##]\". For example, if the DispID of MyComMethod is 3, you can specify the string \"[DispID=3]\" instead of \"MyComMethod\". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.  \n  \n> [!NOTE]\n>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  \n>   \n>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.","nodes":[{"pos":[0,253],"content":"Although the default binder does not process <ph id=\"ph1\">&lt;xref:System.Globalization.CultureInfo&gt;</ph> (the <ph id=\"ph2\">`culture`</ph> parameter), you can use the abstract <ph id=\"ph3\">&lt;xref:System.Reflection.Binder?displayProperty=fullName&gt;</ph> class to write a custom binder that does process <ph id=\"ph4\">`culture`</ph>.","source":"Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `culture`."},{"pos":[261,349],"content":"[!NOTE]\n You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.","leadings":["","> "],"nodes":[{"content":"You cannot use <ph id=\"ph1\">&lt;xref:System.Type.InvokeMember%2A&gt;</ph> to invoke a generic method.","pos":[9,86],"source":" You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method."}]},{"pos":[356,482],"content":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> filter flags can be used to define which members to include in the search:","pos":[0,126],"source":"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:"}]},{"pos":[492,562],"content":"Specify <ph id=\"ph1\">`BindingFlags.Public`</ph> to include public members in the search.","source":"Specify `BindingFlags.Public` to include public members in the search."},{"pos":[572,701],"content":"Specify <ph id=\"ph1\">`BindingFlags.NonPublic`</ph> to include non-public members (that is, private, internal, and protected members) in the search.","source":"Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search."},{"pos":[711,794],"content":"Specify <ph id=\"ph1\">`BindingFlags.FlattenHierarchy`</ph> to include static members up the hierarchy.","source":"Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy."},{"pos":[801,911],"content":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> modifier flags can be used to change how the search works:","pos":[0,110],"source":"The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:"}]},{"pos":[921,976],"content":"<ph id=\"ph1\">`BindingFlags.IgnoreCase`</ph> to ignore the case of <ph id=\"ph2\">`name`</ph>.","source":"`BindingFlags.IgnoreCase` to ignore the case of `name`."},{"pos":[986,1116],"content":"<ph id=\"ph1\">`BindingFlags.DeclaredOnly`</ph> to search only the members declared on the <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph>, not members that were simply inherited.","source":"`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited."},{"pos":[1123,1250],"content":"The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:","nodes":[{"content":"The following <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> invocation flags can be used to denote what action to take with the member:","pos":[0,127],"source":"The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:"}]},{"pos":[1260,1359],"content":"`CreateInstance` to invoke a constructor. `name` is ignored. Not valid with other invocation flags.","nodes":[{"content":"<ph id=\"ph1\">`CreateInstance`</ph> to invoke a constructor.","pos":[0,41],"source":"`CreateInstance` to invoke a constructor."},{"content":"<ph id=\"ph1\">`name`</ph> is ignored.","pos":[42,60],"source":"`name` is ignored."},{"content":"Not valid with other invocation flags.","pos":[61,99]}]},{"pos":[1369,1636],"content":"`InvokeMethod` to invoke a method, but not a constructor or a type initializer. Not valid with `SetField` or `SetProperty`. If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.","nodes":[{"content":"<ph id=\"ph1\">`InvokeMethod`</ph> to invoke a method, but not a constructor or a type initializer.","pos":[0,79],"source":"`InvokeMethod` to invoke a method, but not a constructor or a type initializer."},{"content":"Not valid with <ph id=\"ph1\">`SetField`</ph> or <ph id=\"ph2\">`SetProperty`</ph>.","pos":[80,123],"source":" Not valid with `SetField` or `SetProperty`."},{"content":"If <ph id=\"ph1\">`InvokeMethod`</ph> is specified by itself, <ph id=\"ph2\">`BindingFlags.Public`</ph>, <ph id=\"ph3\">`BindingFlags.Instance`</ph>, and <ph id=\"ph4\">`BindingFlags.Static`</ph> are automatically included.","pos":[124,267],"source":" If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included."}]},{"pos":[1646,1712],"content":"`GetField` to get the value of a field. Not valid with `SetField`.","nodes":[{"content":"<ph id=\"ph1\">`GetField`</ph> to get the value of a field.","pos":[0,39],"source":"`GetField` to get the value of a field."},{"content":"Not valid with <ph id=\"ph1\">`SetField`</ph>.","pos":[40,66],"source":" Not valid with `SetField`."}]},{"pos":[1722,1788],"content":"`SetField` to set the value of a field. Not valid with `GetField`.","nodes":[{"content":"<ph id=\"ph1\">`SetField`</ph> to set the value of a field.","pos":[0,39],"source":"`SetField` to set the value of a field."},{"content":"Not valid with <ph id=\"ph1\">`GetField`</ph>.","pos":[40,66],"source":" Not valid with `GetField`."}]},{"pos":[1798,1860],"content":"`GetProperty` to get a property. Not valid with `SetProperty`.","nodes":[{"content":"<ph id=\"ph1\">`GetProperty`</ph> to get a property.","pos":[0,32],"source":"`GetProperty` to get a property."},{"content":"Not valid with <ph id=\"ph1\">`SetProperty`</ph>.","pos":[33,62],"source":" Not valid with `SetProperty`."}]},{"pos":[1870,1932],"content":"`SetProperty` to set a property. Not valid with `GetProperty`.","nodes":[{"content":"<ph id=\"ph1\">`SetProperty`</ph> to set a property.","pos":[0,32],"source":"`SetProperty` to set a property."},{"content":"Not valid with <ph id=\"ph1\">`GetProperty`</ph>.","pos":[33,62],"source":" Not valid with `GetProperty`."}]},{"pos":[1939,2027],"content":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.","nodes":[{"content":"See <ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph> for more information.","pos":[0,88],"source":"See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information."}]},{"pos":[2034,2104],"content":"A method will be invoked if both of the following conditions are true:","nodes":[{"content":"A method will be invoked if both of the following conditions are true:","pos":[0,70]}]},{"pos":[2114,2322],"content":"The number of parameters in the method declaration equals the number of arguments in the <ph id=\"ph1\">`args`</ph> array (unless default arguments are defined on the member and <ph id=\"ph2\">`BindingFlags.OptionalParamBinding`</ph> is specified).","source":"The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified)."},{"pos":[2332,2418],"content":"The type of each argument can be converted by the binder to the type of the parameter.","nodes":[{"content":"The type of each argument can be converted by the binder to the type of the parameter.","pos":[0,86]}]},{"pos":[2425,2746],"content":"The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.","nodes":[{"content":"The binder will find all of the matching methods.","pos":[0,49]},{"content":"These methods are found based upon the type of binding requested (<ph id=\"ph1\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> values <ph id=\"ph2\">`InvokeMethod`</ph>, <ph id=\"ph3\">`GetProperty`</ph>, and so on).","pos":[50,203],"source":" These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on)."},{"content":"The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.","pos":[204,321]}]},{"pos":[2753,3197],"content":"After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.","nodes":[{"content":"After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.","pos":[0,444],"nodes":[{"content":"After the method is selected, it is invoked.","pos":[0,44]},{"content":"Accessibility is checked at that point.","pos":[45,84]},{"content":"The search may control which set of methods are searched based upon the accessibility attribute associated with the method.","pos":[85,208]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName&gt;</ph> method of the <ph id=\"ph2\">&lt;xref:System.Reflection.Binder&gt;</ph> class is responsible for selecting the method to be invoked.","pos":[209,392],"source":" The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked."},{"content":"The default binder selects the most specific match.","pos":[393,444]}]}]},{"pos":[3204,3405],"content":"Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.","nodes":[{"content":"Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.","pos":[0,201]}]},{"pos":[3412,3680],"content":"You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags?displayProperty=fullName>. For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:","nodes":[{"content":"You can use <ph id=\"ph1\">`Type.InvokeMember`</ph> to set a field to a particular value by specifying <ph id=\"ph2\">&lt;xref:System.Reflection.BindingFlags?displayProperty=fullName&gt;</ph>.","pos":[0,146],"source":"You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags?displayProperty=fullName>."},{"content":"For example, if you want to set a public instance field named F on class C, and F is a <ph id=\"ph1\">`String`</ph> you can use code such as:","pos":[147,268],"source":" For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:"}]},{"pos":[3798,3845],"content":"If F is a <ph id=\"ph1\">`String[]`</ph>, you can use code such as:","source":"If F is a `String[]`, you can use code such as:"},{"pos":[3973,4189],"content":"which will initialize the field F to this new array. You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:","nodes":[{"content":"which will initialize the field F to this new array.","pos":[0,52]},{"content":"You can also use <ph id=\"ph1\">`Type.InvokeMember`</ph> to set a position in an array by supplying the index of the value and then the next value by using code such as the following:","pos":[53,216],"source":" You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:"}]},{"pos":[4294,4362],"content":"This will change string \"z\" in the array that F holds to string \"b\".","nodes":[{"content":"This will change string \"z\" in the array that F holds to string \"b\".","pos":[0,68]}]},{"pos":[4369,4789],"content":"When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format \"[DispID=##]\". For example, if the DispID of MyComMethod is 3, you can specify the string \"[DispID=3]\" instead of \"MyComMethod\". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.","nodes":[{"content":"When you invoke an <ph id=\"ph1\">`IDispatch`</ph> member you can specify the DispID instead of the member name, using the string format \"[DispID=##]\".","pos":[0,131],"source":"When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format \"[DispID=##]\"."},{"content":"For example, if the DispID of MyComMethod is 3, you can specify the string \"[DispID=3]\" instead of \"MyComMethod\".","pos":[132,245]},{"content":"Invoking a member by DispID is faster than looking up the member by name.","pos":[246,319]},{"content":"In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.","pos":[320,420]}]},{"pos":[4797,5367],"content":"[!NOTE]\n Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)","leadings":["","> "],"nodes":[{"content":" Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)","pos":[8,568],"nodes":[{"content":"Starting with the <ph id=\"ph1\">[!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)]</ph>, this method can be used to access non-public members if the caller has been granted <ph id=\"ph2\">&lt;xref:System.Security.Permissions.ReflectionPermission&gt;</ph> with the <ph id=\"ph3\">&lt;xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName&gt;</ph> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof.","pos":[1,429],"source":" Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof."},{"content":"(See <bpt id=\"p1\">[</bpt>Security Considerations for Reflection<ept id=\"p1\">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.)","pos":[430,560],"source":" (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)"}]}]},{"pos":[5378,5505],"content":"To use this functionality, your application should target the <ph id=\"ph1\">[!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)]</ph> or later.","source":"To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later."}],"pos":[570534,576136],"yaml":true,"extradata":"MT"},{"content":"The string containing the name of the constructor, method, property, or field member to invoke.  \n  \n -or-  \n  \n An empty string (\"\") to invoke the default member.  \n  \n -or-  \n  \n For `IDispatch` members, a string representing the DispID, for example \"[DispID=3]\".","nodes":[{"pos":[0,95],"content":"The string containing the name of the constructor, method, property, or field member to invoke.","nodes":[{"content":"The string containing the name of the constructor, method, property, or field member to invoke.","pos":[0,95]}]},{"pos":[102,106],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[113,163],"content":"An empty string (\"\") to invoke the default member.","nodes":[{"content":"An empty string (\"\") to invoke the default member.","pos":[0,50]}]},{"pos":[170,174],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[181,265],"content":"For <ph id=\"ph1\">`IDispatch`</ph> members, a string representing the DispID, for example \"[DispID=3]\".","source":"For `IDispatch` members, a string representing the DispID, for example \"[DispID=3]\"."}],"pos":[576425,576705],"yaml":true},{"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted. The access can be one of the `BindingFlags` such as `Public`, `NonPublic`, `Private`, `InvokeMethod`, `GetField`, and so on. The type of lookup need not be specified. If the type of lookup is omitted, `BindingFlags.Public` | `BindingFlags.Instance` | `BindingFlags.Static` are used.","nodes":[{"pos":[0,411],"content":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted. The access can be one of the `BindingFlags` such as `Public`, `NonPublic`, `Private`, `InvokeMethod`, `GetField`, and so on. The type of lookup need not be specified. If the type of lookup is omitted, `BindingFlags.Public` | `BindingFlags.Instance` | `BindingFlags.Static` are used.","nodes":[{"content":"A bitmask comprised of one or more <ph id=\"ph1\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> that specify how the search is conducted.","pos":[0,128],"source":"A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted."},{"content":"The access can be one of the <ph id=\"ph1\">`BindingFlags`</ph> such as <ph id=\"ph2\">`Public`</ph>, <ph id=\"ph3\">`NonPublic`</ph>, <ph id=\"ph4\">`Private`</ph>, <ph id=\"ph5\">`InvokeMethod`</ph>, <ph id=\"ph6\">`GetField`</ph>, and so on.","pos":[129,253],"source":" The access can be one of the `BindingFlags` such as `Public`, `NonPublic`, `Private`, `InvokeMethod`, `GetField`, and so on."},{"content":"The type of lookup need not be specified.","pos":[254,295]},{"content":"If the type of lookup is omitted, <ph id=\"ph1\">`BindingFlags.Public`</ph><ph id=\"ph2\"> | </ph><ph id=\"ph3\">`BindingFlags.Instance`</ph><ph id=\"ph4\"> | </ph><ph id=\"ph5\">`BindingFlags.Static`</ph> are used.","pos":[296,411],"source":" If the type of lookup is omitted, `BindingFlags.Public` | `BindingFlags.Instance` | `BindingFlags.Static` are used."}]}],"pos":[576788,577200],"yaml":true},{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \n  \n -or-  \n  \n A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>. Note that explicitly defining a <xref href=\"System.Reflection.Binder\"></xref> object may be required for successfully invoking method overloads with variable arguments.","nodes":[{"pos":[0,191],"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","nodes":[{"content":"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.","pos":[0,191]}]},{"pos":[198,202],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[209,482],"content":"A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>. Note that explicitly defining a <xref href=\"System.Reflection.Binder\"></xref> object may be required for successfully invoking method overloads with variable arguments.","nodes":[{"content":"A null reference (<ph id=\"ph1\">`Nothing`</ph> in Visual Basic), to use the <ph id=\"ph2\">&lt;xref href=\"System.Type.DefaultBinder\"&gt;&lt;/xref&gt;</ph>.","pos":[0,104],"source":"A null reference (`Nothing` in Visual Basic), to use the <xref href=\"System.Type.DefaultBinder\"></xref>."},{"content":"Note that explicitly defining a <ph id=\"ph1\">&lt;xref href=\"System.Reflection.Binder\"&gt;&lt;/xref&gt;</ph> object may be required for successfully invoking method overloads with variable arguments.","pos":[105,273],"source":" Note that explicitly defining a <xref href=\"System.Reflection.Binder\"></xref> object may be required for successfully invoking method overloads with variable arguments."}]}],"pos":[577273,577766],"yaml":true},{"content":"The object on which to invoke the specified member.","nodes":[{"pos":[0,51],"content":"The object on which to invoke the specified member.","nodes":[{"content":"The object on which to invoke the specified member.","pos":[0,51]}]}],"pos":[577828,577880],"yaml":true},{"content":"An array containing the arguments to pass to the member to invoke.","nodes":[{"pos":[0,66],"content":"An array containing the arguments to pass to the member to invoke.","nodes":[{"content":"An array containing the arguments to pass to the member to invoke.","pos":[0,66]}]}],"pos":[577942,578009],"yaml":true},{"content":"The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <xref href=\"System.String\"></xref> to a <xref href=\"System.Double\"></xref>.  \n  \n -or-  \n  \n A null reference (`Nothing` in Visual Basic) to use the current thread's <xref href=\"System.Globalization.CultureInfo\"></xref>.","nodes":[{"pos":[0,217],"content":"The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <ph id=\"ph1\">&lt;xref href=\"System.String\"&gt;&lt;/xref&gt;</ph> to a <ph id=\"ph2\">&lt;xref href=\"System.Double\"&gt;&lt;/xref&gt;</ph>.","source":"The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <xref href=\"System.String\"></xref> to a <xref href=\"System.Double\"></xref>."},{"pos":[224,228],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[235,362],"content":"A null reference (<ph id=\"ph1\">`Nothing`</ph> in Visual Basic) to use the current thread's <ph id=\"ph2\">&lt;xref href=\"System.Globalization.CultureInfo\"&gt;&lt;/xref&gt;</ph>.","source":"A null reference (`Nothing` in Visual Basic) to use the current thread's <xref href=\"System.Globalization.CultureInfo\"></xref>."}],"pos":[578091,578466],"yaml":true},{"content":"An object representing the return value of the invoked member.","nodes":[{"pos":[0,62],"content":"An object representing the return value of the invoked member.","nodes":[{"content":"An object representing the return value of the invoked member.","pos":[0,62]}]}],"pos":[578523,578586],"yaml":true},{"content":"<code>invokeAttr</code> does not contain `CreateInstance` and <code>name</code> is `null`.","nodes":[{"pos":[0,90],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> does not contain <ph id=\"ph2\">`CreateInstance`</ph> and <ph id=\"ph3\">&lt;code&gt;name&lt;/code&gt;</ph> is <ph id=\"ph4\">`null`</ph>.","source":"<code>invokeAttr</code> does not contain `CreateInstance` and <code>name</code> is `null`."}],"pos":[578740,578831],"yaml":true},{"content":"<code>invokeAttr</code> is not a valid <xref href=\"System.Reflection.BindingFlags\"></xref> attribute.  \n  \n -or-  \n  \n <code>invokeAttr</code> does not contain one of the following binding flags: `InvokeMethod`, `CreateInstance`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains `CreateInstance` combined with `InvokeMethod`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains both `GetField` and `SetField`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains both `GetProperty` and `SetProperty`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains `InvokeMethod` combined with `SetField` or `SetProperty`.  \n  \n -or-  \n  \n <code>invokeAttr</code> contains `SetField` and <code>args</code> has more than one element.  \n  \n -or-  \n  \n This method is called on a COM object and one of the following binding flags was not passed in: `BindingFlags.InvokeMethod`, `BindingFlags.GetProperty`, `BindingFlags.SetProperty`, `BindingFlags.PutDispProperty`, or `BindingFlags.PutRefDispProperty`.  \n  \n -or-  \n  \n One of the named parameter arrays contains a string that is `null`.","nodes":[{"pos":[0,101],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> is not a valid <ph id=\"ph2\">&lt;xref href=\"System.Reflection.BindingFlags\"&gt;&lt;/xref&gt;</ph> attribute.","source":"<code>invokeAttr</code> is not a valid <xref href=\"System.Reflection.BindingFlags\"></xref> attribute."},{"pos":[108,112],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[119,286],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> does not contain one of the following binding flags: <ph id=\"ph2\">`InvokeMethod`</ph>, <ph id=\"ph3\">`CreateInstance`</ph>, <ph id=\"ph4\">`GetField`</ph>, <ph id=\"ph5\">`SetField`</ph>, <ph id=\"ph6\">`GetProperty`</ph>, or <ph id=\"ph7\">`SetProperty`</ph>.","source":"<code>invokeAttr</code> does not contain one of the following binding flags: `InvokeMethod`, `CreateInstance`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`."},{"pos":[293,297],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[304,440],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id=\"ph2\">`CreateInstance`</ph> combined with <ph id=\"ph3\">`InvokeMethod`</ph>, <ph id=\"ph4\">`GetField`</ph>, <ph id=\"ph5\">`SetField`</ph>, <ph id=\"ph6\">`GetProperty`</ph>, or <ph id=\"ph7\">`SetProperty`</ph>.","source":"<code>invokeAttr</code> contains `CreateInstance` combined with `InvokeMethod`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`."},{"pos":[447,451],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[458,522],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains both <ph id=\"ph2\">`GetField`</ph> and <ph id=\"ph3\">`SetField`</ph>.","source":"<code>invokeAttr</code> contains both `GetField` and `SetField`."},{"pos":[529,533],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[540,610],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains both <ph id=\"ph2\">`GetProperty`</ph> and <ph id=\"ph3\">`SetProperty`</ph>.","source":"<code>invokeAttr</code> contains both `GetProperty` and `SetProperty`."},{"pos":[617,621],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[628,718],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id=\"ph2\">`InvokeMethod`</ph> combined with <ph id=\"ph3\">`SetField`</ph> or <ph id=\"ph4\">`SetProperty`</ph>.","source":"<code>invokeAttr</code> contains `InvokeMethod` combined with `SetField` or `SetProperty`."},{"pos":[725,729],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[736,828],"content":"<ph id=\"ph1\">&lt;code&gt;invokeAttr&lt;/code&gt;</ph> contains <ph id=\"ph2\">`SetField`</ph> and <ph id=\"ph3\">&lt;code&gt;args&lt;/code&gt;</ph> has more than one element.","source":"<code>invokeAttr</code> contains `SetField` and <code>args</code> has more than one element."},{"pos":[835,839],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[846,1096],"content":"This method is called on a COM object and one of the following binding flags was not passed in: <ph id=\"ph1\">`BindingFlags.InvokeMethod`</ph>, <ph id=\"ph2\">`BindingFlags.GetProperty`</ph>, <ph id=\"ph3\">`BindingFlags.SetProperty`</ph>, <ph id=\"ph4\">`BindingFlags.PutDispProperty`</ph>, or <ph id=\"ph5\">`BindingFlags.PutRefDispProperty`</ph>.","source":"This method is called on a COM object and one of the following binding flags was not passed in: `BindingFlags.InvokeMethod`, `BindingFlags.GetProperty`, `BindingFlags.SetProperty`, `BindingFlags.PutDispProperty`, or `BindingFlags.PutRefDispProperty`."},{"pos":[1103,1107],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[1114,1181],"content":"One of the named parameter arrays contains a string that is <ph id=\"ph1\">`null`</ph>.","source":"One of the named parameter arrays contains a string that is `null`."}],"pos":[578925,580143],"yaml":true},{"content":"The specified member is a class initializer.","nodes":[{"pos":[0,44],"content":"The specified member is a class initializer.","nodes":[{"content":"The specified member is a class initializer.","pos":[0,44]}]}],"pos":[580245,580290],"yaml":true},{"content":"The field or property cannot be found.","nodes":[{"pos":[0,38],"content":"The field or property cannot be found.","nodes":[{"content":"The field or property cannot be found.","pos":[0,38]}]}],"pos":[580392,580431],"yaml":true},{"content":"No method can be found that matches the arguments in <code>args</code>.  \n  \n -or-  \n  \n The current <xref href=\"System.Type\"></xref> object represents a type that contains open type parameters, that is, <xref href=\"System.Type.ContainsGenericParameters\"></xref> returns `true`.","nodes":[{"pos":[0,71],"content":"No method can be found that matches the arguments in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">args</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"No method can be found that matches the arguments in <code>args</code>."},{"pos":[78,82],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[89,278],"content":"The current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object represents a type that contains open type parameters, that is, <ph id=\"ph2\">&lt;xref href=\"System.Type.ContainsGenericParameters\"&gt;&lt;/xref&gt;</ph> returns <ph id=\"ph3\">`true`</ph>.","source":"The current <xref href=\"System.Type\"></xref> object represents a type that contains open type parameters, that is, <xref href=\"System.Type.ContainsGenericParameters\"></xref> returns `true`."}],"pos":[580535,580824],"yaml":true},{"content":"The specified member cannot be invoked on <code>target</code>.","nodes":[{"pos":[0,62],"content":"The specified member cannot be invoked on <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">target</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","source":"The specified member cannot be invoked on <code>target</code>."}],"pos":[580936,580999],"yaml":true},{"content":"More than one method matches the binding criteria.","nodes":[{"pos":[0,50],"content":"More than one method matches the binding criteria.","nodes":[{"content":"More than one method matches the binding criteria.","pos":[0,50]}]}],"pos":[581127,581178],"yaml":true},{"content":"The method represented by <code>name</code> has one or more unspecified generic type parameters. That is, the method's <xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"></xref> property returns `true`.","nodes":[{"pos":[0,219],"content":"The method represented by <code>name</code> has one or more unspecified generic type parameters. That is, the method's <xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"></xref> property returns `true`.","nodes":[{"content":"The method represented by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">name</ph><ept id=\"p1\">&lt;/code&gt;</ept> has one or more unspecified generic type parameters.","pos":[0,96],"source":"The method represented by <code>name</code> has one or more unspecified generic type parameters."},{"content":"That is, the method's <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"&gt;&lt;/xref&gt;</ph> property returns <ph id=\"ph2\">`true`</ph>.","pos":[97,219],"source":" That is, the method's <xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"></xref> property returns `true`."}]}],"pos":[581288,581508],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is abstract and must be overridden.","nodes":[{"pos":[0,104],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is abstract and must be overridden.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is abstract and must be overridden."}],"pos":[582549,582654],"yaml":true},{"content":"The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:  \n  \n-   The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes. In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.  \n  \n-   The current type is an interface.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.","nodes":[{"pos":[0,84],"content":"The <ph id=\"ph1\">&lt;xref:System.Type.IsAbstract%2A&gt;</ph> property returns <ph id=\"ph2\">`true`</ph> in the following cases:","source":"The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:"},{"pos":[94,466],"content":"The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes. In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.","nodes":[{"content":"The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.","pos":[0,123]},{"content":"In C#, abstract classes are marked with the <bpt id=\"p1\">[</bpt>abstract<ept id=\"p1\">](~/docs/csharp/language-reference/keywords/abstract.md)</ept> keyword; in Visual Basic, they are marked with the <bpt id=\"p2\">[</bpt>MustInherit<ept id=\"p2\">](~/docs/visual-basic/language-reference/modifiers/mustinherit.md)</ept> keyword.","pos":[124,372],"source":" In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword."}]},{"pos":[476,509],"content":"The current type is an interface.","nodes":[{"content":"The current type is an interface.","pos":[0,33]}]},{"pos":[516,670],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`."}],"pos":[582665,583344],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is abstract; otherwise, `false`.","nodes":[{"pos":[0,79],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is abstract; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is abstract; otherwise, `false`."}],"pos":[584499,584581],"yaml":true},{"content":"Gets a value indicating whether the string format attribute `AnsiClass` is selected for the <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,125],"content":"Gets a value indicating whether the string format attribute <ph id=\"ph1\">`AnsiClass`</ph> is selected for the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Gets a value indicating whether the string format attribute `AnsiClass` is selected for the <xref href=\"System.Type\"></xref>."}],"pos":[585664,585790],"yaml":true},{"content":"The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.  \n  \n If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \n  \n If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.","nodes":[{"pos":[0,199],"content":"The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.","nodes":[{"content":"The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.","pos":[0,199],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selects the string format attributes.","pos":[0,98],"source":"The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes."},{"content":"The string format attributes enhance interoperability by defining how strings should be interpreted.","pos":[99,199]}]}]},{"pos":[206,547],"content":"If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a generic type, this property pertains to the generic type definition from which the type was constructed.","pos":[0,151],"source":"If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed."},{"content":"For example, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents <ph id=\"ph2\">`MyGenericType&lt;int&gt;`</ph> (<ph id=\"ph3\">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id=\"ph4\">`MyGenericType&lt;T&gt;`</ph>.","pos":[152,341],"source":" For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`."}]},{"pos":[554,672],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`."}],"pos":[585801,586480],"yaml":true,"extradata":"MT"},{"content":"`true` if the string format attribute `AnsiClass` is selected for the <xref href=\"System.Type\"></xref>; otherwise, `false`.","nodes":[{"pos":[0,123],"content":"<ph id=\"ph1\">`true`</ph> if the string format attribute <ph id=\"ph2\">`AnsiClass`</ph> is selected for the <ph id=\"ph3\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id=\"ph4\">`false`</ph>.","source":"`true` if the string format attribute `AnsiClass` is selected for the <xref href=\"System.Type\"></xref>; otherwise, `false`."}],"pos":[587071,587197],"yaml":true},{"content":"Gets a value that indicates whether the type is an array.","nodes":[{"pos":[0,57],"content":"Gets a value that indicates whether the type is an array.","nodes":[{"content":"Gets a value that indicates whether the type is an array.","pos":[0,57]}]}],"pos":[588257,588315],"yaml":true},{"content":"The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class. It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.  \n  \n To check for an array, use code such as:  \n  \n```csharp  \ntypeof(Array).IsAssignableFrom(type)  \n```  \n  \n```vb  \nGetType(Array).IsAssignableFrom(type)  \n```  \n  \n If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.  \n  \n This property is read-only.","nodes":[{"pos":[0,357],"content":"The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class. It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.IsArray%2A&gt;</ph> property returns <ph id=\"ph2\">`false`</ph> for the <ph id=\"ph3\">&lt;xref:System.Array&gt;</ph> class.","pos":[0,93],"source":"The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class."},{"content":"It also returns <ph id=\"ph1\">`false`</ph> if the current instance is a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object that represents a collection type or an interface designed to work with collections, such as <ph id=\"ph3\">&lt;xref:System.Collections.IEnumerable&gt;</ph> or <ph id=\"ph4\">&lt;xref:System.Collections.Generic.IEnumerable%601&gt;</ph>.","pos":[94,357],"source":" It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>."}]},{"pos":[364,404],"content":"To check for an array, use code such as:","nodes":[{"content":"To check for an array, use code such as:","pos":[0,40]}]},{"pos":[528,687],"content":"If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph1\">`false`</ph>.","source":"If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`."},{"pos":[694,721],"content":"This property is read-only.","nodes":[{"content":"This property is read-only.","pos":[0,27]}]}],"pos":[588326,589064],"yaml":true,"extradata":"MT"},{"content":"`true` if the current type is an array; otherwise, `false`.","nodes":[{"pos":[0,59],"content":"<ph id=\"ph1\">`true`</ph> if the current type is an array; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the current type is an array; otherwise, `false`."}],"pos":[589536,589598],"yaml":true},{"content":"When overridden in a derived class, implements the <xref href=\"System.Type.IsArray\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is an array.","nodes":[{"pos":[0,173],"content":"When overridden in a derived class, implements the <ph id=\"ph1\">&lt;xref href=\"System.Type.IsArray\"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is an array.","source":"When overridden in a derived class, implements the <xref href=\"System.Type.IsArray\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is an array."}],"pos":[591026,591200],"yaml":true},{"content":"An instance of the <xref:System.Array> class must return `false` because it is an object, not an array.","nodes":[{"pos":[0,103],"content":"An instance of the <ph id=\"ph1\">&lt;xref:System.Array&gt;</ph> class must return <ph id=\"ph2\">`false`</ph> because it is an object, not an array.","source":"An instance of the <xref:System.Array> class must return `false` because it is an object, not an array."}],"pos":[591211,591315],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is an array; otherwise, `false`.","nodes":[{"pos":[0,79],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is an array; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is an array; otherwise, `false`."}],"pos":[591989,592071],"yaml":true},{"content":"Determines whether an instance of a specified type can be assigned to an instance of the current type.","nodes":[{"pos":[0,102],"content":"Determines whether an instance of a specified type can be assigned to an instance of the current type.","nodes":[{"content":"Determines whether an instance of a specified type can be assigned to an instance of the current type.","pos":[0,102]}]}],"pos":[593240,593343],"yaml":true},{"content":"The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.  \n  \n [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]\n [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  \n  \n This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:  \n  \n [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]\n [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  \n  \n This method can be overridden by a derived class.  \n  \n> [!NOTE]\n>  A generic type definition is not assignable from a closed constructed type. That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.  \n  \n If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built. The following code example demonstrates this using a built type named `B`.  \n  \n [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]\n [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]","nodes":[{"pos":[0,321],"content":"The <ph id=\"ph1\">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> method can be used to determine whether an instance of <ph id=\"ph2\">`c`</ph> can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.","source":"The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows."},{"pos":[328,633],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Type.IsAssignableFrom#3<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Type.IsAssignableFrom#3<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]\n [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]"},{"pos":[640,816],"content":"This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:","nodes":[{"content":"This method thus ensures that a line of code like the following will execute at runtime without throwing an <ph id=\"ph1\">&lt;xref:System.InvalidCastException&gt;</ph> exception or a similar exception:","pos":[0,176],"source":"This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:"}]},{"pos":[823,1128],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Type.IsAssignableFrom#4<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Type.IsAssignableFrom#4<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]\n [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]"},{"pos":[1135,1184],"content":"This method can be overridden by a derived class.","nodes":[{"content":"This method can be overridden by a derived class.","pos":[0,49]}]},{"pos":[1192,1442],"content":"[!NOTE]\n A generic type definition is not assignable from a closed constructed type. That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.","leadings":["","> "],"nodes":[{"content":" A generic type definition is not assignable from a closed constructed type. That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.","pos":[8,248],"nodes":[{"content":"A generic type definition is not assignable from a closed constructed type.","pos":[1,76]},{"content":"That is, you cannot assign the closed constructed type <ph id=\"ph1\">`MyGenericList&lt;int&gt;`</ph> (<ph id=\"ph2\">`MyGenericList(Of Integer)`</ph> in Visual Basic) to a variable of type <ph id=\"ph3\">`MyGenericList&lt;T&gt;`</ph>.","pos":[77,240],"source":" That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`."}]}]},{"pos":[1449,1651],"content":"If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built. The following code example demonstrates this using a built type named `B`.","nodes":[{"content":"If the <ph id=\"ph1\">`c`</ph> parameter is of type <ph id=\"ph2\">&lt;xref:System.Reflection.Emit.TypeBuilder&gt;</ph>, the result is based on the type that is to be built.","pos":[0,127],"source":"If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built."},{"content":"The following code example demonstrates this using a built type named <ph id=\"ph1\">`B`</ph>.","pos":[128,202],"source":" The following code example demonstrates this using a built type named `B`."}]},{"pos":[1658,1969],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Type.IsAssignableFrom#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Type.IsAssignableFrom#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)</ept><ept id=\"p3\">]</ept>","source":"[!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]\n [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]"}],"pos":[593354,595344],"yaml":true,"extradata":"MT"},{"content":"The type to compare with the current type.","nodes":[{"pos":[0,42],"content":"The type to compare with the current type.","nodes":[{"content":"The type to compare with the current type.","pos":[0,42]}]}],"pos":[596025,596068],"yaml":true},{"content":"`true` if any of the following conditions is true:  \n  \n-   <code>c</code> and the current instance represent the same type.  \n  \n-   <code>c</code> is derived either directly or indirectly from the current instance. <code>c</code> is derived directly from the current instance if it inherits from the current instance; <code>c</code> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.  \n  \n-   The current instance is an interface that <code>c</code> implements.  \n  \n-   <code>c</code> is a generic type parameter, and the current instance represents one of the constraints of <code>c</code>.  \n  \n     In the following example, the current instance is a <xref href=\"System.Type\"></xref> object that represents the <xref href=\"System.IO.Stream\"></xref> class. <code>GenericWithConstraint</code> is a generic type whose generic type parameter must be of type    <xref href=\"System.IO.Stream\"></xref>. Passing its generic type parameter to the <xref href=\"System.Type.IsAssignableFrom(System.Type)\"></xref> indicates that  an instance of the generic type parameter can be assigned to an <xref href=\"System.IO.Stream\"></xref> object.  \n  \n     [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]\n     [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  \n  \n-   <code>c</code> represents a value type, and the current instance represents <code>Nullable<c></code> (<code>Nullable(Of c)</code> in Visual Basic).  \n  \n `false` if none of these conditions are true, or if <code>c</code> is `null`.","nodes":[{"pos":[0,50],"content":"<ph id=\"ph1\">`true`</ph> if any of the following conditions is true:","source":"`true` if any of the following conditions is true:"},{"pos":[56,124],"content":"<ph id=\"ph1\">-   &lt;code&gt;c&lt;/code&gt;</ph> and the current instance represent the same type.","source":"-   <code>c</code> and the current instance represent the same type."},{"pos":[130,478],"content":"-   <code>c</code> is derived either directly or indirectly from the current instance. <code>c</code> is derived directly from the current instance if it inherits from the current instance; <code>c</code> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.","nodes":[{"content":"<ph id=\"ph1\">-   &lt;code&gt;c&lt;/code&gt;</ph> is derived either directly or indirectly from the current instance.","pos":[0,86],"source":"-   <code>c</code> is derived either directly or indirectly from the current instance."},{"content":"<ph id=\"ph1\">&lt;code&gt;c&lt;/code&gt;</ph> is derived directly from the current instance if it inherits from the current instance; <ph id=\"ph2\">&lt;code&gt;c&lt;/code&gt;</ph> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.","pos":[87,348],"source":"<code>c</code> is derived directly from the current instance if it inherits from the current instance; <code>c</code> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance."}]},{"pos":[488,556],"content":"The current instance is an interface that <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">c</ph><ept id=\"p1\">&lt;/code&gt;</ept> implements.","source":"The current instance is an interface that <code>c</code> implements."},{"pos":[562,687],"content":"<ph id=\"ph1\">-   &lt;code&gt;c&lt;/code&gt;</ph> is a generic type parameter, and the current instance represents one of the constraints of <ph id=\"ph2\">&lt;code&gt;c&lt;/code&gt;</ph>.","source":"-   <code>c</code> is a generic type parameter, and the current instance represents one of the constraints of <code>c</code>."},{"pos":[698,1225],"content":"In the following example, the current instance is a <xref href=\"System.Type\"></xref> object that represents the <xref href=\"System.IO.Stream\"></xref> class. <code>GenericWithConstraint</code> is a generic type whose generic type parameter must be of type    <xref href=\"System.IO.Stream\"></xref>. Passing its generic type parameter to the <xref href=\"System.Type.IsAssignableFrom(System.Type)\"></xref> indicates that  an instance of the generic type parameter can be assigned to an <xref href=\"System.IO.Stream\"></xref> object.","nodes":[{"content":"In the following example, the current instance is a <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object that represents the <ph id=\"ph2\">&lt;xref href=\"System.IO.Stream\"&gt;&lt;/xref&gt;</ph> class.","pos":[0,156],"source":"In the following example, the current instance is a <xref href=\"System.Type\"></xref> object that represents the <xref href=\"System.IO.Stream\"></xref> class."},{"content":"<bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">GenericWithConstraint</ph><ept id=\"p1\">&lt;/code&gt;</ept> is a generic type whose generic type parameter must be of type    <ph id=\"ph2\">&lt;xref href=\"System.IO.Stream\"&gt;&lt;/xref&gt;</ph>.","pos":[157,296],"source":"<code>GenericWithConstraint</code> is a generic type whose generic type parameter must be of type    <xref href=\"System.IO.Stream\"></xref>."},{"content":"Passing its generic type parameter to the <ph id=\"ph1\">&lt;xref href=\"System.Type.IsAssignableFrom(System.Type)\"&gt;&lt;/xref&gt;</ph> indicates that  an instance of the generic type parameter can be assigned to an <ph id=\"ph2\">&lt;xref href=\"System.IO.Stream\"&gt;&lt;/xref&gt;</ph> object.","pos":[297,527],"source":" Passing its generic type parameter to the <xref href=\"System.Type.IsAssignableFrom(System.Type)\"></xref> indicates that  an instance of the generic type parameter can be assigned to an <xref href=\"System.IO.Stream\"></xref> object."}]},{"pos":[1236,1545],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Type.IsAssignableFrom#2<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)</ept><ept id=\"p1\">]</ept>  <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Type.IsAssignableFrom#2<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)</ept><ept id=\"p3\">]</ept>","leadings":["","    "],"source":"[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]\n [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]"},{"pos":[1551,1702],"content":"<ph id=\"ph1\">-   &lt;code&gt;c&lt;/code&gt;</ph> represents a value type, and the current instance represents <ph id=\"ph2\">&lt;code&gt;</ph>Nullable<ph id=\"ph3\">&lt;c&gt;</ph><ph id=\"ph4\">&lt;/code&gt;</ph> (<ph id=\"ph5\">&lt;code&gt;Nullable(Of c)&lt;/code&gt;</ph> in Visual Basic).","source":"-   <code>c</code> represents a value type, and the current instance represents <code>Nullable<c></code> (<code>Nullable(Of c)</code> in Visual Basic)."},{"pos":[1709,1786],"content":"<ph id=\"ph1\">`false`</ph> if none of these conditions are true, or if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">c</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph3\">`null`</ph>.","source":"`false` if none of these conditions are true, or if <code>c</code> is `null`."}],"pos":[596126,597942],"yaml":true},{"content":"Gets a value indicating whether the string format attribute `AutoClass` is selected for the <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,125],"content":"Gets a value indicating whether the string format attribute <ph id=\"ph1\">`AutoClass`</ph> is selected for the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Gets a value indicating whether the string format attribute `AutoClass` is selected for the <xref href=\"System.Type\"></xref>."}],"pos":[599031,599157],"yaml":true},{"content":"The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \n  \n If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.","nodes":[{"pos":[0,199],"content":"The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.","nodes":[{"content":"The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.","pos":[0,199],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> selects the string format attributes.","pos":[0,98],"source":"The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes."},{"content":"The string format attributes enhance interoperability by defining how strings should be interpreted.","pos":[99,199]}]}]},{"pos":[206,558],"content":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.","pos":[0,162],"source":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed."},{"content":"For example, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents <ph id=\"ph2\">`MyGenericType&lt;int&gt;`</ph> (<ph id=\"ph3\">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id=\"ph4\">`MyGenericType&lt;T&gt;`</ph>.","pos":[163,352],"source":" For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`."}]},{"pos":[565,683],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`."}],"pos":[599168,599858],"yaml":true,"extradata":"MT"},{"content":"`true` if the string format attribute `AutoClass` is selected for the <xref href=\"System.Type\"></xref>; otherwise, `false`.","nodes":[{"pos":[0,123],"content":"<ph id=\"ph1\">`true`</ph> if the string format attribute <ph id=\"ph2\">`AutoClass`</ph> is selected for the <ph id=\"ph3\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id=\"ph4\">`false`</ph>.","source":"`true` if the string format attribute `AutoClass` is selected for the <xref href=\"System.Type\"></xref>; otherwise, `false`."}],"pos":[599972,600098],"yaml":true},{"content":"Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.","nodes":[{"pos":[0,121],"content":"Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.","nodes":[{"content":"Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.","pos":[0,121]}]}],"pos":[601188,601310],"yaml":true},{"content":"This property is provided as a convenience. Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set. The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>,<xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory.  \n  \n For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type. In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.  \n  \n> [!NOTE]\n>  You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.","nodes":[{"pos":[0,576],"content":"This property is provided as a convenience. Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set. The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>,<xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory.","nodes":[{"content":"This property is provided as a convenience. Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set. The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>,<xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory.","pos":[0,576],"nodes":[{"content":"This property is provided as a convenience.","pos":[0,43]},{"content":"Alternatively, you can use the <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>enumeration value to select the type layout attributes, and then test whether <ph id=\"ph2\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> is set.","pos":[44,289],"source":" Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>,<ph id=\"ph2\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.","pos":[290,576],"source":" The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>,<xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory."}]}]},{"pos":[583,982],"content":"For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type. In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.","nodes":[{"content":"For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type. In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.","pos":[0,399],"nodes":[{"content":"For dynamic types, you can specify <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> when you create the type.","pos":[0,125],"source":"For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type."},{"content":"In code, apply the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.","pos":[126,399],"source":" In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class."}]}]},{"pos":[990,1198],"content":"[!NOTE]\n You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.","leadings":["","> "],"nodes":[{"content":"You cannot use the <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.","pos":[9,206],"source":" You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type."}]},{"pos":[1205,1557],"content":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.","pos":[0,162],"source":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed."},{"content":"For example, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents <ph id=\"ph2\">`MyGenericType&lt;int&gt;`</ph> (<ph id=\"ph3\">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id=\"ph4\">`MyGenericType&lt;T&gt;.`</ph>","pos":[163,352],"source":" For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`"}]},{"pos":[1564,1718],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`."}],"pos":[601321,603051],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type.Attributes\"></xref> property of the current type includes <xref href=\"System.Reflection.TypeAttributes.AutoLayout\"></xref>; otherwise, `false`.","nodes":[{"pos":[0,181],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type.Attributes\"&gt;&lt;/xref&gt;</ph> property of the current type includes <ph id=\"ph3\">&lt;xref href=\"System.Reflection.TypeAttributes.AutoLayout\"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id=\"ph4\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type.Attributes\"></xref> property of the current type includes <xref href=\"System.Reflection.TypeAttributes.AutoLayout\"></xref>; otherwise, `false`."}],"pos":[603677,603861],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is passed by reference.","nodes":[{"pos":[0,92],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is passed by reference.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is passed by reference."}],"pos":[604922,605015],"yaml":true},{"content":"To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.","nodes":[{"pos":[0,142],"content":"To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.","nodes":[{"content":"To get to the actual type, dereference the type that was passed by reference, and then call <ph id=\"ph1\">&lt;xref:System.Type.GetElementType%2A&gt;</ph> on that type.","pos":[0,142],"source":"To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type."}]}],"pos":[605026,605169],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is passed by reference; otherwise, `false`.","nodes":[{"pos":[0,90],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is passed by reference; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is passed by reference; otherwise, `false`."}],"pos":[606038,606131],"yaml":true},{"content":"When overridden in a derived class, implements the <xref href=\"System.Type.IsByRef\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is passed by reference.","nodes":[{"pos":[0,184],"content":"When overridden in a derived class, implements the <ph id=\"ph1\">&lt;xref href=\"System.Type.IsByRef\"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is passed by reference.","source":"When overridden in a derived class, implements the <xref href=\"System.Type.IsByRef\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is passed by reference."}],"pos":[607559,607744],"yaml":true},{"content":"`true` if the <xref href=\"System.Type\"></xref> is passed by reference; otherwise, `false`.","nodes":[{"pos":[0,90],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is passed by reference; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is passed by reference; otherwise, `false`."}],"pos":[607884,607977],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is a class or a delegate; that is, not a value type or interface.","nodes":[{"pos":[0,134],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a class or a delegate; that is, not a value type or interface.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is a class or a delegate; that is, not a value type or interface."}],"pos":[609037,609172],"yaml":true},{"content":"This property returns `true` for classes as well as delegates. It returns `false` for value types (for structures and enumerations) even if they are boxed.  \n  \n If the current<xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type.  \n  \n> [!NOTE]\n>  This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes. These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves. For more information, see the <xref:System.Type.IsValueType%2A>and <xref:System.Type.IsEnum%2A> properties.  \n  \n The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> attribute. If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property. The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.  \n  \n This property is read-only.","nodes":[{"pos":[0,155],"content":"This property returns `true` for classes as well as delegates. It returns `false` for value types (for structures and enumerations) even if they are boxed.","nodes":[{"content":"This property returns <ph id=\"ph1\">`true`</ph> for classes as well as delegates.","pos":[0,62],"source":"This property returns `true` for classes as well as delegates."},{"content":"It returns <ph id=\"ph1\">`false`</ph> for value types (for structures and enumerations) even if they are boxed.","pos":[63,155],"source":" It returns `false` for value types (for structures and enumerations) even if they are boxed."}]},{"pos":[162,527],"content":"If the current<ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`true`</ph>.If the current <ph id=\"ph3\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns <ph id=\"ph4\">`true`</ph> if the generic type definition is a class definition; that is, it does not define an interface or a value type.","source":"If the current<xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type."},{"pos":[535,920],"content":"[!NOTE]\n This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes. These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves. For more information, see the <xref:System.Type.IsValueType%2A>and <xref:System.Type.IsEnum%2A> properties.","leadings":["","> "],"nodes":[{"content":" This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes. These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves. For more information, see the <xref:System.Type.IsValueType%2A>and <xref:System.Type.IsEnum%2A> properties.","pos":[8,383],"nodes":[{"content":"This property returns <ph id=\"ph1\">`true`</ph> for <ph id=\"ph2\">`Type`</ph> instances that represent the <ph id=\"ph3\">&lt;xref:System.Enum&gt;</ph> and <ph id=\"ph4\">&lt;xref:System.ValueType&gt;</ph> classes.","pos":[1,125],"source":" This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes."},{"content":"These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.","pos":[126,267]},{"content":"For more information, see the <ph id=\"ph1\">&lt;xref:System.Type.IsValueType%2A&gt;</ph>and <ph id=\"ph2\">&lt;xref:System.Type.IsEnum%2A&gt;</ph> properties.","pos":[268,375],"source":" For more information, see the <xref:System.Type.IsValueType%2A>and <xref:System.Type.IsEnum%2A> properties."}]}]},{"pos":[927,1600],"content":"The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> attribute. If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property. The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.","nodes":[{"content":"The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> attribute. If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property. The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.","pos":[0,673],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <ph id=\"ph2\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> attribute.","pos":[0,275],"source":"The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> attribute."},{"content":"If you retrieve the value of a type's Attributes property and use the <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> value to determine whether a type is a class instead of a value type, you must also call the <ph id=\"ph2\">&lt;xref:System.Type.IsValueType%2A&gt;</ph> property.","pos":[276,547],"source":" If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property."},{"content":"The example for the <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes&gt;</ph> enumeration contains additional information as well as anexample.","pos":[548,673],"source":" The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample."}]}]},{"pos":[1607,1634],"content":"This property is read-only.","nodes":[{"content":"This property is read-only.","pos":[0,27]}]}],"pos":[609183,610829],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is a class; otherwise, `false`.","nodes":[{"pos":[0,78],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a class; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is a class; otherwise, `false`."}],"pos":[611384,611465],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is a COM object.","nodes":[{"pos":[0,85],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a COM object.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is a COM object."}],"pos":[612545,612631],"yaml":true},{"content":"This method returns `false` for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.  \n  \n You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.","nodes":[{"pos":[0,147],"content":"This method returns `false` for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.","nodes":[{"content":"This method returns <ph id=\"ph1\">`false`</ph> for COM interfaces because they are not objects.","pos":[0,76],"source":"This method returns `false` for COM interfaces because they are not objects."},{"content":"COM interfaces can be implemented by Microsoft .NET Framework objects.","pos":[77,147]}]},{"pos":[154,342],"content":"You can also load a COM class and get a <ph id=\"ph1\">`Type`</ph> object for that COM class by using the <bpt id=\"p1\">[</bpt>Tlbimp.exe (Type Library Importer)<ept id=\"p1\">](~/docs/framework/tools/tlbimp-exe-type-library-importer.md)</ept> tool.","source":"You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool."},{"pos":[349,701],"content":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.","pos":[0,162],"source":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed."},{"content":"For example, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents <ph id=\"ph2\">`MyGenericType&lt;int`</ph>&gt; (<ph id=\"ph3\">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id=\"ph4\">`MyGenericType&lt;T&gt;`</ph>.","pos":[163,352],"source":" For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`."}]},{"pos":[708,862],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`."}],"pos":[612642,613513],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is a COM object; otherwise, `false`.","nodes":[{"pos":[0,83],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a COM object; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is a COM object; otherwise, `false`."}],"pos":[613627,613713],"yaml":true},{"content":"When overridden in a derived class, implements the <xref href=\"System.Type.IsCOMObject\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is a COM object.","nodes":[{"pos":[0,181],"content":"When overridden in a derived class, implements the <ph id=\"ph1\">&lt;xref href=\"System.Type.IsCOMObject\"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a COM object.","source":"When overridden in a derived class, implements the <xref href=\"System.Type.IsCOMObject\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is a COM object."}],"pos":[614825,615007],"yaml":true},{"content":"This method returns `false` for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.","nodes":[{"pos":[0,147],"content":"This method returns `false` for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.","nodes":[{"content":"This method returns <ph id=\"ph1\">`false`</ph> for COM interfaces because they are not objects.","pos":[0,76],"source":"This method returns `false` for COM interfaces because they are not objects."},{"content":"COM interfaces can be implemented by Microsoft .NET Framework objects.","pos":[77,147]}]}],"pos":[615018,615166],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is a COM object; otherwise, `false`.","nodes":[{"pos":[0,83],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a COM object; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is a COM object; otherwise, `false`."}],"pos":[615310,615396],"yaml":true},{"content":"Gets a value that indicates whether this object represents a constructed generic type. You can create instances of a constructed generic type.","nodes":[{"pos":[0,142],"content":"Gets a value that indicates whether this object represents a constructed generic type. You can create instances of a constructed generic type.","nodes":[{"content":"Gets a value that indicates whether this object represents a constructed generic type. You can create instances of a constructed generic type.","pos":[0,142],"nodes":[{"content":"Gets a value that indicates whether this object represents a constructed generic type.","pos":[0,86]},{"content":"You can create instances of a constructed generic type.","pos":[87,142]}]}]}],"pos":[616562,616705],"yaml":true},{"content":"A constructed generic type has had explicit types supplied for all of its generic type parameters. It is also referred to as a closed generic type.  \n  \n When this property is `true`, you can create instances of the current type; when it is `false`, you can't.","nodes":[{"pos":[0,147],"content":"A constructed generic type has had explicit types supplied for all of its generic type parameters. It is also referred to as a closed generic type.","nodes":[{"content":"A constructed generic type has had explicit types supplied for all of its generic type parameters. It is also referred to as a closed generic type.","pos":[0,147],"nodes":[{"content":"A constructed generic type has had explicit types supplied for all of its generic type parameters.","pos":[0,98]},{"content":"It is also referred to as a closed generic type.","pos":[99,147]}]}]},{"pos":[154,260],"content":"When this property is <ph id=\"ph1\">`true`</ph>, you can create instances of the current type; when it is <ph id=\"ph2\">`false`</ph>, you can't.","source":"When this property is `true`, you can create instances of the current type; when it is `false`, you can't."}],"pos":[616716,616981],"yaml":true,"extradata":"MT"},{"content":"`true` if this object represents a constructed generic type; otherwise, `false`.","nodes":[{"pos":[0,80],"content":"<ph id=\"ph1\">`true`</ph> if this object represents a constructed generic type; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if this object represents a constructed generic type; otherwise, `false`."}],"pos":[617116,617199],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> can be hosted in a context.","nodes":[{"pos":[0,96],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> can be hosted in a context.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> can be hosted in a context."}],"pos":[618646,618743],"yaml":true},{"content":"A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization. For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.","nodes":[{"pos":[0,230],"content":"A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization. For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.","nodes":[{"content":"A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization. For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.","pos":[0,230],"nodes":[{"content":"A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.","pos":[0,125]},{"content":"For more detailed information on remoting contexts, see <ph id=\"ph1\">&lt;xref:System.Runtime.Remoting.Contexts.Context&gt;</ph>.","pos":[126,230],"source":" For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>."}]}]},{"pos":[237,391],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`."}],"pos":[618754,619150],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> can be hosted in a context; otherwise, `false`.","nodes":[{"pos":[0,94],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> can be hosted in a context; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> can be hosted in a context; otherwise, `false`."}],"pos":[619987,620084],"yaml":true},{"content":"Implements the <xref href=\"System.Type.IsContextful\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> can be hosted in a context.","nodes":[{"pos":[0,157],"content":"Implements the <ph id=\"ph1\">&lt;xref href=\"System.Type.IsContextful\"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> can be hosted in a context.","source":"Implements the <xref href=\"System.Type.IsContextful\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> can be hosted in a context."}],"pos":[621203,621361],"yaml":true},{"content":"This method can be overridden by a derived class.  \n  \n A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.","nodes":[{"pos":[0,49],"content":"This method can be overridden by a derived class.","nodes":[{"content":"This method can be overridden by a derived class.","pos":[0,49]}]},{"pos":[56,180],"content":"A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.","nodes":[{"content":"A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.","pos":[0,124]}]}],"pos":[621372,621557],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> can be hosted in a context; otherwise, `false`.","nodes":[{"pos":[0,94],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> can be hosted in a context; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> can be hosted in a context; otherwise, `false`."}],"pos":[622207,622304],"yaml":true},{"content":"Gets a value indicating whether the current <xref href=\"System.Type\"></xref> represents an enumeration.","nodes":[{"pos":[0,103],"content":"Gets a value indicating whether the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> represents an enumeration.","source":"Gets a value indicating whether the current <xref href=\"System.Type\"></xref> represents an enumeration."}],"pos":[623363,623467],"yaml":true},{"content":"This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.  \n  \n This property is read-only.","nodes":[{"pos":[0,96],"content":"This property returns <ph id=\"ph1\">`true`</ph> for an enumeration, but not for the <ph id=\"ph2\">&lt;xref:System.Enum&gt;</ph> type itself.","source":"This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself."},{"pos":[103,455],"content":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.","pos":[0,162],"source":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed."},{"content":"For example, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents <ph id=\"ph2\">`MyGenericType&lt;int&gt;`</ph> (<ph id=\"ph3\">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id=\"ph4\">`MyGenericType&lt;T&gt;`</ph>.","pos":[163,352],"source":" For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`."}]},{"pos":[462,616],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`."},{"pos":[623,650],"content":"This property is read-only.","nodes":[{"content":"This property is read-only.","pos":[0,27]}]}],"pos":[623478,624137],"yaml":true,"extradata":"MT"},{"content":"`true` if the current <xref href=\"System.Type\"></xref> represents an enumeration; otherwise, `false`.","nodes":[{"pos":[0,101],"content":"<ph id=\"ph1\">`true`</ph> if the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> represents an enumeration; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the current <xref href=\"System.Type\"></xref> represents an enumeration; otherwise, `false`."}],"pos":[624655,624759],"yaml":true},{"content":"Returns a value that indicates whether the specified value exists in the current enumeration type.","nodes":[{"pos":[0,98],"content":"Returns a value that indicates whether the specified value exists in the current enumeration type.","nodes":[{"content":"Returns a value that indicates whether the specified value exists in the current enumeration type.","pos":[0,98]}]}],"pos":[625917,626016],"yaml":true},{"content":"The value to be tested.","nodes":[{"pos":[0,23],"content":"The value to be tested.","nodes":[{"content":"The value to be tested.","pos":[0,23]}]}],"pos":[626166,626190],"yaml":true},{"content":"`true` if the specified value is a member of the current enumeration type; otherwise, `false`.","nodes":[{"pos":[0,94],"content":"<ph id=\"ph1\">`true`</ph> if the specified value is a member of the current enumeration type; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the specified value is a member of the current enumeration type; otherwise, `false`."}],"pos":[626248,626345],"yaml":true},{"content":"The current type is not an enumeration.","nodes":[{"pos":[0,39],"content":"The current type is not an enumeration.","nodes":[{"content":"The current type is not an enumeration.","pos":[0,39]}]}],"pos":[626492,626532],"yaml":true},{"content":"<code>value</code> is `null`.","nodes":[{"pos":[0,29],"content":"<ph id=\"ph1\">&lt;code&gt;value&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>value</code> is `null`."}],"pos":[626634,626664],"yaml":true},{"content":"<code>value</code> is of a type that cannot be the underlying type of an enumeration.","nodes":[{"pos":[0,85],"content":"<ph id=\"ph1\">&lt;code&gt;value&lt;/code&gt;</ph> is of a type that cannot be the underlying type of an enumeration.","source":"<code>value</code> is of a type that cannot be the underlying type of an enumeration."}],"pos":[626774,626860],"yaml":true},{"content":"Determines whether two COM types have the same identity and are eligible for type equivalence.","nodes":[{"pos":[0,94],"content":"Determines whether two COM types have the same identity and are eligible for type equivalence.","nodes":[{"content":"Determines whether two COM types have the same identity and are eligible for type equivalence.","pos":[0,94]}]}],"pos":[627963,628058],"yaml":true},{"content":"Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies. Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type. Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type. The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.  \n  \n Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly. The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.  \n  \n For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).","nodes":[{"pos":[0,745],"content":"Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies. Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type. Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type. The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.","nodes":[{"content":"Beginning with the <ph id=\"ph1\">[!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]</ph>, the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.","pos":[0,304],"source":"Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies."},{"content":"Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.","pos":[305,501]},{"content":"Each managed assembly has a different <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object to represent its view of the COM type.","pos":[502,604],"source":" Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type."},{"content":"The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.","pos":[605,745]}]},{"pos":[752,1165],"content":"Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly. The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.","nodes":[{"content":"Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly. The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.","pos":[0,413],"nodes":[{"content":"Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.","pos":[0,163]},{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.IsEquivalentTo%2A&gt;</ph> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.","pos":[164,413],"source":" The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type."}]}]},{"pos":[1172,1317],"content":"For more information, see <bpt id=\"p1\">[</bpt>Type Equivalence and Embedded Interop Types<ept id=\"p1\">](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)</ept>.","source":"For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md)."}],"pos":[628069,629393],"yaml":true,"extradata":"MT"},{"content":"The COM type that is tested for equivalence with the current type.","nodes":[{"pos":[0,66],"content":"The COM type that is tested for equivalence with the current type.","nodes":[{"content":"The COM type that is tested for equivalence with the current type.","pos":[0,66]}]}],"pos":[629540,629607],"yaml":true},{"content":"`true` if the COM types are equivalent; otherwise, `false`. This method also returns `false` if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.","nodes":[{"pos":[0,233],"content":"`true` if the COM types are equivalent; otherwise, `false`. This method also returns `false` if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the COM types are equivalent; otherwise, <ph id=\"ph2\">`false`</ph>.","pos":[0,59],"source":"`true` if the COM types are equivalent; otherwise, `false`."},{"content":"This method also returns <ph id=\"ph1\">`false`</ph> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.","pos":[60,233],"source":" This method also returns `false` if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context."}]}],"pos":[629665,629901],"yaml":true},{"content":"Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.","nodes":[{"pos":[0,108],"content":"Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.","nodes":[{"content":"Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.","pos":[0,108]}]}],"pos":[631018,631127],"yaml":true},{"content":"This property is provided as a convenience. Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set. The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory.  \n  \n For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type. In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.  \n  \n> [!NOTE]\n>  You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.","nodes":[{"pos":[0,577],"content":"This property is provided as a convenience. Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set. The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory.","nodes":[{"content":"This property is provided as a convenience. Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set. The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory.","pos":[0,577],"nodes":[{"content":"This property is provided as a convenience.","pos":[0,43]},{"content":"Alternatively, you can use the <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>enumeration value to select the type layout attributes, and then test whether <ph id=\"ph2\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> is set.","pos":[44,289],"source":" Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.","pos":[290,577],"source":" The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory."}]}]},{"pos":[584,992],"content":"For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type. In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.","nodes":[{"content":"For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type. In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.","pos":[0,408],"nodes":[{"content":"For dynamic types, you can specify <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> when you create the type.","pos":[0,125],"source":"For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type."},{"content":"In code, apply the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.","pos":[126,408],"source":" In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly."}]}]},{"pos":[1000,1208],"content":"[!NOTE]\n You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.","leadings":["","> "],"nodes":[{"content":"You cannot use the <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.","pos":[9,206],"source":" You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type."}]},{"pos":[1215,1567],"content":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.","pos":[0,162],"source":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed."},{"content":"For example, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents <ph id=\"ph2\">`MyGenericType&lt;int&gt;`</ph> (<ph id=\"ph3\">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id=\"ph4\">`MyGenericType&lt;T&gt;`</ph>.","pos":[163,352],"source":" For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`."}]},{"pos":[1574,1728],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`."}],"pos":[631138,632878],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type.Attributes\"></xref> property of the current type includes <xref href=\"System.Reflection.TypeAttributes.ExplicitLayout\"></xref>; otherwise, `false`.","nodes":[{"pos":[0,185],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type.Attributes\"&gt;&lt;/xref&gt;</ph> property of the current type includes <ph id=\"ph3\">&lt;xref href=\"System.Reflection.TypeAttributes.ExplicitLayout\"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id=\"ph4\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type.Attributes\"></xref> property of the current type includes <xref href=\"System.Reflection.TypeAttributes.ExplicitLayout\"></xref>; otherwise, `false`."}],"pos":[633559,633747],"yaml":true},{"content":"Gets a value indicating whether the current <xref href=\"System.Type\"></xref> represents a type parameter in the definition of a generic type or method.","nodes":[{"pos":[0,151],"content":"Gets a value indicating whether the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> represents a type parameter in the definition of a generic type or method.","source":"Gets a value indicating whether the current <xref href=\"System.Type\"></xref> represents a type parameter in the definition of a generic type or method."}],"pos":[634878,635030],"yaml":true},{"content":"<xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.  \n  \n-   For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array.  \n  \n-   For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method.  \n  \n-   For an open constructed type or method, some elements of the array might be specific types and others might be type parameters. <xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters. The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.  \n  \n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"pos":[0,385],"content":"<xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> objects that represent generic type parameters can be obtained by calling the <ph id=\"ph2\">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method of a <ph id=\"ph3\">&lt;xref:System.Type&gt;</ph> object that represents a generic type definition, or the <ph id=\"ph4\">&lt;xref:System.Reflection.MethodInfo.GetGenericArguments%2A&gt;</ph> method of a <ph id=\"ph5\">&lt;xref:System.Reflection.MethodInfo&gt;</ph> object that represents a generic method definition.","pos":[0,385],"source":"<xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition."}]},{"pos":[395,546],"content":"For a generic type or method definition, the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id=\"ph2\">`true`</ph> for every element of the resulting array.","source":"For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array."},{"pos":[556,763],"content":"For a closed constructed type or method, the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property returns <ph id=\"ph2\">`false`</ph> for every element of the array returned by the <ph id=\"ph3\">&lt;xref:System.Type.GetGenericArguments%2A&gt;</ph> method.","source":"For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method."},{"pos":[773,1163],"content":"For an open constructed type or method, some elements of the array might be specific types and others might be type parameters. <xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters. The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.","nodes":[{"content":"For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.","pos":[0,127]},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> returns <ph id=\"ph2\">`false`</ph> for the types and <ph id=\"ph3\">`true`</ph> for the type parameters.","pos":[128,234],"source":" <xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters."},{"content":"The code example for the <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property demonstrates a generic class with a mixture of types and type parameters.","pos":[235,390],"source":" The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters."}]},{"pos":[1170,1308],"content":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"content":"For a list of the invariant conditions for terms used in generic reflection, see the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.","pos":[0,138],"source":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks."}]}],"pos":[635041,636360],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> object represents a type parameter of a generic type definition or generic method definition; otherwise, `false`.","nodes":[{"pos":[0,160],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object represents a type parameter of a generic type definition or generic method definition; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> object represents a type parameter of a generic type definition or generic method definition; otherwise, `false`."}],"pos":[637086,637249],"yaml":true},{"content":"Gets a value indicating whether the current type is a generic type.","nodes":[{"pos":[0,67],"content":"Gets a value indicating whether the current type is a generic type.","nodes":[{"content":"Gets a value indicating whether the current type is a generic type.","pos":[0,67]}]}],"pos":[638696,638764],"yaml":true},{"content":"Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type. Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.  \n  \n> [!NOTE]\n>  The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic. For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.  \n  \n The following table summarizes the invariant conditions for common terms used in generic reflection.  \n  \n|Term|Invariant|  \n|----------|---------------|  \n|generic type definition|The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.<br /><br /> Defines a generic type. A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.<br /><br /> <xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.<br /><br /> Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.|  \n|generic type|The <xref:System.Type.IsGenericType%2A> property is `true`.<br /><br /> Can be a generic type definition, an open constructed type, or a closed constructed type.<br /><br /> Note that an array type whose element type is generic is not itself a generic type. The same is true of a <xref:System.Type> object representing a pointer to a generic type.|  \n|open constructed type|The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.<br /><br /> Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.<br /><br /> It is not possible to create an instance of an open constructed type.<br /><br /> Note that not all open constructed types are generic. For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.|  \n|closed constructed type|The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.<br /><br /> When examined recursively, the type has no unassigned generic parameters.|  \n|generic type parameter|The <xref:System.Type.IsGenericParameter%2A> property is `true`.<br /><br /> The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.<br /><br /> In a generic type definition, a placeholder for a type that will be assigned later.|  \n|generic type argument|Can be any type, including a generic type parameter.<br /><br /> Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type. If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.|  \n  \n The following code example and table illustrate some of these terms and invariants. The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.  \n  \n [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]\n [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]\n [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  \n  \n The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`. When the C++ and C# code is the same, only one entry is shown.  \n  \n|Example|Invariants|  \n|-------------|----------------|  \n|`Derived(Of V)`<br /><br /> `Derived<V>`|For this type:<br /><br /> <xref:System.Type.IsGenericType%2A> is `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true`.|  \n|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|For this type:<br /><br /> <xref:System.Type.IsGenericType%2A> is `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true`.|  \n|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|For the type of variable `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `false`.|  \n|`T`, `U`, and `V` (everywhere they appear)|<xref:System.Type.IsGenericParameter%2A> is `true`.<br /><br /> <xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters. This does not imply anything about type arguments that are assigned to them later.|  \n|The type of field `F`|<xref:System.Type.IsGenericType%2A> is `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to to the type parameter of `G`. Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type. The constructed type is open because its type argument (that is, `Base`) is a generic type definition. This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.|  \n|The nested class `Nested`|<xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `true`. That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters. This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.|","nodes":[{"pos":[0,308],"content":"Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type. Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.","nodes":[{"content":"Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type. Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.","pos":[0,308],"nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property to determine whether a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object represents a generic type.","pos":[0,128],"source":"Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property to determine whether a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object represents an open constructed type or a closed constructed type.","pos":[129,308],"source":" Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type."}]}]},{"pos":[316,551],"content":"[!NOTE]\n The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic. For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.","leadings":["","> "],"nodes":[{"content":" The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic. For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.","pos":[8,233],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property returns <ph id=\"ph2\">`false`</ph> if the immediate type is not generic.","pos":[1,103],"source":" The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic."},{"content":"For example, an array whose elements are of type <ph id=\"ph1\">`A&lt;int&gt;`</ph> (<ph id=\"ph2\">`A(Of Integer)`</ph> in Visual Basic) is not itself a generic type.","pos":[104,225],"source":" For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type."}]}]},{"pos":[558,658],"content":"The following table summarizes the invariant conditions for common terms used in generic reflection.","nodes":[{"content":"The following table summarizes the invariant conditions for common terms used in generic reflection.","pos":[0,100]}]},{"pos":[665,669],"content":"Term","nodes":[{"content":"Term","pos":[0,4]}]},{"pos":[670,679],"content":"Invariant","nodes":[{"content":"Invariant","pos":[0,9]}]},{"pos":[715,738],"content":"generic type definition","nodes":[{"content":"generic type definition","pos":[0,23]}]},{"pos":[739,1298],"content":"The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.<br /><br /> Defines a generic type. A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.<br /><br /> <xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.<br /><br /> Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property is <ph id=\"ph2\">`true`</ph>.","pos":[0,69],"source":"The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`."},{"content":" Defines a generic type. A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.","pos":[81,311],"nodes":[{"content":"Defines a generic type.","pos":[1,24]},{"content":"A constructed type is created by calling the <ph id=\"ph1\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object that represents a generic type definition and specifying an array of type arguments.","pos":[25,230],"source":" A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments."}]},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> can be called only on generic type definitions.","pos":[324,409],"source":" <xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions."},{"content":"Any generic type definition is a generic type (the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property is <ph id=\"ph2\">`true`</ph>), but the converse is not true.","pos":[422,559],"source":" Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true."}]},{"pos":[1303,1315],"content":"generic type","nodes":[{"content":"generic type","pos":[0,12]}]},{"pos":[1316,1663],"content":"The <xref:System.Type.IsGenericType%2A> property is `true`.<br /><br /> Can be a generic type definition, an open constructed type, or a closed constructed type.<br /><br /> Note that an array type whose element type is generic is not itself a generic type. The same is true of a <xref:System.Type> object representing a pointer to a generic type.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property is <ph id=\"ph2\">`true`</ph>.","pos":[0,59],"source":"The <xref:System.Type.IsGenericType%2A> property is `true`."},{"content":"Can be a generic type definition, an open constructed type, or a closed constructed type.","pos":[72,161]},{"content":" Note that an array type whose element type is generic is not itself a generic type. The same is true of a <xref:System.Type> object representing a pointer to a generic type.","pos":[173,347],"nodes":[{"content":"Note that an array type whose element type is generic is not itself a generic type.","pos":[1,84]},{"content":"The same is true of a <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object representing a pointer to a generic type.","pos":[85,174],"source":" The same is true of a <xref:System.Type> object representing a pointer to a generic type."}]}]},{"pos":[1668,1689],"content":"open constructed type","nodes":[{"content":"open constructed type","pos":[0,21]}]},{"pos":[1690,2338],"content":"The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.<br /><br /> Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.<br /><br /> It is not possible to create an instance of an open constructed type.<br /><br /> Note that not all open constructed types are generic. For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id=\"ph2\">`true`</ph>.","pos":[0,71],"source":"The <xref:System.Type.ContainsGenericParameters%2A> property is `true`."},{"content":"Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id=\"ph2\">`true`</ph>.","pos":[84,356],"source":" Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`."},{"content":"It is not possible to create an instance of an open constructed type.","pos":[369,438]},{"content":" Note that not all open constructed types are generic. For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.","pos":[450,648],"nodes":[{"content":"Note that not all open constructed types are generic.","pos":[1,54]},{"content":"For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.","pos":[55,198]}]}]},{"pos":[2343,2366],"content":"closed constructed type","nodes":[{"content":"closed constructed type","pos":[0,23]}]},{"pos":[2367,2525],"content":"The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.<br /><br /> When examined recursively, the type has no unassigned generic parameters.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id=\"ph2\">`false`</ph>.","pos":[0,72],"source":"The <xref:System.Type.ContainsGenericParameters%2A> property is `false`."},{"content":"When examined recursively, the type has no unassigned generic parameters.","pos":[85,158]}]},{"pos":[2530,2552],"content":"generic type parameter","nodes":[{"content":"generic type parameter","pos":[0,22]}]},{"pos":[2553,2797],"content":"The <xref:System.Type.IsGenericParameter%2A> property is `true`.<br /><br /> The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.<br /><br /> In a generic type definition, a placeholder for a type that will be assigned later.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> property is <ph id=\"ph2\">`true`</ph>.","pos":[0,64],"source":"The <xref:System.Type.IsGenericParameter%2A> property is `true`."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property is <ph id=\"ph2\">`true`</ph>.","pos":[77,148],"source":" The <xref:System.Type.ContainsGenericParameters%2A> property is `true`."},{"content":"In a generic type definition, a placeholder for a type that will be assigned later.","pos":[161,244]}]},{"pos":[2802,2823],"content":"generic type argument","nodes":[{"content":"generic type argument","pos":[0,21]}]},{"pos":[2824,3219],"content":"Can be any type, including a generic type parameter.<br /><br /> Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type. If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.","nodes":[{"content":"Can be any type, including a generic type parameter.","pos":[0,52]},{"content":" Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type. If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.","pos":[64,395],"nodes":[{"content":"Type arguments are specified as an array of <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> objects passed to the <ph id=\"ph2\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method when creating a constructed generic type.","pos":[1,172],"source":" Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type."},{"content":"If instances of the resulting type are to be created, the <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property must be <ph id=\"ph2\">`false`</ph> for all the type arguments.","pos":[173,331],"source":" If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments."}]}]},{"pos":[3227,3475],"content":"The following code example and table illustrate some of these terms and invariants. The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.","nodes":[{"content":"The following code example and table illustrate some of these terms and invariants.","pos":[0,83]},{"content":"The <ph id=\"ph1\">`Derived`</ph> class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.","pos":[84,248],"source":" The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list."}]},{"pos":[3482,3888],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Type.IsGenericType#2<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Type.IsGenericType#2<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Type.IsGenericType#2<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]\n [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]\n [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]"},{"pos":[3895,4054],"content":"The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`. When the C++ and C# code is the same, only one entry is shown.","nodes":[{"content":"The following table shows examples that use and build on the classes <ph id=\"ph1\">`Base`</ph>, <ph id=\"ph2\">`Derived`</ph>, and <ph id=\"ph3\">`G`</ph>.","pos":[0,96],"source":"The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`."},{"content":"When the C++ and C# code is the same, only one entry is shown.","pos":[97,159]}]},{"pos":[4061,4068],"content":"Example","nodes":[{"content":"Example","pos":[0,7]}]},{"pos":[4069,4079],"content":"Invariants","nodes":[{"content":"Invariants","pos":[0,10]}]},{"pos":[4119,4159],"content":"`Derived(Of V)`<br /><br /> `Derived<V>`","nodes":[]},{"pos":[4160,4373],"content":"For this type:<br /><br /> <xref:System.Type.IsGenericType%2A> is `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true`.","nodes":[{"content":"For this type:","pos":[0,14]},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id=\"ph2\">`true`</ph>.","pos":[27,73],"source":" <xref:System.Type.IsGenericType%2A> is `true`."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id=\"ph2\">`true`</ph>.","pos":[86,142],"source":" <xref:System.Type.IsGenericTypeDefinition%2A> is `true`."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id=\"ph2\">`true`</ph>.","pos":[155,213],"source":" <xref:System.Type.ContainsGenericParameters%2A> is `true`."}]},{"pos":[4378,4457],"content":"`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`","nodes":[]},{"pos":[4458,4672],"content":"For this type:<br /><br /> <xref:System.Type.IsGenericType%2A> is `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true`.","nodes":[{"content":"For this type:","pos":[0,14]},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id=\"ph2\">`true`</ph>.","pos":[27,73],"source":" <xref:System.Type.IsGenericType%2A> is `true`."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id=\"ph2\">`false`</ph>.","pos":[86,143],"source":" <xref:System.Type.IsGenericTypeDefinition%2A> is `false`."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id=\"ph2\">`true`</ph>.","pos":[156,214],"source":" <xref:System.Type.ContainsGenericParameters%2A> is `true`."}]},{"pos":[4677,4780],"content":"`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`","nodes":[]},{"pos":[4781,5036],"content":"For the type of variable `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `false`.","nodes":[{"content":"For the type of variable <ph id=\"ph1\">`d`</ph>:","pos":[0,29],"source":"For the type of variable `d`:"},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id=\"ph2\">`false`</ph> because <ph id=\"ph3\">`d`</ph> is an array.","pos":[42,113],"source":" <xref:System.Type.IsGenericType%2A> is `false` because `d` is an array."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id=\"ph2\">`false`</ph>.","pos":[126,183],"source":" <xref:System.Type.IsGenericTypeDefinition%2A> is `false`."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id=\"ph2\">`false`</ph>.","pos":[196,255],"source":" <xref:System.Type.ContainsGenericParameters%2A> is `false`."}]},{"pos":[5041,5083],"content":"<ph id=\"ph1\">`T`</ph>, <ph id=\"ph2\">`U`</ph>, and <ph id=\"ph3\">`V`</ph> (everywhere they appear)","source":"`T`, `U`, and `V` (everywhere they appear)"},{"pos":[5084,5555],"content":"<xref:System.Type.IsGenericParameter%2A> is `true`.<br /><br /> <xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters. This does not imply anything about type arguments that are assigned to them later.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Type.IsGenericParameter%2A&gt;</ph> is <ph id=\"ph2\">`true`</ph>.","pos":[0,51],"source":"<xref:System.Type.IsGenericParameter%2A> is `true`."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id=\"ph2\">`false`</ph> because there is no way to constrain a type parameter to generic types.","pos":[64,182],"source":" <xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types."},{"content":"<ph id=\"ph1\">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id=\"ph2\">`false`</ph>.","pos":[195,252],"source":" <xref:System.Type.IsGenericTypeDefinition%2A> is `false`."},{"content":" <xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters. This does not imply anything about type arguments that are assigned to them later.","pos":[264,471],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id=\"ph2\">`true`</ph> because <ph id=\"ph3\">`T`</ph>, <ph id=\"ph4\">`U`</ph>, and <ph id=\"ph5\">`V`</ph> are themselves generic type parameters.","pos":[1,124],"source":" <xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters."},{"content":"This does not imply anything about type arguments that are assigned to them later.","pos":[125,207]}]}]},{"pos":[5560,5581],"content":"The type of field <ph id=\"ph1\">`F`</ph>","source":"The type of field `F`"},{"pos":[5582,6207],"content":"<xref:System.Type.IsGenericType%2A> is `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to to the type parameter of `G`. Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type. The constructed type is open because its type argument (that is, `Base`) is a generic type definition. This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id=\"ph2\">`true`</ph>.","pos":[0,46],"source":"<xref:System.Type.IsGenericType%2A> is `true`."},{"content":" <xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to to the type parameter of `G`. Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.","pos":[58,277],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id=\"ph2\">`false`</ph> because a type has been assigned to to the type parameter of <ph id=\"ph3\">`G`</ph>.","pos":[1,123],"source":" <xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to to the type parameter of `G`."},{"content":"Note that this is equivalent to having called the <ph id=\"ph1\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method.","pos":[124,219],"source":" Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method."}]},{"content":" <xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type. The constructed type is open because its type argument (that is, `Base`) is a generic type definition. This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.","pos":[289,625],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id=\"ph2\">`true`</ph> because the type of field <ph id=\"ph3\">`F`</ph> has a type argument that is an open constructed type.","pos":[1,142],"source":" <xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type."},{"content":"The constructed type is open because its type argument (that is, <ph id=\"ph1\">`Base`</ph>) is a generic type definition.","pos":[143,245],"source":" The constructed type is open because its type argument (that is, `Base`) is a generic type definition."},{"content":"This illustrates the recursive nature of the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property.","pos":[246,336],"source":" This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property."}]}]},{"pos":[6212,6237],"content":"The nested class <ph id=\"ph1\">`Nested`</ph>","source":"The nested class `Nested`"},{"pos":[6238,6843],"content":"<xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `true`. That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters. This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> is <ph id=\"ph2\">`true`</ph>, even though the <ph id=\"ph3\">`Nested`</ph> class has no generic type parameters of its own, because it is nested in a generic type.","pos":[0,160],"source":"<xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type."},{"content":" <xref:System.Type.IsGenericTypeDefinition%2A> is `true`. That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.","pos":[172,364],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> is <ph id=\"ph2\">`true`</ph>.","pos":[1,57],"source":" <xref:System.Type.IsGenericTypeDefinition%2A> is `true`."},{"content":"That is, you can call the <ph id=\"ph1\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method and supply the type parameter of the enclosing type, <ph id=\"ph2\">`Derived`</ph>.","pos":[58,192],"source":" That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`."}]},{"content":" <xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters. This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.","pos":[376,605],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> is <ph id=\"ph2\">`true`</ph> because the enclosing type, <ph id=\"ph3\">`Derived`</ph>, has generic type parameters.","pos":[1,126],"source":" <xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters."},{"content":"This illustrates the recursive nature of the <ph id=\"ph1\">&lt;xref:System.Type.ContainsGenericParameters%2A&gt;</ph> property.","pos":[127,229],"source":" This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property."}]}]}],"pos":[638775,645653],"yaml":true,"extradata":"MT"},{"content":"`true` if the current type is a generic type; otherwise, `false`.","nodes":[{"pos":[0,65],"content":"<ph id=\"ph1\">`true`</ph> if the current type is a generic type; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the current type is a generic type; otherwise, `false`."}],"pos":[646578,646646],"yaml":true},{"content":"Gets a value indicating whether the current <xref href=\"System.Type\"></xref> represents a generic type definition, from which other generic types can be constructed.","nodes":[{"pos":[0,165],"content":"Gets a value indicating whether the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> represents a generic type definition, from which other generic types can be constructed.","source":"Gets a value indicating whether the current <xref href=\"System.Type\"></xref> represents a generic type definition, from which other generic types can be constructed."}],"pos":[647804,647970],"yaml":true},{"content":"A generic type definition is a template from which other types can be constructed. For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type. Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.  \n  \n Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type. If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.  \n  \n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"pos":[0,622],"content":"A generic type definition is a template from which other types can be constructed. For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type. Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.","nodes":[{"content":"A generic type definition is a template from which other types can be constructed.","pos":[0,82]},{"content":"For example, from the generic type definition <ph id=\"ph1\">`G&lt;T&gt;`</ph> (expressed in C# syntax; <ph id=\"ph2\">`G(Of T)`</ph> in Visual Basic or <ph id=\"ph3\">`generic &lt;typename T&gt; ref class G`</ph> in C++) you can construct and instantiate the type <ph id=\"ph4\">`G&lt;int&gt;`</ph> (<ph id=\"ph5\">`G(Of Integer)`</ph> in Visual Basic), by calling the <ph id=\"ph6\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with a generic argument list containing the <ph id=\"ph7\">&lt;xref:System.Int32&gt;</ph> type.","pos":[83,449],"source":" For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type."},{"content":"Given a <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object representing this constructed type, the <ph id=\"ph2\">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method gets the generic type definition back again.","pos":[450,622],"source":" Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again."}]},{"pos":[629,929],"content":"Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type. If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.","nodes":[{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property to determine whether you can create new types from the current type.","pos":[0,131],"source":"Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type."},{"content":"If the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericTypeDefinition%2A&gt;</ph> property returns <ph id=\"ph2\">`true`</ph>, you can call the <ph id=\"ph3\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method to create new generic types.","pos":[132,300],"source":" If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types."}]},{"pos":[936,1074],"content":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"content":"For a list of the invariant conditions for terms used in generic reflection, see the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.","pos":[0,138],"source":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks."}]}],"pos":[647981,649062],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> object represents a generic type definition; otherwise, `false`.","nodes":[{"pos":[0,111],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object represents a generic type definition; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> object represents a generic type definition; otherwise, `false`."}],"pos":[649910,650024],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> has a <xref href=\"System.Runtime.InteropServices.ComImportAttribute\"></xref> attribute applied, indicating that it was imported from a COM type library.","nodes":[{"pos":[0,221],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> has a <ph id=\"ph2\">&lt;xref href=\"System.Runtime.InteropServices.ComImportAttribute\"&gt;&lt;/xref&gt;</ph> attribute applied, indicating that it was imported from a COM type library.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> has a <xref href=\"System.Runtime.InteropServices.ComImportAttribute\"></xref> attribute applied, indicating that it was imported from a COM type library."}],"pos":[651102,651324],"yaml":true},{"content":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.","nodes":[{"pos":[0,352],"content":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.","pos":[0,162],"source":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed."},{"content":"For example, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents <ph id=\"ph2\">`MyGenericType&lt;int&gt;`</ph> (<ph id=\"ph3\">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id=\"ph4\">`MyGenericType&lt;T&gt;.`</ph>","pos":[163,352],"source":" For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`"}]},{"pos":[359,513],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`."}],"pos":[651335,651853],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> has a <xref href=\"System.Runtime.InteropServices.ComImportAttribute\"></xref>; otherwise, `false`.","nodes":[{"pos":[0,144],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> has a <ph id=\"ph3\">&lt;xref href=\"System.Runtime.InteropServices.ComImportAttribute\"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id=\"ph4\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> has a <xref href=\"System.Runtime.InteropServices.ComImportAttribute\"></xref>; otherwise, `false`."}],"pos":[651964,652111],"yaml":true},{"content":"Determines whether the specified object is an instance of the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,103],"content":"Determines whether the specified object is an instance of the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Determines whether the specified object is an instance of the current <xref href=\"System.Type\"></xref>."}],"pos":[653289,653393],"yaml":true},{"content":"This method can be overridden by a derived class.  \n  \n> [!NOTE]\n>  A constructed type is not an instance of its generic type definition. That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).","nodes":[{"pos":[0,49],"content":"This method can be overridden by a derived class.","nodes":[{"content":"This method can be overridden by a derived class.","pos":[0,49]}]},{"pos":[57,295],"content":"[!NOTE]\n A constructed type is not an instance of its generic type definition. That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).","leadings":["","> "],"nodes":[{"content":" A constructed type is not an instance of its generic type definition. That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).","pos":[8,236],"nodes":[{"content":"A constructed type is not an instance of its generic type definition.","pos":[1,70]},{"content":"That is, <ph id=\"ph1\">`MyGenericList&lt;int&gt;`</ph> (<ph id=\"ph2\">`MyGenericList(Of Integer)`</ph> in Visual Basic) is not an instance of <ph id=\"ph3\">`MyGenericList&lt;T&gt;`</ph> (<ph id=\"ph4\">`MyGenericList(Of T)`</ph> in Visual Basic).","pos":[71,228],"source":" That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic)."}]}]}],"pos":[653404,653705],"yaml":true,"extradata":"MT"},{"content":"The object to compare with the current type.","nodes":[{"pos":[0,44],"content":"The object to compare with the current type.","nodes":[{"content":"The object to compare with the current type.","pos":[0,44]}]}],"pos":[654349,654394],"yaml":true},{"content":"`true` if the current `Type` is in the inheritance hierarchy of the object represented by <code>o</code>, or if the current `Type` is an interface that <code>o</code> implements. `false` if neither of these conditions is the case, if <code>o</code> is `null`, or if the current `Type` is an open generic type (that is, <xref href=\"System.Type.ContainsGenericParameters\"></xref> returns `true`).","nodes":[{"pos":[0,394],"content":"`true` if the current `Type` is in the inheritance hierarchy of the object represented by <code>o</code>, or if the current `Type` is an interface that <code>o</code> implements. `false` if neither of these conditions is the case, if <code>o</code> is `null`, or if the current `Type` is an open generic type (that is, <xref href=\"System.Type.ContainsGenericParameters\"></xref> returns `true`).","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the current <ph id=\"ph2\">`Type`</ph> is in the inheritance hierarchy of the object represented by <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph3\">o</ph><ept id=\"p1\">&lt;/code&gt;</ept>, or if the current <ph id=\"ph4\">`Type`</ph> is an interface that <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph5\">o</ph><ept id=\"p2\">&lt;/code&gt;</ept> implements.","pos":[0,178],"source":"`true` if the current `Type` is in the inheritance hierarchy of the object represented by <code>o</code>, or if the current `Type` is an interface that <code>o</code> implements."},{"content":"<ph id=\"ph1\">`false`</ph> if neither of these conditions is the case, if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">o</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph3\">`null`</ph>, or if the current <ph id=\"ph4\">`Type`</ph> is an open generic type (that is, <ph id=\"ph5\">&lt;xref href=\"System.Type.ContainsGenericParameters\"&gt;&lt;/xref&gt;</ph> returns <ph id=\"ph6\">`true`</ph>).","pos":[179,394],"source":"`false` if neither of these conditions is the case, if <code>o</code> is `null`, or if the current `Type` is an open generic type (that is, <xref href=\"System.Type.ContainsGenericParameters\"></xref> returns `true`)."}]}],"pos":[654452,654849],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is an interface; that is, not a class or a value type.","nodes":[{"pos":[0,123],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is an interface; that is, not a class or a value type.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is an interface; that is, not a class or a value type."}],"pos":[655938,656062],"yaml":true},{"content":"The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.  \n  \n This property is read-only.","nodes":[{"pos":[0,130],"content":"The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes.ClassSemanticsMask&gt;</ph> distinguishes a type declaration as class, interface or value type.","pos":[0,130],"source":"The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type."}]},{"pos":[137,291],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`."},{"pos":[298,325],"content":"This property is read-only.","nodes":[{"content":"This property is read-only.","pos":[0,27]}]}],"pos":[656073,656405],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is an interface; otherwise, `false`.","nodes":[{"pos":[0,83],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is an interface; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is an interface; otherwise, `false`."}],"pos":[657106,657192],"yaml":true},{"content":"Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.","nodes":[{"pos":[0,153],"content":"Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.","nodes":[{"content":"Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.","pos":[0,153]}]}],"pos":[658386,658540],"yaml":true},{"content":"This property is provided as a convenience. Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set. The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory.  \n  \n For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type. In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to specify that layout is sequential.  \n  \n> [!NOTE]\n>  You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.  \n  \n For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, \"Partition II: Metadata Definition and Semantics\". The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.","nodes":[{"pos":[0,577],"content":"This property is provided as a convenience. Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set. The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory.","nodes":[{"content":"This property is provided as a convenience. Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set. The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory.","pos":[0,577],"nodes":[{"content":"This property is provided as a convenience.","pos":[0,43]},{"content":"Alternatively, you can use the <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>enumeration value to select the type layout attributes, and then test whether <ph id=\"ph2\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> is set.","pos":[44,289],"source":" Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set."},{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> enumeration values indicate the way the fields of the type are laid out in memory.","pos":[290,577],"source":" The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory."}]}]},{"pos":[584,950],"content":"For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type. In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to specify that layout is sequential.","nodes":[{"content":"For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type. In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to specify that layout is sequential.","pos":[0,366],"nodes":[{"content":"For dynamic types, you can specify <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> when you create the type.","pos":[0,125],"source":"For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type."},{"content":"In code, apply the <ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> attribute with the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName&gt;</ph> enumeration value to the type, to specify that layout is sequential.","pos":[126,366],"source":" In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to specify that layout is sequential."}]}]},{"pos":[958,1166],"content":"[!NOTE]\n You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.","leadings":["","> "],"nodes":[{"content":"You cannot use the <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method to determine whether the <ph id=\"ph2\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> has been applied to a type.","pos":[9,206],"source":" You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type."}]},{"pos":[1173,1641],"content":"For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, \"Partition II: Metadata Definition and Semantics\". The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.","nodes":[{"content":"For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, \"Partition II: Metadata Definition and Semantics\".","pos":[0,171]},{"content":"The documentation is available online; see <bpt id=\"p1\">[</bpt>ECMA C# and Common Language Infrastructure Standards<ept id=\"p1\">](http://go.microsoft.com/fwlink/?LinkID=99212)</ept> on MSDN and <bpt id=\"p2\">[</bpt>Standard ECMA-335 - Common Language Infrastructure (CLI)<ept id=\"p2\">](http://go.microsoft.com/fwlink/?LinkID=65552)</ept> on the Ecma International Web site.","pos":[172,468],"source":" The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site."}]},{"pos":[1648,2000],"content":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.","pos":[0,162],"source":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed."},{"content":"For example, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents <ph id=\"ph2\">`MyGenericType&lt;int&gt;`</ph> (<ph id=\"ph3\">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id=\"ph4\">`MyGenericType&lt;T&gt;`</ph>.","pos":[163,352],"source":" For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`."}]},{"pos":[2007,2161],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`."}],"pos":[658551,660728],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type.Attributes\"></xref> property of the current type includes <xref href=\"System.Reflection.TypeAttributes.SequentialLayout\"></xref>; otherwise, `false`.","nodes":[{"pos":[0,187],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type.Attributes\"&gt;&lt;/xref&gt;</ph> property of the current type includes <ph id=\"ph3\">&lt;xref href=\"System.Reflection.TypeAttributes.SequentialLayout\"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id=\"ph4\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type.Attributes\"></xref> property of the current type includes <xref href=\"System.Reflection.TypeAttributes.SequentialLayout\"></xref>; otherwise, `false`."}],"pos":[661634,661824],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is marshaled by reference.","nodes":[{"pos":[0,95],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is marshaled by reference.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is marshaled by reference."}],"pos":[662933,663029],"yaml":true},{"content":"`true` if the <xref href=\"System.Type\"></xref> is marshaled by reference; otherwise, `false`.","nodes":[{"pos":[0,93],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is marshaled by reference; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is marshaled by reference; otherwise, `false`."}],"pos":[663882,663978],"yaml":true},{"content":"Implements the <xref href=\"System.Type.IsMarshalByRef\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is marshaled by reference.","nodes":[{"pos":[0,158],"content":"Implements the <ph id=\"ph1\">&lt;xref href=\"System.Type.IsMarshalByRef\"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is marshaled by reference.","source":"Implements the <xref href=\"System.Type.IsMarshalByRef\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is marshaled by reference."}],"pos":[665111,665270],"yaml":true},{"content":"This method can be overridden by a derived class.","nodes":[{"pos":[0,49],"content":"This method can be overridden by a derived class.","nodes":[{"content":"This method can be overridden by a derived class.","pos":[0,49]}]}],"pos":[665281,665331],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is marshaled by reference; otherwise, `false`.","nodes":[{"pos":[0,93],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is marshaled by reference; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is marshaled by reference; otherwise, `false`."}],"pos":[666033,666129],"yaml":true},{"content":"Gets a value indicating whether the current <xref href=\"System.Type\"></xref> object represents a type whose definition is nested inside the definition of another type.","nodes":[{"pos":[0,167],"content":"Gets a value indicating whether the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object represents a type whose definition is nested inside the definition of another type.","source":"Gets a value indicating whether the current <xref href=\"System.Type\"></xref> object represents a type whose definition is nested inside the definition of another type."}],"pos":[667202,667370],"yaml":true},{"content":"The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility. To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.  \n  \n> [!NOTE]\n>  The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.","nodes":[{"pos":[0,429],"content":"The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility. To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.IsNested%2A&gt;</ph> property returns <ph id=\"ph2\">`true`</ph> for all nested types, regardless of visibility.","pos":[0,106],"source":"The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility."},{"content":"To test for nesting and visibility at the same time, use the related properties <ph id=\"ph1\">&lt;xref:System.Type.IsNestedAssembly%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Type.IsNestedFamily%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Type.IsNestedFamANDAssem%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.Type.IsNestedPrivate%2A&gt;</ph>, or <ph id=\"ph6\">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph>.","pos":[107,429],"source":" To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>."}]},{"pos":[437,571],"content":"[!NOTE]\n The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.","leadings":["","> "],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes.VisibilityMask&gt;</ph> enumeration member selects the visibility attributes for a type.","pos":[9,132],"source":" The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type."}]}],"pos":[667381,667958],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is nested inside another type; otherwise, `false`.","nodes":[{"pos":[0,97],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is nested inside another type; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is nested inside another type; otherwise, `false`."}],"pos":[668689,668789],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and visible only within its own assembly.","nodes":[{"pos":[0,120],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is nested and visible only within its own assembly.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and visible only within its own assembly."}],"pos":[670244,670365],"yaml":true},{"content":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.  \n  \n <xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.","nodes":[{"pos":[0,118],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`."},{"pos":[125,224],"content":"<xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> selects the visibility attributes.","pos":[0,99],"source":"<xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes."}]}],"pos":[670376,670605],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is nested and visible only within its own assembly; otherwise, `false`.","nodes":[{"pos":[0,118],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is nested and visible only within its own assembly; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is nested and visible only within its own assembly; otherwise, `false`."}],"pos":[671344,671465],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and visible only to classes that belong to both its own family and its own assembly.","nodes":[{"pos":[0,163],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is nested and visible only to classes that belong to both its own family and its own assembly.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and visible only to classes that belong to both its own family and its own assembly."}],"pos":[672602,672766],"yaml":true},{"content":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.  \n  \n <xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.  \n  \n> [!NOTE]\n>  The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly. `protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.  \n  \n A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.","nodes":[{"pos":[0,118],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`."},{"pos":[125,224],"content":"<xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> selects the visibility attributes.","pos":[0,99],"source":"<xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes."}]},{"pos":[232,585],"content":"[!NOTE]\n The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly. `protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.","leadings":["","> "],"nodes":[{"content":" The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly. `protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.","pos":[8,351],"nodes":[{"content":"The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.","pos":[1,159]},{"content":"<ph id=\"ph1\">`protected internal`</ph> visibility in C# and <ph id=\"ph2\">`Protected Friend`</ph> visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.","pos":[160,343],"source":"`protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly."}]}]},{"pos":[592,706],"content":"A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.","nodes":[{"content":"A <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the same <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> and of its subtypes.","pos":[0,114],"source":"A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes."}]}],"pos":[672777,673493],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, `false`.","nodes":[{"pos":[0,161],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, `false`."}],"pos":[674235,674399],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and visible only within its own family.","nodes":[{"pos":[0,118],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is nested and visible only within its own family.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and visible only within its own family."}],"pos":[675509,675628],"yaml":true},{"content":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.  \n  \n <xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.  \n  \n A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.","nodes":[{"pos":[0,118],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`."},{"pos":[125,224],"content":"<xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> selects the visibility attributes.","pos":[0,99],"source":"<xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes."}]},{"pos":[231,351],"content":"A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.","nodes":[{"content":"A <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the exact same <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> and of its subtypes.","pos":[0,120],"source":"A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes."}]}],"pos":[675639,675997],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is nested and visible only within its own family; otherwise, `false`.","nodes":[{"pos":[0,116],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is nested and visible only within its own family; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is nested and visible only within its own family; otherwise, `false`."}],"pos":[676734,676853],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and visible only to classes that belong to either its own family or to its own assembly.","nodes":[{"pos":[0,167],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is nested and visible only to classes that belong to either its own family or to its own assembly.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and visible only to classes that belong to either its own family or to its own assembly."}],"pos":[677982,678150],"yaml":true},{"content":"If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`.  \n  \n If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.  \n  \n <xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.  \n  \n A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.","nodes":[{"pos":[0,166],"content":"If the visibility of a type is <ph id=\"ph1\">`protected internal`</ph> in C# or <ph id=\"ph2\">`Protected Friend`</ph> in Visual Basic, the <ph id=\"ph3\">&lt;xref:System.Type.IsNestedFamORAssem%2A&gt;</ph> property returns <ph id=\"ph4\">`true`</ph>.","source":"If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`."},{"pos":[173,291],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`."},{"pos":[298,397],"content":"<xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> selects the visibility attributes.","pos":[0,99],"source":"<xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes."}]},{"pos":[404,524],"content":"A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.","nodes":[{"content":"A <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object's family is defined as all objects of the exact same <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> and of its subtypes.","pos":[0,120],"source":"A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes."}]}],"pos":[678161,678694],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, `false`.","nodes":[{"pos":[0,158],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, `false`."}],"pos":[679435,679596],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and declared private.","nodes":[{"pos":[0,100],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is nested and declared private.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and declared private."}],"pos":[680711,680812],"yaml":true},{"content":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.  \n  \n <xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.","nodes":[{"pos":[0,118],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`."},{"pos":[125,224],"content":"<xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> selects the visibility attributes.","pos":[0,99],"source":"<xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes."}]}],"pos":[680823,681052],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is nested and declared private; otherwise, `false`.","nodes":[{"pos":[0,98],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is nested and declared private; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is nested and declared private; otherwise, `false`."}],"pos":[681790,681891],"yaml":true},{"content":"Gets a value indicating whether a class is nested and declared public.","nodes":[{"pos":[0,70],"content":"Gets a value indicating whether a class is nested and declared public.","nodes":[{"content":"Gets a value indicating whether a class is nested and declared public.","pos":[0,70]}]}],"pos":[682997,683068],"yaml":true},{"content":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.  \n  \n <xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.","nodes":[{"pos":[0,118],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`."},{"pos":[125,224],"content":"<xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> selects the visibility attributes.","pos":[0,99],"source":"<xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes."}]}],"pos":[683079,683308],"yaml":true,"extradata":"MT"},{"content":"`true` if the class is nested and declared public; otherwise, `false`.","nodes":[{"pos":[0,70],"content":"<ph id=\"ph1\">`true`</ph> if the class is nested and declared public; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the class is nested and declared public; otherwise, `false`."}],"pos":[684045,684118],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is not declared public.","nodes":[{"pos":[0,92],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is not declared public.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is not declared public."}],"pos":[685205,685298],"yaml":true},{"content":"Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.  \n  \n If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`.","nodes":[{"pos":[0,106],"content":"Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.","nodes":[{"content":"Do not use this property with nested types; use the <ph id=\"ph1\">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> property instead.","pos":[0,106],"source":"Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead."}]},{"pos":[113,224],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`."}],"pos":[685309,685538],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is not declared public and is not a nested type; otherwise, `false`.","nodes":[{"pos":[0,115],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is not declared public and is not a nested type; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is not declared public and is not a nested type; otherwise, `false`."}],"pos":[687258,687376],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is a pointer.","nodes":[{"pos":[0,82],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a pointer.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is a pointer."}],"pos":[688448,688531],"yaml":true},{"content":"If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.  \n  \n This property is read-only.","nodes":[{"pos":[0,173],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`."},{"pos":[180,207],"content":"This property is read-only.","nodes":[{"content":"This property is read-only.","pos":[0,27]}]}],"pos":[688542,688754],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is a pointer; otherwise, `false`.","nodes":[{"pos":[0,80],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a pointer; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is a pointer; otherwise, `false`."}],"pos":[689378,689461],"yaml":true},{"content":"When overridden in a derived class, implements the <xref href=\"System.Type.IsPointer\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is a pointer.","nodes":[{"pos":[0,176],"content":"When overridden in a derived class, implements the <ph id=\"ph1\">&lt;xref href=\"System.Type.IsPointer\"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a pointer.","source":"When overridden in a derived class, implements the <xref href=\"System.Type.IsPointer\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is a pointer."}],"pos":[690903,691080],"yaml":true},{"content":"`true` if the <xref href=\"System.Type\"></xref> is a pointer; otherwise, `false`.","nodes":[{"pos":[0,80],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a pointer; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is a pointer; otherwise, `false`."}],"pos":[691222,691305],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is one of the primitive types.","nodes":[{"pos":[0,99],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is one of the primitive types.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is one of the primitive types."}],"pos":[692391,692491],"yaml":true},{"content":"The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.  \n  \n If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.","nodes":[{"pos":[0,329],"content":"The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.","nodes":[{"content":"The primitive types are <ph id=\"ph1\">&lt;xref:System.Boolean&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Byte&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.SByte&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Int16&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.UInt16&gt;</ph>, <ph id=\"ph6\">&lt;xref:System.Int32&gt;</ph>, <ph id=\"ph7\">&lt;xref:System.UInt32&gt;</ph>, <ph id=\"ph8\">&lt;xref:System.Int64&gt;</ph>, <ph id=\"ph9\">&lt;xref:System.UInt64&gt;</ph>, <ph id=\"ph10\">&lt;xref:System.IntPtr&gt;</ph>, <ph id=\"ph11\">&lt;xref:System.UIntPtr&gt;</ph>, <ph id=\"ph12\">&lt;xref:System.Char&gt;</ph>, <ph id=\"ph13\">&lt;xref:System.Double&gt;</ph>, and <ph id=\"ph14\">&lt;xref:System.Single&gt;</ph>.","pos":[0,329],"source":"The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>."}]},{"pos":[336,509],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`."}],"pos":[692502,693016],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is one of the primitive types; otherwise, `false`.","nodes":[{"pos":[0,97],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is one of the primitive types; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is one of the primitive types; otherwise, `false`."}],"pos":[693852,693952],"yaml":true},{"content":"When overridden in a derived class, implements the <xref href=\"System.Type.IsPrimitive\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is one of the primitive types.","nodes":[{"pos":[0,195],"content":"When overridden in a derived class, implements the <ph id=\"ph1\">&lt;xref href=\"System.Type.IsPrimitive\"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is one of the primitive types.","source":"When overridden in a derived class, implements the <xref href=\"System.Type.IsPrimitive\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is one of the primitive types."}],"pos":[695064,695260],"yaml":true},{"content":"The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.","nodes":[{"pos":[0,284],"content":"The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.","nodes":[{"content":"The primitive types are <ph id=\"ph1\">&lt;xref:System.Boolean&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Byte&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.SByte&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Int16&gt;</ph>, <ph id=\"ph5\">&lt;xref:System.UInt16&gt;</ph>, <ph id=\"ph6\">&lt;xref:System.Int32&gt;</ph>, <ph id=\"ph7\">&lt;xref:System.UInt32&gt;</ph>, <ph id=\"ph8\">&lt;xref:System.Int64&gt;</ph>, <ph id=\"ph9\">&lt;xref:System.UInt64&gt;</ph>, <ph id=\"ph10\">&lt;xref:System.Char&gt;</ph>, <ph id=\"ph11\">&lt;xref:System.Double&gt;</ph>, and <ph id=\"ph12\">&lt;xref:System.Single&gt;</ph>.","pos":[0,284],"source":"The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>."}]}],"pos":[695271,695556],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is one of the primitive types; otherwise, `false`.","nodes":[{"pos":[0,97],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is one of the primitive types; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is one of the primitive types; otherwise, `false`."}],"pos":[696223,696323],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is declared public.","nodes":[{"pos":[0,88],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is declared public.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is declared public."}],"pos":[697393,697482],"yaml":true},{"content":"Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.  \n  \n If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`.  \n  \n <xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.","nodes":[{"pos":[0,79],"content":"Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.","nodes":[{"content":"Do not use with nested types; use <ph id=\"ph1\">&lt;xref:System.Type.IsNestedPublic%2A&gt;</ph> instead.","pos":[0,79],"source":"Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead."}]},{"pos":[86,196],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property returns <ph id=\"ph2\">`true`</ph>.","source":"If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`."},{"pos":[203,302],"content":"<xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.","nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes?displayProperty=fullName&gt;</ph> selects the visibility attributes.","pos":[0,99],"source":"<xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes."}]}],"pos":[697493,697802],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is declared public and is not a nested type; otherwise, `false`.","nodes":[{"pos":[0,111],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is declared public and is not a nested type; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is declared public and is not a nested type; otherwise, `false`."}],"pos":[698593,698707],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is declared sealed.","nodes":[{"pos":[0,88],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is declared sealed.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is declared sealed."}],"pos":[699770,699859],"yaml":true},{"content":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`.","nodes":[{"pos":[0,117],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter of a generic type, this property always returns <ph id=\"ph2\">`true`</ph>.","source":"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`."}],"pos":[699870,699988],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is declared sealed; otherwise, `false`.","nodes":[{"pos":[0,86],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is declared sealed; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is declared sealed; otherwise, `false`."}],"pos":[700582,700671],"yaml":true},{"content":"Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.","nodes":[{"pos":[0,174],"content":"Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.","nodes":[{"content":"Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.","pos":[0,174]}]}],"pos":[701794,701969],"yaml":true},{"content":"The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  \n  \n|Security level|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  \n|--------------------|------------------------|----------------------------|---------------------------|  \n|Critical|`true`|`false`|`false`|  \n|Safe critical|`true`|`true`|`false`|  \n|Transparent|`false`|`false`|`true`|  \n  \n Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.  \n  \n> [!IMPORTANT]\n>  For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.  \n  \n For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).","nodes":[{"pos":[0,343],"content":"The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:","nodes":[{"content":"The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:","pos":[0,343],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).","pos":[0,272],"source":"The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR)."},{"content":"The combinations of these properties are shown in the following table:","pos":[273,343]}]}]},{"pos":[350,364],"content":"Security level","nodes":[{"content":"Security level","pos":[0,14]}]},{"pos":[365,383],"content":"IsSecurityCritical","nodes":[{"content":"IsSecurityCritical","pos":[0,18]}]},{"pos":[384,406],"content":"IsSecuritySafeCritical","nodes":[{"content":"IsSecuritySafeCritical","pos":[0,22]}]},{"pos":[407,428],"content":"IsSecurityTransparent","nodes":[{"content":"IsSecurityTransparent","pos":[0,21]}]},{"pos":[540,548],"content":"Critical","nodes":[{"content":"Critical","pos":[0,8]}]},{"pos":[576,589],"content":"Safe critical","nodes":[{"content":"Safe critical","pos":[0,13]}]},{"pos":[616,627],"content":"Transparent","nodes":[{"content":"Transparent","pos":[0,11]}]},{"pos":[658,849],"content":"Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.","nodes":[{"content":"Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.","pos":[0,191]}]},{"pos":[857,1973],"content":"[!IMPORTANT]\n For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.","leadings":["","> "],"nodes":[{"content":" For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.","pos":[13,1114],"nodes":[{"content":"For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.","pos":[1,109]},{"content":"If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.","pos":[110,298]},{"content":"The assembly and all its types are treated as transparent.","pos":[299,357]},{"content":"The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).","pos":[358,591]},{"content":"By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.","pos":[592,847]},{"content":"You can determine the current trust levels of assemblies and application domains by using the <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> properties.","pos":[848,1101],"source":" You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties."}]}]},{"pos":[1980,2271],"content":"For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).","nodes":[{"content":"For more information about reflection and transparency, see <bpt id=\"p1\">[</bpt>Security Considerations for Reflection<ept id=\"p1\">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.","pos":[0,184],"source":"For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)."},{"content":"For information about transparency, see <bpt id=\"p1\">[</bpt>Security Changes<ept id=\"p1\">](~/docs/framework/security/security-changes.md)</ept>.","pos":[185,291],"source":" For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md)."}]}],"pos":[701980,704267],"yaml":true,"extradata":"MT"},{"content":"`true` if the current type is security-critical or security-safe-critical at the current trust level; `false` if it is transparent.","nodes":[{"pos":[0,131],"content":"<ph id=\"ph1\">`true`</ph> if the current type is security-critical or security-safe-critical at the current trust level; <ph id=\"ph2\">`false`</ph> if it is transparent.","source":"`true` if the current type is security-critical or security-safe-critical at the current trust level; `false` if it is transparent."}],"pos":[704396,704530],"yaml":true},{"content":"Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.","nodes":[{"pos":[0,199],"content":"Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.","nodes":[{"content":"Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.","pos":[0,199]}]}],"pos":[705687,705887],"yaml":true},{"content":"The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  \n  \n|Security level|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  \n|--------------------|------------------------|----------------------------|---------------------------|  \n|Critical|`true`|`false`|`false`|  \n|Safe critical|`true`|`true`|`false`|  \n|Transparent|`false`|`false`|`true`|  \n  \n Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.  \n  \n> [!IMPORTANT]\n>  For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.  \n  \n For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).","nodes":[{"pos":[0,343],"content":"The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:","nodes":[{"content":"The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:","pos":[0,343],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).","pos":[0,272],"source":"The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR)."},{"content":"The combinations of these properties are shown in the following table:","pos":[273,343]}]}]},{"pos":[350,364],"content":"Security level","nodes":[{"content":"Security level","pos":[0,14]}]},{"pos":[365,383],"content":"IsSecurityCritical","nodes":[{"content":"IsSecurityCritical","pos":[0,18]}]},{"pos":[384,406],"content":"IsSecuritySafeCritical","nodes":[{"content":"IsSecuritySafeCritical","pos":[0,22]}]},{"pos":[407,428],"content":"IsSecurityTransparent","nodes":[{"content":"IsSecurityTransparent","pos":[0,21]}]},{"pos":[540,548],"content":"Critical","nodes":[{"content":"Critical","pos":[0,8]}]},{"pos":[576,589],"content":"Safe critical","nodes":[{"content":"Safe critical","pos":[0,13]}]},{"pos":[616,627],"content":"Transparent","nodes":[{"content":"Transparent","pos":[0,11]}]},{"pos":[658,849],"content":"Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.","nodes":[{"content":"Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.","pos":[0,191]}]},{"pos":[857,1973],"content":"[!IMPORTANT]\n For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.","leadings":["","> "],"nodes":[{"content":" For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.","pos":[13,1114],"nodes":[{"content":"For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.","pos":[1,109]},{"content":"If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.","pos":[110,298]},{"content":"The assembly and all its types are treated as transparent.","pos":[299,357]},{"content":"The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).","pos":[358,591]},{"content":"By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.","pos":[592,847]},{"content":"You can determine the current trust levels of assemblies and application domains by using the <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> properties.","pos":[848,1101],"source":" You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties."}]}]},{"pos":[1980,2271],"content":"For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).","nodes":[{"content":"For more information about reflection and transparency, see <bpt id=\"p1\">[</bpt>Security Considerations for Reflection<ept id=\"p1\">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.","pos":[0,184],"source":"For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)."},{"content":"For information about transparency, see <bpt id=\"p1\">[</bpt>Security Changes<ept id=\"p1\">](~/docs/framework/security/security-changes.md)</ept>.","pos":[185,291],"source":" For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md)."}]}],"pos":[705898,708185],"yaml":true,"extradata":"MT"},{"content":"`true` if the current type is security-safe-critical at the current trust level; `false` if it is security-critical or transparent.","nodes":[{"pos":[0,131],"content":"<ph id=\"ph1\">`true`</ph> if the current type is security-safe-critical at the current trust level; <ph id=\"ph2\">`false`</ph> if it is security-critical or transparent.","source":"`true` if the current type is security-safe-critical at the current trust level; `false` if it is security-critical or transparent."}],"pos":[708318,708452],"yaml":true},{"content":"Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.","nodes":[{"pos":[0,145],"content":"Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.","nodes":[{"content":"Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.","pos":[0,145]}]}],"pos":[709607,709753],"yaml":true},{"content":"If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`.  \n  \n The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.  \n  \n> [!IMPORTANT]\n>  For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.  \n  \n For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).","nodes":[{"pos":[0,153],"content":"If this property returns <ph id=\"ph1\">`true`</ph>, the <ph id=\"ph2\">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph> and <ph id=\"ph3\">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph> properties return <ph id=\"ph4\">`false`</ph>.","source":"If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`."},{"pos":[160,624],"content":"The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.","nodes":[{"content":"The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.","pos":[0,464],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.IsSecurityCritical%2A&gt;</ph>, <ph id=\"ph2\">&lt;xref:System.Type.IsSecuritySafeCritical%2A&gt;</ph>, and <ph id=\"ph3\">&lt;xref:System.Type.IsSecurityTransparent%2A&gt;</ph> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).","pos":[0,272],"source":"The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR)."},{"content":"Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.","pos":[273,464]}]}]},{"pos":[632,1748],"content":"[!IMPORTANT]\n For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.","leadings":["","> "],"nodes":[{"content":" For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.","pos":[13,1114],"nodes":[{"content":"For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.","pos":[1,109]},{"content":"If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.","pos":[110,298]},{"content":"The assembly and all its types are treated as transparent.","pos":[299,357]},{"content":"The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).","pos":[358,591]},{"content":"By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.","pos":[592,847]},{"content":"You can determine the current trust levels of assemblies and application domains by using the <ph id=\"ph1\">&lt;xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> and <ph id=\"ph2\">&lt;xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName&gt;</ph> properties.","pos":[848,1101],"source":" You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties."}]}]},{"pos":[1755,2046],"content":"For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).","nodes":[{"content":"For more information about reflection and transparency, see <bpt id=\"p1\">[</bpt>Security Considerations for Reflection<ept id=\"p1\">](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)</ept>.","pos":[0,184],"source":"For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md)."},{"content":"For information about transparency, see <bpt id=\"p1\">[</bpt>Security Changes<ept id=\"p1\">](~/docs/framework/security/security-changes.md)</ept>.","pos":[185,291],"source":" For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md)."}]}],"pos":[709764,711820],"yaml":true,"extradata":"MT"},{"content":"`true` if the type is security-transparent at the current trust level; otherwise, `false`.","nodes":[{"pos":[0,90],"content":"<ph id=\"ph1\">`true`</ph> if the type is security-transparent at the current trust level; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the type is security-transparent at the current trust level; otherwise, `false`."}],"pos":[711952,712045],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is serializable.","nodes":[{"pos":[0,85],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is serializable.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is serializable."}],"pos":[713157,713243],"yaml":true},{"content":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.","nodes":[{"pos":[0,352],"content":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.","pos":[0,162],"source":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed."},{"content":"For example, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents <ph id=\"ph2\">`MyGenericType&lt;int&gt;`</ph> (<ph id=\"ph3\">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id=\"ph4\">`MyGenericType&lt;T&gt;`</ph>.","pos":[163,352],"source":" For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`."}]},{"pos":[359,513],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`."}],"pos":[713254,713772],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is serializable; otherwise, `false`.","nodes":[{"pos":[0,83],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is serializable; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is serializable; otherwise, `false`."}],"pos":[714475,714561],"yaml":true},{"content":"Gets a value indicating whether the type has a name that requires special handling.","nodes":[{"pos":[0,83],"content":"Gets a value indicating whether the type has a name that requires special handling.","nodes":[{"content":"Gets a value indicating whether the type has a name that requires special handling.","pos":[0,83]}]}],"pos":[715660,715744],"yaml":true},{"content":"Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.","nodes":[{"pos":[0,192],"content":"Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.","nodes":[{"content":"Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.","pos":[0,192]}]},{"pos":[199,551],"content":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.","pos":[0,162],"source":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed."},{"content":"For example, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents <ph id=\"ph2\">`MyGenericType&lt;int&gt;`</ph> (<ph id=\"ph3\">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id=\"ph4\">`MyGenericType&lt;T&gt;`</ph>.","pos":[163,352],"source":" For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`."}]},{"pos":[558,712],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`."}],"pos":[715755,716474],"yaml":true,"extradata":"MT"},{"content":"`true` if the type has a name that requires special handling; otherwise, `false`.","nodes":[{"pos":[0,81],"content":"<ph id=\"ph1\">`true`</ph> if the type has a name that requires special handling; otherwise, <ph id=\"ph2\">`false`</ph>.","source":"`true` if the type has a name that requires special handling; otherwise, `false`."}],"pos":[716590,716674],"yaml":true},{"content":"Determines whether the current <xref href=\"System.Type\"></xref> derives from the specified <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,124],"content":"Determines whether the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> derives from the specified <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Determines whether the current <xref href=\"System.Type\"></xref> derives from the specified <xref href=\"System.Type\"></xref>."}],"pos":[717821,717946],"yaml":true},{"content":"You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:  \n  \n-   Whether one class derives from another.  \n  \n-   Whether a type derives from <xref:System.ValueType>. However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.  \n  \n-   Whether a type derives from <xref:System.Enum>. However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.  \n  \n-   Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.  \n  \n The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface. Use the<xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.  \n  \n [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]\n [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=fullName> if it has no class constraint.  \n  \n> [!NOTE]\n>  Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>. That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.  \n  \n This method can be overridden by a derived class.","nodes":[{"pos":[0,93],"content":"You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:","nodes":[{"content":"You can call the <ph id=\"ph1\">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method to determine any of the following:","pos":[0,93],"source":"You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:"}]},{"pos":[103,142],"content":"Whether one class derives from another.","nodes":[{"content":"Whether one class derives from another.","pos":[0,39]}]},{"pos":[152,320],"content":"Whether a type derives from <xref:System.ValueType>. However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.","nodes":[{"content":"Whether a type derives from <xref:System.ValueType>. However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.","pos":[0,168],"nodes":[{"content":"Whether a type derives from <ph id=\"ph1\">&lt;xref:System.ValueType&gt;</ph>.","pos":[0,52],"source":"Whether a type derives from <xref:System.ValueType>."},{"content":"However, the <ph id=\"ph1\">&lt;xref:System.Type.IsValueType%2A&gt;</ph> is a more efficient way to determine whether a type is a value type.","pos":[53,168],"source":" However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type."}]}]},{"pos":[330,497],"content":"Whether a type derives from <xref:System.Enum>. However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.","nodes":[{"content":"Whether a type derives from <xref:System.Enum>. However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.","pos":[0,167],"nodes":[{"content":"Whether a type derives from <ph id=\"ph1\">&lt;xref:System.Enum&gt;</ph>.","pos":[0,47],"source":"Whether a type derives from <xref:System.Enum>."},{"content":"However, the <ph id=\"ph1\">&lt;xref:System.Type.IsEnum%2A&gt;</ph> method is a more efficient way to determine whether a type is an enumeration.","pos":[48,167],"source":" However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration."}]}]},{"pos":[507,635],"content":"Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.","nodes":[{"content":"Whether a type is a delegate, that is, whether it derives from either <ph id=\"ph1\">&lt;xref:System.Delegate&gt;</ph> or <ph id=\"ph2\">&lt;xref:System.MulticastDelegate&gt;</ph>.","pos":[0,128],"source":"Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>."}]},{"pos":[642,915],"content":"The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface. Use the<xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.","nodes":[{"content":"The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface. Use the<xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.","pos":[0,273],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.","pos":[0,170],"source":"The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface."},{"content":"Use the<ph id=\"ph1\">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph> method for that purpose, as the following example shows.","pos":[171,273],"source":" Use the<xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows."}]}]},{"pos":[922,1223],"content":"<bpt id=\"p1\">[!code-csharp</bpt><bpt id=\"p2\">[</bpt>System.Type.IsSubclassOf#1<ept id=\"p2\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-vb</bpt><bpt id=\"p4\">[</bpt>System.Type.IsSubclassOf#1<ept id=\"p4\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)</ept><ept id=\"p3\">]</ept>","leadings":[""," "],"source":"[!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]\n[!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]"},{"pos":[1230,1468],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=fullName> if it has no class constraint.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <ph id=\"ph2\">&lt;xref:System.Object?displayProperty=fullName&gt;</ph> if it has no class constraint.","pos":[0,238],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=fullName> if it has no class constraint."}]},{"pos":[1476,1706],"content":"[!NOTE]\n Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>. That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.","leadings":["","> "],"nodes":[{"content":" Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>. That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.","pos":[8,228],"nodes":[{"content":"Except when used with interfaces, <ph id=\"ph1\">&lt;xref:System.Type.IsSubclassOf%2A&gt;</ph> is the converse of <ph id=\"ph2\">&lt;xref:System.Type.IsAssignableFrom%2A&gt;</ph>.","pos":[1,128],"source":" Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>."},{"content":"That is, if <ph id=\"ph1\">`t1.IsSubclassOf(t2)`</ph> is <ph id=\"ph2\">`true`</ph>, then <ph id=\"ph3\">`t2.IsAssignableFrom(t1)`</ph> is also <ph id=\"ph4\">`true`</ph>.","pos":[129,220],"source":" That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`."}]}]},{"pos":[1713,1762],"content":"This method can be overridden by a derived class.","nodes":[{"content":"This method can be overridden by a derived class.","pos":[0,49]}]}],"pos":[717957,719742],"yaml":true,"extradata":"MT"},{"content":"The type to compare with the current type.","nodes":[{"pos":[0,42],"content":"The type to compare with the current type.","nodes":[{"content":"The type to compare with the current type.","pos":[0,42]}]}],"pos":[720412,720455],"yaml":true},{"content":"`true` if the current `Type` derives from <code>c</code>; otherwise, `false`. This method also returns `false` if <code>c</code> and the current `Type` are equal.","nodes":[{"pos":[0,162],"content":"`true` if the current `Type` derives from <code>c</code>; otherwise, `false`. This method also returns `false` if <code>c</code> and the current `Type` are equal.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> if the current <ph id=\"ph2\">`Type`</ph> derives from <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph3\">c</ph><ept id=\"p1\">&lt;/code&gt;</ept>; otherwise, <ph id=\"ph4\">`false`</ph>.","pos":[0,77],"source":"`true` if the current `Type` derives from <code>c</code>; otherwise, `false`."},{"content":"This method also returns <ph id=\"ph1\">`false`</ph> if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">c</ph><ept id=\"p1\">&lt;/code&gt;</ept> and the current <ph id=\"ph3\">`Type`</ph> are equal.","pos":[78,162],"source":" This method also returns `false` if <code>c</code> and the current `Type` are equal."}]}],"pos":[720513,720678],"yaml":true},{"content":"<code>c</code> is `null`.","nodes":[{"pos":[0,25],"content":"<ph id=\"ph1\">&lt;code&gt;c&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>c</code> is `null`."}],"pos":[720832,720858],"yaml":true},{"content":"Gets a value indicating whether the string format attribute `UnicodeClass` is selected for the <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,128],"content":"Gets a value indicating whether the string format attribute <ph id=\"ph1\">`UnicodeClass`</ph> is selected for the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Gets a value indicating whether the string format attribute `UnicodeClass` is selected for the <xref href=\"System.Type\"></xref>."}],"pos":[723201,723330],"yaml":true},{"content":"The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.","nodes":[{"pos":[0,209],"content":"The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.","nodes":[{"content":"The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.","pos":[0,209],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Reflection.TypeAttributes.StringFormatMask&gt;</ph> is used to select the string format attributes.","pos":[0,108],"source":"The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes."},{"content":"The string format attributes enhance interoperability by defining how strings should be interpreted.","pos":[109,209]}]}]},{"pos":[216,568],"content":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.","pos":[0,162],"source":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed."},{"content":"For example, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents <ph id=\"ph2\">`MyGenericType&lt;int&gt;`</ph> (<ph id=\"ph3\">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id=\"ph4\">`MyGenericType&lt;T&gt;`</ph>.","pos":[163,352],"source":" For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`."}]},{"pos":[575,729],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns <ph id=\"ph2\">`false`</ph>.","source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`."}],"pos":[723341,724077],"yaml":true,"extradata":"MT"},{"content":"`true` if the string format attribute `UnicodeClass` is selected for the <xref href=\"System.Type\"></xref>; otherwise, `false`.","nodes":[{"pos":[0,126],"content":"<ph id=\"ph1\">`true`</ph> if the string format attribute <ph id=\"ph2\">`UnicodeClass`</ph> is selected for the <ph id=\"ph3\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>; otherwise, <ph id=\"ph4\">`false`</ph>.","source":"`true` if the string format attribute `UnicodeClass` is selected for the <xref href=\"System.Type\"></xref>; otherwise, `false`."}],"pos":[724194,724323],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is a value type.","nodes":[{"pos":[0,85],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a value type.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> is a value type."}],"pos":[725410,725496],"yaml":true},{"content":"Value types are types that are represented as sequences of bits; value types are not classes or interfaces. Value types are referred to as \"structs\" in some programming languages. Enums are a special case of value types.  \n  \n This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself. It is the base class for all value types, and therefore any value type can be assigned to it. This would not be possible if <xref:System.ValueType> itself was a value type. Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.  \n  \n This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself. For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.  \n  \n This property is read-only.","nodes":[{"pos":[0,220],"content":"Value types are types that are represented as sequences of bits; value types are not classes or interfaces. Value types are referred to as \"structs\" in some programming languages. Enums are a special case of value types.","nodes":[{"content":"Value types are types that are represented as sequences of bits; value types are not classes or interfaces. Value types are referred to as \"structs\" in some programming languages. Enums are a special case of value types.","pos":[0,220],"nodes":[{"content":"Value types are types that are represented as sequences of bits; value types are not classes or interfaces.","pos":[0,107]},{"content":"Value types are referred to as \"structs\" in some programming languages.","pos":[108,179]},{"content":"Enums are a special case of value types.","pos":[180,220]}]}]},{"pos":[227,617],"content":"This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself. It is the base class for all value types, and therefore any value type can be assigned to it. This would not be possible if <xref:System.ValueType> itself was a value type. Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.","nodes":[{"content":"This property returns <ph id=\"ph1\">`false`</ph> for the <ph id=\"ph2\">&lt;xref:System.ValueType&gt;</ph> class, because <ph id=\"ph3\">&lt;xref:System.ValueType&gt;</ph> is not a value type itself.","pos":[0,128],"source":"This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself."},{"content":"It is the base class for all value types, and therefore any value type can be assigned to it.","pos":[129,222]},{"content":"This would not be possible if <ph id=\"ph1\">&lt;xref:System.ValueType&gt;</ph> itself was a value type.","pos":[223,301],"source":" This would not be possible if <xref:System.ValueType> itself was a value type."},{"content":"Value types are boxed when they are assigned to a field of type <ph id=\"ph1\">&lt;xref:System.ValueType&gt;</ph>.","pos":[302,390],"source":" Value types are boxed when they are assigned to a field of type <xref:System.ValueType>."}]},{"pos":[624,800],"content":"This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself. For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.","nodes":[{"content":"This property returns <ph id=\"ph1\">`true`</ph> for enumerations, but not for the <ph id=\"ph2\">&lt;xref:System.Enum&gt;</ph> type itself.","pos":[0,94],"source":"This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself."},{"content":"For an example that demonstrates this behavior, see <ph id=\"ph1\">&lt;xref:System.Type.IsEnum%2A&gt;</ph>.","pos":[95,176],"source":" For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>."}]},{"pos":[807,834],"content":"This property is read-only.","nodes":[{"content":"This property is read-only.","pos":[0,27]}]}],"pos":[725507,726352],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is a value type; otherwise, `false`.","nodes":[{"pos":[0,83],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a value type; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is a value type; otherwise, `false`."}],"pos":[726975,727061],"yaml":true},{"content":"Implements the <xref href=\"System.Type.IsValueType\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is a value type; that is, not a class or an interface.","nodes":[{"pos":[0,183],"content":"Implements the <ph id=\"ph1\">&lt;xref href=\"System.Type.IsValueType\"&gt;&lt;/xref&gt;</ph> property and determines whether the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a value type; that is, not a class or an interface.","source":"Implements the <xref href=\"System.Type.IsValueType\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is a value type; that is, not a class or an interface."}],"pos":[728173,728357],"yaml":true},{"content":"This method is provided to enable the implementation of alternate type systems. It is not generally used in application code.","nodes":[{"pos":[0,125],"content":"This method is provided to enable the implementation of alternate type systems. It is not generally used in application code.","nodes":[{"content":"This method is provided to enable the implementation of alternate type systems. It is not generally used in application code.","pos":[0,125],"nodes":[{"content":"This method is provided to enable the implementation of alternate type systems.","pos":[0,79]},{"content":"It is not generally used in application code.","pos":[80,125]}]}]}],"pos":[728368,728494],"yaml":true,"extradata":"MT"},{"content":"`true` if the <xref href=\"System.Type\"></xref> is a value type; otherwise, `false`.","nodes":[{"pos":[0,83],"content":"<ph id=\"ph1\">`true`</ph> if the <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a value type; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the <xref href=\"System.Type\"></xref> is a value type; otherwise, `false`."}],"pos":[728637,728723],"yaml":true},{"content":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> can be accessed by code outside the assembly.","nodes":[{"pos":[0,114],"content":"Gets a value indicating whether the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> can be accessed by code outside the assembly.","source":"Gets a value indicating whether the <xref href=\"System.Type\"></xref> can be accessed by code outside the assembly."}],"pos":[730469,730584],"yaml":true},{"content":"Use this property to determine whether a type is part of the public interface of a component assembly.","nodes":[{"pos":[0,102],"content":"Use this property to determine whether a type is part of the public interface of a component assembly.","nodes":[{"content":"Use this property to determine whether a type is part of the public interface of a component assembly.","pos":[0,102]}]}],"pos":[730595,730698],"yaml":true,"extradata":"MT"},{"content":"`true` if the current <xref href=\"System.Type\"></xref> is a public type or a public nested type such that all the enclosing types are public; otherwise, `false`.","nodes":[{"pos":[0,161],"content":"<ph id=\"ph1\">`true`</ph> if the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is a public type or a public nested type such that all the enclosing types are public; otherwise, <ph id=\"ph3\">`false`</ph>.","source":"`true` if the current <xref href=\"System.Type\"></xref> is a public type or a public nested type such that all the enclosing types are public; otherwise, `false`."}],"pos":[731314,731478],"yaml":true},{"content":"Returns a <xref href=\"System.Type\"></xref> object representing an array of the current type, with the specified number of dimensions.","nodes":[{"pos":[0,133],"content":"Returns a <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object representing an array of the current type, with the specified number of dimensions.","source":"Returns a <xref href=\"System.Type\"></xref> object representing an array of the current type, with the specified number of dimensions."}],"pos":[732633,732767],"yaml":true},{"content":"The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.  \n  \n> [!NOTE]\n>  The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays. A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension. You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension. Use the <xref:System.Type.MakeArrayType> method overload to create vector types.","nodes":[{"pos":[0,131],"content":"The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method provides a way to generate array types whose element types are computed at run time.","pos":[0,131],"source":"The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time."}]},{"pos":[139,688],"content":"[!NOTE]\n The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays. A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension. You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension. Use the <xref:System.Type.MakeArrayType> method overload to create vector types.","leadings":["","> "],"nodes":[{"content":" The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays. A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension. You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension. Use the <xref:System.Type.MakeArrayType> method overload to create vector types.","pos":[8,547],"nodes":[{"content":"The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.","pos":[1,154]},{"content":"A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.","pos":[155,286]},{"content":"You cannot use this method overload to create a vector type; if <ph id=\"ph1\">`rank`</ph> is 1, this method overload returns a multidimensional array type that happens to have one dimension.","pos":[287,458],"source":" You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension."},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Type.MakeArrayType&gt;</ph> method overload to create vector types.","pos":[459,539],"source":" Use the <xref:System.Type.MakeArrayType> method overload to create vector types."}]}]}],"pos":[732778,733472],"yaml":true,"extradata":"MT"},{"content":"The number of dimensions for the array. This number must be less than or equal to 32.","nodes":[{"pos":[0,85],"content":"The number of dimensions for the array. This number must be less than or equal to 32.","nodes":[{"content":"The number of dimensions for the array. This number must be less than or equal to 32.","pos":[0,85],"nodes":[{"content":"The number of dimensions for the array.","pos":[0,39]},{"content":"This number must be less than or equal to 32.","pos":[40,85]}]}]}],"pos":[734150,734236],"yaml":true},{"content":"An object representing an array of the current type, with the specified number of dimensions.","nodes":[{"pos":[0,93],"content":"An object representing an array of the current type, with the specified number of dimensions.","nodes":[{"content":"An object representing an array of the current type, with the specified number of dimensions.","pos":[0,93]}]}],"pos":[734291,734385],"yaml":true},{"content":"<code>rank</code> is invalid. For example, 0 or negative.","nodes":[{"pos":[0,57],"content":"<code>rank</code> is invalid. For example, 0 or negative.","nodes":[{"content":"<ph id=\"ph1\">&lt;code&gt;rank&lt;/code&gt;</ph> is invalid.","pos":[0,29],"source":"<code>rank</code> is invalid."},{"content":"For example, 0 or negative.","pos":[30,57]}]}],"pos":[734546,734604],"yaml":true},{"content":"The invoked method is not supported in the base class.","nodes":[{"pos":[0,54],"content":"The invoked method is not supported in the base class.","nodes":[{"content":"The invoked method is not supported in the base class.","pos":[0,54]}]}],"pos":[734706,734761],"yaml":true},{"content":"The current type is <xref href=\"System.TypedReference\"></xref>.  \n  \n -or-  \n  \n The current type is a `ByRef` type. That is, <xref href=\"System.Type.IsByRef\"></xref> returns `true`.  \n  \n -or-  \n  \n <code>rank</code> is greater than 32.","nodes":[{"pos":[0,63],"content":"The current type is <ph id=\"ph1\">&lt;xref href=\"System.TypedReference\"&gt;&lt;/xref&gt;</ph>.","source":"The current type is <xref href=\"System.TypedReference\"></xref>."},{"pos":[70,74],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[81,182],"content":"The current type is a `ByRef` type. That is, <xref href=\"System.Type.IsByRef\"></xref> returns `true`.","nodes":[{"content":"The current type is a <ph id=\"ph1\">`ByRef`</ph> type.","pos":[0,35],"source":"The current type is a `ByRef` type."},{"content":"That is, <ph id=\"ph1\">&lt;xref href=\"System.Type.IsByRef\"&gt;&lt;/xref&gt;</ph> returns <ph id=\"ph2\">`true`</ph>.","pos":[36,101],"source":" That is, <xref href=\"System.Type.IsByRef\"></xref> returns `true`."}]},{"pos":[189,193],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[200,237],"content":"<ph id=\"ph1\">&lt;code&gt;rank&lt;/code&gt;</ph> is greater than 32.","source":"<code>rank</code> is greater than 32."}],"pos":[734855,735107],"yaml":true},{"content":"Returns a <xref href=\"System.Type\"></xref> object representing a one-dimensional array of the current type, with a lower bound of zero.","nodes":[{"pos":[0,135],"content":"Returns a <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object representing a one-dimensional array of the current type, with a lower bound of zero.","source":"Returns a <xref href=\"System.Type\"></xref> object representing a one-dimensional array of the current type, with a lower bound of zero."}],"pos":[736497,736633],"yaml":true},{"content":"The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.  \n  \n **Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays. A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension. This method overload can only be used to create vector types, and it is the only way to create a vector type. Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.","nodes":[{"pos":[0,131],"content":"The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method provides a way to generate array types whose element types are computed at run time.","pos":[0,131],"source":"The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time."}]},{"pos":[138,657],"content":"**Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays. A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension. This method overload can only be used to create vector types, and it is the only way to create a vector type. Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.","nodes":[{"content":"<bpt id=\"p1\">**</bpt>Note<ept id=\"p1\">**</ept> The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.","pos":[0,162],"source":"**Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays."},{"content":"A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.","pos":[163,294]},{"content":"This method overload can only be used to create vector types, and it is the only way to create a vector type.","pos":[295,404]},{"content":"Use the <ph id=\"ph1\">&lt;xref:System.Type.MakeArrayType%28System.Int32%29&gt;</ph> method overload to create multidimensional array types.","pos":[405,519],"source":" Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types."}]}],"pos":[736644,737306],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Type\"></xref> object representing a one-dimensional array of the current type, with a lower bound of zero.","nodes":[{"pos":[0,127],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object representing a one-dimensional array of the current type, with a lower bound of zero.","source":"A <xref href=\"System.Type\"></xref> object representing a one-dimensional array of the current type, with a lower bound of zero."}],"pos":[737975,738103],"yaml":true},{"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","nodes":[{"pos":[0,102],"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","nodes":[{"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","pos":[0,102],"nodes":[{"content":"The invoked method is not supported in the base class.","pos":[0,54]},{"content":"Derived classes must provide an implementation.","pos":[55,102]}]}]}],"pos":[738258,738361],"yaml":true},{"content":"The current type is <xref href=\"System.TypedReference\"></xref>.  \n  \n -or-  \n  \n The current type is a `ByRef` type. That is, <xref href=\"System.Type.IsByRef\"></xref> returns `true`.","nodes":[{"pos":[0,63],"content":"The current type is <ph id=\"ph1\">&lt;xref href=\"System.TypedReference\"&gt;&lt;/xref&gt;</ph>.","source":"The current type is <xref href=\"System.TypedReference\"></xref>."},{"pos":[70,74],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[81,182],"content":"The current type is a `ByRef` type. That is, <xref href=\"System.Type.IsByRef\"></xref> returns `true`.","nodes":[{"content":"The current type is a <ph id=\"ph1\">`ByRef`</ph> type.","pos":[0,35],"source":"The current type is a `ByRef` type."},{"content":"That is, <ph id=\"ph1\">&lt;xref href=\"System.Type.IsByRef\"&gt;&lt;/xref&gt;</ph> returns <ph id=\"ph2\">`true`</ph>.","pos":[36,101],"source":" That is, <xref href=\"System.Type.IsByRef\"></xref> returns `true`."}]}],"pos":[738455,738648],"yaml":true},{"content":"Returns a <xref href=\"System.Type\"></xref> object that represents the current type when passed as a `ref` parameter (`ByRef` parameter in Visual Basic).","nodes":[{"pos":[0,152],"content":"Returns a <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object that represents the current type when passed as a <ph id=\"ph2\">`ref`</ph> parameter (<ph id=\"ph3\">`ByRef`</ph> parameter in Visual Basic).","source":"Returns a <xref href=\"System.Type\"></xref> object that represents the current type when passed as a `ref` parameter (`ByRef` parameter in Visual Basic)."}],"pos":[740038,740191],"yaml":true},{"content":"The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.  \n  \n Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`.","nodes":[{"pos":[0,132],"content":"The <ph id=\"ph1\">&lt;xref:System.Type.MakeByRefType%2A&gt;</ph> method provides a way to generate <ph id=\"ph2\">`ref`</ph> types (<ph id=\"ph3\">`ByRef`</ph> in Visual Basic) for parameter lists.","source":"The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists."},{"pos":[139,342],"content":"Using the syntax of Microsoft intermediate language (MSIL), if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object represents <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph>, this method returns a <ph id=\"ph3\">&lt;xref:System.Type&gt;</ph> object representing <ph id=\"ph4\">`Int32&amp;`</ph>.","source":"Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`."}],"pos":[740202,740549],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Type\"></xref> object that represents the current type when passed as a `ref` parameter (`ByRef` parameter in Visual Basic).","nodes":[{"pos":[0,144],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object that represents the current type when passed as a <ph id=\"ph2\">`ref`</ph> parameter (<ph id=\"ph3\">`ByRef`</ph> parameter in Visual Basic).","source":"A <xref href=\"System.Type\"></xref> object that represents the current type when passed as a `ref` parameter (`ByRef` parameter in Visual Basic)."}],"pos":[741218,741363],"yaml":true},{"content":"The invoked method is not supported in the base class.","nodes":[{"pos":[0,54],"content":"The invoked method is not supported in the base class.","nodes":[{"content":"The invoked method is not supported in the base class.","pos":[0,54]}]}],"pos":[741518,741573],"yaml":true},{"content":"The current type is <xref href=\"System.TypedReference\"></xref>.  \n  \n -or-  \n  \n The current type is a `ByRef` type. That is, <xref href=\"System.Type.IsByRef\"></xref> returns `true`.","nodes":[{"pos":[0,63],"content":"The current type is <ph id=\"ph1\">&lt;xref href=\"System.TypedReference\"&gt;&lt;/xref&gt;</ph>.","source":"The current type is <xref href=\"System.TypedReference\"></xref>."},{"pos":[70,74],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[81,182],"content":"The current type is a `ByRef` type. That is, <xref href=\"System.Type.IsByRef\"></xref> returns `true`.","nodes":[{"content":"The current type is a <ph id=\"ph1\">`ByRef`</ph> type.","pos":[0,35],"source":"The current type is a `ByRef` type."},{"content":"That is, <ph id=\"ph1\">&lt;xref href=\"System.Type.IsByRef\"&gt;&lt;/xref&gt;</ph> returns <ph id=\"ph2\">`true`</ph>.","pos":[36,101],"source":" That is, <xref href=\"System.Type.IsByRef\"></xref> returns `true`."}]}],"pos":[741667,741860],"yaml":true},{"content":"Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <xref href=\"System.Type\"></xref> object representing the resulting constructed type.","nodes":[{"pos":[0,207],"content":"Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object representing the resulting constructed type.","source":"Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <xref href=\"System.Type\"></xref> object representing the resulting constructed type."}],"pos":[743325,743533],"yaml":true},{"content":"The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type. You can use this <xref:System.Type> object to create run-time instances of the constructed type.  \n  \n Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types. You might use such open constructed types when you emit dynamic assemblies. For example, consider the classes `Base` and `Derived` in the following code.  \n  \n [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]\n [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]\n [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  \n  \n To generate `Derived` in a dynamic assembly, it is necessary to construct its base type. To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`. Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.  \n  \n> [!NOTE]\n>  A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition. To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.  \n  \n The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A>method of any constructed type that was created from the same generic type definition using the same type arguments.  \n  \n> [!NOTE]\n>  An array of generic types is not itself a generic type. You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic). To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type. The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).  \n  \n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.  \n  \n## Nested Types  \n If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic. This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types. Consider the following classes:  \n  \n [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]\n [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]\n [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  \n  \n The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class. Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes. The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.  \n  \n If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.  \n  \n To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own. To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.  \n  \n The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types. Otherwise, the type parameters would not be in scope within the bodies of the nested types. It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Consider the following code for the MSIL assembler:  \n  \n```  \n.class public Outer<T> {  \n    .class nested public Inner<U> {  \n        .class nested public Innermost {  \n        }  \n    }  \n}  \n```  \n  \n In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope. The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:  \n  \n```  \n.class public Outer<T> {  \n    .class nested public Inner<T, U> {  \n        .class nested public Innermost<T, U, V> {  \n        }  \n    }  \n}  \n```  \n  \n You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme.","nodes":[{"pos":[0,340],"content":"The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type. You can use this <xref:System.Type> object to create run-time instances of the constructed type.","nodes":[{"content":"The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type. You can use this <xref:System.Type> object to create run-time instances of the constructed type.","pos":[0,340],"nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object that represents a particular constructed type.","pos":[0,243],"source":"The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type."},{"content":"You can use this <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object to create run-time instances of the constructed type.","pos":[244,340],"source":" You can use this <xref:System.Type> object to create run-time instances of the constructed type."}]}]},{"pos":[347,674],"content":"Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types. You might use such open constructed types when you emit dynamic assemblies. For example, consider the classes `Base` and `Derived` in the following code.","nodes":[{"content":"Types constructed with <ph id=\"ph1\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.","pos":[0,173],"source":"Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types."},{"content":"You might use such open constructed types when you emit dynamic assemblies.","pos":[174,249]},{"content":"For example, consider the classes <ph id=\"ph1\">`Base`</ph> and <ph id=\"ph2\">`Derived`</ph> in the following code.","pos":[250,327],"source":" For example, consider the classes `Base` and `Derived` in the following code."}]},{"pos":[681,1099],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Type.MakeGenericType#1<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Type.MakeGenericType#1<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Type.MakeGenericType#1<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]\n [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]\n [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]"},{"pos":[1106,1604],"content":"To generate `Derived` in a dynamic assembly, it is necessary to construct its base type. To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`. Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.","nodes":[{"content":"To generate <ph id=\"ph1\">`Derived`</ph> in a dynamic assembly, it is necessary to construct its base type.","pos":[0,88],"source":"To generate `Derived` in a dynamic assembly, it is necessary to construct its base type."},{"content":"To do this, call the <ph id=\"ph1\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object representing the class <ph id=\"ph3\">`Base`</ph>, using the generic type arguments <ph id=\"ph4\">&lt;xref:System.Int32&gt;</ph> and the type parameter <ph id=\"ph5\">`V`</ph> from <ph id=\"ph6\">`Derived`</ph>.","pos":[89,312],"source":" To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`."},{"content":"Because types and generic type parameters are both represented by <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> objects, an array containing both can be passed to the <ph id=\"ph2\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method.","pos":[313,498],"source":" Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method."}]},{"pos":[1612,2113],"content":"[!NOTE]\n A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition. To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.","leadings":["","> "],"nodes":[{"content":" A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition. To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.","pos":[8,499],"nodes":[{"content":"A constructed type such as <ph id=\"ph1\">`Base&lt;int, V&gt;`</ph> is useful when emitting code, but you cannot call the <ph id=\"ph2\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method on this type because it is not a generic type definition.","pos":[1,199],"source":" A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition."},{"content":"To create a closed constructed type that can be instantiated, first call the <ph id=\"ph1\">&lt;xref:System.Type.GetGenericTypeDefinition%2A&gt;</ph> method to get a <ph id=\"ph2\">&lt;xref:System.Type&gt;</ph> object representing the generic type definition and then call <ph id=\"ph3\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> with the desired type arguments.","pos":[200,491],"source":" To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments."}]}]},{"pos":[2120,2490],"content":"The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A>method of any constructed type that was created from the same generic type definition using the same type arguments.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object returned by <ph id=\"ph2\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> is the same as the <ph id=\"ph3\">&lt;xref:System.Type&gt;</ph> obtained by calling the <ph id=\"ph4\">&lt;xref:System.Object.GetType%2A&gt;</ph> method of the resulting constructed type, or the <ph id=\"ph5\">&lt;xref:System.Object.GetType%2A&gt;</ph>method of any constructed type that was created from the same generic type definition using the same type arguments.","pos":[0,370],"source":"The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A>method of any constructed type that was created from the same generic type definition using the same type arguments."}]},{"pos":[2498,3128],"content":"[!NOTE]\n An array of generic types is not itself a generic type. You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic). To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type. The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).","leadings":["","> "],"nodes":[{"content":" An array of generic types is not itself a generic type. You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic). To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type. The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).","pos":[8,628],"nodes":[{"content":"An array of generic types is not itself a generic type.","pos":[1,56]},{"content":"You cannot call <ph id=\"ph1\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> on an array type such as <ph id=\"ph2\">`C&lt;T&gt;[]`</ph> (<ph id=\"ph3\">`Dim ac() As C(Of T)`</ph> in Visual Basic).","pos":[57,185],"source":" You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic)."},{"content":"To construct a closed generic type from <ph id=\"ph1\">`C&lt;T&gt;[]`</ph>, call <ph id=\"ph2\">&lt;xref:System.Type.GetElementType%2A&gt;</ph> to obtain the generic type definition <ph id=\"ph3\">`C&lt;T&gt;`</ph>; call <ph id=\"ph4\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> on the generic type definition to create the constructed type; and finally call the <ph id=\"ph5\">&lt;xref:System.Type.MakeArrayType%2A&gt;</ph> method on the constructed type to create the array type.","pos":[186,543],"source":" To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type."},{"content":"The same is true of pointer types and <ph id=\"ph1\">`ref`</ph> types (<ph id=\"ph2\">`ByRef`</ph> in Visual Basic).","pos":[544,620],"source":" The same is true of pointer types and `ref` types (`ByRef` in Visual Basic)."}]}]},{"pos":[3135,3273],"content":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.","nodes":[{"content":"For a list of the invariant conditions for terms used in generic reflection, see the <ph id=\"ph1\">&lt;xref:System.Type.IsGenericType%2A&gt;</ph> property remarks.","pos":[0,138],"source":"For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks."}]},{"pos":[3282,3294],"content":"Nested Types","linkify":"Nested Types","nodes":[{"content":"Nested Types","pos":[0,12]}]},{"pos":[3298,3625],"content":"If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic. This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types. Consider the following classes:","nodes":[{"content":"If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic. This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types. Consider the following classes:","pos":[0,327],"nodes":[{"content":"If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.","pos":[0,99]},{"content":"This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.","pos":[100,295]},{"content":"Consider the following classes:","pos":[296,327]}]}]},{"pos":[3632,4050],"content":"<bpt id=\"p1\">[!code-cpp</bpt><bpt id=\"p2\">[</bpt>System.Type.MakeGenericType#2<ept id=\"p2\">](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)</ept><ept id=\"p1\">]</ept> <bpt id=\"p3\">[!code-csharp</bpt><bpt id=\"p4\">[</bpt>System.Type.MakeGenericType#2<ept id=\"p4\">](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)</ept><ept id=\"p3\">]</ept> <bpt id=\"p5\">[!code-vb</bpt><bpt id=\"p6\">[</bpt>System.Type.MakeGenericType#2<ept id=\"p6\">](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)</ept><ept id=\"p5\">]</ept>","source":"[!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]\n [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]\n [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]"},{"pos":[4057,4484],"content":"The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class. Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes. The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.","nodes":[{"content":"The type parameter list of the nested class <ph id=\"ph1\">`Inner`</ph> has two type parameters, <ph id=\"ph2\">`T`</ph> and <ph id=\"ph3\">`U`</ph>, the first of which is the type parameter of its enclosing class.","pos":[0,154],"source":"The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class."},{"content":"Similarly, the type parameter list of the nested class <ph id=\"ph1\">`Innermost1`</ph> has three type parameters, <ph id=\"ph2\">`T`</ph>, <ph id=\"ph3\">`U`</ph>, and <ph id=\"ph4\">`V`</ph>, with <ph id=\"ph5\">`T`</ph> and <ph id=\"ph6\">`U`</ph> coming from its enclosing classes.","pos":[155,320],"source":" Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes."},{"content":"The nested class <ph id=\"ph1\">`Innermost2`</ph> has two type parameters, <ph id=\"ph2\">`T`</ph> and <ph id=\"ph3\">`U`</ph>, which come from its enclosing classes.","pos":[321,427],"source":" The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes."}]},{"pos":[4491,4661],"content":"If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.","nodes":[{"content":"If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.","pos":[0,170]}]},{"pos":[4668,5359],"content":"To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own. To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.","nodes":[{"content":"To construct a generic type from the generic type definition for a nested type, call the <ph id=\"ph1\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.","pos":[0,373],"source":"To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own."},{"content":"To create an instance of <ph id=\"ph1\">`Innermost1`</ph>, call the <ph id=\"ph2\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with an array containing three types, to be assigned to T, U, and V. To create an instance of <ph id=\"ph3\">`Innermost2`</ph>, call the <ph id=\"ph4\">&lt;xref:System.Type.MakeGenericType%2A&gt;</ph> method with an array containing two types, to be assigned to T and U.","pos":[374,691],"source":" To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U."}]},{"pos":[5366,5909],"content":"The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types. Otherwise, the type parameters would not be in scope within the bodies of the nested types. It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Consider the following code for the MSIL assembler:","nodes":[{"content":"The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.","pos":[0,168]},{"content":"Otherwise, the type parameters would not be in scope within the bodies of the nested types.","pos":[169,260]},{"content":"It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the <bpt id=\"p1\">[</bpt>Ilasm.exe (IL Assembler)<ept id=\"p1\">](~/docs/framework/tools/ilasm-exe-il-assembler.md)</ept>.","pos":[261,491],"source":" It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md)."},{"content":"Consider the following code for the MSIL assembler:","pos":[492,543]}]},{"pos":[6063,6329],"content":"In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope. The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:","nodes":[{"content":"In this example, it is not possible to define a field of type <ph id=\"ph1\">`T`</ph> or <ph id=\"ph2\">`U`</ph> in class <ph id=\"ph3\">`Innermost`</ph>, because those type parameters are not in scope.","pos":[0,142],"source":"In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope."},{"content":"The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:","pos":[143,266]}]},{"pos":[6495,6689],"content":"You can use the <bpt id=\"p1\">[</bpt>Ildasm.exe (IL Disassembler)<ept id=\"p1\">](~/docs/framework/tools/ildasm-exe-il-disassembler.md)</ept> to examine nested classes defined in the high-level languages and observe this naming scheme.","source":"You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme."}],"pos":[743544,750291],"yaml":true,"extradata":"MT"},{"content":"An array of types to be substituted for the type parameters of the current generic type.","nodes":[{"pos":[0,88],"content":"An array of types to be substituted for the type parameters of the current generic type.","nodes":[{"content":"An array of types to be substituted for the type parameters of the current generic type.","pos":[0,88]}]}],"pos":[751258,751347],"yaml":true},{"content":"A <xref href=\"System.Type\"></xref> representing the constructed type formed by substituting the elements of <code>typeArguments</code> for the type parameters of the current generic type.","nodes":[{"pos":[0,187],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> representing the constructed type formed by substituting the elements of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">typeArguments</ph><ept id=\"p1\">&lt;/code&gt;</ept> for the type parameters of the current generic type.","source":"A <xref href=\"System.Type\"></xref> representing the constructed type formed by substituting the elements of <code>typeArguments</code> for the type parameters of the current generic type."}],"pos":[751402,751590],"yaml":true},{"content":"The current type does not represent a generic type definition. That is, <xref href=\"System.Type.IsGenericTypeDefinition\"></xref> returns `false`.","nodes":[{"pos":[0,145],"content":"The current type does not represent a generic type definition. That is, <xref href=\"System.Type.IsGenericTypeDefinition\"></xref> returns `false`.","nodes":[{"content":"The current type does not represent a generic type definition.","pos":[0,62]},{"content":"That is, <ph id=\"ph1\">&lt;xref href=\"System.Type.IsGenericTypeDefinition\"&gt;&lt;/xref&gt;</ph> returns <ph id=\"ph2\">`false`</ph>.","pos":[63,145],"source":" That is, <xref href=\"System.Type.IsGenericTypeDefinition\"></xref> returns `false`."}]}],"pos":[751755,751901],"yaml":true},{"content":"<code>typeArguments</code> is `null`.  \n  \n -or-  \n  \n Any element of <code>typeArguments</code> is `null`.","nodes":[{"pos":[0,37],"content":"<ph id=\"ph1\">&lt;code&gt;typeArguments&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>typeArguments</code> is `null`."},{"pos":[44,48],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[55,107],"content":"Any element of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeArguments</ph><ept id=\"p1\">&lt;/code&gt;</ept> is <ph id=\"ph2\">`null`</ph>.","source":"Any element of <code>typeArguments</code> is `null`."}],"pos":[752003,752117],"yaml":true},{"content":"The number of elements in <code>typeArguments</code> is not the same as the number of type parameters in the current generic type definition.  \n  \n -or-  \n  \n Any element of <code>typeArguments</code> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.  \n  \n -or-  \n  \n <code>typeArguments</code> contains an element that is a pointer type (<xref href=\"System.Type.IsPointer\"></xref> returns `true`), a by-ref type (<xref href=\"System.Type.IsByRef\"></xref> returns `true`), or <xref href=\"System.Void\"></xref>.","nodes":[{"pos":[0,141],"content":"The number of elements in <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeArguments</ph><ept id=\"p1\">&lt;/code&gt;</ept> is not the same as the number of type parameters in the current generic type definition.","source":"The number of elements in <code>typeArguments</code> is not the same as the number of type parameters in the current generic type definition."},{"pos":[148,152],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[159,309],"content":"Any element of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">typeArguments</ph><ept id=\"p1\">&lt;/code&gt;</ept> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.","source":"Any element of <code>typeArguments</code> does not satisfy the constraints specified for the corresponding type parameter of the current generic type."},{"pos":[316,320],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[327,567],"content":"<ph id=\"ph1\">&lt;code&gt;typeArguments&lt;/code&gt;</ph> contains an element that is a pointer type (<ph id=\"ph2\">&lt;xref href=\"System.Type.IsPointer\"&gt;&lt;/xref&gt;</ph> returns <ph id=\"ph3\">`true`</ph>), a by-ref type (<ph id=\"ph4\">&lt;xref href=\"System.Type.IsByRef\"&gt;&lt;/xref&gt;</ph> returns <ph id=\"ph5\">`true`</ph>), or <ph id=\"ph6\">&lt;xref href=\"System.Void\"&gt;&lt;/xref&gt;</ph>.","source":"<code>typeArguments</code> contains an element that is a pointer type (<xref href=\"System.Type.IsPointer\"></xref> returns `true`), a by-ref type (<xref href=\"System.Type.IsByRef\"></xref> returns `true`), or <xref href=\"System.Void\"></xref>."}],"pos":[752211,752795],"yaml":true},{"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","nodes":[{"pos":[0,102],"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","nodes":[{"content":"The invoked method is not supported in the base class. Derived classes must provide an implementation.","pos":[0,102],"nodes":[{"content":"The invoked method is not supported in the base class.","pos":[0,54]},{"content":"Derived classes must provide an implementation.","pos":[55,102]}]}]}],"pos":[752897,753000],"yaml":true},{"content":"Returns a <xref href=\"System.Type\"></xref> object that represents a pointer to the current type.","nodes":[{"pos":[0,96],"content":"Returns a <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object that represents a pointer to the current type.","source":"Returns a <xref href=\"System.Type\"></xref> object that represents a pointer to the current type."}],"pos":[754402,754499],"yaml":true},{"content":"The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.  \n  \n Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`.","nodes":[{"pos":[0,110],"content":"The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.","nodes":[{"content":"The <ph id=\"ph1\">&lt;xref:System.Type.MakePointerType%2A&gt;</ph> method provides a way to generate pointer types for parameter lists.","pos":[0,110],"source":"The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists."}]},{"pos":[117,320],"content":"Using the syntax of Microsoft intermediate language (MSIL), if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object represents <ph id=\"ph2\">&lt;xref:System.Int32&gt;</ph>, this method returns a <ph id=\"ph3\">&lt;xref:System.Type&gt;</ph> object representing <ph id=\"ph4\">`Int32*`</ph>.","source":"Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`."}],"pos":[754510,754835],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Type\"></xref> object that represents a pointer to the current type.","nodes":[{"pos":[0,88],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object that represents a pointer to the current type.","source":"A <xref href=\"System.Type\"></xref> object that represents a pointer to the current type."}],"pos":[755506,755595],"yaml":true},{"content":"The invoked method is not supported in the base class.","nodes":[{"pos":[0,54],"content":"The invoked method is not supported in the base class.","nodes":[{"content":"The invoked method is not supported in the base class.","pos":[0,54]}]}],"pos":[755752,755807],"yaml":true},{"content":"The current type is <xref href=\"System.TypedReference\"></xref>.  \n  \n -or-  \n  \n The current type is a `ByRef` type. That is, <xref href=\"System.Type.IsByRef\"></xref> returns `true`.","nodes":[{"pos":[0,63],"content":"The current type is <ph id=\"ph1\">&lt;xref href=\"System.TypedReference\"&gt;&lt;/xref&gt;</ph>.","source":"The current type is <xref href=\"System.TypedReference\"></xref>."},{"pos":[70,74],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[81,182],"content":"The current type is a `ByRef` type. That is, <xref href=\"System.Type.IsByRef\"></xref> returns `true`.","nodes":[{"content":"The current type is a <ph id=\"ph1\">`ByRef`</ph> type.","pos":[0,35],"source":"The current type is a `ByRef` type."},{"content":"That is, <ph id=\"ph1\">&lt;xref href=\"System.Type.IsByRef\"&gt;&lt;/xref&gt;</ph> returns <ph id=\"ph2\">`true`</ph>.","pos":[36,101],"source":" That is, <xref href=\"System.Type.IsByRef\"></xref> returns `true`."}]}],"pos":[755901,756094],"yaml":true},{"content":"Gets a <xref href=\"System.Reflection.MemberTypes\"></xref> value indicating that this member is a type or a nested type.","nodes":[{"pos":[0,119],"content":"Gets a <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MemberTypes\"&gt;&lt;/xref&gt;</ph> value indicating that this member is a type or a nested type.","source":"Gets a <xref href=\"System.Reflection.MemberTypes\"></xref> value indicating that this member is a type or a nested type."}],"pos":[757462,757582],"yaml":true},{"content":"This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=fullName>. Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objectsfor example, the array returned by <xref:System.Type.GetMembers%2A>the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes?displayProperty=fullName> when a given member is a nested type.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns<xref:System.Reflection.MemberTypes?displayProperty=fullName>.","nodes":[{"pos":[0,419],"content":"This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=fullName>. Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objectsfor example, the array returned by <xref:System.Type.GetMembers%2A>the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes?displayProperty=fullName> when a given member is a nested type.","nodes":[{"content":"This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=fullName>. Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objectsfor example, the array returned by <xref:System.Type.GetMembers%2A>the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes?displayProperty=fullName> when a given member is a nested type.","pos":[0,419],"nodes":[{"content":"This property overrides <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=fullName&gt;</ph>.","pos":[0,99],"source":"This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=fullName>."},{"content":"Therefore, when you examine a set of <ph id=\"ph1\">&lt;xref:System.Reflection.MemberInfo&gt;</ph> objectsfor example, the array returned by <ph id=\"ph2\">&lt;xref:System.Type.GetMembers%2A&gt;</ph>the <ph id=\"ph3\">&lt;xref:System.Reflection.MemberInfo.MemberType%2A&gt;</ph> property returns <ph id=\"ph4\">&lt;xref:System.Reflection.MemberTypes?displayProperty=fullName&gt;</ph> when a given member is a nested type.","pos":[100,419],"source":" Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objectsfor example, the array returned by <xref:System.Type.GetMembers%2A>the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes?displayProperty=fullName> when a given member is a nested type."}]}]},{"pos":[426,778],"content":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.","pos":[0,162],"source":"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed."},{"content":"For example, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents <ph id=\"ph2\">`MyGenericType&lt;int&gt;`</ph> (<ph id=\"ph3\">`MyGenericType(Of Integer)`</ph> in Visual Basic), the value of this property is determined by <ph id=\"ph4\">`MyGenericType&lt;T&gt;`</ph>.","pos":[163,352],"source":" For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`."}]},{"pos":[785,992],"content":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns<xref:System.Reflection.MemberTypes?displayProperty=fullName>.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property always returns<ph id=\"ph2\">&lt;xref:System.Reflection.MemberTypes?displayProperty=fullName&gt;</ph>.","pos":[0,207],"source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns<xref:System.Reflection.MemberTypes?displayProperty=fullName>."}]}],"pos":[757593,758592],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.Reflection.MemberTypes\"></xref> value indicating that this member is a type or a nested type.","nodes":[{"pos":[0,114],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.Reflection.MemberTypes\"&gt;&lt;/xref&gt;</ph> value indicating that this member is a type or a nested type.","source":"A <xref href=\"System.Reflection.MemberTypes\"></xref> value indicating that this member is a type or a nested type."}],"pos":[759322,759437],"yaml":true},{"content":"Represents a missing value in the <xref href=\"System.Type\"></xref> information. This field is read-only.","nodes":[{"pos":[0,104],"content":"Represents a missing value in the <xref href=\"System.Type\"></xref> information. This field is read-only.","nodes":[{"content":"Represents a missing value in the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> information.","pos":[0,79],"source":"Represents a missing value in the <xref href=\"System.Type\"></xref> information."},{"content":"This field is read-only.","pos":[80,104]}]}],"pos":[760493,760598],"yaml":true},{"content":"Use the `Missing` field for invocation through reflection to obtain the default value of a parameter. If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.","nodes":[{"pos":[0,255],"content":"Use the `Missing` field for invocation through reflection to obtain the default value of a parameter. If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.","nodes":[{"content":"Use the <ph id=\"ph1\">`Missing`</ph> field for invocation through reflection to obtain the default value of a parameter.","pos":[0,101],"source":"Use the `Missing` field for invocation through reflection to obtain the default value of a parameter."},{"content":"If the <ph id=\"ph1\">`Missing`</ph> field is passed in for a parameter value and there is no default value for that parameter, an <ph id=\"ph2\">&lt;xref:System.ArgumentException&gt;</ph> is thrown.","pos":[102,255],"source":" If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown."}]}],"pos":[760609,760865],"yaml":true,"extradata":"MT"},{"content":"Gets the module (the DLL) in which the current <xref href=\"System.Type\"></xref> is defined.","nodes":[{"pos":[0,91],"content":"Gets the module (the DLL) in which the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is defined.","source":"Gets the module (the DLL) in which the current <xref href=\"System.Type\"></xref> is defined."}],"pos":[763049,763141],"yaml":true},{"content":"If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined. For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.  \n  \n Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.","nodes":[{"pos":[0,347],"content":"If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined. For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the module in which the generic type definition was defined.","pos":[0,155],"source":"If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined."},{"content":"For example, if you create an instance of <ph id=\"ph1\">`MyGenericStack&lt;int&gt;`</ph>, the <ph id=\"ph2\">&lt;xref:System.Type.Module%2A&gt;</ph> property for the constructed type returns the module in which <ph id=\"ph3\">`MyGenericStack&lt;T&gt;`</ph> is defined.","pos":[156,347],"source":" For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined."}]},{"pos":[354,518],"content":"Similarly, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a generic parameter <ph id=\"ph2\">`T`</ph>, this property returns the assembly that contains the generic type that defines <ph id=\"ph3\">`T`</ph>.","source":"Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`."}],"pos":[763152,763675],"yaml":true,"extradata":"MT"},{"content":"The module in which the current <xref href=\"System.Type\"></xref> is defined.","nodes":[{"pos":[0,76],"content":"The module in which the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> is defined.","source":"The module in which the current <xref href=\"System.Type\"></xref> is defined."}],"pos":[764356,764433],"yaml":true},{"content":"Gets the namespace of the <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,59],"content":"Gets the namespace of the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Gets the namespace of the <xref href=\"System.Type\"></xref>."}],"pos":[766356,766416],"yaml":true},{"content":"A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure. From the viewpoint of the runtime, there are no namespaces.  \n  \n If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition. Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.  \n  \n If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.","nodes":[{"pos":[0,235],"content":"A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure. From the viewpoint of the runtime, there are no namespaces.","nodes":[{"content":"A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure. From the viewpoint of the runtime, there are no namespaces.","pos":[0,235],"nodes":[{"content":"A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.","pos":[0,175]},{"content":"From the viewpoint of the runtime, there are no namespaces.","pos":[176,235]}]}]},{"pos":[242,570],"content":"If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition. Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.","nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a constructed generic type, this property returns the namespace that contains the generic type definition.","pos":[0,151],"source":"If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition."},{"content":"Similarly, if the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a generic parameter <ph id=\"ph2\">`T`</ph>, this property returns the namespace that contains the generic type definition that defines <ph id=\"ph3\">`T`</ph>.","pos":[152,328],"source":" Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`."}]},{"pos":[577,679],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> object represents a generic parameter, this property returns <ph id=\"ph2\">`null`</ph>.","source":"If the current <xref:System.Type> object represents a generic parameter, this property returns `null`."}],"pos":[766427,767113],"yaml":true,"extradata":"MT"},{"content":"The namespace of the <xref href=\"System.Type\"></xref>; `null` if the current instance has no namespace or represents a generic parameter.","nodes":[{"pos":[0,137],"content":"The namespace of the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>; <ph id=\"ph2\">`null`</ph> if the current instance has no namespace or represents a generic parameter.","source":"The namespace of the <xref href=\"System.Type\"></xref>; `null` if the current instance has no namespace or represents a generic parameter."}],"pos":[767768,767906],"yaml":true},{"content":"Indicates whether two <xref href=\"System.Type\"></xref> objects are equal.","nodes":[{"pos":[0,73],"content":"Indicates whether two <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects are equal.","source":"Indicates whether two <xref href=\"System.Type\"></xref> objects are equal."}],"pos":[769443,769517],"yaml":true},{"content":"The first object to compare.","nodes":[{"pos":[0,28],"content":"The first object to compare.","nodes":[{"content":"The first object to compare.","pos":[0,28]}]}],"pos":[769670,769699],"yaml":true},{"content":"The second object to compare.","nodes":[{"pos":[0,29],"content":"The second object to compare.","nodes":[{"content":"The second object to compare.","pos":[0,29]}]}],"pos":[769758,769788],"yaml":true},{"content":"`true` if <code>left</code> is equal to <code>right</code>; otherwise, `false`.","nodes":[{"pos":[0,79],"content":"<ph id=\"ph1\">`true`</ph> if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">left</ph><ept id=\"p1\">&lt;/code&gt;</ept> is equal to <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">right</ph><ept id=\"p2\">&lt;/code&gt;</ept>; otherwise, <ph id=\"ph4\">`false`</ph>.","source":"`true` if <code>left</code> is equal to <code>right</code>; otherwise, `false`."}],"pos":[769846,769928],"yaml":true},{"content":"Indicates whether two <xref href=\"System.Type\"></xref> objects are not equal.","nodes":[{"pos":[0,77],"content":"Indicates whether two <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> objects are not equal.","source":"Indicates whether two <xref href=\"System.Type\"></xref> objects are not equal."}],"pos":[771135,771213],"yaml":true},{"content":"The first object to compare.","nodes":[{"pos":[0,28],"content":"The first object to compare.","nodes":[{"content":"The first object to compare.","pos":[0,28]}]}],"pos":[771368,771397],"yaml":true},{"content":"The second object to compare.","nodes":[{"pos":[0,29],"content":"The second object to compare.","nodes":[{"content":"The second object to compare.","pos":[0,29]}]}],"pos":[771456,771486],"yaml":true},{"content":"`true` if <code>left</code> is not equal to <code>right</code>; otherwise, `false`.","nodes":[{"pos":[0,83],"content":"<ph id=\"ph1\">`true`</ph> if <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">left</ph><ept id=\"p1\">&lt;/code&gt;</ept> is not equal to <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph3\">right</ph><ept id=\"p2\">&lt;/code&gt;</ept>; otherwise, <ph id=\"ph4\">`false`</ph>.","source":"`true` if <code>left</code> is not equal to <code>right</code>; otherwise, `false`."}],"pos":[771544,771630],"yaml":true},{"content":"Gets the class object that was used to obtain this member.","nodes":[{"pos":[0,58],"content":"Gets the class object that was used to obtain this member.","nodes":[{"content":"Gets the class object that was used to obtain this member.","pos":[0,58]}]}],"pos":[772728,772787],"yaml":true},{"content":"For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.","nodes":[{"pos":[0,143],"content":"For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.","nodes":[{"content":"For <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> objects, the value of this property is always the same as the value of the <ph id=\"ph2\">&lt;xref:System.Type.DeclaringType%2A&gt;</ph> property.","pos":[0,143],"source":"For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property."}]}],"pos":[772798,772942],"yaml":true,"extradata":"MT"},{"content":"The `Type` object through which this <xref href=\"System.Type\"></xref> object was obtained.","nodes":[{"pos":[0,90],"content":"The <ph id=\"ph1\">`Type`</ph> object through which this <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> object was obtained.","source":"The `Type` object through which this <xref href=\"System.Type\"></xref> object was obtained."}],"pos":[773612,773703],"yaml":true},{"content":"Gets the <xref href=\"System.Type\"></xref> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found. The type is loaded for reflection only, not for execution.","nodes":[{"pos":[0,239],"content":"Gets the <xref href=\"System.Type\"></xref> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found. The type is loaded for reflection only, not for execution.","nodes":[{"content":"Gets the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.","pos":[0,180],"source":"Gets the <xref href=\"System.Type\"></xref> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found."},{"content":"The type is loaded for reflection only, not for execution.","pos":[181,239]}]}],"pos":[775060,775300],"yaml":true},{"content":"If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method. For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=fullName> property. For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.  \n  \n If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.  \n  \n The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of `throwIfNotFound`. For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.  \n  \n For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).","nodes":[{"pos":[0,710],"content":"If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method. For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=fullName> property. For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.","nodes":[{"content":"If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method. For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=fullName> property. For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.","pos":[0,710],"nodes":[{"content":"If the assembly containing the type is not already loaded into the reflection-only context, using the <ph id=\"ph1\">&lt;xref:System.Type.ReflectionOnlyGetType%2A&gt;</ph> method is equivalent to first loading the assembly for reflection only, using the <ph id=\"ph2\">&lt;xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A&gt;</ph> method, and then loading the type by calling the assembly's <ph id=\"ph3\">&lt;xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName&gt;</ph> method.","pos":[0,421],"source":"If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method."},{"content":"For information about assembly-qualified names, see the <ph id=\"ph1\">&lt;xref:System.Type.AssemblyQualifiedName%2A?displayProperty=fullName&gt;</ph> property.","pos":[422,556],"source":" For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=fullName> property."},{"content":"For additional details on specifying type names, see the <ph id=\"ph1\">&lt;xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29&gt;</ph> method overload.","pos":[557,710],"source":" For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload."}]}]},{"pos":[717,822],"content":"If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.","nodes":[{"content":"If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.","pos":[0,105]}]},{"pos":[829,1211],"content":"The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of `throwIfNotFound`. For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.","nodes":[{"content":"The <ph id=\"ph1\">`throwIfNotFound`</ph> parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.","pos":[0,178],"source":"The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section."},{"content":"Some exceptions are thrown regardless of the value of <ph id=\"ph1\">`throwIfNotFound`</ph>.","pos":[179,251],"source":" Some exceptions are thrown regardless of the value of `throwIfNotFound`."},{"content":"For example, if the assembly is not valid, a <ph id=\"ph1\">&lt;xref:System.BadImageFormatException&gt;</ph> is thrown even if <ph id=\"ph2\">`throwIfNotFound`</ph> is <ph id=\"ph3\">`false`</ph>.","pos":[252,382],"source":" For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`."}]},{"pos":[1218,1443],"content":"For more information about using the reflection-only context, see <bpt id=\"p1\">[</bpt>How to: Load Assemblies into the Reflection-Only Context<ept id=\"p1\">](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)</ept>.","source":"For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md)."}],"pos":[775311,776763],"yaml":true,"extradata":"MT"},{"content":"The assembly-qualified name of the <xref href=\"System.Type\"></xref> to get.","nodes":[{"pos":[0,75],"content":"The assembly-qualified name of the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph> to get.","source":"The assembly-qualified name of the <xref href=\"System.Type\"></xref> to get."}],"pos":[776965,777041],"yaml":true},{"content":"`true` to throw a <xref href=\"System.TypeLoadException\"></xref> if the type cannot be found; `false` to return `null` if the type cannot be found. Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.","nodes":[{"pos":[0,263],"content":"`true` to throw a <xref href=\"System.TypeLoadException\"></xref> if the type cannot be found; `false` to return `null` if the type cannot be found. Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.","nodes":[{"content":"<ph id=\"ph1\">`true`</ph> to throw a <ph id=\"ph2\">&lt;xref href=\"System.TypeLoadException\"&gt;&lt;/xref&gt;</ph> if the type cannot be found; <ph id=\"ph3\">`false`</ph> to return <ph id=\"ph4\">`null`</ph> if the type cannot be found.","pos":[0,146],"source":"`true` to throw a <xref href=\"System.TypeLoadException\"></xref> if the type cannot be found; `false` to return `null` if the type cannot be found."},{"content":"Specifying <ph id=\"ph1\">`false`</ph> also suppresses some other exception conditions, but not all of them.","pos":[147,235],"source":" Specifying `false` also suppresses some other exception conditions, but not all of them."},{"content":"See the Exceptions section.","pos":[236,263]}]}],"pos":[777113,777379],"yaml":true},{"content":"`true` to perform a case-insensitive search for <code>typeName</code>; `false` to perform a case-sensitive search for <code>typeName</code>.","nodes":[{"pos":[0,140],"content":"<ph id=\"ph1\">`true`</ph> to perform a case-insensitive search for <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph2\">typeName</ph><ept id=\"p1\">&lt;/code&gt;</ept>; <ph id=\"ph3\">`false`</ph> to perform a case-sensitive search for <bpt id=\"p2\">&lt;code&gt;</bpt><ph id=\"ph4\">typeName</ph><ept id=\"p2\">&lt;/code&gt;</ept>.","source":"`true` to perform a case-insensitive search for <code>typeName</code>; `false` to perform a case-sensitive search for <code>typeName</code>."}],"pos":[777446,777589],"yaml":true},{"content":"The type with the specified name, if found; otherwise, `null`. If the type is not found, the <code>throwIfNotFound</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwIfNotFound</code>. See the Exceptions section.","nodes":[{"pos":[0,318],"content":"The type with the specified name, if found; otherwise, `null`. If the type is not found, the <code>throwIfNotFound</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwIfNotFound</code>. See the Exceptions section.","nodes":[{"content":"The type with the specified name, if found; otherwise, <ph id=\"ph1\">`null`</ph>.","pos":[0,62],"source":"The type with the specified name, if found; otherwise, `null`."},{"content":"If the type is not found, the <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">throwIfNotFound</ph><ept id=\"p1\">&lt;/code&gt;</ept> parameter specifies whether <ph id=\"ph2\">`null`</ph> is returned or an exception is thrown.","pos":[63,195],"source":" If the type is not found, the <code>throwIfNotFound</code> parameter specifies whether `null` is returned or an exception is thrown."},{"content":"In some cases, an exception is thrown regardless of the value of <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">throwIfNotFound</ph><ept id=\"p1\">&lt;/code&gt;</ept>.","pos":[196,290],"source":" In some cases, an exception is thrown regardless of the value of <code>throwIfNotFound</code>."},{"content":"See the Exceptions section.","pos":[291,318]}]}],"pos":[777644,777963],"yaml":true},{"content":"<code>typeName</code> is `null`.","nodes":[{"pos":[0,32],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> is <ph id=\"ph2\">`null`</ph>.","source":"<code>typeName</code> is `null`."}],"pos":[778126,778159],"yaml":true},{"content":"A class initializer is invoked and throws an exception.","nodes":[{"pos":[0,55],"content":"A class initializer is invoked and throws an exception.","nodes":[{"content":"A class initializer is invoked and throws an exception.","pos":[0,55]}]}],"pos":[778291,778347],"yaml":true},{"content":"<code>throwIfNotFound</code> is `true` and the type is not found.  \n  \n -or-  \n  \n <code>throwIfNotFound</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab.  \n  \n -or-  \n  \n <code>throwIfNotFound</code> is `true` and <code>typeName</code> is an empty string.  \n  \n -or-  \n  \n <code>throwIfNotFound</code> is `true` and <code>typeName</code> represents an array type with an invalid size.  \n  \n -or-  \n  \n <code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref> objects.","nodes":[{"pos":[0,65],"content":"<ph id=\"ph1\">&lt;code&gt;throwIfNotFound&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and the type is not found.","source":"<code>throwIfNotFound</code> is `true` and the type is not found."},{"pos":[72,76],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[83,201],"content":"<ph id=\"ph1\">&lt;code&gt;throwIfNotFound&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid characters, such as an embedded tab.","source":"<code>throwIfNotFound</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab."},{"pos":[208,212],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[219,303],"content":"<ph id=\"ph1\">&lt;code&gt;throwIfNotFound&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> is an empty string.","source":"<code>throwIfNotFound</code> is `true` and <code>typeName</code> is an empty string."},{"pos":[310,314],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[321,432],"content":"<ph id=\"ph1\">&lt;code&gt;throwIfNotFound&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array type with an invalid size.","source":"<code>throwIfNotFound</code> is `true` and <code>typeName</code> represents an array type with an invalid size."},{"pos":[439,443],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[450,546],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents an array of <ph id=\"ph2\">&lt;xref href=\"System.TypedReference\"&gt;&lt;/xref&gt;</ph> objects.","source":"<code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref> objects."}],"pos":[778441,779008],"yaml":true},{"content":"<code>typeName</code> does not include the assembly name.  \n  \n -or-  \n  \n <code>throwIfNotFound</code> is `true` and <code>typeName</code> contains invalid syntax; for example, \"MyType[,*,]\".  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\"System.Void\"></xref> as one of its type arguments.  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  \n  \n -or-  \n  \n <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.","nodes":[{"pos":[0,57],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> does not include the assembly name.","source":"<code>typeName</code> does not include the assembly name."},{"pos":[64,68],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[75,192],"content":"<ph id=\"ph1\">&lt;code&gt;throwIfNotFound&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and <ph id=\"ph3\">&lt;code&gt;typeName&lt;/code&gt;</ph> contains invalid syntax; for example, \"MyType[,*,]\".","source":"<code>throwIfNotFound</code> is `true` and <code>typeName</code> contains invalid syntax; for example, \"MyType[,*,]\"."},{"pos":[199,203],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[210,364],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has a pointer type, a <ph id=\"ph2\">`ByRef`</ph> type, or <ph id=\"ph3\">&lt;xref href=\"System.Void\"&gt;&lt;/xref&gt;</ph> as one of its type arguments.","source":"<code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\"System.Void\"></xref> as one of its type arguments."},{"pos":[371,375],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[382,477],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type that has an incorrect number of type arguments.","source":"<code>typeName</code> represents a generic type that has an incorrect number of type arguments."},{"pos":[484,488],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[495,644],"content":"<ph id=\"ph1\">&lt;code&gt;typeName&lt;/code&gt;</ph> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.","source":"<code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter."}],"pos":[779102,779769],"yaml":true},{"content":"<code>throwIfNotFound</code> is `true` and the assembly or one of its dependencies was not found.","nodes":[{"pos":[0,97],"content":"<ph id=\"ph1\">&lt;code&gt;throwIfNotFound&lt;/code&gt;</ph> is <ph id=\"ph2\">`true`</ph> and the assembly or one of its dependencies was not found.","source":"<code>throwIfNotFound</code> is `true` and the assembly or one of its dependencies was not found."}],"pos":[779877,779975],"yaml":true},{"content":"The assembly or one of its dependencies was found, but could not be loaded.","nodes":[{"pos":[0,75],"content":"The assembly or one of its dependencies was found, but could not be loaded.","nodes":[{"content":"The assembly or one of its dependencies was found, but could not be loaded.","pos":[0,75]}]}],"pos":[780075,780151],"yaml":true},{"content":"The assembly or one of its dependencies is not valid.  \n  \n -or-  \n  \n The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.","nodes":[{"pos":[0,53],"content":"The assembly or one of its dependencies is not valid.","nodes":[{"content":"The assembly or one of its dependencies is not valid.","pos":[0,53]}]},{"pos":[60,64],"content":"-or-","nodes":[{"content":"-or-","pos":[0,4]}]},{"pos":[71,191],"content":"The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.","nodes":[{"content":"The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.","pos":[0,120]}]}],"pos":[780257,780455],"yaml":true},{"content":"Gets a <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"></xref> that describes the layout of the current type.","nodes":[{"pos":[0,127],"content":"Gets a <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"&gt;&lt;/xref&gt;</ph> that describes the layout of the current type.","source":"Gets a <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"></xref> that describes the layout of the current type."}],"pos":[781545,781673],"yaml":true},{"content":"<xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method. Instead, use this property to get it.","nodes":[{"pos":[0,187],"content":"<xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method. Instead, use this property to get it.","nodes":[{"content":"<xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method. Instead, use this property to get it.","pos":[0,187],"nodes":[{"content":"<ph id=\"ph1\">&lt;xref:System.Runtime.InteropServices.StructLayoutAttribute&gt;</ph> is not returned by the <ph id=\"ph2\">&lt;xref:System.Reflection.MemberInfo.GetCustomAttributes%2A&gt;</ph> method.","pos":[0,149],"source":"<xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method."},{"content":"Instead, use this property to get it.","pos":[150,187]}]}]}],"pos":[781684,781872],"yaml":true,"extradata":"MT"},{"content":"Gets a <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"></xref> that describes the gross layout features of the current type.","nodes":[{"pos":[0,142],"content":"Gets a <ph id=\"ph1\">&lt;xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"&gt;&lt;/xref&gt;</ph> that describes the gross layout features of the current type.","source":"Gets a <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"></xref> that describes the gross layout features of the current type."}],"pos":[782895,783038],"yaml":true},{"content":"The invoked method is not supported in the base class.","nodes":[{"pos":[0,54],"content":"The invoked method is not supported in the base class.","nodes":[{"content":"The invoked method is not supported in the base class.","pos":[0,54]}]}],"pos":[783201,783256],"yaml":true},{"content":"Returns a `String` representing the name of the current `Type`.","nodes":[{"pos":[0,63],"content":"Returns a <ph id=\"ph1\">`String`</ph> representing the name of the current <ph id=\"ph2\">`Type`</ph>.","source":"Returns a `String` representing the name of the current `Type`."}],"pos":[784272,784336],"yaml":true},{"content":"This method returns the fully qualified common language runtime namespace and name for all primitive types. For example, the C# instruction, `(long)0.Type().ToString()` returns \"System.Int64\" instead of merely \"Int64\".  \n  \n If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly. If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.","nodes":[{"pos":[0,218],"content":"This method returns the fully qualified common language runtime namespace and name for all primitive types. For example, the C# instruction, `(long)0.Type().ToString()` returns \"System.Int64\" instead of merely \"Int64\".","nodes":[{"content":"This method returns the fully qualified common language runtime namespace and name for all primitive types.","pos":[0,107]},{"content":"For example, the C# instruction, <ph id=\"ph1\">`(long)0.Type().ToString()`</ph> returns \"System.Int64\" instead of merely \"Int64\".","pos":[108,218],"source":" For example, the C# instruction, `(long)0.Type().ToString()` returns \"System.Int64\" instead of merely \"Int64\"."}]},{"pos":[225,566],"content":"If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly. If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.","nodes":[{"content":"If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly. If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.","pos":[0,341],"nodes":[{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.","pos":[0,160],"source":"If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly."},{"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.","pos":[161,341],"source":" If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter."}]}]}],"pos":[784347,784922],"yaml":true,"extradata":"MT"},{"content":"A <xref href=\"System.String\"></xref> representing the name of the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,107],"content":"A <ph id=\"ph1\">&lt;xref href=\"System.String\"&gt;&lt;/xref&gt;</ph> representing the name of the current <ph id=\"ph2\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"A <xref href=\"System.String\"></xref> representing the name of the current <xref href=\"System.Type\"></xref>."}],"pos":[786070,786178],"yaml":true},{"content":"Gets the handle for the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,65],"content":"Gets the handle for the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"Gets the handle for the current <xref href=\"System.Type\"></xref>."}],"pos":[787597,787663],"yaml":true},{"content":"`TypeHandle` encapsulates a pointer to an internal data structure that represents the type. This handle is unique during the process lifetime. The handle is valid only in the application domain in which it was obtained.","nodes":[{"pos":[0,219],"content":"`TypeHandle` encapsulates a pointer to an internal data structure that represents the type. This handle is unique during the process lifetime. The handle is valid only in the application domain in which it was obtained.","nodes":[{"content":"<ph id=\"ph1\">`TypeHandle`</ph> encapsulates a pointer to an internal data structure that represents the type.","pos":[0,91],"source":"`TypeHandle` encapsulates a pointer to an internal data structure that represents the type."},{"content":"This handle is unique during the process lifetime.","pos":[92,142]},{"content":"The handle is valid only in the application domain in which it was obtained.","pos":[143,219]}]}],"pos":[787674,787896],"yaml":true,"extradata":"MT"},{"content":"The handle for the current <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,60],"content":"The handle for the current <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"The handle for the current <xref href=\"System.Type\"></xref>."}],"pos":[788570,788631],"yaml":true},{"content":"The .NET Compact Framework does not currently support this property.","nodes":[{"pos":[0,68],"content":"The .NET Compact Framework does not currently support this property.","nodes":[{"content":"The .NET Compact Framework does not currently support this property.","pos":[0,68]}]}],"pos":[788783,788852],"yaml":true},{"content":"Gets the initializer for the type.","nodes":[{"pos":[0,34],"content":"Gets the initializer for the type.","nodes":[{"content":"Gets the initializer for the type.","pos":[0,34]}]}],"pos":[790250,790285],"yaml":true},{"content":"Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.  \n  \n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`.","nodes":[{"pos":[0,338],"content":"Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.","nodes":[{"content":"Class initializers are also available through the <ph id=\"ph1\">&lt;xref:System.Type.FindMembers%2A&gt;</ph> method, or through overloads of the <ph id=\"ph2\">&lt;xref:System.Type.GetMember%2A&gt;</ph>, <ph id=\"ph3\">&lt;xref:System.Type.GetMembers%2A&gt;</ph>, <ph id=\"ph4\">&lt;xref:System.Type.GetConstructor%2A&gt;</ph>, and <ph id=\"ph5\">&lt;xref:System.Type.GetConstructors%2A&gt;</ph> methods that take <ph id=\"ph6\">&lt;xref:System.Reflection.BindingFlags&gt;</ph> as a parameter.","pos":[0,338],"source":"Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter."}]},{"pos":[345,491],"content":"If the current <ph id=\"ph1\">&lt;xref:System.Type&gt;</ph> represents a type parameter in the definition of a generic type or generic method, this property returns <ph id=\"ph2\">`null`</ph>.","source":"If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`."}],"pos":[790296,790792],"yaml":true,"extradata":"MT"},{"content":"An object that contains the name of the class constructor for the <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,99],"content":"An object that contains the name of the class constructor for the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"An object that contains the name of the class constructor for the <xref href=\"System.Type\"></xref>."}],"pos":[791024,791124],"yaml":true},{"content":"Indicates the type provided by the common language runtime that represents this type.","nodes":[{"pos":[0,85],"content":"Indicates the type provided by the common language runtime that represents this type.","nodes":[{"content":"Indicates the type provided by the common language runtime that represents this type.","pos":[0,85]}]}],"pos":[792341,792427],"yaml":true},{"content":"The underlying system type for the <xref href=\"System.Type\"></xref>.","nodes":[{"pos":[0,68],"content":"The underlying system type for the <ph id=\"ph1\">&lt;xref href=\"System.Type\"&gt;&lt;/xref&gt;</ph>.","source":"The underlying system type for the <xref href=\"System.Type\"></xref>."}],"pos":[792556,792625],"yaml":true},{"content":"Maps a set of names to a corresponding set of dispatch identifiers.","nodes":[{"pos":[0,67],"content":"Maps a set of names to a corresponding set of dispatch identifiers.","nodes":[{"content":"Maps a set of names to a corresponding set of dispatch identifiers.","pos":[0,67]}]}],"pos":[794160,794228],"yaml":true},{"content":"This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.","nodes":[{"pos":[0,186],"content":"This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.","nodes":[{"content":"This method is for access to managed classes from unmanaged code, and should not be called from managed code.","pos":[0,109]},{"content":"For more information about <ph id=\"ph1\">`IDispatch::GetIDsOfNames`</ph>, see the MSDN Library.","pos":[110,186],"source":" For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library."}]}],"pos":[794239,794426],"yaml":true,"extradata":"MT"},{"content":"Reserved for future use. Must be IID_NULL.","nodes":[{"pos":[0,42],"content":"Reserved for future use. Must be IID_NULL.","nodes":[{"content":"Reserved for future use. Must be IID_NULL.","pos":[0,42],"nodes":[{"content":"Reserved for future use.","pos":[0,24]},{"content":"Must be IID_NULL.","pos":[25,42]}]}]}],"pos":[794624,794667],"yaml":true},{"content":"Passed-in array of names to be mapped.","nodes":[{"pos":[0,38],"content":"Passed-in array of names to be mapped.","nodes":[{"content":"Passed-in array of names to be mapped.","pos":[0,38]}]}],"pos":[794732,794771],"yaml":true},{"content":"Count of the names to be mapped.","nodes":[{"pos":[0,32],"content":"Count of the names to be mapped.","nodes":[{"content":"Count of the names to be mapped.","pos":[0,32]}]}],"pos":[794833,794866],"yaml":true},{"content":"The locale context in which to interpret the names.","nodes":[{"pos":[0,51],"content":"The locale context in which to interpret the names.","nodes":[{"content":"The locale context in which to interpret the names.","pos":[0,51]}]}],"pos":[794926,794978],"yaml":true},{"content":"Caller-allocated array which receives the IDs corresponding to the names.","nodes":[{"pos":[0,73],"content":"Caller-allocated array which receives the IDs corresponding to the names.","nodes":[{"content":"Caller-allocated array which receives the IDs corresponding to the names.","pos":[0,73]}]}],"pos":[795042,795116],"yaml":true},{"content":"Late-bound access using the COM <code>IDispatch</code> interface is not supported.","nodes":[{"pos":[0,82],"content":"Late-bound access using the COM <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">IDispatch</ph><ept id=\"p1\">&lt;/code&gt;</ept> interface is not supported.","source":"Late-bound access using the COM <code>IDispatch</code> interface is not supported."}],"pos":[795312,795395],"yaml":true},{"content":"Retrieves the type information for an object, which can then be used to get the type information for an interface.","nodes":[{"pos":[0,114],"content":"Retrieves the type information for an object, which can then be used to get the type information for an interface.","nodes":[{"content":"Retrieves the type information for an object, which can then be used to get the type information for an interface.","pos":[0,114]}]}],"pos":[796660,796775],"yaml":true},{"content":"This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.","nodes":[{"pos":[0,184],"content":"This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.","nodes":[{"content":"This method is for access to managed classes from unmanaged code, and should not be called from managed code.","pos":[0,109]},{"content":"For more information about <ph id=\"ph1\">`IDispatch::GetTypeInfo`</ph>, see the MSDN Library.","pos":[110,184],"source":" For more information about `IDispatch::GetTypeInfo`, see the MSDN Library."}]}],"pos":[796786,796971],"yaml":true,"extradata":"MT"},{"content":"The type information to return.","nodes":[{"pos":[0,31],"content":"The type information to return.","nodes":[{"content":"The type information to return.","pos":[0,31]}]}],"pos":[797137,797169],"yaml":true},{"content":"The locale identifier for the type information.","nodes":[{"pos":[0,47],"content":"The locale identifier for the type information.","nodes":[{"content":"The locale identifier for the type information.","pos":[0,47]}]}],"pos":[797229,797277],"yaml":true},{"content":"A pointer to the requested type information object.","nodes":[{"pos":[0,51],"content":"A pointer to the requested type information object.","nodes":[{"content":"A pointer to the requested type information object.","pos":[0,51]}]}],"pos":[797340,797392],"yaml":true},{"content":"Late-bound access using the COM <code>IDispatch</code> interface is not supported.","nodes":[{"pos":[0,82],"content":"Late-bound access using the COM <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">IDispatch</ph><ept id=\"p1\">&lt;/code&gt;</ept> interface is not supported.","source":"Late-bound access using the COM <code>IDispatch</code> interface is not supported."}],"pos":[797586,797669],"yaml":true},{"content":"Retrieves the number of type information interfaces that an object provides (either 0 or 1).","nodes":[{"pos":[0,92],"content":"Retrieves the number of type information interfaces that an object provides (either 0 or 1).","nodes":[{"content":"Retrieves the number of type information interfaces that an object provides (either 0 or 1).","pos":[0,92]}]}],"pos":[798835,798928],"yaml":true},{"content":"This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.","nodes":[{"pos":[0,189],"content":"This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.","nodes":[{"content":"This method is for access to managed classes from unmanaged code, and should not be called from managed code.","pos":[0,109]},{"content":"For more information about <ph id=\"ph1\">`IDispatch::GetTypeInfoCount`</ph>, see the MSDN Library.","pos":[110,189],"source":" For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library."}]}],"pos":[798939,799129],"yaml":true,"extradata":"MT"},{"content":"Points to a location that receives the number of type information interfaces provided by the object.","nodes":[{"pos":[0,100],"content":"Points to a location that receives the number of type information interfaces provided by the object.","nodes":[{"content":"Points to a location that receives the number of type information interfaces provided by the object.","pos":[0,100]}]}],"pos":[799279,799380],"yaml":true},{"content":"Late-bound access using the COM <code>IDispatch</code> interface is not supported.","nodes":[{"pos":[0,82],"content":"Late-bound access using the COM <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">IDispatch</ph><ept id=\"p1\">&lt;/code&gt;</ept> interface is not supported.","source":"Late-bound access using the COM <code>IDispatch</code> interface is not supported."}],"pos":[799579,799662],"yaml":true},{"content":"Provides access to properties and methods exposed by an object.","nodes":[{"pos":[0,63],"content":"Provides access to properties and methods exposed by an object.","nodes":[{"content":"Provides access to properties and methods exposed by an object.","pos":[0,63]}]}],"pos":[801212,801276],"yaml":true},{"content":"This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::Invoke`, see the MSDN Library.","nodes":[{"pos":[0,179],"content":"This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::Invoke`, see the MSDN Library.","nodes":[{"content":"This method is for access to managed classes from unmanaged code, and should not be called from managed code.","pos":[0,109]},{"content":"For more information about <ph id=\"ph1\">`IDispatch::Invoke`</ph>, see the MSDN Library.","pos":[110,179],"source":" For more information about `IDispatch::Invoke`, see the MSDN Library."}]}],"pos":[801287,801467],"yaml":true,"extradata":"MT"},{"content":"Identifies the member.","nodes":[{"pos":[0,22],"content":"Identifies the member.","nodes":[{"content":"Identifies the member.","pos":[0,22]}]}],"pos":[801728,801751],"yaml":true},{"content":"Reserved for future use. Must be IID_NULL.","nodes":[{"pos":[0,42],"content":"Reserved for future use. Must be IID_NULL.","nodes":[{"content":"Reserved for future use. Must be IID_NULL.","pos":[0,42],"nodes":[{"content":"Reserved for future use.","pos":[0,24]},{"content":"Must be IID_NULL.","pos":[25,42]}]}]}],"pos":[801809,801852],"yaml":true},{"content":"The locale context in which to interpret arguments.","nodes":[{"pos":[0,51],"content":"The locale context in which to interpret arguments.","nodes":[{"content":"The locale context in which to interpret arguments.","pos":[0,51]}]}],"pos":[801912,801964],"yaml":true},{"content":"Flags describing the context of the call.","nodes":[{"pos":[0,41],"content":"Flags describing the context of the call.","nodes":[{"content":"Flags describing the context of the call.","pos":[0,41]}]}],"pos":[802025,802067],"yaml":true},{"content":"Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.","nodes":[{"pos":[0,159],"content":"Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.","nodes":[{"content":"Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.","pos":[0,159]}]}],"pos":[802134,802294],"yaml":true},{"content":"Pointer to the location where the result is to be stored.","nodes":[{"pos":[0,57],"content":"Pointer to the location where the result is to be stored.","nodes":[{"content":"Pointer to the location where the result is to be stored.","pos":[0,57]}]}],"pos":[802360,802418],"yaml":true},{"content":"Pointer to a structure that contains exception information.","nodes":[{"pos":[0,59],"content":"Pointer to a structure that contains exception information.","nodes":[{"content":"Pointer to a structure that contains exception information.","pos":[0,59]}]}],"pos":[802484,802544],"yaml":true},{"content":"The index of the first argument that has an error.","nodes":[{"pos":[0,50],"content":"The index of the first argument that has an error.","nodes":[{"content":"The index of the first argument that has an error.","pos":[0,50]}]}],"pos":[802608,802659],"yaml":true},{"content":"Late-bound access using the COM <code>IDispatch</code> interface is not supported.","nodes":[{"pos":[0,82],"content":"Late-bound access using the COM <bpt id=\"p1\">&lt;code&gt;</bpt><ph id=\"ph1\">IDispatch</ph><ept id=\"p1\">&lt;/code&gt;</ept> interface is not supported.","source":"Late-bound access using the COM <code>IDispatch</code> interface is not supported."}],"pos":[802848,802931],"yaml":true}],"content":"### YamlMime:ManagedReference\nitems:\n- uid: System.Type\n  commentId: T:System.Type\n  id: Type\n  children:\n  - System.Type.#ctor\n  - System.Type.Assembly\n  - System.Type.AssemblyQualifiedName\n  - System.Type.Attributes\n  - System.Type.BaseType\n  - System.Type.ContainsGenericParameters\n  - System.Type.DeclaringMethod\n  - System.Type.DeclaringType\n  - System.Type.DefaultBinder\n  - System.Type.Delimiter\n  - System.Type.EmptyTypes\n  - System.Type.Equals(System.Object)\n  - System.Type.Equals(System.Type)\n  - System.Type.FilterAttribute\n  - System.Type.FilterName\n  - System.Type.FilterNameIgnoreCase\n  - System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)\n  - System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)\n  - System.Type.FullName\n  - System.Type.GenericParameterAttributes\n  - System.Type.GenericParameterPosition\n  - System.Type.GenericTypeArguments\n  - System.Type.GetArrayRank\n  - System.Type.GetAttributeFlagsImpl\n  - System.Type.GetConstructor(System.Type[])\n  - System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])\n  - System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  - System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  - System.Type.GetConstructors\n  - System.Type.GetConstructors(System.Reflection.BindingFlags)\n  - System.Type.GetDefaultMembers\n  - System.Type.GetElementType\n  - System.Type.GetEnumName(System.Object)\n  - System.Type.GetEnumNames\n  - System.Type.GetEnumUnderlyingType\n  - System.Type.GetEnumValues\n  - System.Type.GetEvent(System.String)\n  - System.Type.GetEvent(System.String,System.Reflection.BindingFlags)\n  - System.Type.GetEvents\n  - System.Type.GetEvents(System.Reflection.BindingFlags)\n  - System.Type.GetField(System.String)\n  - System.Type.GetField(System.String,System.Reflection.BindingFlags)\n  - System.Type.GetFields\n  - System.Type.GetFields(System.Reflection.BindingFlags)\n  - System.Type.GetGenericArguments\n  - System.Type.GetGenericParameterConstraints\n  - System.Type.GetGenericTypeDefinition\n  - System.Type.GetHashCode\n  - System.Type.GetInterface(System.String)\n  - System.Type.GetInterface(System.String,System.Boolean)\n  - System.Type.GetInterfaceMap(System.Type)\n  - System.Type.GetInterfaces\n  - System.Type.GetMember(System.String)\n  - System.Type.GetMember(System.String,System.Reflection.BindingFlags)\n  - System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)\n  - System.Type.GetMembers\n  - System.Type.GetMembers(System.Reflection.BindingFlags)\n  - System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  - System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])\n  - System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])\n  - System.Type.GetMethod(System.String)\n  - System.Type.GetMethod(System.String,System.Reflection.BindingFlags)\n  - System.Type.GetMethod(System.String,System.Type[])\n  - System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  - System.Type.GetMethods\n  - System.Type.GetMethods(System.Reflection.BindingFlags)\n  - System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)\n  - System.Type.GetNestedType(System.String)\n  - System.Type.GetNestedTypes(System.Reflection.BindingFlags)\n  - System.Type.GetNestedTypes\n  - System.Type.GetProperties\n  - System.Type.GetProperties(System.Reflection.BindingFlags)\n  - System.Type.GetProperty(System.String)\n  - System.Type.GetProperty(System.String,System.Reflection.BindingFlags)\n  - System.Type.GetProperty(System.String,System.Type)\n  - System.Type.GetProperty(System.String,System.Type[])\n  - System.Type.GetProperty(System.String,System.Type,System.Type[])\n  - System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  - System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  - System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  - System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)\n  - System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)\n  - System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})\n  - System.Type.GetType\n  - System.Type.GetType(System.String,System.Boolean)\n  - System.Type.GetType(System.String)\n  - System.Type.GetType(System.String,System.Boolean,System.Boolean)\n  - System.Type.GetTypeArray(System.Object[])\n  - System.Type.GetTypeCode(System.Type)\n  - System.Type.GetTypeCodeImpl\n  - System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)\n  - System.Type.GetTypeFromCLSID(System.Guid,System.String)\n  - System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)\n  - System.Type.GetTypeFromCLSID(System.Guid)\n  - System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\n  - System.Type.GetTypeFromProgID(System.String)\n  - System.Type.GetTypeFromProgID(System.String,System.Boolean)\n  - System.Type.GetTypeFromProgID(System.String,System.String)\n  - System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)\n  - System.Type.GetTypeHandle(System.Object)\n  - System.Type.GUID\n  - System.Type.HasElementType\n  - System.Type.HasElementTypeImpl\n  - System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])\n  - System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])\n  - System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)\n  - System.Type.IsAbstract\n  - System.Type.IsAnsiClass\n  - System.Type.IsArray\n  - System.Type.IsArrayImpl\n  - System.Type.IsAssignableFrom(System.Type)\n  - System.Type.IsAutoClass\n  - System.Type.IsAutoLayout\n  - System.Type.IsByRef\n  - System.Type.IsByRefImpl\n  - System.Type.IsClass\n  - System.Type.IsCOMObject\n  - System.Type.IsCOMObjectImpl\n  - System.Type.IsConstructedGenericType\n  - System.Type.IsContextful\n  - System.Type.IsContextfulImpl\n  - System.Type.IsEnum\n  - System.Type.IsEnumDefined(System.Object)\n  - System.Type.IsEquivalentTo(System.Type)\n  - System.Type.IsExplicitLayout\n  - System.Type.IsGenericParameter\n  - System.Type.IsGenericType\n  - System.Type.IsGenericTypeDefinition\n  - System.Type.IsImport\n  - System.Type.IsInstanceOfType(System.Object)\n  - System.Type.IsInterface\n  - System.Type.IsLayoutSequential\n  - System.Type.IsMarshalByRef\n  - System.Type.IsMarshalByRefImpl\n  - System.Type.IsNested\n  - System.Type.IsNestedAssembly\n  - System.Type.IsNestedFamANDAssem\n  - System.Type.IsNestedFamily\n  - System.Type.IsNestedFamORAssem\n  - System.Type.IsNestedPrivate\n  - System.Type.IsNestedPublic\n  - System.Type.IsNotPublic\n  - System.Type.IsPointer\n  - System.Type.IsPointerImpl\n  - System.Type.IsPrimitive\n  - System.Type.IsPrimitiveImpl\n  - System.Type.IsPublic\n  - System.Type.IsSealed\n  - System.Type.IsSecurityCritical\n  - System.Type.IsSecuritySafeCritical\n  - System.Type.IsSecurityTransparent\n  - System.Type.IsSerializable\n  - System.Type.IsSpecialName\n  - System.Type.IsSubclassOf(System.Type)\n  - System.Type.IsSZArray\n  - System.Type.IsTypeDefinition\n  - System.Type.IsUnicodeClass\n  - System.Type.IsValueType\n  - System.Type.IsValueTypeImpl\n  - System.Type.IsVariableBoundArray\n  - System.Type.IsVisible\n  - System.Type.MakeArrayType(System.Int32)\n  - System.Type.MakeArrayType\n  - System.Type.MakeByRefType\n  - System.Type.MakeGenericType(System.Type[])\n  - System.Type.MakePointerType\n  - System.Type.MemberType\n  - System.Type.Missing\n  - System.Type.Module\n  - System.Type.Name\n  - System.Type.Namespace\n  - System.Type.op_Equality(System.Type,System.Type)\n  - System.Type.op_Inequality(System.Type,System.Type)\n  - System.Type.ReflectedType\n  - System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)\n  - System.Type.StructLayoutAttribute\n  - System.Type.ToString\n  - System.Type.TypeHandle\n  - System.Type.TypeInitializer\n  - System.Type.UnderlyingSystemType\n  - System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)\n  - System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)\n  - System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)\n  - System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)\n  langs:\n  - csharp\n  name: Type\n  nameWithType: Type\n  fullName: System.Type\n  type: Class\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: 'Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.'\n  remarks: \"> [!NOTE]\\n>  To view the .NET Framework source code for this type, see the [Reference Source](http://referencesource.microsoft.com/#mscorlib/system/type.cs#3d00eeab9feb80f3). You can browse through the source code online, download the reference for offline viewing, and step through the sources (including patches and updates) during debugging; see [instructions](http://referencesource.microsoft.com/).  \\n  \\n `Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata. Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.  \\n  \\n No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels. No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation. However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>. See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).  \\n  \\n `Type` is an abstract base class that allows multiple implementations. The system will always provide the derived class `RuntimeType`. In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.  \\n  \\n> [!NOTE]\\n>  In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data. Other code, over which you have no control, might also lock your class type. This might result in a deadlock. Instead, synchronize access to static data by locking a private `static` object.  \\n  \\n> [!NOTE]\\n>  A derived class can access protected members of the calling code's base classes. Also, access is allowed to assembly members of the calling code's assembly. As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.  \\n  \\n> [!NOTE]\\n>  Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.  \\n  \\n In this section:  \\n  \\n [What types does a Type object represent?](#WhatTypes)   \\n [Retrieving a Type object](#Retrieve)   \\n [Comparing type objects for equality](#Equality)  \\n  \\n<a name=\\\"WhatTypes\\\"></a>   \\n## What types does a Type object represent?  \\n This class is thread safe; multiple threads can concurrently read from an instance of this type. An instance of the <xref:System.Type> class can represent any of the following types:  \\n  \\n-   Classes  \\n  \\n-   Value types  \\n  \\n-   Arrays  \\n  \\n-   Interfaces  \\n  \\n-   Enumerations  \\n  \\n-   Delegates  \\n  \\n-   Constructed generic types and generic type definitions  \\n  \\n-   Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions  \\n  \\n<a name=\\\"Retrieve\\\"></a>   \\n## Retrieving a Type object  \\n The <xref:System.Type> object associated with a particular type can be obtained in the following ways:  \\n  \\n-   The instance <xref:System.Object.GetType%2A?displayProperty=fullName> method returns a <xref:System.Type> object that represents the type of an instance. Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.  \\n  \\n     The following example calls the <xref:System.Object.GetType%2A?displayProperty=fullName> method to determine the runtime type of each object in an object array.  \\n  \\n     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]\\n     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]\\n     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  \\n  \\n-   The static <xref:System.Type.GetType%2A?displayProperty=fullName> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.  \\n  \\n-   The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=fullName>, <xref:System.Reflection.Module.GetType%2A?displayProperty=fullName>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=fullName> methods return `Type` objects that represent the types defined in a module. The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module. (You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=fullName> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=fullName> method, or through the <xref:System.Type.Module%2A?displayProperty=fullName> property.)  \\n  \\n-   The <xref:System.Reflection.Assembly?displayProperty=fullName> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=fullName>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=fullName>.  \\n  \\n-   The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.  \\n  \\n-   The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element.  \\n  \\n-   The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.  \\n  \\n-   The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects. The objects are specified with an array of type <xref:System.Object>.  \\n  \\n-   The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability. They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.  \\n  \\n-   The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability. It returns a `Type` object that represents the type specified by a class handle.  \\n  \\n-   The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type.  \\n  \\n-   The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise. A generic type can be instantiated only if it is closed.  \\n  \\n-   The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic).  \\n  \\n<a name=\\\"Equality\\\"></a>   \\n## Comparing type objects for equality  \\n A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type. This allows for comparison of <xref:System.Type> objects using reference equality. The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.  \\n  \\n [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]\\n [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]\\n [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]\"\n  example:\n  - \"The following  example shows a few representative features of <xref:System.Type>. The C# `typeof` operator (`GetType` operator in Visual Basic, `typeid` operator in Visual C++) is used to get a <xref:System.Type> object representing <xref:System.String>. From this <xref:System.Type> object, the <xref:System.Type.GetMethod%2A> method is used to get a <xref:System.Reflection.MethodInfo> representing the <xref:System.String.Substring%2A> overload that takes a starting location and a length.  \\n  \\n To identify the overload signature, the code example creates a temporary array containing two <xref:System.Type> objects representing `int` (`Integer` in Visual Basic).  \\n  \\n> [!NOTE]\\n>  To be precise, the array contains two references to the instance of <xref:System.Type> that represents `int` in the current application domain. For any type, there is only one instance of <xref:System.Type> per application domain.  \\n  \\n The code example uses the <xref:System.Reflection.MethodInfo> to invoke the <xref:System.String.Substring%2A> method on the string \\\"Hello, World!\\\", and displays the result.  \\n  \\n [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]\\n [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]\\n [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)]\n\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type\n  inheritance:\n  - System.Object\n  implements:\n  - System.Reflection.IReflect\n  - System.Runtime.InteropServices._Type\n  inheritedMembers:\n  - System.Object.Equals(System.Object,System.Object)\n  - System.Object.MemberwiseClone\n  - System.Object.ReferenceEquals(System.Object,System.Object)\n  extensionMethods:\n  - System.Reflection.IntrospectionExtensions.GetTypeInfo(System.Type)\n  - System.Reflection.RuntimeReflectionExtensions.GetRuntimeEvent(System.Type,System.String)\n  - System.Reflection.RuntimeReflectionExtensions.GetRuntimeEvents(System.Type)\n  - System.Reflection.RuntimeReflectionExtensions.GetRuntimeField(System.Type,System.String)\n  - System.Reflection.RuntimeReflectionExtensions.GetRuntimeFields(System.Type)\n  - System.Reflection.RuntimeReflectionExtensions.GetRuntimeMethod(System.Type,System.String,System.Type[])\n  - System.Reflection.RuntimeReflectionExtensions.GetRuntimeMethods(System.Type)\n  - System.Reflection.RuntimeReflectionExtensions.GetRuntimeProperties(System.Type)\n  - System.Reflection.RuntimeReflectionExtensions.GetRuntimeProperty(System.Type,System.String)\n  - System.Reflection.TypeExtensions.GetConstructor(System.Type,System.Type[])\n  - System.Reflection.TypeExtensions.GetConstructors(System.Type)\n  - System.Reflection.TypeExtensions.GetConstructors(System.Type,System.Reflection.BindingFlags)\n  - System.Reflection.TypeExtensions.GetDefaultMembers(System.Type)\n  - System.Reflection.TypeExtensions.GetEvent(System.Type,System.String)\n  - System.Reflection.TypeExtensions.GetEvent(System.Type,System.String,System.Reflection.BindingFlags)\n  - System.Reflection.TypeExtensions.GetEvents(System.Type)\n  - System.Reflection.TypeExtensions.GetEvents(System.Type,System.Reflection.BindingFlags)\n  - System.Reflection.TypeExtensions.GetField(System.Type,System.String)\n  - System.Reflection.TypeExtensions.GetField(System.Type,System.String,System.Reflection.BindingFlags)\n  - System.Reflection.TypeExtensions.GetFields(System.Type)\n  - System.Reflection.TypeExtensions.GetFields(System.Type,System.Reflection.BindingFlags)\n  - System.Reflection.TypeExtensions.GetGenericArguments(System.Type)\n  - System.Reflection.TypeExtensions.GetInterfaces(System.Type)\n  - System.Reflection.TypeExtensions.GetMember(System.Type,System.String)\n  - System.Reflection.TypeExtensions.GetMember(System.Type,System.String,System.Reflection.BindingFlags)\n  - System.Reflection.TypeExtensions.GetMembers(System.Type)\n  - System.Reflection.TypeExtensions.GetMembers(System.Type,System.Reflection.BindingFlags)\n  - System.Reflection.TypeExtensions.GetMethod(System.Type,System.String)\n  - System.Reflection.TypeExtensions.GetMethod(System.Type,System.String,System.Reflection.BindingFlags)\n  - System.Reflection.TypeExtensions.GetMethod(System.Type,System.String,System.Type[])\n  - System.Reflection.TypeExtensions.GetMethods(System.Type)\n  - System.Reflection.TypeExtensions.GetMethods(System.Type,System.Reflection.BindingFlags)\n  - System.Reflection.TypeExtensions.GetNestedType(System.Type,System.String,System.Reflection.BindingFlags)\n  - System.Reflection.TypeExtensions.GetNestedTypes(System.Type,System.Reflection.BindingFlags)\n  - System.Reflection.TypeExtensions.GetProperties(System.Type)\n  - System.Reflection.TypeExtensions.GetProperties(System.Type,System.Reflection.BindingFlags)\n  - System.Reflection.TypeExtensions.GetProperty(System.Type,System.String)\n  - System.Reflection.TypeExtensions.GetProperty(System.Type,System.String,System.Reflection.BindingFlags)\n  - System.Reflection.TypeExtensions.GetProperty(System.Type,System.String,System.Type)\n  - System.Reflection.TypeExtensions.GetProperty(System.Type,System.String,System.Type,System.Type[])\n  - System.Reflection.TypeExtensions.IsAssignableFrom(System.Type,System.Type)\n  - System.Reflection.TypeExtensions.IsInstanceOfType(System.Type,System.Object)\n  attributes:\n  - type: System.Runtime.InteropServices.ClassInterfaceAttribute\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.#ctor\n  commentId: M:System.Type.#ctor\n  id: '#ctor'\n  parent: System.Type\n  langs:\n  - csharp\n  name: Type()\n  nameWithType: Type.Type()\n  fullName: Type.Type()\n  type: Constructor\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Initializes a new instance of the <xref href=\"System.Type\"></xref> class.\n  remarks: This constructor is invoked by derived classes during the construction of type objects.\n  syntax:\n    content: protected Type ();\n    parameters: []\n  overload: System.Type.#ctor*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.Assembly\n  commentId: P:System.Type.Assembly\n  id: Assembly\n  parent: System.Type\n  langs:\n  - csharp\n  name: Assembly\n  nameWithType: Type.Assembly\n  fullName: Type.Assembly\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the <xref href=\"System.Reflection.Assembly\"></xref> in which the type is declared. For generic types, gets the <xref href=\"System.Reflection.Assembly\"></xref> in which the generic type is defined.\n  remarks: \"If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition. For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++). If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.  \\n  \\n Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.  \\n  \\n If the <xref:System.Type.Assembly%2A?displayProperty=fullName> property is not available on a particular .NET platform, such as .NET Core or the Universal Windows Platform, use the  `System.Reflection.TypeInfo.Assembly` property instead. ?qualifyHint=False&autoUpgrade=True  \\n  \\n This property is read-only.\"\n  example:\n  - \"The following example displays the assembly name associated with the class and the fully qualified name of the type.  \\n  \\n [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]\\n [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]\\n [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]\"\n  syntax:\n    content: public abstract System.Reflection.Assembly Assembly { get; }\n    return:\n      type: System.Reflection.Assembly\n      description: An <xref href=\"System.Reflection.Assembly\"></xref> instance that describes the assembly containing the current type. For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.\n  overload: System.Type.Assembly*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.AssemblyQualifiedName\n  commentId: P:System.Type.AssemblyQualifiedName\n  id: AssemblyQualifiedName\n  parent: System.Type\n  langs:\n  - csharp\n  name: AssemblyQualifiedName\n  nameWithType: Type.AssemblyQualifiedName\n  fullName: Type.AssemblyQualifiedName\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <xref href=\"System.Type\"></xref> object was loaded.\n  remarks: \"The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly. The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=fullName> property.  \\n  \\n> [!NOTE]\\n>  In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \\\"ProcessorArchitecture=msil\\\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.  \\n  \\n All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  \\n  \\n|Delimiter|Meaning|  \\n|---------------|-------------|  \\n|Backslash (\\\\\\\\)|Escape character.|  \\n|Comma (,)|Precedes the Assembly name.|  \\n|Plus sign (+)|Precedes a nested class.|  \\n|Period (.)|Denotes namespace identifiers.|  \\n|Brackets ([])|After a type name, denotes an array of that type.<br /><br /> -or-<br /><br /> For a generic type, encloses the generic type argument list.<br /><br /> -or-<br /><br /> Within a type argument list, encloses an assembly-qualified type.|  \\n  \\n For example, the assembly-qualified name for a class might look like this:  \\n  \\n```  \\nTopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  \\n```  \\n  \\n If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\\\\\\\) to prevent it from being interpreted as a nesting separator. Reflection would emit this string as follows:  \\n  \\n```  \\nTopNamespace.Sub\\\\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   \\n```  \\n  \\n A \\\"++\\\" becomes \\\"\\\\\\\\+\\\\\\\\+\\\", and a \\\"\\\\\\\\\\\" becomes \\\"\\\\\\\\\\\\\\\\\\\".  \\n  \\n This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.  \\n  \\n Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.  \\n  \\n Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.  \\n  \\n Generic arguments of generic types are themselves qualified by assembly name. For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.  \\n  \\n If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.\"\n  example:\n  - \"The following example displays the assembly name associated with the class and the fully qualified name of the type.  \\n  \\n [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]\\n [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]\\n [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  \\n  \\n The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.  \\n  \\n [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]\\n [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]\"\n  syntax:\n    content: public abstract string AssemblyQualifiedName { get; }\n    return:\n      type: System.String\n      description: The assembly-qualified name of the <xref href=\"System.Type\"></xref>, which includes the name of the assembly from which the <xref href=\"System.Type\"></xref> was loaded, or `null` if the current instance represents a generic type parameter.\n  overload: System.Type.AssemblyQualifiedName*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.Attributes\n  commentId: P:System.Type.Attributes\n  id: Attributes\n  parent: System.Type\n  langs:\n  - csharp\n  name: Attributes\n  nameWithType: Type.Attributes\n  fullName: Type.Attributes\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the attributes associated with the <xref href=\"System.Type\"></xref>.\n  remarks: \"Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values. Each group includes one member whose underlying value is zero. For example, the underlying value of the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> member in the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> group is zero, as is the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> member in the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> group. Because of this, you must use the mask before testing for those values. The example provides an illustration.  \\n  \\n> [!TIP]\\n>  For most purposes, properties like<xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and<xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition. For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).  \\n  \\n If the current <xref:System.Type> represents a generic type parameter  that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true`  the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified.\"\n  example:\n  - \"The following example usesthe <xref:System.Type.Attributes%2A> property.  \\n  \\n [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]\\n [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]\"\n  syntax:\n    content: public System.Reflection.TypeAttributes Attributes { get; }\n    return:\n      type: System.Reflection.TypeAttributes\n      description: A <xref href=\"System.Reflection.TypeAttributes\"></xref> object representing the attribute set of the <xref href=\"System.Type\"></xref>, unless the <xref href=\"System.Type\"></xref> represents a generic type parameter, in which case the value is unspecified.\n  overload: System.Type.Attributes*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.BaseType\n  commentId: P:System.Type.BaseType\n  id: BaseType\n  parent: System.Type\n  langs:\n  - csharp\n  name: BaseType\n  nameWithType: Type.BaseType\n  fullName: Type.BaseType\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the type from which the current <xref href=\"System.Type\"></xref> directly inherits.\n  remarks: \"The base type is the type from which the current type directly inherits. <xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.  \\n  \\n Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface. The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments. For example, consider the following declarations:  \\n  \\n [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]\\n [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]\\n [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  \\n  \\n For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`.  \\n  \\n If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit. If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=fullName>.  \\n  \\n This property is read-only.\"\n  example:\n  - \"The following example demonstrates using the <xref:System.Type.BaseType%2A> property.  \\n  \\n [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]\\n [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]\\n [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  \\n  \\n The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly. The example defines a class named `C` that derives from a class named `B`, which, in turn, derives from a class named `A`.  \\n  \\n [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]\\n [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]\"\n  syntax:\n    content: public abstract Type BaseType { get; }\n    return:\n      type: System.Type\n      description: The <xref href=\"System.Type\"></xref> from which the current <xref href=\"System.Type\"></xref> directly inherits, or `null` if the current `Type` represents the <xref href=\"System.Object\"></xref> class or an interface.\n  overload: System.Type.BaseType*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.ContainsGenericParameters\n  commentId: P:System.Type.ContainsGenericParameters\n  id: ContainsGenericParameters\n  parent: System.Type\n  langs:\n  - csharp\n  name: ContainsGenericParameters\n  nameWithType: Type.ContainsGenericParameters\n  fullName: Type.ContainsGenericParameters\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the current <xref href=\"System.Type\"></xref> object has type parameters that have not been replaced by specific types.\n  remarks: \"In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type. Another way of saying this is that when examined recursively, the type must contain no generic type parameters.  \\n  \\n Since types can be arbitrarily complex, making this determination is difficult. For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot. If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.  \\n  \\n The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters. For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic. Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.  \\n  \\n For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.\"\n  example:\n  - \"The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class. The derived class's base class has two type arguments: the first is <xref:System.Int32> and the second is a type parameter of the derived type. The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.  \\n  \\n [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]\\n [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]\\n [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual bool ContainsGenericParameters { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, `false`.'\n  overload: System.Type.ContainsGenericParameters*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.DeclaringMethod\n  commentId: P:System.Type.DeclaringMethod\n  id: DeclaringMethod\n  parent: System.Type\n  langs:\n  - csharp\n  name: DeclaringMethod\n  nameWithType: Type.DeclaringMethod\n  fullName: Type.DeclaringMethod\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a <xref href=\"System.Reflection.MethodBase\"></xref> that represents the declaring method, if the current <xref href=\"System.Type\"></xref> represents a type parameter of a generic method.\n  remarks: \"The declaring method is a generic method definition. That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.  \\n  \\n The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:  \\n  \\n-   If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.  \\n  \\n-   If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.  \\n  \\n-   Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.  \\n  \\n The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.  \\n  \\n> [!NOTE]\\n>  In the .NET Framework version 2.0, generic constructors are not supported.  \\n  \\n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.\"\n  example:\n  - \"The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method. It also displays information about the generic method definition and the constructed method. When displaying information about the type parameters of the generic method definition, in the `DisplayGenericMethodInfo` method, the example code shows the value of the <xref:System.Type.DeclaringMethod%2A> property for the method's generic type parameter.  \\n  \\n [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]\\n [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]\\n [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual System.Reflection.MethodBase DeclaringMethod { get; }\n    return:\n      type: System.Reflection.MethodBase\n      description: If the current <xref href=\"System.Type\"></xref> represents a type parameter of a generic method, a <xref href=\"System.Reflection.MethodBase\"></xref> that represents declaring method; otherwise, `null`.\n  overload: System.Type.DeclaringMethod*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.DeclaringType\n  commentId: P:System.Type.DeclaringType\n  id: DeclaringType\n  parent: System.Type\n  langs:\n  - csharp\n  name: DeclaringType\n  nameWithType: Type.DeclaringType\n  fullName: Type.DeclaringType\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets the type that declares the current nested type or generic type parameter.\n  remarks: \"If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.  \\n  \\n If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition. If the type is generic, the generic type definition is returned. That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:  \\n  \\n [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]\\n [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]\\n [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:  \\n  \\n-   If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.  \\n  \\n-   If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.  \\n  \\n-   Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.\"\n  example:\n  - \"This example displays the declaring type of a method in a derived class.  \\n  \\n [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]\\n [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]\"\n  syntax:\n    content: public override Type DeclaringType { get; }\n    return:\n      type: System.Type\n      description: A <xref href=\"System.Type\"></xref> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, `null`.\n  overload: System.Type.DeclaringType*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.DefaultBinder\n  commentId: P:System.Type.DefaultBinder\n  id: DefaultBinder\n  parent: System.Type\n  langs:\n  - csharp\n  name: DefaultBinder\n  nameWithType: Type.DefaultBinder\n  fullName: Type.DefaultBinder\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <xref href=\"System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])\"></xref>.\n  remarks: \"The default binder provided with the common language runtime is applicable in all but the most specialized circumstances. If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.  \\n  \\n Reflection models the accessibility rules of the common type system. For example, if the caller is in the same assembly, the caller does not need special permissions for internal members. Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>. This is consistent with lookup of members that are protected, private, and so on.  \\n  \\n The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data. An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer. This is distinguished from a narrowing conversion, which may lose data. An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.  \\n  \\n The following table lists the conversions supported by the default binder.  \\n  \\n|Source Type|Target Type|  \\n|-----------------|-----------------|  \\n|Any type|Its base type.|  \\n|Any type|The interface it implements.|  \\n|Char|Unt16, UInt32, Int32, UInt64, Int64, Single, Double|  \\n|Byte|Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double|  \\n|SByte|Int16, Int32, Int64, Single, Double|  \\n|UInt16|UInt32, Int32, UInt64, Int64, Single, Double|  \\n|Int16|Int32, Int64, Single, Double|  \\n|UInt32|UInt64, Int64, Single, Double|  \\n|Int32|Int64, Single, Double|  \\n|UInt64|Single, Double|  \\n|Int64|Single, Double|  \\n|Single|Double|  \\n|Non-reference|By-reference.|\"\n  example:\n  - \"The following example gets the default binder from the `DefaultBinder` property, and invokes a member of MyClass by passing the `DefaultBinder` value as a parameter to <xref:System.Type.InvokeMember%2A>.  \\n  \\n [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]\\n [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]\\n [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]\"\n  syntax:\n    content: public static System.Reflection.Binder DefaultBinder { get; }\n    return:\n      type: System.Reflection.Binder\n      description: A reference to the default binder used by the system.\n  overload: System.Type.DefaultBinder*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.Delimiter\n  commentId: F:System.Type.Delimiter\n  id: Delimiter\n  parent: System.Type\n  langs:\n  - csharp\n  name: Delimiter\n  nameWithType: Type.Delimiter\n  fullName: Type.Delimiter\n  type: Field\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Separates names in the namespace of the <xref href=\"System.Type\"></xref>. This field is read-only.\n  syntax:\n    content: public static readonly char Delimiter;\n    return:\n      type: System.Char\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.EmptyTypes\n  commentId: F:System.Type.EmptyTypes\n  id: EmptyTypes\n  parent: System.Type\n  langs:\n  - csharp\n  name: EmptyTypes\n  nameWithType: Type.EmptyTypes\n  fullName: Type.EmptyTypes\n  type: Field\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Represents an empty array of type <xref href=\"System.Type\"></xref>. This field is read-only.\n  remarks: ''\n  example:\n  - \"The following code example shows the `EmptyTypes` field used in one of the `GetConstructor` methods to get a constructor that takes no parameters.  \\n  \\n [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]\\n [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]\"\n  syntax:\n    content: public static readonly Type[] EmptyTypes;\n    return:\n      type: System.Type[]\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.Equals(System.Object)\n  commentId: M:System.Type.Equals(System.Object)\n  id: Equals(System.Object)\n  parent: System.Type\n  langs:\n  - csharp\n  name: Equals(Object)\n  nameWithType: Type.Equals(Object)\n  fullName: Type.Equals(Object)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Determines if the underlying system type of the current <xref href=\"System.Type\"></xref> object is the same as the underlying system type of the specified <xref href=\"System.Object\"></xref>.\n  remarks: This method overrides <xref:System.Object.Equals%2A?displayProperty=fullName>. It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=fullName> method.\n  example:\n  - \"The following example uses <xref:System.Type.Equals%28System.Object%29> to compare various <xref:System.Type> object instances with various <xref:System.Object> instances.  \\n  \\n [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]\\n [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  \\n  \\n Two things are particularly worth noting about the example:  \\n  \\n-   The comparison of a <xref:System.Type> object that represents an integer with a <xref:System.Reflection.TypeInfo> object that represents an integer return `true` because <xref:System.Reflection.TypeInfo> is derived from <xref:System.Type>.  \\n  \\n-   The comparison of a  <xref:System.Type> object that represents a <xref:System.Collections.Generic.IList%601> object (an open generic type) with a `List(Of String)` object (a closed generic type) returns `false`.\"\n  syntax:\n    content: public override bool Equals (object o);\n    parameters:\n    - id: o\n      type: System.Object\n      description: The object whose underlying system type is to be compared with the underlying system type of the current <xref href=\"System.Type\"></xref>. For the comparison to succeed, <code>o</code> must be able to be cast or converted to an object of type   <xref href=\"System.Type\"></xref>.\n    return:\n      type: System.Boolean\n      description: \"`true` if the underlying system type of <code>o</code> is the same as the underlying system type of the current <xref href=\\\"System.Type\\\"></xref>; otherwise, `false`. This method also returns `false` if: .  \\n  \\n-   <code>o</code> is `null`.  \\n  \\n-   <code>o</code> cannot be cast or converted to a <xref href=\\\"System.Type\\\"></xref> object.\"\n  overload: System.Type.Equals*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.Equals(System.Type)\n  commentId: M:System.Type.Equals(System.Type)\n  id: Equals(System.Type)\n  parent: System.Type\n  langs:\n  - csharp\n  name: Equals(Type)\n  nameWithType: Type.Equals(Type)\n  fullName: Type.Equals(Type)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Determines if the underlying system type of the current <xref href=\"System.Type\"></xref> is the same as the underlying system type of the specified <xref href=\"System.Type\"></xref>.\n  remarks: ''\n  example:\n  - \"The following example uses `Equals` to compare two types.  \\n  \\n [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]\\n [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual bool Equals (Type o);\n    parameters:\n    - id: o\n      type: System.Type\n      description: The object whose underlying system type is to be compared with the underlying system type of the current <xref href=\"System.Type\"></xref>.\n    return:\n      type: System.Boolean\n      description: '`true` if the underlying system type of <code>o</code> is the same as the underlying system type of the current <xref href=\"System.Type\"></xref>; otherwise, `false`.'\n  overload: System.Type.Equals*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.FilterAttribute\n  commentId: F:System.Type.FilterAttribute\n  id: FilterAttribute\n  parent: System.Type\n  langs:\n  - csharp\n  name: FilterAttribute\n  nameWithType: Type.FilterAttribute\n  fullName: Type.FilterAttribute\n  type: Field\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Represents the member filter used on attributes. This field is read-only.\n  remarks: \"This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method. The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`. The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`. The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.  \\n  \\n For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public. In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.\"\n  example:\n  - \"The following example gets the `FilterAttribute` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the specified members and their attributes.  \\n  \\n [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]\\n [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]\\n [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]\"\n  syntax:\n    content: public static readonly System.Reflection.MemberFilter FilterAttribute;\n    return:\n      type: System.Reflection.MemberFilter\n      description: ''\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.FilterName\n  commentId: F:System.Type.FilterName\n  id: FilterName\n  parent: System.Type\n  langs:\n  - csharp\n  name: FilterName\n  nameWithType: Type.FilterName\n  fullName: Type.FilterName\n  type: Field\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Represents the case-sensitive member filter used on names. This field is read-only.\n  remarks: \"This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method. The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`. The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`. The `Object` is assigned a string value, which may include a trailing \\\"*\\\" wildcard character. Only wildcard end string matching is supported.  \\n  \\n For example, the `Object` may be assigned the value \\\"Byte*\\\". In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with \\\"Byte\\\".\"\n  example:\n  - \"The following code example gets the methods associated with the user-defined `Application` type.  \\n  \\n [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]\\n [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]\"\n  syntax:\n    content: public static readonly System.Reflection.MemberFilter FilterName;\n    return:\n      type: System.Reflection.MemberFilter\n      description: ''\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.FilterNameIgnoreCase\n  commentId: F:System.Type.FilterNameIgnoreCase\n  id: FilterNameIgnoreCase\n  parent: System.Type\n  langs:\n  - csharp\n  name: FilterNameIgnoreCase\n  nameWithType: Type.FilterNameIgnoreCase\n  fullName: Type.FilterNameIgnoreCase\n  type: Field\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Represents the case-insensitive member filter used on names. This field is read-only.\n  remarks: \"This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method. The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`. The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`. The `Object` is assigned a string value, which may include a trailing \\\"*\\\" wildcard character. Only wildcard end string matching is supported.  \\n  \\n For example, the `Object` may be assigned the value \\\"ByTe*\\\". In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with \\\"byte\\\", ignoring case.\"\n  example:\n  - \"The following example gets the `MemberFilter` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the methods and their attributes of the `String` class that begin with the letter \\\"c\\\", disregarding the case.  \\n  \\n [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]\\n [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]\\n [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]\"\n  syntax:\n    content: public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;\n    return:\n      type: System.Reflection.MemberFilter\n      description: ''\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)\n  commentId: M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)\n  id: FindInterfaces(System.Reflection.TypeFilter,System.Object)\n  parent: System.Type\n  langs:\n  - csharp\n  name: FindInterfaces(TypeFilter, Object)\n  nameWithType: Type.FindInterfaces(TypeFilter, Object)\n  fullName: Type.FindInterfaces(TypeFilter, Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns an array of <xref href=\"System.Type\"></xref> objects representing a filtered list of interfaces implemented or inherited by the current <xref href=\"System.Type\"></xref>.\n  remarks: \"This method can be overridden by a derived class.  \\n  \\n The <xref:System.Reflection.Module.FilterTypeName?displayProperty=fullName> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=fullName> delegates supplied by the <xref:System.Reflection.Module?displayProperty=fullName> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=fullName> delegate.  \\n  \\n All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.  \\n  \\n This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned). No duplicate interfaces are returned.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints. If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.  \\n  \\n> [!NOTE]\\n>  <xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic. For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).\"\n  example:\n  - \"The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.  \\n  \\n [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]\\n [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]\\n [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]\"\n  syntax:\n    content: public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);\n    parameters:\n    - id: filter\n      type: System.Reflection.TypeFilter\n      description: The delegate that compares the interfaces against <code>filterCriteria</code>.\n    - id: filterCriteria\n      type: System.Object\n      description: The search criteria that determines whether an interface should be included in the returned array.\n    return:\n      type: System.Type[]\n      description: An array of <xref href=\"System.Type\"></xref> objects representing a filtered list of the interfaces implemented or inherited by the current <xref href=\"System.Type\"></xref>, or an empty array of type <xref href=\"System.Type\"></xref> if no interfaces matching the filter are implemented or inherited by the current <xref href=\"System.Type\"></xref>.\n  overload: System.Type.FindInterfaces*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>filter</code> is `null`.\n  - type: System.Reflection.TargetInvocationException\n    commentId: T:System.Reflection.TargetInvocationException\n    description: A static initializer is invoked and throws an exception.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)\n  commentId: M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)\n  id: FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)\n  parent: System.Type\n  langs:\n  - csharp\n  name: FindMembers(MemberTypes, BindingFlags, MemberFilter, Object)\n  nameWithType: Type.FindMembers(MemberTypes, BindingFlags, MemberFilter, Object)\n  fullName: Type.FindMembers(MemberTypes, BindingFlags, MemberFilter, Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns a filtered array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects of the specified member type.\n  remarks: \"This method can be overridden by a derived class.  \\n  \\n Members include properties, methods, fields, events, and so on.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Instance` to include instance members in the search.  \\n  \\n-   Specify `BindingFlags.Static` to include static members in the search.  \\n  \\n-   Specify `BindingFlags.Public` to include public members in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n Valid values for <xref:System.Type.MemberType%2A> are defined in <xref:System.Reflection.MemberInfo>. If no such members are found, an empty array is returned.  \\n  \\n To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \\n  \\n If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.\"\n  example:\n  - \"The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.  \\n  \\n [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]\\n [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]\\n [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]\"\n  syntax:\n    content: public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);\n    parameters:\n    - id: memberType\n      type: System.Reflection.MemberTypes\n      description: An object that indicates the type of member to search for.\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    - id: filter\n      type: System.Reflection.MemberFilter\n      description: The delegate that does the comparisons, returning `true` if the member currently being inspected matches the <code>filterCriteria</code> and `false` otherwise. You can use the `FilterAttribute`, `FilterName`, and `FilterNameIgnoreCase` delegates supplied by this class. The first uses the fields of `FieldAttributes`, `MethodAttributes`, and `MethodImplAttributes` as search criteria, and the other two delegates use `String` objects as the search criteria.\n    - id: filterCriteria\n      type: System.Object\n      description: \"The search criteria that determines whether a member is returned in the array of `MemberInfo` objects.  \\n  \\n The fields of `FieldAttributes`, `MethodAttributes`, and `MethodImplAttributes` can be used in conjunction with the `FilterAttribute` delegate supplied by this class.\"\n    return:\n      type: System.Reflection.MemberInfo[]\n      description: \"A filtered array of <xref href=\\\"System.Reflection.MemberInfo\\\"></xref> objects of the specified member type.  \\n  \\n -or-  \\n  \\n An empty array of type <xref href=\\\"System.Reflection.MemberInfo\\\"></xref>, if the current <xref href=\\\"System.Type\\\"></xref> does not have members of type <code>memberType</code> that match the filter criteria.\"\n  overload: System.Type.FindMembers*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>filter</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.FullName\n  commentId: P:System.Type.FullName\n  id: FullName\n  parent: System.Type\n  langs:\n  - csharp\n  name: FullName\n  nameWithType: Type.FullName\n  fullName: Type.FullName\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets the fully qualified name of the type, including its namespace but not its assembly.\n  remarks: \"For example, the fully qualified name of the <xref:System.String> type is `System.String`. Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.  \\n  \\n If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A>property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name. The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.  \\n  \\n [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]\\n [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  \\n  \\n This property returns `null` if:  \\n  \\n-   The current <xref:System.Type> object represents a type parameter of a generic type.  \\n  \\n     The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.  \\n  \\n     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]\\n     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  \\n  \\n-   The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter.  \\n  \\n     The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference. Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type. The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.  \\n  \\n     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]\\n     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  \\n  \\n-   The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`  \\n  \\n     In the following example, `Derived<T>` inherits from `Base<T>`. The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.  \\n  \\n     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]\\n     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  \\n  \\n     To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates.  \\n  \\n This property is read-only.\"\n  example:\n  - \"The following example displays the full name of the specified type.  \\n  \\n [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]\\n [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]\\n [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  \\n  \\n The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.  \\n  \\n [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]\\n [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]\"\n  syntax:\n    content: public abstract string FullName { get; }\n    return:\n      type: System.String\n      description: The fully qualified name of the type, including its namespace but not its assembly; or `null` if the current instance represents a generic type parameter, an array type, pointer type, or `byref` type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.\n  overload: System.Type.FullName*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GenericParameterAttributes\n  commentId: P:System.Type.GenericParameterAttributes\n  id: GenericParameterAttributes\n  parent: System.Type\n  langs:\n  - csharp\n  name: GenericParameterAttributes\n  nameWithType: Type.GenericParameterAttributes\n  fullName: Type.GenericParameterAttributes\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a combination of <xref href=\"System.Reflection.GenericParameterAttributes\"></xref> flags that describe the covariance and special constraints of the current generic type parameter.\n  remarks: \"The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints. Use the <xref:System.Reflection.GenericParameterAttributes?displayProperty=fullName> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes?displayProperty=fullName> value to select the constraint flags.  \\n  \\n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.\"\n  example:\n  - \"The following code example defines a generic type `Test` with two type parameters that have different constraints. When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.  \\n  \\n [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]\\n [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]\\n [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }\n    return:\n      type: System.Reflection.GenericParameterAttributes\n      description: A bitwise combination of <xref href=\"System.Reflection.GenericParameterAttributes\"></xref> values that describes the covariance and special constraints of the current generic type parameter.\n  overload: System.Type.GenericParameterAttributes*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current <xref href=\"System.Type\"></xref> object is not a generic type parameter. That is, the <xref href=\"System.Type.IsGenericParameter\"></xref> property returns `false`.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The invoked method is not supported in the base class.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GenericParameterPosition\n  commentId: P:System.Type.GenericParameterPosition\n  id: GenericParameterPosition\n  parent: System.Type\n  langs:\n  - csharp\n  name: GenericParameterPosition\n  nameWithType: Type.GenericParameterPosition\n  fullName: Type.GenericParameterPosition\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <xref href=\"System.Type\"></xref> object represents a type parameter of a generic type or a generic method.\n  remarks: \"The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined. The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:  \\n  \\n-   If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.  \\n  \\n-   If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.  \\n  \\n To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to. For example, consider the return value of the generic method `GetSomething` in the following code:  \\n  \\n [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]\\n [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]\\n [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  \\n  \\n The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself. You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type. When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both. The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`. The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.  \\n  \\n> [!NOTE]\\n>  Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter. When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types. The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.\"\n  example:\n  - \"The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class. The derived class's base class has two type arguments: the first is <xref:System.Int32>, and the second is a type parameter of the derived type. The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.  \\n  \\n [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]\\n [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]\\n [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual int GenericParameterPosition { get; }\n    return:\n      type: System.Int32\n      description: The position of a type parameter in the type parameter list of the generic type or method that defines the parameter. Position numbers begin at 0.\n  overload: System.Type.GenericParameterPosition*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current type does not represent a type parameter. That is, <xref href=\"System.Type.IsGenericParameter\"></xref> returns `false`.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GenericTypeArguments\n  commentId: P:System.Type.GenericTypeArguments\n  id: GenericTypeArguments\n  parent: System.Type\n  langs:\n  - csharp\n  name: GenericTypeArguments\n  nameWithType: Type.GenericTypeArguments\n  fullName: Type.GenericTypeArguments\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets an array of the generic type arguments for this type.\n  remarks: \"This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type. If the current type is a generic type definition, this property returns an empty array.  \\n  \\n> [!NOTE]\\n>  If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.  \\n  \\n To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=fullName> property. To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=fullName> extension method.\"\n  syntax:\n    content: public virtual Type[] GenericTypeArguments { get; }\n    return:\n      type: System.Type[]\n      description: An array of the generic type arguments for this type.\n  overload: System.Type.GenericTypeArguments*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetArrayRank\n  commentId: M:System.Type.GetArrayRank\n  id: GetArrayRank\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetArrayRank()\n  nameWithType: Type.GetArrayRank()\n  fullName: Type.GetArrayRank()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets the number of dimensions in an array.\n  remarks: ''\n  example:\n  - \"The following example displays the number of dimensions in an array.  \\n  \\n [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]\\n [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]\\n [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]\"\n  syntax:\n    content: public virtual int GetArrayRank ();\n    parameters: []\n    return:\n      type: System.Int32\n      description: An integer that contains the number of dimensions in the current type.\n  overload: System.Type.GetArrayRank*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The current type is not an array.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetAttributeFlagsImpl\n  commentId: M:System.Type.GetAttributeFlagsImpl\n  id: GetAttributeFlagsImpl\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetAttributeFlagsImpl()\n  nameWithType: Type.GetAttributeFlagsImpl()\n  fullName: Type.GetAttributeFlagsImpl()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, implements the <xref href=\"System.Type.Attributes\"></xref> property and gets a bitmask indicating the attributes associated with the <xref href=\"System.Type\"></xref>.\n  syntax:\n    content: protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();\n    parameters: []\n    return:\n      type: System.Reflection.TypeAttributes\n      description: A <xref href=\"System.Reflection.TypeAttributes\"></xref> object representing the attribute set of the <xref href=\"System.Type\"></xref>.\n  overload: System.Type.GetAttributeFlagsImpl*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetConstructor(System.Type[])\n  commentId: M:System.Type.GetConstructor(System.Type[])\n  id: GetConstructor(System.Type[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetConstructor(Type[])\n  nameWithType: Type.GetConstructor(Type[])\n  fullName: Type.GetConstructor(Type[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for a public instance constructor whose parameters match the types in the specified array.\n  remarks: \"This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor). To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \\n  \\n If the requested constructor is non-public, this method returns `null`.  \\n  \\n> [!NOTE]\\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments. If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.\"\n  example:\n  - \"The following example obtains the type of `MyClass`, gets the <xref:System.Reflection.ConstructorInfo> object, and displays the constructor signature.  \\n  \\n [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]\\n [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]\\n [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public System.Reflection.ConstructorInfo GetConstructor (Type[] types);\n    parameters:\n    - id: types\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing the number, order, and type of the parameters for the desired constructor.  \\n  \\n -or-  \\n  \\n An empty array of <xref href=\\\"System.Type\\\"></xref> objects, to get a constructor that takes no parameters. Such an empty array is provided by the `static` field <xref href=\\\"System.Type.EmptyTypes\\\"></xref>.\"\n    return:\n      type: System.Reflection.ConstructorInfo\n      description: An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, `null`.\n  overload: System.Type.GetConstructor*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>types</code> is `null`.  \\n  \\n -or-  \\n  \\n One of the elements in <code>types</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>types</code> is multidimensional.\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])\n  commentId: M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])\n  id: GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetConstructor(BindingFlags, Binder, Type[], ParameterModifier[])\n  nameWithType: Type.GetConstructor(BindingFlags, Binder, Type[], ParameterModifier[])\n  fullName: Type.GetConstructor(BindingFlags, Binder, Type[], ParameterModifier[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.\n  remarks: \"If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match. If the `binder` is unable to select a match, then `null` is returned.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public constructors in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \\n  \\n> [!NOTE]\\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments. If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.\"\n  example:\n  - \"The following program obtains the type of `MyClass1` class, gets the <xref:System.Reflection.ConstructorInfo> object matching the specified binding flags, and displays the signature of the constructor.  \\n  \\n [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]\\n [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]\\n [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);\n    parameters:\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    - id: binder\n      type: System.Reflection.Binder\n      description: \"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \\n  \\n -or-  \\n  \\n A null reference (`Nothing` in Visual Basic), to use the <xref href=\\\"System.Type.DefaultBinder\\\"></xref>.\"\n    - id: types\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing the number, order, and type of the parameters for the constructor to get.  \\n  \\n -or-  \\n  \\n An empty array of the type <xref href=\\\"System.Type\\\"></xref> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.  \\n  \\n -or-  \\n  \\n <xref href=\\\"System.Type.EmptyTypes\\\"></xref>.\"\n    - id: modifiers\n      type: System.Reflection.ParameterModifier[]\n      description: An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the parameter type array. The default binder does not process this parameter.\n    return:\n      type: System.Reflection.ConstructorInfo\n      description: A <xref href=\"System.Reflection.ConstructorInfo\"></xref> object representing the constructor that matches the specified requirements, if found; otherwise, `null`.\n  overload: System.Type.GetConstructor*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>types</code> is `null`.  \\n  \\n -or-  \\n  \\n One of the elements in <code>types</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>types</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>modifiers</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>types</code> and <code>modifiers</code> do not have the same length.\"\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  commentId: M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  id: GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetConstructor(BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  nameWithType: Type.GetConstructor(BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  fullName: Type.GetConstructor(BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.\n  remarks: \"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \\n  \\n If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match. If the `binder` is unable to select a match, then `null` is returned.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public constructors in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n> [!NOTE]\\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments. If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.\"\n  example:\n  - \"The following example obtains the type of `MyClass1`, gets the <xref:System.Reflection.ConstructorInfo> object that matches the specified binding flags, and displays the constructor signature.  \\n  \\n [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]\\n [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]\\n [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);\n    parameters:\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    - id: binder\n      type: System.Reflection.Binder\n      description: \"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \\n  \\n -or-  \\n  \\n A null reference (`Nothing` in Visual Basic), to use the <xref href=\\\"System.Type.DefaultBinder\\\"></xref>.\"\n    - id: callConvention\n      type: System.Reflection.CallingConventions\n      description: The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.\n    - id: types\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing the number, order, and type of the parameters for the constructor to get.  \\n  \\n -or-  \\n  \\n An empty array of the type <xref href=\\\"System.Type\\\"></xref> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.\"\n    - id: modifiers\n      type: System.Reflection.ParameterModifier[]\n      description: An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.\n    return:\n      type: System.Reflection.ConstructorInfo\n      description: An object representing the constructor that matches the specified requirements, if found; otherwise, `null`.\n  overload: System.Type.GetConstructor*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>types</code> is `null`.  \\n  \\n -or-  \\n  \\n One of the elements in <code>types</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>types</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>modifiers</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>types</code> and <code>modifiers</code> do not have the same length.\"\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  commentId: M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  id: GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetConstructorImpl(BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  nameWithType: Type.GetConstructorImpl(BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  fullName: Type.GetConstructorImpl(BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.\n  remarks: \"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \\n  \\n If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match. If the `binder` is unable to select a match, then `null` is returned.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public constructors in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n This method implements <xref:System.Type.GetConstructor%2A>.\"\n  syntax:\n    content: protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);\n    parameters:\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    - id: binder\n      type: System.Reflection.Binder\n      description: \"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \\n  \\n -or-  \\n  \\n A null reference (`Nothing` in Visual Basic), to use the <xref href=\\\"System.Type.DefaultBinder\\\"></xref>.\"\n    - id: callConvention\n      type: System.Reflection.CallingConventions\n      description: The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.\n    - id: types\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing the number, order, and type of the parameters for the constructor to get.  \\n  \\n -or-  \\n  \\n An empty array of the type <xref href=\\\"System.Type\\\"></xref> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.\"\n    - id: modifiers\n      type: System.Reflection.ParameterModifier[]\n      description: An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.\n    return:\n      type: System.Reflection.ConstructorInfo\n      description: A <xref href=\"System.Reflection.ConstructorInfo\"></xref> object representing the constructor that matches the specified requirements, if found; otherwise, `null`.\n  overload: System.Type.GetConstructorImpl*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>types</code> is `null`.  \\n  \\n -or-  \\n  \\n One of the elements in <code>types</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>types</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>modifiers</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>types</code> and <code>modifiers</code> do not have the same length.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The current type is a <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref> or <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\"></xref>.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetConstructors\n  commentId: M:System.Type.GetConstructors\n  id: GetConstructors\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetConstructors()\n  nameWithType: Type.GetConstructors()\n  fullName: Type.GetConstructors()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns all the public constructors defined for the current <xref href=\"System.Type\"></xref>.\n  remarks: \"The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order. Your code must not depend on the order in which constructors are returned, because that order varies.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). It will not find class initializers (.cctor). To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments. For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).  \\n  \\n If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.\"\n  example:\n  - \"This example shows the output of the <xref:System.Type.GetConstructors%2A> overload from a class that has two instance constructors and one static constructor.  \\n  \\n [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]\\n [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]\\n [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  \\n  \\n The output of this code is:  \\n  \\n 2  \\n  \\n False  \\n  \\n False  \\n  \\n Because the <xref:System.Type.GetConstructors> overload uses only <xref:System.Reflection.BindingFlags?displayProperty=fullName> and <xref:System.Reflection.BindingFlags?displayProperty=fullName>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.  \\n  \\n To find static constructors, use the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload, and pass the combination (logical `OR`) of <xref:System.Reflection.BindingFlags?displayProperty=fullName>, <xref:System.Reflection.BindingFlags?displayProperty=fullName>, <xref:System.Reflection.BindingFlags?displayProperty=fullName>, <xref:System.Reflection.BindingFlags?displayProperty=fullName>, as shown in the following code example:  \\n  \\n [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]\\n [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]\\n [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  \\n  \\n Now the output is:  \\n  \\n 3  \\n  \\n False  \\n  \\n True  \\n  \\n False\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public System.Reflection.ConstructorInfo[] GetConstructors ();\n    parameters: []\n    return:\n      type: System.Reflection.ConstructorInfo[]\n      description: An array of <xref href=\"System.Reflection.ConstructorInfo\"></xref> objects representing all the public instance constructors defined for the current <xref href=\"System.Type\"></xref>, but not including the type initializer (static constructor). If no public instance constructors are defined for the current <xref href=\"System.Type\"></xref>, or if the current <xref href=\"System.Type\"></xref> represents a type parameter in the definition of a generic type or generic method, an empty array of type <xref href=\"System.Reflection.ConstructorInfo\"></xref> is returned.\n  overload: System.Type.GetConstructors*\n  exceptions: []\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetConstructors(System.Reflection.BindingFlags)\n  commentId: M:System.Type.GetConstructors(System.Reflection.BindingFlags)\n  id: GetConstructors(System.Reflection.BindingFlags)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetConstructors(BindingFlags)\n  nameWithType: Type.GetConstructors(BindingFlags)\n  fullName: Type.GetConstructors(BindingFlags)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, searches for the constructors defined for the current <xref href=\"System.Type\"></xref>, using the specified `BindingFlags`.\n  remarks: \"The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order. Your code must not depend on the order in which constructors are returned, because that order varies.  \\n  \\n `bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors.  \\n  \\n If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match. If the `binder` is unable to select a match, then `null` is returned.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public constructors in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search. Constructors of base classes are not returned.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments. For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).  \\n  \\n If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.\"\n  example:\n  - \"This example shows the output of the <xref:System.Type.GetConstructors> overload from a class that has two instance constructors and one static constructor.  \\n  \\n [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]\\n [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]\\n [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  \\n  \\n The output of this code is:  \\n  \\n 2  \\n  \\n False  \\n  \\n False  \\n  \\n Because the <xref:System.Type.GetConstructors%2A> overload uses only <xref:System.Reflection.BindingFlags.Public> and <xref:System.Reflection.BindingFlags.Instance>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.  \\n  \\n To find static constructors, use the <xref:System.Type.GetConstructors%2A> overload, and pass it the combination (logical OR) of <xref:System.Reflection.BindingFlags?displayProperty=fullName>, <xref:System.Reflection.BindingFlags?displayProperty=fullName>, <xref:System.Reflection.BindingFlags?displayProperty=fullName>, <xref:System.Reflection.BindingFlags?displayProperty=fullName>, as shown in the following code example:  \\n  \\n [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]\\n [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]\\n [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  \\n  \\n Now the output is:  \\n  \\n 3  \\n  \\n False  \\n  \\n True  \\n  \\n False\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);\n    parameters:\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    return:\n      type: System.Reflection.ConstructorInfo[]\n      description: An array of <xref href=\"System.Reflection.ConstructorInfo\"></xref> objects representing all constructors defined for the current <xref href=\"System.Type\"></xref> that match the specified binding constraints, including the type initializer if it is defined. Returns an empty array of type <xref href=\"System.Reflection.ConstructorInfo\"></xref> if no constructors are defined for the current <xref href=\"System.Type\"></xref>, if none of the defined constructors match the binding constraints, or if the current <xref href=\"System.Type\"></xref> represents a type parameter in the definition of a generic type or generic method.\n  overload: System.Type.GetConstructors*\n  exceptions: []\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetDefaultMembers\n  commentId: M:System.Type.GetDefaultMembers\n  id: GetDefaultMembers\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetDefaultMembers()\n  nameWithType: Type.GetDefaultMembers()\n  fullName: Type.GetDefaultMembers()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the members defined for the current <xref href=\"System.Type\"></xref> whose <xref href=\"System.Reflection.DefaultMemberAttribute\"></xref> is set.\n  remarks: \"The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  \\n  \\n This method can be overridden by a derived class.  \\n  \\n Members include properties, methods, fields, events, and so on.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments. For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.\"\n  example:\n  - \"The following example obtains the default member information of `MyClass` and displays the default members.  \\n  \\n [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]\\n [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]\\n [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]\"\n  syntax:\n    content: public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();\n    parameters: []\n    return:\n      type: System.Reflection.MemberInfo[]\n      description: \"An array of <xref href=\\\"System.Reflection.MemberInfo\\\"></xref> objects representing all default members of the current <xref href=\\\"System.Type\\\"></xref>.  \\n  \\n -or-  \\n  \\n An empty array of type <xref href=\\\"System.Reflection.MemberInfo\\\"></xref>, if the current <xref href=\\\"System.Type\\\"></xref> does not have default members.\"\n  overload: System.Type.GetDefaultMembers*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetElementType\n  commentId: M:System.Type.GetElementType\n  id: GetElementType\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetElementType()\n  nameWithType: Type.GetElementType()\n  fullName: Type.GetElementType()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: When overridden in a derived class, returns the <xref href=\"System.Type\"></xref> of the object encompassed or referred to by the current array, pointer or reference type.\n  remarks: This method returns `null` for the <xref:System.Array> class.\n  example:\n  - \"The following example demonstrates using the `GetElementType` method.  \\n  \\n [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]\\n [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]\\n [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]\"\n  syntax:\n    content: public abstract Type GetElementType ();\n    parameters: []\n    return:\n      type: System.Type\n      description: The <xref href=\"System.Type\"></xref> of the object encompassed or referred to by the current array, pointer, or reference type, or `null` if the current <xref href=\"System.Type\"></xref> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.\n  overload: System.Type.GetElementType*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetEnumName(System.Object)\n  commentId: M:System.Type.GetEnumName(System.Object)\n  id: GetEnumName(System.Object)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetEnumName(Object)\n  nameWithType: Type.GetEnumName(Object)\n  fullName: Type.GetEnumName(Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns the name of the constant that has the specified value, for the current enumeration type.\n  syntax:\n    content: public virtual string GetEnumName (object value);\n    parameters:\n    - id: value\n      type: System.Object\n      description: The value whose name is to be retrieved.\n    return:\n      type: System.String\n      description: The name of the member of the current enumeration type that has the specified value, or `null` if no such constant is found.\n  overload: System.Type.GetEnumName*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"The current type is not an enumeration.  \\n  \\n -or-  \\n  \\n <code>value</code> is neither of the current type nor does it have the same underlying type as the current type.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>value</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetEnumNames\n  commentId: M:System.Type.GetEnumNames\n  id: GetEnumNames\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetEnumNames()\n  nameWithType: Type.GetEnumNames()\n  fullName: Type.GetEnumNames()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns the names of the members of the current enumeration type.\n  remarks: The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants. If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.\n  syntax:\n    content: public virtual string[] GetEnumNames ();\n    parameters: []\n    return:\n      type: System.String[]\n      description: An array that contains the names of the members of the enumeration.\n  overload: System.Type.GetEnumNames*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The current type is not an enumeration.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetEnumUnderlyingType\n  commentId: M:System.Type.GetEnumUnderlyingType\n  id: GetEnumUnderlyingType\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetEnumUnderlyingType()\n  nameWithType: Type.GetEnumUnderlyingType()\n  fullName: Type.GetEnumUnderlyingType()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns the underlying type of the current enumeration type.\n  remarks: By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>. Other integer types can be specified.\n  syntax:\n    content: public virtual Type GetEnumUnderlyingType ();\n    parameters: []\n    return:\n      type: System.Type\n      description: The underlying type of the current enumeration.\n  overload: System.Type.GetEnumUnderlyingType*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"The current type is not an enumeration.  \\n  \\n -or-  \\n  \\n The enumeration type is not valid, because it contains more than one instance field.\"\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetEnumValues\n  commentId: M:System.Type.GetEnumValues\n  id: GetEnumValues\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetEnumValues()\n  nameWithType: Type.GetEnumValues()\n  fullName: Type.GetEnumValues()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns an array of the values of the constants in the current enumeration type.\n  syntax:\n    content: public virtual Array GetEnumValues ();\n    parameters: []\n    return:\n      type: System.Array\n      description: An array that contains the values. The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.\n  overload: System.Type.GetEnumValues*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The current type is not an enumeration.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetEvent(System.String)\n  commentId: M:System.Type.GetEvent(System.String)\n  id: GetEvent(System.String)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetEvent(String)\n  nameWithType: Type.GetEvent(String)\n  fullName: Type.GetEvent(String)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns the <xref href=\"System.Reflection.EventInfo\"></xref> object representing the specified public event.\n  remarks: \"An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \\n  \\n The search for `name` is case-sensitive. The search includes public static and public instance events.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.\"\n  example:\n  - \"The following example creates an <xref:System.Reflection.EventInfo> object and gets the event for a button class for the specified event.  \\n  \\n [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]\\n [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]\\n [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]\"\n  syntax:\n    content: public System.Reflection.EventInfo GetEvent (string name);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of an event that is declared or inherited by the current <xref href=\"System.Type\"></xref>.\n    return:\n      type: System.Reflection.EventInfo\n      description: The object representing the specified public event that is declared or inherited by the current <xref href=\"System.Type\"></xref>, if found; otherwise, `null`.\n  overload: System.Type.GetEvent*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetEvent(System.String,System.Reflection.BindingFlags)\n  commentId: M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)\n  id: GetEvent(System.String,System.Reflection.BindingFlags)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetEvent(String, BindingFlags)\n  nameWithType: Type.GetEvent(String, BindingFlags)\n  fullName: Type.GetEvent(String, BindingFlags)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, returns the <xref href=\"System.Reflection.EventInfo\"></xref> object representing the specified event, using the specified binding constraints.\n  remarks: \"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public events in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.\"\n  example:\n  - \"The following code example uses the <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> method to search a type for a public or non-public event named \\\"Click\\\" that is not `static` (`Shared` in Visual Basic).  \\n  \\n [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]\\n [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]\\n [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]\"\n  syntax:\n    content: public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of an event which is declared or inherited by the current <xref href=\"System.Type\"></xref>.\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    return:\n      type: System.Reflection.EventInfo\n      description: The object representing the specified event that is declared or inherited by the current <xref href=\"System.Type\"></xref>, if found; otherwise, `null`.\n  overload: System.Type.GetEvent*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetEvents\n  commentId: M:System.Type.GetEvents\n  id: GetEvents\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetEvents()\n  nameWithType: Type.GetEvents()\n  fullName: Type.GetEvents()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns all the public events that are declared or inherited by the current <xref href=\"System.Type\"></xref>.\n  remarks: \"An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \\n  \\n The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which events are returned, because that order varies.  \\n  \\n This method can be overridden by a derived class.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.\"\n  example:\n  - \"The following example obtains an array of <xref:System.Reflection.EventInfo> objects, gets all the events for a `Button` class, and displays the event names. To compile the Visual Basic example, use the following command line:  \\n  \\n `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  \\n  \\n [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]\\n [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]\\n [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]\"\n  syntax:\n    content: public virtual System.Reflection.EventInfo[] GetEvents ();\n    parameters: []\n    return:\n      type: System.Reflection.EventInfo[]\n      description: \"An array of <xref href=\\\"System.Reflection.EventInfo\\\"></xref> objects representing all the public events which are declared or inherited by the current <xref href=\\\"System.Type\\\"></xref>.  \\n  \\n -or-  \\n  \\n An empty array of type <xref href=\\\"System.Reflection.EventInfo\\\"></xref>, if the current <xref href=\\\"System.Type\\\"></xref> does not have public events.\"\n  overload: System.Type.GetEvents*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetEvents(System.Reflection.BindingFlags)\n  commentId: M:System.Type.GetEvents(System.Reflection.BindingFlags)\n  id: GetEvents(System.Reflection.BindingFlags)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetEvents(BindingFlags)\n  nameWithType: Type.GetEvents(BindingFlags)\n  fullName: Type.GetEvents(BindingFlags)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, searches for events that are declared or inherited by the current <xref href=\"System.Type\"></xref>, using the specified binding constraints.\n  remarks: \"The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which events are returned, because that order varies.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public events in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search. Only protected and internal events on base classes are returned; private events on base classes are not returned.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n An event is considered public to reflection if it has at least one method or accessor that is public. Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.\"\n  example:\n  - \"The following example obtains an array of <xref:System.Reflection.EventInfo> objects that match the specified binding flags, gets all the events for a `Button` class, and displays the event names. To compile the Visual Basic example, use the following command line:  \\n  \\n `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  \\n  \\n [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]\\n [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]\\n [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]\"\n  syntax:\n    content: public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);\n    parameters:\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    return:\n      type: System.Reflection.EventInfo[]\n      description: \"An array of <xref href=\\\"System.Reflection.EventInfo\\\"></xref> objects representing all events that are declared or inherited by the current <xref href=\\\"System.Type\\\"></xref> that match the specified binding constraints.  \\n  \\n -or-  \\n  \\n An empty array of type <xref href=\\\"System.Reflection.EventInfo\\\"></xref>, if the current <xref href=\\\"System.Type\\\"></xref> does not have events, or if none of the events match the binding constraints.\"\n  overload: System.Type.GetEvents*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetField(System.String)\n  commentId: M:System.Type.GetField(System.String)\n  id: GetField(System.String)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetField(String)\n  nameWithType: Type.GetField(String)\n  fullName: Type.GetField(String)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the public field with the specified name.\n  remarks: \"The search for `name` is case-sensitive. The search includes public static and public instance fields.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.\"\n  example:\n  - \"The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field, and displays the value of the field.  \\n  \\n [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]\\n [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]\\n [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]\"\n  syntax:\n    content: public System.Reflection.FieldInfo GetField (string name);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the data field to get.\n    return:\n      type: System.Reflection.FieldInfo\n      description: An object representing the public field with the specified name, if found; otherwise, `null`.\n  overload: System.Type.GetField*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: This <xref href=\"System.Type\"></xref> object is a <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref> whose <xref href=\"System.Reflection.Emit.TypeBuilder.CreateType\"></xref> method has not yet been called.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetField(System.String,System.Reflection.BindingFlags)\n  commentId: M:System.Type.GetField(System.String,System.Reflection.BindingFlags)\n  id: GetField(System.String,System.Reflection.BindingFlags)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetField(String, BindingFlags)\n  nameWithType: Type.GetField(String, BindingFlags)\n  fullName: Type.GetField(String, BindingFlags)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the specified field, using the specified binding constraints.\n  remarks: \"The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public fields in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.\"\n  example:\n  - \"The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field that matches the specified binding flags, and displays the value of the field.  \\n  \\n [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]\\n [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]\\n [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]\"\n  syntax:\n    content: public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the data field to get.\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    return:\n      type: System.Reflection.FieldInfo\n      description: An object representing the field that matches the specified requirements, if found; otherwise, `null`.\n  overload: System.Type.GetField*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetFields\n  commentId: M:System.Type.GetFields\n  id: GetFields\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetFields()\n  nameWithType: Type.GetFields()\n  fullName: Type.GetFields()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns all the public fields of the current <xref href=\"System.Type\"></xref>.\n  remarks: \"The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order varies.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.\"\n  example:\n  - \"The following example shows a use of the `GetFields()` method.  \\n  \\n [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]\\n [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]\\n [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]\"\n  syntax:\n    content: public System.Reflection.FieldInfo[] GetFields ();\n    parameters: []\n    return:\n      type: System.Reflection.FieldInfo[]\n      description: \"An array of <xref href=\\\"System.Reflection.FieldInfo\\\"></xref> objects representing all the public fields defined for the current <xref href=\\\"System.Type\\\"></xref>.  \\n  \\n -or-  \\n  \\n An empty array of type <xref href=\\\"System.Reflection.FieldInfo\\\"></xref>, if no public fields are defined for the current <xref href=\\\"System.Type\\\"></xref>.\"\n  overload: System.Type.GetFields*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetFields(System.Reflection.BindingFlags)\n  commentId: M:System.Type.GetFields(System.Reflection.BindingFlags)\n  id: GetFields(System.Reflection.BindingFlags)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetFields(BindingFlags)\n  nameWithType: Type.GetFields(BindingFlags)\n  fullName: Type.GetFields(BindingFlags)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, searches for the fields defined for the current <xref href=\"System.Type\"></xref>, using the specified binding constraints.\n  remarks: \"The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which fields are returned, because that order varies.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public fields in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search. Only protected and internal fields on base classes are returned; private fields on base classes are not returned.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.\"\n  example:\n  - \"The following example shows a use of the `GetFields(BindingFlags)` method.  \\n  \\n [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]\\n [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]\"\n  syntax:\n    content: public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);\n    parameters:\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    return:\n      type: System.Reflection.FieldInfo[]\n      description: \"An array of <xref href=\\\"System.Reflection.FieldInfo\\\"></xref> objects representing all fields defined for the current <xref href=\\\"System.Type\\\"></xref> that match the specified binding constraints.  \\n  \\n -or-  \\n  \\n An empty array of type <xref href=\\\"System.Reflection.FieldInfo\\\"></xref>, if no fields are defined for the current <xref href=\\\"System.Type\\\"></xref>, or if none of the defined fields match the binding constraints.\"\n  overload: System.Type.GetFields*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetGenericArguments\n  commentId: M:System.Type.GetGenericArguments\n  id: GetGenericArguments\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetGenericArguments()\n  nameWithType: Type.GetGenericArguments()\n  fullName: Type.GetGenericArguments()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns an array of <xref href=\"System.Type\"></xref> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.\n  remarks: \"The array elements are returned in the order in which they appear in the list of type arguments for the generic type.  \\n  \\n-   If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition.  \\n  \\n-   If the current type is a generic type definition, the array contains the type parameters.  \\n  \\n-   If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters. Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart. For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.  \\n  \\n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.\"\n  example:\n  - \"The following code example uses the <xref:System.Type.GetGenericArguments%2A> method to display the type arguments of a constructed type and the type parameters of its generic type definition.  \\n  \\n This code example is part of a larger example provided for the <xref:System.Type.IsGenericTypeDefinition%2A> property. See the larger example for sample output.  \\n  \\n [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]\\n [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]\\n [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]\"\n  syntax:\n    content: public virtual Type[] GetGenericArguments ();\n    parameters: []\n    return:\n      type: System.Type[]\n      description: An array of <xref href=\"System.Type\"></xref> objects that represent the type arguments of a generic type. Returns an empty array if the current type is not a generic type.\n  overload: System.Type.GetGenericArguments*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The invoked method is not supported in the base class. Derived classes must provide an implementation.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetGenericParameterConstraints\n  commentId: M:System.Type.GetGenericParameterConstraints\n  id: GetGenericParameterConstraints\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetGenericParameterConstraints()\n  nameWithType: Type.GetGenericParameterConstraints()\n  fullName: Type.GetGenericParameterConstraints()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns an array of <xref href=\"System.Type\"></xref> objects that represent the constraints on the current generic type parameter.\n  remarks: \"Each constraint on a generic type parameter is expressed as a <xref:System.Type> object. Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint. If a type parameter has no class constraint and no interface constraints, an empty array is returned.  \\n  \\n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.\"\n  example:\n  - \"The following code example defines a generic type `Test` with two type parameters that have different constraints. When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.  \\n  \\n [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]\\n [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]\\n [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual Type[] GetGenericParameterConstraints ();\n    parameters: []\n    return:\n      type: System.Type[]\n      description: An array of <xref href=\"System.Type\"></xref> objects that represent the constraints on the current generic type parameter.\n  overload: System.Type.GetGenericParameterConstraints*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current <xref href=\"System.Type\"></xref> object is not a generic type parameter. That is, the <xref href=\"System.Type.IsGenericParameter\"></xref> property returns `false`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetGenericTypeDefinition\n  commentId: M:System.Type.GetGenericTypeDefinition\n  id: GetGenericTypeDefinition\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetGenericTypeDefinition()\n  nameWithType: Type.GetGenericTypeDefinition()\n  fullName: Type.GetGenericTypeDefinition()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns a <xref href=\"System.Type\"></xref> object that represents a generic type definition from which the current generic type can be constructed.\n  remarks: \"A generic type definition is a template from which other types can be constructed. For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic). Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.  \\n  \\n If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.  \\n  \\n If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.  \\n  \\n> [!IMPORTANT]\\n>  An array of generic types is not itself generic. In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic. Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.  \\n  \\n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.\"\n  example:\n  - \"The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <xref:System.Type.GetType%2A> and <xref:System.Type.GetGenericTypeDefinition%2A> methods to retrieve the constructed type and the generic type definition. This example uses the generic <xref:System.Collections.Generic.Dictionary%602> type; the constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.  \\n  \\n [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]\\n [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]\\n [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual Type GetGenericTypeDefinition ();\n    parameters: []\n    return:\n      type: System.Type\n      description: A <xref href=\"System.Type\"></xref> object representing a generic type from which the current type can be constructed.\n  overload: System.Type.GetGenericTypeDefinition*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current type is not a generic type.  That is, <xref href=\"System.Type.IsGenericType\"></xref> returns `false`.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The invoked method is not supported in the base class. Derived classes must provide an implementation.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetHashCode\n  commentId: M:System.Type.GetHashCode\n  id: GetHashCode\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetHashCode()\n  nameWithType: Type.GetHashCode()\n  fullName: Type.GetHashCode()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns the hash code for this instance.\n  remarks: This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=fullName>.\n  example:\n  - \"The following example displays the hash code of the `System.Windows.Forms.Button` class.  \\n  \\n [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]\\n [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]\\n [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]\"\n  syntax:\n    content: public override int GetHashCode ();\n    parameters: []\n    return:\n      type: System.Int32\n      description: The hash code for this instance.\n  overload: System.Type.GetHashCode*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetInterface(System.String)\n  commentId: M:System.Type.GetInterface(System.String)\n  id: GetInterface(System.String)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetInterface(String)\n  nameWithType: Type.GetInterface(String)\n  fullName: Type.GetInterface(String)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the interface with the specified name.\n  remarks: \"The search for `name` is case-sensitive.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.  \\n  \\n> [!NOTE]\\n>  For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\\\\`) and the number of type parameters. This is true for both generic interface definitions and constructed generic interfaces. For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``\\\"IExample`1\\\"``.\"\n  example:\n  - \"The following code example uses the <xref:System.Type.GetInterface%28System.String%29> method to search the <xref:System.Collections.Hashtable> class for the <xref:System.Runtime.Serialization.IDeserializationCallback> interface, and lists the methods of the interface.  \\n  \\n The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.  \\n  \\n [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]\\n [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]\\n [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]\"\n  syntax:\n    content: public Type GetInterface (string name);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the interface to get. For generic interfaces, this is the mangled name.\n    return:\n      type: System.Type\n      description: An object representing the interface with the specified name, implemented or inherited by the current <xref href=\"System.Type\"></xref>, if found; otherwise, `null`.\n  overload: System.Type.GetInterface*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: The current <xref href=\"System.Type\"></xref> represents a type that implements the same generic interface with different type arguments.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetInterface(System.String,System.Boolean)\n  commentId: M:System.Type.GetInterface(System.String,System.Boolean)\n  id: GetInterface(System.String,System.Boolean)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetInterface(String, Boolean)\n  nameWithType: Type.GetInterface(String, Boolean)\n  fullName: Type.GetInterface(String, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.\n  remarks: \"The `ignoreCase` parameter applies only to the simple interface name, not to the namespace. The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found. For example, the string \\\"System.icomparable\\\" finds the <xref:System.IComparable> interface, but the string \\\"system.icomparable\\\" does not.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.  \\n  \\n> [!NOTE]\\n>  For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\\\\`) and the number of type parameters. This is true for both generic interface definitions and constructed generic interfaces. For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `\\\"IExample`1\\\"`.\"\n  example:\n  - \"The following code example uses the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method to perform a case-insensitive search of the <xref:System.Collections.Hashtable> class for the <xref:System.Collections.IEnumerable> interface.  \\n  \\n The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.  \\n  \\n [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]\\n [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]\\n [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]\"\n  syntax:\n    content: public abstract Type GetInterface (string name, bool ignoreCase);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the interface to get. For generic interfaces, this is the mangled name.\n    - id: ignoreCase\n      type: System.Boolean\n      description: \"`true` to ignore the case of that part of <code>name</code> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).  \\n  \\n -or-  \\n  \\n `false` to perform a case-sensitive search for all parts of <code>name</code>.\"\n    return:\n      type: System.Type\n      description: An object representing the interface with the specified name, implemented or inherited by the current <xref href=\"System.Type\"></xref>, if found; otherwise, `null`.\n  overload: System.Type.GetInterface*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: The current <xref href=\"System.Type\"></xref> represents a type that implements the same generic interface with different type arguments.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetInterfaceMap(System.Type)\n  commentId: M:System.Type.GetInterfaceMap(System.Type)\n  id: GetInterfaceMap(System.Type)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetInterfaceMap(Type)\n  nameWithType: Type.GetInterfaceMap(Type)\n  fullName: Type.GetInterfaceMap(Type)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns an interface mapping for the specified interface type.\n  remarks: \"The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.\"\n  example:\n  - \"The following example calls the <xref:System.Type.GetInterfaceMap%2A> method to determine how the <xref:System.IFormatProvider> interface maps to <xref:System.Globalization.CultureInfo> methods, and how the <xref:System.IAppDomainSetup> interface maps to <xref:System.AppDomainSetup> properties. Note that, because the <xref:System.IAppDomainSetup> interface defines a set of properties, the returned <xref:System.Reflection.InterfaceMapping> object includes separate <xref:System.Reflection.MethodInfo> objects for a property's get and set accessors.  \\n  \\n [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]\\n [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);\n    parameters:\n    - id: interfaceType\n      type: System.Type\n      description: The interface type to retrieve a mapping for.\n    return:\n      type: System.Reflection.InterfaceMapping\n      description: An object that represents the interface mapping for <code>interfaceType</code>.\n  overload: System.Type.GetInterfaceMap*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>interfaceType</code> is not implemented by the current type.  \\n  \\n -or-  \\n  \\n The <code>interfaceType</code> parameter does not refer to an interface.  \\n  \\n -or-  \\n  \\n <code>interfaceType</code> is a generic interface, and the current type is an array type.\"\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>interfaceType</code> is `null`.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current <xref href=\"System.Type\"></xref> represents a generic type parameter; that is, <xref href=\"System.Type.IsGenericParameter\"></xref> is `true`.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The invoked method is not supported in the base class. Derived classes must provide an implementation.\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetInterfaces\n  commentId: M:System.Type.GetInterfaces\n  id: GetInterfaces\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetInterfaces()\n  nameWithType: Type.GetInterfaces()\n  fullName: Type.GetInterfaces()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, gets all the interfaces implemented or inherited by the current <xref href=\"System.Type\"></xref>.\n  remarks: \"The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which interfaces are returned, because that order varies.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.\"\n  example:\n  - \"The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits. To compile the Visual Basic example, use the following compiler commands:  \\n  \\n `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  \\n  \\n [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]\\n [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]\\n [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]\"\n  syntax:\n    content: public abstract Type[] GetInterfaces ();\n    parameters: []\n    return:\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing all the interfaces implemented or inherited by the current <xref href=\\\"System.Type\\\"></xref>.  \\n  \\n -or-  \\n  \\n An empty array of type <xref href=\\\"System.Type\\\"></xref>, if no interfaces are implemented or inherited by the current <xref href=\\\"System.Type\\\"></xref>.\"\n  overload: System.Type.GetInterfaces*\n  exceptions:\n  - type: System.Reflection.TargetInvocationException\n    commentId: T:System.Reflection.TargetInvocationException\n    description: A static initializer is invoked and throws an exception.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetMember(System.String)\n  commentId: M:System.Type.GetMember(System.String)\n  id: GetMember(System.String)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetMember(String)\n  nameWithType: Type.GetMember(String)\n  fullName: Type.GetMember(String)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the public members with the specified name.\n  remarks: \"The search for `name` is case-sensitive. The search includes public static and public instance members.  \\n  \\n Members include properties, methods, fields, events, and so on.  \\n  \\n The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  \\n  \\n This method overload will not find class initializers (.cctor). To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.  \\n  \\n> [!NOTE]\\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\\\"MyMethod<int>\\\")` searches for a member with the text name \\\"`MyMethod<int>`\\\", rather than for a method named `MyMethod` that has one generic argument of type `int`.\"\n  example:\n  - \"The following example displays all the members of the `String` class that start with the letter C.  \\n  \\n [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]\\n [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]\\n [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]\"\n  syntax:\n    content: public System.Reflection.MemberInfo[] GetMember (string name);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the public members to get.\n    return:\n      type: System.Reflection.MemberInfo[]\n      description: An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing the public members with the specified name, if found; otherwise, an empty array.\n  overload: System.Type.GetMember*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetMember(System.String,System.Reflection.BindingFlags)\n  commentId: M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)\n  id: GetMember(System.String,System.Reflection.BindingFlags)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetMember(String, BindingFlags)\n  nameWithType: Type.GetMember(String, BindingFlags)\n  fullName: Type.GetMember(String, BindingFlags)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the specified members, using the specified binding constraints.\n  remarks: \"This method can be overridden by a derived class.  \\n  \\n Members include properties, methods, fields, events, and so on.  \\n  \\n The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public members in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n To get the class initializer (.cctor) using this method overload, you must specify \\\".cctor\\\" for `name`, and <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic) for `bindingAttr`. You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.  \\n  \\n> [!NOTE]\\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\\\"MyMethod<int>\\\")` searches for a member with the text name \\\"`MyMethod<int>`\\\", rather than for a method named `MyMethod` that has one generic argument of type `int`.\"\n  example:\n  - \"The following example displays all the public static members of the `myString` class that start with the letter C.  \\n  \\n [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]\\n [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]\\n [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]\"\n  syntax:\n    content: public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the members to get.\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return an empty array.\"\n    return:\n      type: System.Reflection.MemberInfo[]\n      description: An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing the public members with the specified name, if found; otherwise, an empty array.\n  overload: System.Type.GetMember*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)\n  commentId: M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)\n  id: GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetMember(String, MemberTypes, BindingFlags)\n  nameWithType: Type.GetMember(String, MemberTypes, BindingFlags)\n  fullName: Type.GetMember(String, MemberTypes, BindingFlags)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the specified members of the specified member type, using the specified binding constraints.\n  remarks: \"Members include properties, methods, fields, events, and so on.  \\n  \\n The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public members in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n To get the class initializer (.cctor) using this method overload, you must specify \\\".cctor\\\" for `name`, <xref:System.Reflection.MemberTypes?displayProperty=fullName> for `type`, and  <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic) for `bindingAttr`. You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.  \\n  \\n> [!NOTE]\\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\\\"MyMethod<int>\\\")` searches for a member with the text name \\\"`MyMethod<int>`\\\", rather than for a method named `MyMethod` that has one generic argument of type `int`.\"\n  example:\n  - \"The following example displays all the methods of the `myString` class that start with the letter C.  \\n  \\n [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]\\n [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]\\n [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]\"\n  syntax:\n    content: public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the members to get.\n    - id: type\n      type: System.Reflection.MemberTypes\n      description: The value to search for.\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return an empty array.\"\n    return:\n      type: System.Reflection.MemberInfo[]\n      description: An array of <xref href=\"System.Reflection.MemberInfo\"></xref> objects representing the public members with the specified name, if found; otherwise, an empty array.\n  overload: System.Type.GetMember*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: A derived class must provide an implementation.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetMembers\n  commentId: M:System.Type.GetMembers\n  id: GetMembers\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetMembers()\n  nameWithType: Type.GetMembers()\n  fullName: Type.GetMembers()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns all the public members of the current <xref href=\"System.Type\"></xref>.\n  remarks: \"Members include properties, methods, fields, events, and so on.  \\n  \\n The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  \\n  \\n This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). It will not find class initializers (.cctor). To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.\"\n  example:\n  - \"The following code example demonstrates how to use the <xref:System.Type.GetMembers> method overload to collect information about all public members of a specified class.  \\n  \\n [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]\\n [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]\\n [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]\"\n  syntax:\n    content: public System.Reflection.MemberInfo[] GetMembers ();\n    parameters: []\n    return:\n      type: System.Reflection.MemberInfo[]\n      description: \"An array of <xref href=\\\"System.Reflection.MemberInfo\\\"></xref> objects representing all the public members of the current <xref href=\\\"System.Type\\\"></xref>.  \\n  \\n -or-  \\n  \\n An empty array of type <xref href=\\\"System.Reflection.MemberInfo\\\"></xref>, if the current <xref href=\\\"System.Type\\\"></xref> does not have public members.\"\n  overload: System.Type.GetMembers*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetMembers(System.Reflection.BindingFlags)\n  commentId: M:System.Type.GetMembers(System.Reflection.BindingFlags)\n  id: GetMembers(System.Reflection.BindingFlags)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetMembers(BindingFlags)\n  nameWithType: Type.GetMembers(BindingFlags)\n  fullName: Type.GetMembers(BindingFlags)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, searches for the members defined for the current <xref href=\"System.Type\"></xref>, using the specified binding constraints.\n  remarks: \"Members include properties, methods, fields, events, and so on.  \\n  \\n The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which members are returned, because that order varies.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public members in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search. Only protected and internal members on base classes are returned; private members on base classes are not returned.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.  \\n  \\n Calling this method with only the `Public` flag or only the `NonPublic` flag will return the specified members and does not require any other flags.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (<xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName> in Visual Basic). You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.  \\n  \\n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.\"\n  example:\n  - \"The following code example demonstrates how to use the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload to collect information about all public instance members of a specified class.  \\n  \\n [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]\\n [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]\\n [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]\"\n  syntax:\n    content: public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);\n    parameters:\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero (<xref href=\\\"System.Reflection.BindingFlags.Default\\\"></xref>), to return an empty array.\"\n    return:\n      type: System.Reflection.MemberInfo[]\n      description: \"An array of <xref href=\\\"System.Reflection.MemberInfo\\\"></xref> objects representing all members defined for the current <xref href=\\\"System.Type\\\"></xref> that match the specified binding constraints.  \\n  \\n -or-  \\n  \\n An empty array of type <xref href=\\\"System.Reflection.MemberInfo\\\"></xref>, if no members are defined for the current <xref href=\\\"System.Type\\\"></xref>, or if none of the defined members match the binding constraints.\"\n  overload: System.Type.GetMembers*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  commentId: M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  id: GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetMethod(String, BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  nameWithType: Type.GetMethod(String, BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  fullName: Type.GetMethod(String, BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.\n  remarks: \"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \\n  \\n The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public methods in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n> [!NOTE]\\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \\n  \\n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.  \\n  \\n> [!NOTE]\\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\\\"MyMethod<int>\\\")` searches for a member with the text name \\\"`MyMethod<int>`\\\", rather than for a method named `MyMethod` that has one generic argument of type `int`.\"\n  example:\n  - \"The following example finds specific overloads of `MethodA`, specifying binding constraints, calling conventions, and a variety of argument types.  \\n  \\n> [!NOTE]\\n>  The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.  \\n  \\n [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]\\n [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]\\n [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]\"\n  syntax:\n    content: public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the method to get.\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    - id: binder\n      type: System.Reflection.Binder\n      description: \"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \\n  \\n -or-  \\n  \\n A null reference (`Nothing` in Visual Basic), to use the <xref href=\\\"System.Type.DefaultBinder\\\"></xref>.\"\n    - id: callConvention\n      type: System.Reflection.CallingConventions\n      description: The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.\n    - id: types\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing the number, order, and type of the parameters for the method to get.  \\n  \\n -or-  \\n  \\n An empty array of <xref href=\\\"System.Type\\\"></xref> objects (as provided by the <xref href=\\\"System.Type.EmptyTypes\\\"></xref> field) to get a method that takes no parameters.\"\n    - id: modifiers\n      type: System.Reflection.ParameterModifier[]\n      description: An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.\n    return:\n      type: System.Reflection.MethodInfo\n      description: An object representing the method that matches the specified requirements, if found; otherwise, `null`.\n  overload: System.Type.GetMethod*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one method is found with the specified name and matching the specified binding constraints.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>name</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>types</code> is `null`.  \\n  \\n -or-  \\n  \\n One of the elements in <code>types</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>types</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>modifiers</code> is multidimensional.\"\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])\n  commentId: M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])\n  id: GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetMethod(String, BindingFlags, Binder, Type[], ParameterModifier[])\n  nameWithType: Type.GetMethod(String, BindingFlags, Binder, Type[], ParameterModifier[])\n  fullName: Type.GetMethod(String, BindingFlags, Binder, Type[], ParameterModifier[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.\n  remarks: \"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public methods in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n> [!NOTE]\\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \\n  \\n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.  \\n  \\n> [!NOTE]\\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\\\"MyMethod<int>\\\")` searches for a member with the text name \\\"`MyMethod<int>`\\\", rather than for a method named `MyMethod` that has one generic argument of type `int`.\"\n  example:\n  - \"The following example finds specific overloads of `MethodA`, specifying binding constraints and a variety of argument types.  \\n  \\n> [!NOTE]\\n>  The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.  \\n  \\n [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]\\n [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]\\n [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]\"\n  syntax:\n    content: public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the method to get.\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    - id: binder\n      type: System.Reflection.Binder\n      description: \"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \\n  \\n -or-  \\n  \\n A null reference (`Nothing` in Visual Basic), to use the <xref href=\\\"System.Type.DefaultBinder\\\"></xref>.\"\n    - id: types\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing the number, order, and type of the parameters for the method to get.  \\n  \\n -or-  \\n  \\n An empty array of <xref href=\\\"System.Type\\\"></xref> objects (as provided by the <xref href=\\\"System.Type.EmptyTypes\\\"></xref> field) to get a method that takes no parameters.\"\n    - id: modifiers\n      type: System.Reflection.ParameterModifier[]\n      description: An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.\n    return:\n      type: System.Reflection.MethodInfo\n      description: An object representing the method that matches the specified requirements, if found; otherwise, `null`.\n  overload: System.Type.GetMethod*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one method is found with the specified name and matching the specified binding constraints.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>name</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>types</code> is `null`.  \\n  \\n -or-  \\n  \\n One of the elements in <code>types</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>types</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>modifiers</code> is multidimensional.\"\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])\n  commentId: M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])\n  id: GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetMethod(String, Type[], ParameterModifier[])\n  nameWithType: Type.GetMethod(String, Type[], ParameterModifier[])\n  fullName: Type.GetMethod(String, Type[], ParameterModifier[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the specified public method whose parameters match the specified argument types and modifiers.\n  remarks: \"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \\n  \\n The search for `name` is case-sensitive. The search includes public static and public instance methods.  \\n  \\n> [!NOTE]\\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \\n  \\n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.  \\n  \\n> [!NOTE]\\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMethod(\\\"MyMethod<int>\\\")` searches for a member with the text name \\\"`MyMethod<int>`\\\", rather than for a method named `MyMethod` that has one generic argument of type `int`. Instead, use `GetMethod(\\\"MyMethod\\\")` with the appropriate parameter in the `types` array.\"\n  syntax:\n    content: public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the public method to get.\n    - id: types\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing the number, order, and type of the parameters for the method to get.  \\n  \\n -or-  \\n  \\n An empty array of <xref href=\\\"System.Type\\\"></xref> objects (as provided by the <xref href=\\\"System.Type.EmptyTypes\\\"></xref> field) to get a method that takes no parameters.\"\n    - id: modifiers\n      type: System.Reflection.ParameterModifier[]\n      description: An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. To be only used when calling through COM interop, and only parameters that are passed by reference are handled. The default binder does not process this parameter.\n    return:\n      type: System.Reflection.MethodInfo\n      description: An object representing the public method that matches the specified requirements, if found; otherwise, `null`.\n  overload: System.Type.GetMethod*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one method is found with the specified name and specified parameters.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>name</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>types</code> is `null`.  \\n  \\n -or-  \\n  \\n One of the elements in <code>types</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>types</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>modifiers</code> is multidimensional.\"\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetMethod(System.String)\n  commentId: M:System.Type.GetMethod(System.String)\n  id: GetMethod(System.String)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetMethod(String)\n  nameWithType: Type.GetMethod(String)\n  fullName: Type.GetMethod(String)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the public method with the specified name.\n  remarks: \"The search for `name` is case-sensitive. The search includes public static and public instance methods.  \\n  \\n If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception. In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=fullName> method.  On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=fullName> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.  \\n  \\n [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]\\n [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  \\n  \\n You can do one of the following to retrieve a specific method:  \\n  \\n-   Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method. For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags?displayProperty=fullName>`Or`<xref:System.Reflection.BindingFlags?displayProperty=fullName>.  \\n  \\n-   Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.  \\n  \\n-   Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type. You can then iterate it to identify the duplicate methods named `name`.  \\n  \\n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.  \\n  \\n> [!NOTE]\\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\\\"MyMethod<int>\\\")` searches for a member with the text name \\\"`MyMethod<int>`\\\", rather than for a method named `MyMethod` that has one generic argument of type `int`.\"\n  example:\n  - \"The following example gets a method named `MethodA`.  \\n  \\n [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]\\n [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]\\n [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]\"\n  syntax:\n    content: public System.Reflection.MethodInfo GetMethod (string name);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the public method to get.\n    return:\n      type: System.Reflection.MethodInfo\n      description: An object that represents the public method with the specified name, if found; otherwise, `null`.\n  overload: System.Type.GetMethod*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one method is found with the specified name.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetMethod(System.String,System.Reflection.BindingFlags)\n  commentId: M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)\n  id: GetMethod(System.String,System.Reflection.BindingFlags)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetMethod(String, BindingFlags)\n  nameWithType: Type.GetMethod(String, BindingFlags)\n  fullName: Type.GetMethod(String, BindingFlags)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the specified method, using the specified binding constraints.\n  remarks: \"The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:  \\n  \\n-   You must specify either <xref:System.Reflection.BindingFlags?displayProperty=fullName> or <xref:System.Reflection.BindingFlags?displayProperty=fullName> in order to get a return.  \\n  \\n-   Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include public methods in the search.  \\n  \\n-   Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include non-public methods (that is, private, internal, and protected methods) in the search.  \\n  \\n-   Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   <xref:System.Reflection.BindingFlags?displayProperty=fullName> to ignore the case of `name`.  \\n  \\n-   <xref:System.Reflection.BindingFlags?displayProperty=fullName> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception. In the following example, an exception is thrown because:  \\n  \\n-   The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`.  \\n  \\n-   The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`.  \\n  \\n [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]\\n [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  \\n  \\n You can do one of the following to retrieve a specific method:  \\n  \\n-   Change the binding constraints. In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.  \\n  \\n-   Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.  \\n  \\n-   Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes. You can then iterate it to identify the duplicate methods named `name`. This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.  \\n  \\n> [!NOTE]\\n>  For generic methods, do not include the type arguments in `name`. For example, the C# code `GetMember(\\\"MyMethod<int>\\\")` searches for a member with the text name \\\"`MyMethod<int>`\\\", rather than for a method named `MyMethod` that has one generic argument of type `int`.\"\n  example:\n  - \"The following example gets the method that matches the specified binding flags.  \\n  \\n [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]\\n [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]\\n [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]\"\n  syntax:\n    content: public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the method to get.\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    return:\n      type: System.Reflection.MethodInfo\n      description: An object representing the method that matches the specified requirements, if found; otherwise, `null`.\n  overload: System.Type.GetMethod*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one method is found with the specified name and matching the specified binding constraints.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetMethod(System.String,System.Type[])\n  commentId: M:System.Type.GetMethod(System.String,System.Type[])\n  id: GetMethod(System.String,System.Type[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetMethod(String, Type[])\n  nameWithType: Type.GetMethod(String, Type[])\n  fullName: Type.GetMethod(String, Type[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the specified public method whose parameters match the specified argument types.\n  remarks: \"The search for `name` is case-sensitive. The search includes public static and public instance methods.  \\n  \\n> [!NOTE]\\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.  \\n  \\n> [!NOTE]\\n>  The `name` parameter cannot include type arguments. For example, the C# code `GetMethod(\\\"MyGenericMethod<int>\\\")` searches for a method with the text name \\\"`MyGenericMethod<int>`\\\", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`. Instead, use `GetMethod(\\\"MyGenericMethod\\\")` with the appropriate parameter in the `types` array.\"\n  example:\n  - \"The following example finds specific overloads of `MethodA`, specifying a variety of argument types.  \\n  \\n> [!NOTE]\\n>  The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.  \\n  \\n [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]\\n [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]\\n [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  \\n  \\n The following example retrieves <xref:System.Reflection.MethodInfo> objects that represent the `Add` methods  of a non-generic type (the <xref:System.Collections.ArrayList> class), an open generic type (the <xref:System.Collections.Generic.List%601> class), and a closed generic type (the `List(Of String)` type.  \\n  \\n [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]\\n [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  \\n  \\n The example defines a `GetAddMethod` method that retrieves the appropriate <xref:System.Reflection.MethodInfo> object. To provide the `types` argument for an open generic type, it calls the <xref:System.Type.GetGenericArguments%2A?displayProperty=fullName> method. To provide the `types` argument for a closed generic type, it retrieves the value of the <xref:System.Type.GenericTypeArguments%2A?displayProperty=fullName> property.\"\n  syntax:\n    content: public System.Reflection.MethodInfo GetMethod (string name, Type[] types);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the public method to get.\n    - id: types\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing the number, order, and type of the parameters for the method to get.  \\n  \\n -or-  \\n  \\n An empty array of <xref href=\\\"System.Type\\\"></xref> objects (as provided by the <xref href=\\\"System.Type.EmptyTypes\\\"></xref> field) to get a method that takes no parameters.\"\n    return:\n      type: System.Reflection.MethodInfo\n      description: An object representing the public method whose parameters match the specified argument types, if found; otherwise, `null`.\n  overload: System.Type.GetMethod*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one method is found with the specified name and specified parameters.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>name</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>types</code> is `null`.  \\n  \\n -or-  \\n  \\n One of the elements in <code>types</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>types</code> is multidimensional.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  commentId: M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  id: GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetMethodImpl(String, BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  nameWithType: Type.GetMethodImpl(String, BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  fullName: Type.GetMethodImpl(String, BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.\n  remarks: \"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \\n  \\n If `types` is `null`, arguments are not matched.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public methods in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.\"\n  syntax:\n    content: protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the method to get.\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    - id: binder\n      type: System.Reflection.Binder\n      description: \"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \\n  \\n -or-  \\n  \\n A null reference (`Nothing` in Visual Basic), to use the <xref href=\\\"System.Type.DefaultBinder\\\"></xref>.\"\n    - id: callConvention\n      type: System.Reflection.CallingConventions\n      description: The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.\n    - id: types\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing the number, order, and type of the parameters for the method to get.  \\n  \\n -or-  \\n  \\n An empty array of the type <xref href=\\\"System.Type\\\"></xref> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.  \\n  \\n -or-  \\n  \\n `null`. If <code>types</code> is `null`, arguments are not matched.\"\n    - id: modifiers\n      type: System.Reflection.ParameterModifier[]\n      description: An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.\n    return:\n      type: System.Reflection.MethodInfo\n      description: An object representing the method that matches the specified requirements, if found; otherwise, `null`.\n  overload: System.Type.GetMethodImpl*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one method is found with the specified name and matching the specified binding constraints.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>types</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>modifiers</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>types</code> and <code>modifiers</code> do not have the same length.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The current type is a <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref> or <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\"></xref>.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetMethods\n  commentId: M:System.Type.GetMethods\n  id: GetMethods\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetMethods()\n  nameWithType: Type.GetMethods()\n  fullName: Type.GetMethods()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns all the public methods of the current <xref href=\"System.Type\"></xref>.\n  remarks: \"The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which methods are returned, because that order varies.  \\n  \\n Constructors are not included in the array of methods returned by this call. Make a separate call to `GetConstructors()` to get the constructor methods.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n> [!NOTE]\\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \\n  \\n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.\"\n  syntax:\n    content: public System.Reflection.MethodInfo[] GetMethods ();\n    parameters: []\n    return:\n      type: System.Reflection.MethodInfo[]\n      description: \"An array of <xref href=\\\"System.Reflection.MethodInfo\\\"></xref> objects representing all the public methods defined for the current <xref href=\\\"System.Type\\\"></xref>.  \\n  \\n -or-  \\n  \\n An empty array of type <xref href=\\\"System.Reflection.MethodInfo\\\"></xref>, if no public methods are defined for the current <xref href=\\\"System.Type\\\"></xref>.\"\n  overload: System.Type.GetMethods*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetMethods(System.Reflection.BindingFlags)\n  commentId: M:System.Type.GetMethods(System.Reflection.BindingFlags)\n  id: GetMethods(System.Reflection.BindingFlags)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetMethods(BindingFlags)\n  nameWithType: Type.GetMethods(BindingFlags)\n  fullName: Type.GetMethods(BindingFlags)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, searches for the methods defined for the current <xref href=\"System.Type\"></xref>, using the specified binding constraints.\n  remarks: \"The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which methods are returned, because that order varies.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public methods in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search. Only protected and internal methods on base classes are returned; private methods on base classes are not returned.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n> [!NOTE]\\n>  You cannot omit parameters when looking up constructors and methods. You can only omit parameters when invoking.  \\n  \\n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.\"\n  example:\n  - \"The following example creates a class with two public methods and one protected method, creates a `Type` object corresponding to `MyTypeClass`, gets all public and non-public methods, and displays their names.  \\n  \\n [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]\\n [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]\\n [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]\"\n  syntax:\n    content: public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);\n    parameters:\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    return:\n      type: System.Reflection.MethodInfo[]\n      description: \"An array of <xref href=\\\"System.Reflection.MethodInfo\\\"></xref> objects representing all methods defined for the current <xref href=\\\"System.Type\\\"></xref> that match the specified binding constraints.  \\n  \\n -or-  \\n  \\n An empty array of type <xref href=\\\"System.Reflection.MethodInfo\\\"></xref>, if no methods are defined for the current <xref href=\\\"System.Type\\\"></xref>, or if none of the defined methods match the binding constraints.\"\n  overload: System.Type.GetMethods*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)\n  commentId: M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)\n  id: GetNestedType(System.String,System.Reflection.BindingFlags)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetNestedType(String, BindingFlags)\n  nameWithType: Type.GetNestedType(String, BindingFlags)\n  fullName: Type.GetNestedType(String, BindingFlags)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.\n  remarks: \"Use the simple name of the nested class for `name`. Do not qualify it with the name of the outer class. For a generic nested class, use the mangled name  that is, append a grave accent and the number of generic parameters. For example, use the string \\\"Inner\\\\`1\\\" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic). Do not include language-specific syntax for type parameters.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:  \\n  \\n-   You must specify either <xref:System.Reflection.BindingFlags?displayProperty=fullName> or <xref:System.Reflection.BindingFlags?displayProperty=fullName> to get a return.  \\n  \\n-   Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include public nested types in the search.  \\n  \\n-   Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include non-public nested types (that is, private, internal, and protected nested types) in the search.  \\n  \\n This method returns only the nested types of the current type. It does not search the base classes of the current type. To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.  \\n  \\n <xref:System.Reflection.BindingFlags?displayProperty=fullName> and <xref:System.Reflection.BindingFlags?displayProperty=fullName> are ignored.  \\n  \\n Calling this method with only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag or only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag will return the specified nested types and does not require any other flags.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.  \\n  \\n If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.  \\n  \\n> [!NOTE]\\n>  If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  \\n  \\n For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.\"\n  syntax:\n    content: public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the nested type to get.\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    return:\n      type: System.Type\n      description: An object representing the nested type that matches the specified requirements, if found; otherwise, `null`.\n  overload: System.Type.GetNestedType*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetNestedType(System.String)\n  commentId: M:System.Type.GetNestedType(System.String)\n  id: GetNestedType(System.String)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetNestedType(String)\n  nameWithType: Type.GetNestedType(String)\n  fullName: Type.GetNestedType(String)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the public nested type with the specified name.\n  remarks: \"The search for `name` is case-sensitive.  \\n  \\n Use the simple name of the nested class for `name`. Do not qualify it with the name of the outer class. For a generic nested class, use the mangled name  that is, append a grave accent and the number of generic arguments. For example, use the string \\\"Inner\\\\`1\\\" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic). Do not include language-specific syntax for type parameters.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.  \\n  \\n If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.  \\n  \\n> [!NOTE]\\n>  If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  \\n  \\n For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.\"\n  syntax:\n    content: public Type GetNestedType (string name);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the nested type to get.\n    return:\n      type: System.Type\n      description: An object representing the public nested type with the specified name, if found; otherwise, `null`.\n  overload: System.Type.GetNestedType*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetNestedTypes(System.Reflection.BindingFlags)\n  commentId: M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)\n  id: GetNestedTypes(System.Reflection.BindingFlags)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetNestedTypes(BindingFlags)\n  nameWithType: Type.GetNestedTypes(BindingFlags)\n  fullName: Type.GetNestedTypes(BindingFlags)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, searches for the types nested in the current <xref href=\"System.Type\"></xref>, using the specified binding constraints.\n  remarks: \"The search for nested types is not recursive.  \\n  \\n The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which types are returned, because that order varies.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:  \\n  \\n-   You must specify either <xref:System.Reflection.BindingFlags?displayProperty=fullName> or <xref:System.Reflection.BindingFlags?displayProperty=fullName> to get a return.  \\n  \\n-   Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include public nested types in the search.  \\n  \\n-   Specify <xref:System.Reflection.BindingFlags?displayProperty=fullName> to include non-public nested types (that is, private, internal, and protected nested types) in the search.  \\n  \\n This method returns only the nested types of the current type. It does not search the base classes of the current type. To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.  \\n  \\n <xref:System.Reflection.BindingFlags?displayProperty=fullName> and <xref:System.Reflection.BindingFlags?displayProperty=fullName> are ignored.  \\n  \\n Calling this method with only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag or only the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag will return the specified nested types and does not require any other flags.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.  \\n  \\n If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.  \\n  \\n> [!NOTE]\\n>  If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  \\n  \\n For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.\"\n  example:\n  - \"The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.  \\n  \\n [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]\\n [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]\\n [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]\"\n  syntax:\n    content: public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);\n    parameters:\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    return:\n      type: System.Type[]\n      description: An array of <xref href=\"System.Type\"></xref> objects representing all the types nested in the current <xref href=\"System.Type\"></xref> that match the specified binding constraints (the search is not recursive), or an empty array of type <xref href=\"System.Type\"></xref>, if no nested types are found that match the binding constraints.\n  overload: System.Type.GetNestedTypes*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetNestedTypes\n  commentId: M:System.Type.GetNestedTypes\n  id: GetNestedTypes\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetNestedTypes()\n  nameWithType: Type.GetNestedTypes()\n  fullName: Type.GetNestedTypes()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns the public types nested in the current <xref href=\"System.Type\"></xref>.\n  remarks: \"The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which types are returned, because that order varies.  \\n  \\n Only the public types immediately nested in the current type are returned; the search is not recursive.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.  \\n  \\n If a nested type is generic, this method returns its generic type definition. This is true even if the enclosing generic type is a closed constructed type.  \\n  \\n> [!NOTE]\\n>  If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own. This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).  \\n  \\n For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.\"\n  example:\n  - \"The following example defines a nested class and a `struct` in `MyClass`, and then obtains objects of the nested types using the type of `MyClass`.  \\n  \\n [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]\\n [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]\\n [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]\"\n  syntax:\n    content: public Type[] GetNestedTypes ();\n    parameters: []\n    return:\n      type: System.Type[]\n      description: An array of <xref href=\"System.Type\"></xref> objects representing the public types nested in the current <xref href=\"System.Type\"></xref> (the search is not recursive), or an empty array of type <xref href=\"System.Type\"></xref> if no public types are nested in the current <xref href=\"System.Type\"></xref>.\n  overload: System.Type.GetNestedTypes*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetProperties\n  commentId: M:System.Type.GetProperties\n  id: GetProperties\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetProperties()\n  nameWithType: Type.GetProperties()\n  fullName: Type.GetProperties()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns all the public properties of the current <xref href=\"System.Type\"></xref>.\n  remarks: \"Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic. It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.  \\n  \\n A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \\n  \\n The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.\"\n  example:\n  - \"The following example demonstrates the use of the `GetProperties` method.  \\n  \\n [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]\\n [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]\\n [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]\"\n  syntax:\n    content: public System.Reflection.PropertyInfo[] GetProperties ();\n    parameters: []\n    return:\n      type: System.Reflection.PropertyInfo[]\n      description: \"An array of <xref href=\\\"System.Reflection.PropertyInfo\\\"></xref> objects representing all public properties of the current <xref href=\\\"System.Type\\\"></xref>.  \\n  \\n -or-  \\n  \\n An empty array of type <xref href=\\\"System.Reflection.PropertyInfo\\\"></xref>, if the current <xref href=\\\"System.Type\\\"></xref> does not have public properties.\"\n  overload: System.Type.GetProperties*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetProperties(System.Reflection.BindingFlags)\n  commentId: M:System.Type.GetProperties(System.Reflection.BindingFlags)\n  id: GetProperties(System.Reflection.BindingFlags)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetProperties(BindingFlags)\n  nameWithType: Type.GetProperties(BindingFlags)\n  fullName: Type.GetProperties(BindingFlags)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, searches for the properties of the current <xref href=\"System.Type\"></xref>, using the specified binding constraints.\n  remarks: \"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \\n  \\n The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order. Your code must not depend on the order in which properties are returned, because that order varies.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public properties in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search. Only protected and internal properties on base classes are returned; private properties on base classes are not returned.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \\n  \\n If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.\"\n  example:\n  - \"The following example defines a class named `PropertyClass` that includes six properties: two are public, one is private, one is protected, one is internal (`Friend` in Visual Basic), and one is protected internal (`Protected Friend` in Visual Basic). It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its `get` and `set` accessors) for the properties that match the specified binding constraints.  \\n  \\n [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]\\n [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]\\n [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]\"\n  syntax:\n    content: public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);\n    parameters:\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    return:\n      type: System.Reflection.PropertyInfo[]\n      description: \"An array of <xref href=\\\"System.Reflection.PropertyInfo\\\"></xref> objects representing all properties of the current <xref href=\\\"System.Type\\\"></xref> that match the specified binding constraints.  \\n  \\n -or-  \\n  \\n An empty array of type <xref href=\\\"System.Reflection.PropertyInfo\\\"></xref>, if the current <xref href=\\\"System.Type\\\"></xref> does not have properties, or if none of the properties match the binding constraints.\"\n  overload: System.Type.GetProperties*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetProperty(System.String)\n  commentId: M:System.Type.GetProperty(System.String)\n  id: GetProperty(System.String)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetProperty(String)\n  nameWithType: Type.GetProperty(String)\n  fullName: Type.GetProperty(String)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the public property with the specified name.\n  remarks: \"The search for `name` is case-sensitive. The search includes public static and public instance properties.  \\n  \\n A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  \\n  \\n Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:  \\n  \\n-   A type contains two indexed properties that have the same name but different numbers of parameters. To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.  \\n  \\n-   A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic). To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags?displayProperty=fullName> flag to restrict the search to members that are not inherited.  \\n  \\n## Indexers and Default Properties  \\n [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.  \\n  \\n In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \\\"Item\\\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.  \\n  \\n To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.\"\n  example:\n  - \"The following example retrieves the `Type` object of a user-defined class, retrieves a property of that class, and displays the property name.  \\n  \\n [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]\\n [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]\\n [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  \\n  \\n Internally, this property is referred to in the metadata by the name \\\"Item.\\\" Any attempt to get `PropertyInfo` using reflection must specify this internal name in order to correctly return the `PropertyInfo` property.\"\n  syntax:\n    content: public System.Reflection.PropertyInfo GetProperty (string name);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the public property to get.\n    return:\n      type: System.Reflection.PropertyInfo\n      description: An object representing the public property with the specified name, if found; otherwise, `null`.\n  overload: System.Type.GetProperty*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one property is found with the specified name.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetProperty(System.String,System.Reflection.BindingFlags)\n  commentId: M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)\n  id: GetProperty(System.String,System.Reflection.BindingFlags)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetProperty(String, BindingFlags)\n  nameWithType: Type.GetProperty(String, BindingFlags)\n  fullName: Type.GetProperty(String, BindingFlags)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the specified property, using the specified binding constraints.\n  remarks: \"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public properties in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  \\n  \\n Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:  \\n  \\n-   A type contains two indexed properties that have the same name but different numbers of parameters. To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.  \\n  \\n-   A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic). To resolve the ambiguity, include <xref:System.Reflection.BindingFlags?displayProperty=fullName> to restrict the search to members that are not inherited.  \\n  \\n## Indexers and Default Properties  \\n [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.  \\n  \\n In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \\\"Item\\\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.  \\n  \\n To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.\"\n  example:\n  - \"The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.  \\n  \\n [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]\\n [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]\\n [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]\"\n  syntax:\n    content: public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the property to get.\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    return:\n      type: System.Reflection.PropertyInfo\n      description: An object representing the property that matches the specified requirements, if found; otherwise, `null`.\n  overload: System.Type.GetProperty*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one property is found with the specified name and matching the specified binding constraints.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetProperty(System.String,System.Type)\n  commentId: M:System.Type.GetProperty(System.String,System.Type)\n  id: GetProperty(System.String,System.Type)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetProperty(String, Type)\n  nameWithType: Type.GetProperty(String, Type)\n  fullName: Type.GetProperty(String, Type)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the public property with the specified name and return type.\n  remarks: \"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \\n  \\n The search for `name` is case-sensitive. The search includes public static and public instance properties.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  \\n  \\n## Indexers and Default Properties  \\n [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.  \\n  \\n In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \\\"Item\\\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.  \\n  \\n To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.\"\n  example:\n  - \"The following example defines a class with one property and retrieves the name and type of the property.  \\n  \\n [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]\\n [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]\\n [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]\"\n  syntax:\n    content: public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the public property to get.\n    - id: returnType\n      type: System.Type\n      description: The return type of the property.\n    return:\n      type: System.Reflection.PropertyInfo\n      description: An object representing the public property with the specified name, if found; otherwise, `null`.\n  overload: System.Type.GetProperty*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one property is found with the specified name.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>name</code> is `null`, or <code>returnType</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetProperty(System.String,System.Type[])\n  commentId: M:System.Type.GetProperty(System.String,System.Type[])\n  id: GetProperty(System.String,System.Type[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetProperty(String, Type[])\n  nameWithType: Type.GetProperty(String, Type[])\n  fullName: Type.GetProperty(String, Type[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the specified public property whose parameters match the specified argument types.\n  remarks: \"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \\n  \\n The search for `name` is case-sensitive. The search includes public static and public instance properties.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  \\n  \\n## Indexers and Default Properties  \\n [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.  \\n  \\n In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \\\"Item\\\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.  \\n  \\n To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.\"\n  example:\n  - \"The following example retrieves the `Type` object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to `GetProperty`.  \\n  \\n [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]\\n [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]\\n [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]\"\n  syntax:\n    content: public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the public property to get.\n    - id: types\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get.  \\n  \\n -or-  \\n  \\n An empty array of the type <xref href=\\\"System.Type\\\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed.\"\n    return:\n      type: System.Reflection.PropertyInfo\n      description: An object representing the public property whose parameters match the specified argument types, if found; otherwise, `null`.\n  overload: System.Type.GetProperty*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one property is found with the specified name and matching the specified argument types.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>name</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>types</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>types</code> is multidimensional.\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: An element of <code>types</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetProperty(System.String,System.Type,System.Type[])\n  commentId: M:System.Type.GetProperty(System.String,System.Type,System.Type[])\n  id: GetProperty(System.String,System.Type,System.Type[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetProperty(String, Type, Type[])\n  nameWithType: Type.GetProperty(String, Type, Type[])\n  fullName: Type.GetProperty(String, Type, Type[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the specified public property whose parameters match the specified argument types.\n  remarks: \"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \\n  \\n The search for `name` is case-sensitive. The search includes public static and public instance properties.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  \\n  \\n## Indexers and Default Properties  \\n [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.  \\n  \\n In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \\\"Item\\\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.  \\n  \\n To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.\"\n  syntax:\n    content: public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the public property to get.\n    - id: returnType\n      type: System.Type\n      description: The return type of the property.\n    - id: types\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get.  \\n  \\n -or-  \\n  \\n An empty array of the type <xref href=\\\"System.Type\\\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed.\"\n    return:\n      type: System.Reflection.PropertyInfo\n      description: An object representing the public property whose parameters match the specified argument types, if found; otherwise, `null`.\n  overload: System.Type.GetProperty*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one property is found with the specified name and matching the specified argument types.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>name</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>types</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>types</code> is multidimensional.\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: An element of <code>types</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  commentId: M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  id: GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetProperty(String, Type, Type[], ParameterModifier[])\n  nameWithType: Type.GetProperty(String, Type, Type[], ParameterModifier[])\n  fullName: Type.GetProperty(String, Type, Type[], ParameterModifier[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the specified public property whose parameters match the specified argument types and modifiers.\n  remarks: \"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \\n  \\n Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \\n  \\n The search for `name` is case-sensitive. The search includes public static and public instance properties.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  \\n  \\n## Indexers and Default Properties  \\n [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.  \\n  \\n In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \\\"Item\\\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.  \\n  \\n To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.\"\n  example:\n  - \"The following example obtains a `Type` object corresponding to `MyPropertyClass`, and the indexed property of this class is retrieved using the arguments passed to the `GetProperty` method.  \\n  \\n [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]\\n [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]\\n [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]\"\n  syntax:\n    content: public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the public property to get.\n    - id: returnType\n      type: System.Type\n      description: The return type of the property.\n    - id: types\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get.  \\n  \\n -or-  \\n  \\n An empty array of the type <xref href=\\\"System.Type\\\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed.\"\n    - id: modifiers\n      type: System.Reflection.ParameterModifier[]\n      description: An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.\n    return:\n      type: System.Reflection.PropertyInfo\n      description: An object representing the public property that matches the specified requirements, if found; otherwise, `null`.\n  overload: System.Type.GetProperty*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one property is found with the specified name and matching the specified argument types and modifiers.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>name</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>types</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>types</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>modifiers</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>types</code> and <code>modifiers</code> do not have the same length.\"\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: An element of <code>types</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  commentId: M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  id: GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetProperty(String, BindingFlags, Binder, Type, Type[], ParameterModifier[])\n  nameWithType: Type.GetProperty(String, BindingFlags, Binder, Type, Type[], ParameterModifier[])\n  fullName: Type.GetProperty(String, BindingFlags, Binder, Type, Type[], ParameterModifier[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.\n  remarks: \"A property is considered public to reflection if it has at least one accessor that is public. Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> &#124; <xref:System.Reflection.BindingFlags?displayProperty=fullName> (in Visual Basic, combine the values using `Or`) to get it.  \\n  \\n Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public properties in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.  \\n  \\n## Indexers and Default Properties  \\n [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)], [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type. For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3. You can overload the property.  \\n  \\n In C#, this feature is called an indexer and cannot be refered to by name. By default, a C# indexer appears in metadata as an indexed property named \\\"Item\\\". However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata. For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>. Indexed properties created using languages other than C# can have names other than Item, as well.  \\n  \\n To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute. If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.\"\n  syntax:\n    content: public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the property to get.\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    - id: binder\n      type: System.Reflection.Binder\n      description: \"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \\n  \\n -or-  \\n  \\n A null reference (`Nothing` in Visual Basic), to use the <xref href=\\\"System.Type.DefaultBinder\\\"></xref>.\"\n    - id: returnType\n      type: System.Type\n      description: The return type of the property.\n    - id: types\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get.  \\n  \\n -or-  \\n  \\n An empty array of the type <xref href=\\\"System.Type\\\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed.\"\n    - id: modifiers\n      type: System.Reflection.ParameterModifier[]\n      description: An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.\n    return:\n      type: System.Reflection.PropertyInfo\n      description: An object representing the property that matches the specified requirements, if found; otherwise, `null`.\n  overload: System.Type.GetProperty*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one property is found with the specified name and matching the specified binding constraints.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>name</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>types</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>types</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>modifiers</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>types</code> and <code>modifiers</code> do not have the same length.\"\n  - type: System.NullReferenceException\n    commentId: T:System.NullReferenceException\n    description: An element of <code>types</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  commentId: M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  id: GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetPropertyImpl(String, BindingFlags, Binder, Type, Type[], ParameterModifier[])\n  nameWithType: Type.GetPropertyImpl(String, BindingFlags, Binder, Type, Type[], ParameterModifier[])\n  fullName: Type.GetPropertyImpl(String, BindingFlags, Binder, Type, Type[], ParameterModifier[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.\n  remarks: \"Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:  \\n  \\n-   You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.  \\n  \\n-   Specify `BindingFlags.Public` to include public properties in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.\"\n  syntax:\n    content: protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);\n    parameters:\n    - id: name\n      type: System.String\n      description: The string containing the name of the property to get.\n    - id: bindingAttr\n      type: System.Reflection.BindingFlags\n      description: \"A bitmask comprised of one or more <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> that specify how the search is conducted.  \\n  \\n -or-  \\n  \\n Zero, to return `null`.\"\n    - id: binder\n      type: System.Reflection.Binder\n      description: \"An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.  \\n  \\n -or-  \\n  \\n A null reference (`Nothing` in Visual Basic), to use the <xref href=\\\"System.Type.DefaultBinder\\\"></xref>.\"\n    - id: returnType\n      type: System.Type\n      description: The return type of the property.\n    - id: types\n      type: System.Type[]\n      description: \"An array of <xref href=\\\"System.Type\\\"></xref> objects representing the number, order, and type of the parameters for the indexed property to get.  \\n  \\n -or-  \\n  \\n An empty array of the type <xref href=\\\"System.Type\\\"></xref> (that is, Type[] types = new Type[0]) to get a property that is not indexed.\"\n    - id: modifiers\n      type: System.Reflection.ParameterModifier[]\n      description: An array of <xref href=\"System.Reflection.ParameterModifier\"></xref> objects representing the attributes associated with the corresponding element in the <code>types</code> array. The default binder does not process this parameter.\n    return:\n      type: System.Reflection.PropertyInfo\n      description: An object representing the property that matches the specified requirements, if found; otherwise, `null`.\n  overload: System.Type.GetPropertyImpl*\n  exceptions:\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one property is found with the specified name and matching the specified binding constraints.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>name</code> is `null`.  \\n  \\n -or-  \\n  \\n <code>types</code> is `null`.  \\n  \\n -or-  \\n  \\n One of the elements in <code>types</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>types</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>modifiers</code> is multidimensional.  \\n  \\n -or-  \\n  \\n <code>types</code> and <code>modifiers</code> do not have the same length.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The current type is a <xref href=\"System.Reflection.Emit.TypeBuilder\"></xref>, <xref href=\"System.Reflection.Emit.EnumBuilder\"></xref>, or <xref href=\"System.Reflection.Emit.GenericTypeParameterBuilder\"></xref>.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)\n  commentId: M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)\n  id: GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>, Boolean, Boolean)\n  nameWithType: Type.GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>, Boolean, Boolean)\n  fullName: Type.GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>, Boolean, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.\n  remarks: \"Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations. By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:  \\n  \\n-   Control which version of an assembly a type is loaded from.  \\n  \\n-   Provide another place to look for a type name that does not include an assembly name.  \\n  \\n-   Load assemblies using partial assembly names.  \\n  \\n-   Return subclasses of <xref:System.Type?displayProperty=fullName> that are not created by the common language runtime (CLR).  \\n  \\n For example, in version-tolerant serialization this method enables you to search for a \\\"best fit\\\" assembly by using a partial name. Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.  \\n  \\n Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=fullName> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.  \\n  \\n<a name=\\\"usage_notes\\\"></a>   \\n## Usage Notes  \\n This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names. Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.  \\n  \\n> [!NOTE]\\n>  If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.  \\n  \\n If `typeName` is not an assembly-qualified name, assembly resolution is skipped. Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter. The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.  \\n  \\n General usage notes:  \\n  \\n-   Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers. Use only methods that you provide or that you are familiar with.  \\n  \\n    > [!CAUTION]\\n    >  Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.  \\n  \\n-   If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution.  \\n  \\n-   If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`.  \\n  \\n-   This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`. You are responsible for any exceptions that are thrown by the resolver methods.  \\n  \\n<a name=\\\"resolving_assemblies\\\"></a>   \\n### Resolving Assemblies  \\n The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`. If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.  \\n  \\n If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly. If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.  \\n  \\n The `assemblyResolver` method should return `null` if the assembly cannot be resolved. If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.  \\n  \\n If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`. For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`. If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied. The `assemblyResolver` method can use or ignore all parts of the assembly name.  \\n  \\n The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.  \\n  \\n<a name=\\\"resolving_types\\\"></a>   \\n### Resolving Types  \\n If `typeName` does not specify an assembly name, `typeResolver` is always called. If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved. If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.  \\n  \\n The `typeResolver` method receives three arguments:  \\n  \\n-   The assembly to search or `null` if `typeName` does not contain an assembly name.  \\n  \\n-   The simple name of the type. In the case of a nested type, this is the outermost containing type. In the case of a generic type, this is the simple name of the generic type.  \\n  \\n-   A Boolean value that is `true` if the case of type names is to be ignored.  \\n  \\n The implementation determines the way these arguments are used. The `typeResolver` method should return `null` if it cannot resolve the type. If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.  \\n  \\n The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.  \\n  \\n#### Resolving Nested Types  \\n If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`. When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.  \\n  \\n#### Resolving Generic Types  \\n The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments. If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.  \\n  \\n The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion. For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`. Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic). You might pass the following generic type name:  \\n  \\n```  \\n\\\"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]\\\"  \\n```  \\n  \\n Notice that `MyType` is the only assembly-qualified type argument. The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified. Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>. It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:  \\n  \\n [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  \\n  \\n The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.  \\n  \\n Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:  \\n  \\n```  \\n\\\"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]\\\"  \\n```  \\n  \\n Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name. Because your `assemblyResolve` will be called recursively, it must be able to handle this case. Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.  \\n  \\n [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  \\n  \\n Back to [Usage Notes](#usage_notes).  \\n  \\n#### Resolving Type Names with Special Characters  \\n Certain characters have special meanings in assembly-qualified names. If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name. To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method. For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\\\\]Type`.  \\n  \\n> [!NOTE]\\n>  Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.  \\n  \\n The following table shows the special characters for type names.  \\n  \\n|Character|Meaning|  \\n|---------------|-------------|  \\n|, (comma)|Delimiter for assembly-qualified names.|  \\n|[] (square brackets)|As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.|  \\n|& (ampersand)|As a suffix, indicates that a type is a reference type.|  \\n|* (asterisk)|As a suffix, indicates that a type is a pointer type.|  \\n|+ (plus)|Delimiter for nested types.|  \\n|\\\\ (backslash)|Escape character.|  \\n  \\n Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings. You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method. In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods. If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.  \\n  \\n Back to [Usage Notes](#usage_notes).  \\n  \\n<a name=\\\"mixed_name_resolution\\\"></a>   \\n## Mixed Name Resolution  \\n The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:  \\n  \\n|Contents of type name|Assembly resolver method|Type resolver method|Result|  \\n|---------------------------|------------------------------|--------------------------|------------|  \\n|type, assembly|null|null|Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> method overload.|  \\n|type, assembly|provided|null|`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly. If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.|  \\n|type, assembly|null|provided|Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=fullName> method overload to get the assembly. If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.|  \\n|type, assembly|provided|provided|`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly. If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.|  \\n|type|null, provided|null|Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=fullName> method overload. Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched. If `assemblyResolver` is provided, it is ignored.|  \\n|type|null, provided|provided|`typeResolver` is called, and `null` is passed for the assembly. `typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose. If `assemblyResolver` is provided, it is ignored.|  \\n|assembly|null, provided|null, provided|A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name. This results in an invalid assembly name.|  \\n  \\n Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types).\"\n  syntax:\n    content: public static Type GetType (string typeName, Func<System.Reflection.AssemblyName,System.Reflection.Assembly> assemblyResolver, Func<System.Reflection.Assembly,string,bool,Type> typeResolver, bool throwOnError, bool ignoreCase);\n    parameters:\n    - id: typeName\n      type: System.String\n      description: The name of the type to get. If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving. If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <xref href=\"System.Type.AssemblyQualifiedName\"></xref>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.\n    - id: assemblyResolver\n      type: System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly}\n      description: \"A method that locates and returns the assembly that is specified in <code>typeName</code>. The assembly name is passed to <code>assemblyResolver</code> as an <xref href=\\\"System.Reflection.AssemblyName\\\"></xref> object. If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called. If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed.  \\n  \\n Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.\"\n    - id: typeResolver\n      type: System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type}\n      description: \"A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution. If no assembly is provided, the method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <code>ignoreCase</code> is passed to that parameter.  \\n  \\n Caution   Do not pass methods from unknown or untrusted callers.\"\n    - id: throwOnError\n      type: System.Boolean\n      description: '`true` to throw an exception if the type cannot be found; `false` to return `null`. Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.'\n    - id: ignoreCase\n      type: System.Boolean\n      description: '`true` to perform a case-insensitive search for <code>typeName</code>, `false` to perform a case-sensitive search for <code>typeName</code>.'\n    return:\n      type: System.Type\n      description: The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.\n  overload: System.Type.GetType*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>typeName</code> is `null`.\n  - type: System.Reflection.TargetInvocationException\n    commentId: T:System.Reflection.TargetInvocationException\n    description: A class initializer is invoked and throws an exception.\n  - type: System.TypeLoadException\n    commentId: T:System.TypeLoadException\n    description: \"<code>throwOnError</code> is `true` and the type is not found.  \\n  \\n -or-  \\n  \\n <code>throwOnError</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab.  \\n  \\n -or-  \\n  \\n <code>throwOnError</code> is `true` and <code>typeName</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>throwOnError</code> is `true` and <code>typeName</code> represents an array type with an invalid size.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents an array of <xref href=\\\"System.TypedReference\\\"></xref>.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"An error occurs when <code>typeName</code> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).  \\n  \\n -or-  \\n  \\n <code>throwOnError</code> is `true` and <code>typeName</code> contains invalid syntax (for example, \\\"MyType[,*,]\\\").  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\\\"System.Void\\\"></xref> as one of its type arguments.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.\"\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: <code>throwOnError</code> is `true` and the assembly or one of its dependencies was not found.\n  - type: System.IO.FileLoadException\n    commentId: T:System.IO.FileLoadException\n    description: \"The assembly or one of its dependencies was found, but could not be loaded.  \\n  \\n -or-  \\n  \\n <code>typeName</code> contains an invalid assembly name.  \\n  \\n -or-  \\n  \\n <code>typeName</code> is a valid assembly name without a type name.\"\n  - type: System.BadImageFormatException\n    commentId: T:System.BadImageFormatException\n    description: \"The assembly or one of its dependencies is not valid.  \\n  \\n -or-  \\n  \\n The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.\"\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)\n  commentId: M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)\n  id: GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>, Boolean)\n  nameWithType: Type.GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>, Boolean)\n  fullName: Type.GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.\n  remarks: \"Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.  \\n  \\n Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter.\"\n  syntax:\n    content: public static Type GetType (string typeName, Func<System.Reflection.AssemblyName,System.Reflection.Assembly> assemblyResolver, Func<System.Reflection.Assembly,string,bool,Type> typeResolver, bool throwOnError);\n    parameters:\n    - id: typeName\n      type: System.String\n      description: The name of the type to get. If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving. If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <xref href=\"System.Type.AssemblyQualifiedName\"></xref>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.\n    - id: assemblyResolver\n      type: System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly}\n      description: \"A method that locates and returns the assembly that is specified in <code>typeName</code>. The assembly name is passed to <code>assemblyResolver</code> as an <xref href=\\\"System.Reflection.AssemblyName\\\"></xref> object. If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called. If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed.  \\n  \\n Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.\"\n    - id: typeResolver\n      type: System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type}\n      description: \"A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution. If no assembly is provided, the method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; `false` is passed to that parameter.  \\n  \\n Caution   Do not pass methods from unknown or untrusted callers.\"\n    - id: throwOnError\n      type: System.Boolean\n      description: '`true` to throw an exception if the type cannot be found; `false` to return `null`. Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.'\n    return:\n      type: System.Type\n      description: The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.\n  overload: System.Type.GetType*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>typeName</code> is `null`.\n  - type: System.Reflection.TargetInvocationException\n    commentId: T:System.Reflection.TargetInvocationException\n    description: A class initializer is invoked and throws an exception.\n  - type: System.TypeLoadException\n    commentId: T:System.TypeLoadException\n    description: \"<code>throwOnError</code> is `true` and the type is not found.  \\n  \\n -or-  \\n  \\n <code>throwOnError</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab.  \\n  \\n -or-  \\n  \\n <code>throwOnError</code> is `true` and <code>typeName</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>throwOnError</code> is `true` and <code>typeName</code> represents an array type with an invalid size.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents an array of <xref href=\\\"System.TypedReference\\\"></xref>.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"An error occurs when <code>typeName</code> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).  \\n  \\n -or-  \\n  \\n <code>throwOnError</code> is `true` and <code>typeName</code> contains invalid syntax (for example, \\\"MyType[,*,]\\\").  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\\\"System.Void\\\"></xref> as one of its type arguments.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.\"\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: \"<code>throwOnError</code> is `true` and the assembly or one of its dependencies was not found.  \\n  \\n -or-  \\n  \\n <code>typeName</code> contains an invalid assembly name.  \\n  \\n -or-  \\n  \\n <code>typeName</code> is a valid assembly name without a type name.\"\n  - type: System.IO.FileLoadException\n    commentId: T:System.IO.FileLoadException\n    description: The assembly or one of its dependencies was found, but could not be loaded.\n  - type: System.BadImageFormatException\n    commentId: T:System.BadImageFormatException\n    description: \"The assembly or one of its dependencies is not valid.  \\n  \\n -or-  \\n  \\n The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.\"\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})\n  commentId: M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})\n  id: GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>)\n  nameWithType: Type.GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>)\n  fullName: Type.GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.\n  remarks: \"Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.  \\n  \\n> [!NOTE]\\n>  If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`. It does not throw an exception. To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.  \\n  \\n Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters.\"\n  syntax:\n    content: public static Type GetType (string typeName, Func<System.Reflection.AssemblyName,System.Reflection.Assembly> assemblyResolver, Func<System.Reflection.Assembly,string,bool,Type> typeResolver);\n    parameters:\n    - id: typeName\n      type: System.String\n      description: The name of the type to get. If the <code>typeResolver</code> parameter is provided, the type name can be any string that <code>typeResolver</code> is capable of resolving. If the <code>assemblyResolver</code> parameter is provided or if standard type resolution is used, <code>typeName</code> must be an assembly-qualified name (see <xref href=\"System.Type.AssemblyQualifiedName\"></xref>), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.\n    - id: assemblyResolver\n      type: System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly}\n      description: \"A method that locates and returns the assembly that is specified in <code>typeName</code>. The assembly name is passed to <code>assemblyResolver</code> as an <xref href=\\\"System.Reflection.AssemblyName\\\"></xref> object. If <code>typeName</code> does not contain the name of an assembly, <code>assemblyResolver</code> is not called. If <code>assemblyResolver</code> is not supplied, standard assembly resolution is performed.  \\n  \\n Caution   Do not pass methods from unknown or untrusted callers. Doing so could result in elevation of privilege for malicious code. Use only methods that you provide or that you are familiar with.\"\n    - id: typeResolver\n      type: System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type}\n      description: \"A method that locates and returns the type that is specified by <code>typeName</code> from the assembly that is returned by <code>assemblyResolver</code> or by standard assembly resolution. If no assembly is provided, the <code>typeResolver</code> method can provide one. The method also takes a parameter that specifies whether to perform a case-insensitive search; `false` is passed to that parameter.  \\n  \\n Caution   Do not pass methods from unknown or untrusted callers.\"\n    return:\n      type: System.Type\n      description: The type with the specified name, or `null` if the type is not found.\n  overload: System.Type.GetType*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>typeName</code> is `null`.\n  - type: System.Reflection.TargetInvocationException\n    commentId: T:System.Reflection.TargetInvocationException\n    description: A class initializer is invoked and throws an exception.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"An error occurs when <code>typeName</code> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\\\"System.Void\\\"></xref> as one of its type arguments.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.\"\n  - type: System.TypeLoadException\n    commentId: T:System.TypeLoadException\n    description: <code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref>.\n  - type: System.IO.FileLoadException\n    commentId: T:System.IO.FileLoadException\n    description: \"The assembly or one of its dependencies was found, but could not be loaded.  \\n  \\n -or-  \\n  \\n <code>typeName</code> contains an invalid assembly name.  \\n  \\n -or-  \\n  \\n <code>typeName</code> is a valid assembly name without a type name.\"\n  - type: System.BadImageFormatException\n    commentId: T:System.BadImageFormatException\n    description: \"The assembly or one of its dependencies is not valid.  \\n  \\n -or-  \\n  \\n The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.\"\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetType\n  commentId: M:System.Type.GetType\n  id: GetType\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetType()\n  nameWithType: Type.GetType()\n  fullName: Type.GetType()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the current <xref href=\"System.Type\"></xref>.\n  syntax:\n    content: public Type GetType ();\n    parameters: []\n    return:\n      type: System.Type\n      description: The current <xref href=\"System.Type\"></xref>.\n  overload: System.Type.GetType*\n  exceptions:\n  - type: System.Reflection.TargetInvocationException\n    commentId: T:System.Reflection.TargetInvocationException\n    description: A class initializer is invoked and throws an exception.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetType(System.String,System.Boolean)\n  commentId: M:System.Type.GetType(System.String,System.Boolean)\n  id: GetType(System.String,System.Boolean)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetType(String, Boolean)\n  nameWithType: Type.GetType(String, Boolean)\n  fullName: Type.GetType(String, Boolean)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets the <xref href=\"System.Type\"></xref> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.\n  remarks: \"You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace-qualified name. <xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`. You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.  \\n  \\n `GetType` only works on assemblies loaded from disk. If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> enumeration. If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when `GetType` is called, the method returns `null`. `GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.  \\n  \\n To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> event and call `GetType` before saving. Otherwise, you will get two copies of the assembly in memory.  \\n  \\n The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of `throwOnError`. For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.  \\n  \\n `typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <xref:System.Type.AssemblyQualifiedName%2A>.  \\n  \\n If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.  \\n  \\n The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  \\n  \\n> [!NOTE]\\n>  In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \\\"ProcessorArchitecture=msil\\\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method. You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly. See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.  \\n  \\n|Delimiter|Meaning|  \\n|---------------|-------------|  \\n|Backslash (\\\\\\\\)|Escape character.|  \\n|Backtick (`)|Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.|  \\n|Brackets ([])|Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.|  \\n|Comma (,)|Precedes the Assembly name.|  \\n|Period (.)|Denotes namespace identifiers.|  \\n|Plus sign (+)|Precedes a nested class.|  \\n  \\n For example, the fully qualified name for a class might look like this:  \\n  \\n```  \\nTopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  \\n```  \\n  \\n If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\\\\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:  \\n  \\n```  \\nTopNamespace.Sub\\\\+Namespace.ContainingClass+NestedClass,MyAssembly  \\n```  \\n  \\n A \\\"++\\\" becomes \\\"\\\\\\\\+\\\\\\\\+\\\", and a \\\"\\\\\\\\\\\" becomes \\\"\\\\\\\\\\\\\\\\\\\".  \\n  \\n This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.  \\n  \\n Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.  \\n  \\n Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.  \\n  \\n The name of a generic type ends with a backtick (\\\\`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\\\\<T0, T1>` in Visual C#.  \\n  \\n For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters. A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:  \\n  \\n```  \\nSystem.Collections.Generic.Dictionary`2[System.String,MyType]  \\n```  \\n  \\n To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:  \\n  \\n```  \\nType.GetType(\\\"System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]\\\")  \\n```  \\n  \\n> [!NOTE]\\n>  An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.  \\n  \\n Nullable types are a special case of generic types. For example, a nullable <xref:System.Int32> is represented by the string \\\"System.Nullable`1[System.Int32]\\\".  \\n  \\n> [!NOTE]\\n>  In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.  \\n  \\n The following table shows the syntax you use with `GetType` for various types.  \\n  \\n|To Get|Use|  \\n|------------|---------|  \\n|A nullable <xref:System.Int32>|`Type.GetType(\\\"System.Nullable`1[System.Int32]\\\")`|  \\n|An unmanaged pointer to `MyType`|`Type.GetType(\\\"MyType*\\\")`|  \\n|An unmanaged pointer to a pointer to `MyType`|`Type.GetType(\\\"MyType**\\\")`|  \\n|A managed pointer or reference to `MyType`|`Type.GetType(\\\"MyType&\\\")`. Note that unlike pointers, references are limited to one level.|  \\n|A parent class and a nested class|`Type.GetType(\\\"MyParentClass+MyNestedClass\\\")`|  \\n|A one-dimensional array with a lower bound of 0|`Type.GetType(\\\"MyArray[]\\\")`|  \\n|A one-dimensional array with an unknown lower bound|`Type.GetType(\\\"MyArray[*]\\\")`|  \\n|An n-dimensional array|A comma (,) inside the brackets a total of n-1 times. For example, `System.Object[,,]` represents a three-dimensional `Object` array.|  \\n|A two-dimensional array's array|`Type.GetType(\\\"MyArray[][]\\\")`|  \\n|A rectangular two-dimensional array with unknown lower bounds|`Type.GetType(\\\"MyArray[,]\\\")`|  \\n|A generic type with one type argument|`Type.GetType(\\\"MyGenericType`1[MyType]\\\")`|  \\n|A generic type with two type arguments|`Type.GetType(\\\"MyGenericType`2[MyType,AnotherType]\\\")`|  \\n|A generic type with two assembly-qualified type arguments|`Type.GetType(\\\"MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]\\\")`|  \\n|An assembly-qualified generic type with an assembly-qualified type argument|`Type.GetType(\\\"MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly\\\")`|  \\n|A generic type whose type argument is a generic type with two type arguments|`Type.GetType(\\\"MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]\\\")`|\"\n  example:\n  - \"The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`. If a type object refers to an assembly that does not exist, this example throws an exception.  \\n  \\n [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]\\n [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]\\n [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]\"\n  syntax:\n    content: public static Type GetType (string typeName, bool throwOnError);\n    parameters:\n    - id: typeName\n      type: System.String\n      description: The assembly-qualified name of the type to get. See <xref href=\"System.Type.AssemblyQualifiedName\"></xref>. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.\n    - id: throwOnError\n      type: System.Boolean\n      description: '`true` to throw an exception if the type cannot be found; `false` to return `null`. Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.'\n    return:\n      type: System.Type\n      description: The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.\n  overload: System.Type.GetType*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>typeName</code> is `null`.\n  - type: System.Reflection.TargetInvocationException\n    commentId: T:System.Reflection.TargetInvocationException\n    description: A class initializer is invoked and throws an exception.\n  - type: System.TypeLoadException\n    commentId: T:System.TypeLoadException\n    description: \"<code>throwOnError</code> is `true` and the type is not found.  \\n  \\n -or-  \\n  \\n <code>throwOnError</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab.  \\n  \\n -or-  \\n  \\n <code>throwOnError</code> is `true` and <code>typeName</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>throwOnError</code> is `true` and <code>typeName</code> represents an array type with an invalid size.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents an array of <xref href=\\\"System.TypedReference\\\"></xref>.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>throwOnError</code> is `true` and <code>typeName</code> contains invalid syntax. For example, \\\"MyType[,*,]\\\".  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\\\"System.Void\\\"></xref> as one of its type arguments.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.\"\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: <code>throwOnError</code> is `true` and the assembly or one of its dependencies was not found.\n  - type: System.IO.FileLoadException\n    commentId: T:System.IO.FileLoadException\n    description: \"<block subset=\\\"none\\\" type=\\\"note\\\">\\n      <p>  \\n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\\\"System.IO.IOException\\\"></xref>, instead.  \\n  \\n</p>\\n    </block>  \\n  \\n The assembly or one of its dependencies was found, but could not be loaded.\"\n  - type: System.BadImageFormatException\n    commentId: T:System.BadImageFormatException\n    description: \"The assembly or one of its dependencies is not valid.  \\n  \\n -or-  \\n  \\n Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetType(System.String)\n  commentId: M:System.Type.GetType(System.String)\n  id: GetType(System.String)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetType(String)\n  nameWithType: Type.GetType(String)\n  fullName: Type.GetType(String)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets the <xref href=\"System.Type\"></xref> with the specified name, performing a case-sensitive search.\n  remarks: \"You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its namespace-qualified name. <xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`. You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <xref:System.Type.GetType%2A> in Visual Basic, or  in C++.  \\n  \\n> [!NOTE]\\n>  If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`. It does not throw an exception. To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.  \\n  \\n <xref:System.Type.GetType%2A>GetType only works on assemblies loaded from disk. If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> enumeration. If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when `GetType` is called, the method returns `null`. `GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.  \\n  \\n To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> event and call `GetType` before saving. Otherwise, you will get two copies of the assembly in memory.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.  \\n  \\n `typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <xref:System.Type.AssemblyQualifiedName%2A>.  \\n  \\n If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.  \\n  \\n The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  \\n  \\n> [!NOTE]\\n>  In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \\\"ProcessorArchitecture=msil\\\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method. You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly. See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.  \\n  \\n|Delimiter|Meaning|  \\n|---------------|-------------|  \\n|Backslash (\\\\\\\\)|Escape character.|  \\n|Backtick (`)|Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.|  \\n|Brackets ([])|Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.|  \\n|Comma (,)|Precedes the Assembly name.|  \\n|Period (.)|Denotes namespace identifiers.|  \\n|Plus sign (+)|Precedes a nested class.|  \\n  \\n For example, the fully qualified name for a class might look like this:  \\n  \\n```  \\nTopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  \\n```  \\n  \\n If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\\\\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:  \\n  \\n```  \\nTopNamespace.Sub\\\\+Namespace.ContainingClass+NestedClass,MyAssembly  \\n```  \\n  \\n A \\\"++\\\" becomes \\\"\\\\\\\\+\\\\\\\\+\\\", and a \\\"\\\\\\\\\\\" becomes \\\"\\\\\\\\\\\\\\\\\\\".  \\n  \\n This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.  \\n  \\n Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.  \\n  \\n Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.  \\n  \\n The name of a generic type ends with a backtick (\\\\`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\\\\<T0, T1>` in Visual C#.  \\n  \\n For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters. A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:  \\n  \\n```  \\nSystem.Collections.Generic.Dictionary`2[System.String,MyType]  \\n```  \\n  \\n To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:  \\n  \\n```  \\nType.GetType(\\\"System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]\\\")  \\n```  \\n  \\n> [!NOTE]\\n>  An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.  \\n  \\n Nullable types are a special case of generic types. For example, a nullable <xref:System.Int32> is represented by the string \\\"System.Nullable`1[System.Int32]\\\".  \\n  \\n> [!NOTE]\\n>  In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.  \\n  \\n The following table shows the syntax you use with `GetType` for various types.  \\n  \\n|To Get|Use|  \\n|------------|---------|  \\n|A nullable <xref:System.Int32>|`Type.GetType(\\\"System.Nullable`1[System.Int32]\\\")`|  \\n|An unmanaged pointer to `MyType`|`Type.GetType(\\\"MyType*\\\")`|  \\n|An unmanaged pointer to a pointer to `MyType`|`Type.GetType(\\\"MyType**\\\")`|  \\n|A managed pointer or reference to `MyType`|`Type.GetType(\\\"MyType&\\\")`. Note that unlike pointers, references are limited to one level.|  \\n|A parent class and a nested class|`Type.GetType(\\\"MyParentClass+MyNestedClass\\\")`|  \\n|A one-dimensional array with a lower bound of 0|`Type.GetType(\\\"MyType[]\\\")`|  \\n|A one-dimensional array with an unknown lower bound|`Type.GetType(\\\"MyType[*]\\\")`|  \\n|An n-dimensional array|A comma (,) inside the brackets a total of n-1 times. For example, `System.Object[,,]` represents a three-dimensional `Object` array.|  \\n|An array of one-dimensional arrays|`Type.GetType(\\\"MyType[][]\\\")`|  \\n|A rectangular two-dimensional array with unknown lower bounds|`Type.GetType(\\\"MyType[,]\\\")`|  \\n|A generic type with one type argument|`Type.GetType(\\\"MyGenericType`1[MyType]\\\")`|  \\n|A generic type with two type arguments|`Type.GetType(\\\"MyGenericType`2[MyType,AnotherType]\\\")`|  \\n|A generic type with two assembly-qualified type arguments|`Type.GetType(\\\"MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]\\\")`|  \\n|An assembly-qualified generic type with an assembly-qualified type argument|`Type.GetType(\\\"MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly\\\")`|  \\n|A generic type whose type argument is a generic type with two type arguments|`Type.GetType(\\\"MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]\\\")`|\"\n  example:\n  - \"The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.  \\n  \\n [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]\\n [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]\\n [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]\"\n  syntax:\n    content: public static Type GetType (string typeName);\n    parameters:\n    - id: typeName\n      type: System.String\n      description: The assembly-qualified name of the type to get. See <xref href=\"System.Type.AssemblyQualifiedName\"></xref>. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.\n    return:\n      type: System.Type\n      description: The type with the specified name, if found; otherwise, `null`.\n  overload: System.Type.GetType*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>typeName</code> is `null`.\n  - type: System.Reflection.TargetInvocationException\n    commentId: T:System.Reflection.TargetInvocationException\n    description: A class initializer is invoked and throws an exception.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\\\"System.Void\\\"></xref> as one of its type arguments.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.\"\n  - type: System.TypeLoadException\n    commentId: T:System.TypeLoadException\n    description: <code>typeName</code> represents an array of <xref href=\"System.TypedReference\"></xref>.\n  - type: System.IO.FileLoadException\n    commentId: T:System.IO.FileLoadException\n    description: \"<block subset=\\\"none\\\" type=\\\"note\\\">\\n      <p>  \\n In the [.NET for Windows Store apps](http://go.microsoft.com/fwlink/?LinkID=247912) or the [Portable Class Library](~/docs/standard/cross-platform/cross-platform-development-with-the-portable-class-library.md), catch the base class exception, <xref href=\\\"System.IO.IOException\\\"></xref>, instead.  \\n  \\n</p>\\n    </block>  \\n  \\n The assembly or one of its dependencies was found, but could not be loaded.\"\n  - type: System.BadImageFormatException\n    commentId: T:System.BadImageFormatException\n    description: \"The assembly or one of its dependencies is not valid.  \\n  \\n -or-  \\n  \\n Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetType(System.String,System.Boolean,System.Boolean)\n  commentId: M:System.Type.GetType(System.String,System.Boolean,System.Boolean)\n  id: GetType(System.String,System.Boolean,System.Boolean)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetType(String, Boolean, Boolean)\n  nameWithType: Type.GetType(String, Boolean, Boolean)\n  fullName: Type.GetType(String, Boolean, Boolean)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets the <xref href=\"System.Type\"></xref> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.\n  remarks: \"You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if the you know its namespace-qualified name. <xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`. You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A>method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects. If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.  \\n  \\n `GetType` only works on assemblies loaded from disk. If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior. The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=fullName> enumeration. If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly. If the assembly has not been saved to disk when `GetType` is called, the method returns `null`. `GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.  \\n  \\n To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=fullName> event and call `GetType` before saving. Otherwise, you will get two copies of the assembly in memory.  \\n  \\n The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of `throwOnError`. For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.  \\n  \\n The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.  \\n  \\n|Member Type|Static|Non-Static|  \\n|-----------------|------------|-----------------|  \\n|Constructor|No|No|  \\n|Field|No|Yes. A field is always hide-by-name-and-signature.|  \\n|Event|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n|Method|No|Yes. A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.|  \\n|Nested Type|No|No|  \\n|Property|Not applicable|The common type system rule is that the inheritance is the same as that of the methods that implement the property. Reflection treats properties as hide-by-name-and-signature. See note 2 below.|  \\n  \\n1.  Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions. This is a binary comparison.  \\n  \\n2.  For reflection, properties and events are hide-by-name-and-signature. If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.  \\n  \\n3.  Custom attributes are not part of the common type system.  \\n  \\n Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.  \\n  \\n `typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification. See <xref:System.Type.AssemblyQualifiedName%2A>.  \\n  \\n If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order. If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly. If the assembly has a strong name, a complete assembly name is required.  \\n  \\n The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments. All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.  \\n  \\n> [!NOTE]\\n>  In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings. For example, \\\"ProcessorArchitecture=msil\\\". However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons. You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method. You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method to load types from the assembly. See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=fullName>.  \\n  \\n|Delimiter|Meaning|  \\n|---------------|-------------|  \\n|Backslash (\\\\\\\\)|Escape character.|  \\n|Backtick (`)|Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.|  \\n|Brackets ([])|Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.|  \\n|Comma (,)|Precedes the Assembly name.|  \\n|Period (.)|Denotes namespace identifiers.|  \\n|Plus sign (+)|Precedes a nested class.|  \\n  \\n For example, the fully qualified name for a class might look like this:  \\n  \\n```  \\nTopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  \\n```  \\n  \\n If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\\\\\\\) to prevent it from being interpreted as a nesting separator. Reflection emits this string as follows:  \\n  \\n```  \\nTopNamespace.Sub\\\\+Namespace.ContainingClass+NestedClass,MyAssembly  \\n```  \\n  \\n A \\\"++\\\" becomes \\\"\\\\\\\\+\\\\\\\\+\\\", and a \\\"\\\\\\\\\\\" becomes \\\"\\\\\\\\\\\\\\\\\\\".  \\n  \\n This qualified name can be persisted and later used to load the <xref:System.Type>. To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name. <xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly. <xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.  \\n  \\n Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type. To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.  \\n  \\n Spaces are relevant in all type name components except the assembly name. In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.  \\n  \\n The name of a generic type ends with a backtick (\\\\`) followed by digits representing the number of generic type arguments. The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope. For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\\\\<T0, T1>` in Visual C#.  \\n  \\n For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas. For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters. A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:  \\n  \\n```  \\nSystem.Collections.Generic.Dictionary`2[System.String,MyType]  \\n```  \\n  \\n To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets. Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments. For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:  \\n  \\n```  \\nType.GetType(\\\"System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]\\\")  \\n```  \\n  \\n> [!NOTE]\\n>  An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list. The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.  \\n  \\n Nullable types are a special case of generic types. For example, a nullable <xref:System.Int32> is represented by the string \\\"System.Nullable`1[System.Int32]\\\".  \\n  \\n> [!NOTE]\\n>  In C#, C++, and Visual Basic you can also get nullable types using type operators. For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.  \\n  \\n The following table shows the syntax you use with `GetType` for various types.  \\n  \\n|To Get|Use|  \\n|------------|---------|  \\n|A nullable <xref:System.Int32>|`Type.GetType(\\\"System.Nullable`1[System.Int32]\\\")`|  \\n|An unmanaged pointer to `MyType`|`Type.GetType(\\\"MyType*\\\")`|  \\n|An unmanaged pointer to a pointer to `MyType`|`Type.GetType(\\\"MyType**\\\")`|  \\n|A managed pointer or reference to `MyType`|`Type.GetType(\\\"MyType&\\\")`. Note that unlike pointers, references are limited to one level.|  \\n|A parent class and a nested class|`Type.GetType(\\\"MyParentClass+MyNestedClass\\\")`|  \\n|A one-dimensional array with a lower bound of 0|`Type.GetType(\\\"MyArray[]\\\")`|  \\n|A one-dimensional array with an unknown lower bound|`Type.GetType(\\\"MyArray[*]\\\")`|  \\n|An n-dimensional array|A comma (,) inside the brackets a total of n-1 times. For example, `System.Object[,,]` represents a three-dimensional `Object` array.|  \\n|A two-dimensional array's array|`Type.GetType(\\\"MyArray[][]\\\")`|  \\n|A rectangular two-dimensional array with unknown lower bounds|`Type.GetType(\\\"MyArray[,]\\\")`|  \\n|A generic type with one type argument|`Type.GetType(\\\"MyGenericType`1[MyType]\\\")`|  \\n|A generic type with two type arguments|`Type.GetType(\\\"MyGenericType`2[MyType,AnotherType]\\\")`|  \\n|A generic type with two assembly-qualified type arguments|`Type.GetType(\\\"MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]\\\")`|  \\n|An assembly-qualified generic type with an assembly-qualified type argument|`Type.GetType(\\\"MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly\\\")`|  \\n|A generic type whose type argument is a generic type with two type arguments|`Type.GetType(\\\"MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]\\\")`|\"\n  syntax:\n    content: public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);\n    parameters:\n    - id: typeName\n      type: System.String\n      description: The assembly-qualified name of the type to get. See <xref href=\"System.Type.AssemblyQualifiedName\"></xref>. If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.\n    - id: throwOnError\n      type: System.Boolean\n      description: '`true` to throw an exception if the type cannot be found; `false` to return `null`.Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.'\n    - id: ignoreCase\n      type: System.Boolean\n      description: '`true` to perform a case-insensitive search for <code>typeName</code>, `false` to perform a case-sensitive search for <code>typeName</code>.'\n    return:\n      type: System.Type\n      description: The type with the specified name. If the type is not found, the <code>throwOnError</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwOnError</code>. See the Exceptions section.\n  overload: System.Type.GetType*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>typeName</code> is `null`.\n  - type: System.Reflection.TargetInvocationException\n    commentId: T:System.Reflection.TargetInvocationException\n    description: A class initializer is invoked and throws an exception.\n  - type: System.TypeLoadException\n    commentId: T:System.TypeLoadException\n    description: \"<code>throwOnError</code> is `true` and the type is not found.  \\n  \\n -or-  \\n  \\n <code>throwOnError</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab.  \\n  \\n -or-  \\n  \\n <code>throwOnError</code> is `true` and <code>typeName</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>throwOnError</code> is `true` and <code>typeName</code> represents an array type with an invalid size.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents an array of <xref href=\\\"System.TypedReference\\\"></xref>.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>throwOnError</code> is `true` and <code>typeName</code> contains invalid syntax. For example, \\\"MyType[,*,]\\\".  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\\\"System.Void\\\"></xref> as one of its type arguments.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.\"\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: <code>throwOnError</code> is `true` and the assembly or one of its dependencies was not found.\n  - type: System.IO.FileLoadException\n    commentId: T:System.IO.FileLoadException\n    description: The assembly or one of its dependencies was found, but could not be loaded.\n  - type: System.BadImageFormatException\n    commentId: T:System.BadImageFormatException\n    description: \"The assembly or one of its dependencies is not valid.  \\n  \\n -or-  \\n  \\n Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetTypeArray(System.Object[])\n  commentId: M:System.Type.GetTypeArray(System.Object[])\n  id: GetTypeArray(System.Object[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetTypeArray(Object[])\n  nameWithType: Type.GetTypeArray(Object[])\n  fullName: Type.GetTypeArray(Object[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the types of the objects in the specified array.\n  remarks: ''\n  example:\n  - \"The following code example demonstrates how to use the <xref:System.Type.GetTypeArray%2A> method to list the types of the elements of an array.  \\n  \\n [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]\\n [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]\\n [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]\"\n  syntax:\n    content: public static Type[] GetTypeArray (object[] args);\n    parameters:\n    - id: args\n      type: System.Object[]\n      description: An array of objects whose types to determine.\n    return:\n      type: System.Type[]\n      description: An array of <xref href=\"System.Type\"></xref> objects representing the types of the corresponding elements in <code>args</code>.\n  overload: System.Type.GetTypeArray*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>args</code> is `null`.  \\n  \\n -or-  \\n  \\n One or more of the elements in <code>args</code> is `null`.\"\n  - type: System.Reflection.TargetInvocationException\n    commentId: T:System.Reflection.TargetInvocationException\n    description: The class initializers are invoked and at least one throws an exception.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetTypeCode(System.Type)\n  commentId: M:System.Type.GetTypeCode(System.Type)\n  id: GetTypeCode(System.Type)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetTypeCode(Type)\n  nameWithType: Type.GetTypeCode(Type)\n  fullName: Type.GetTypeCode(Type)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets the underlying type code of the specified <xref href=\"System.Type\"></xref>.\n  remarks: When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.\n  example:\n  - \"The following code example demonstrates how the <xref:System.TypeCode> enumeration can be used. In a decision block inside the `WriteObjectInfo` method, the <xref:System.TypeCode> of an <xref:System.Object> parameter is examined, and an appropriate message is written to the console.  \\n  \\n [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]\\n [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]\\n [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]\"\n  syntax:\n    content: public static TypeCode GetTypeCode (Type type);\n    parameters:\n    - id: type\n      type: System.Type\n      description: The type whose underlying type code to get.\n    return:\n      type: System.TypeCode\n      description: The code of the underlying type, or <xref href=\"System.TypeCode.Empty\"></xref> if <code>type</code> is `null`.\n  overload: System.Type.GetTypeCode*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetTypeCodeImpl\n  commentId: M:System.Type.GetTypeCodeImpl\n  id: GetTypeCodeImpl\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetTypeCodeImpl()\n  nameWithType: Type.GetTypeCodeImpl()\n  fullName: Type.GetTypeCodeImpl()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns the underlying type code of this <xref href=\"System.Type\"></xref> instance.\n  remarks: This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method. When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.\n  syntax:\n    content: protected virtual TypeCode GetTypeCodeImpl ();\n    parameters: []\n    return:\n      type: System.TypeCode\n      description: The type code of the underlying type.\n  overload: System.Type.GetTypeCodeImpl*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)\n  commentId: M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)\n  id: GetTypeFromCLSID(System.Guid,System.String,System.Boolean)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetTypeFromCLSID(Guid, String, Boolean)\n  nameWithType: Type.GetTypeFromCLSID(Guid, String, Boolean)\n  fullName: Type.GetTypeFromCLSID(Guid, String, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.\n  remarks: \"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.  \\n  \\n> [!TIP]\\n>  You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.  \\n  \\n Instantiating an unmanaged COM object from its CLSID is a two-step process:  \\n  \\n1.  Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.  \\n  \\n2.  Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object.  \\n  \\n Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.\"\n  example:\n  - \"The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method. An exception is thrown if an error occurs while loading the type.  \\n  \\n [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]\\n [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]\"\n  syntax:\n    content: public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);\n    parameters:\n    - id: clsid\n      type: System.Guid\n      description: The CLSID of the type to get.\n    - id: server\n      type: System.String\n      description: The server from which to load the type. If the server name is `null`, this method automatically reverts to the local machine.\n    - id: throwOnError\n      type: System.Boolean\n      description: \"`true` to throw any exception that occurs.  \\n  \\n -or-  \\n  \\n `false` to ignore any exception that occurs.\"\n    return:\n      type: System.Type\n      description: '`System.__ComObject` regardless of whether the CLSID is valid.'\n  overload: System.Type.GetTypeFromCLSID*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetTypeFromCLSID(System.Guid,System.String)\n  commentId: M:System.Type.GetTypeFromCLSID(System.Guid,System.String)\n  id: GetTypeFromCLSID(System.Guid,System.String)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetTypeFromCLSID(Guid, String)\n  nameWithType: Type.GetTypeFromCLSID(Guid, String)\n  fullName: Type.GetTypeFromCLSID(Guid, String)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the type associated with the specified class identifier (CLSID) from the specified server.\n  remarks: \"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.  \\n  \\n> [!TIP]\\n>  You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.  \\n  \\n Instantiating an unmanaged COM object from its CLSID is a two-step process:  \\n  \\n1.  Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.  \\n  \\n2.  Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object.\"\n  example:\n  - \"The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com. It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method.  \\n  \\n [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]\\n [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]\"\n  syntax:\n    content: public static Type GetTypeFromCLSID (Guid clsid, string server);\n    parameters:\n    - id: clsid\n      type: System.Guid\n      description: The CLSID of the type to get.\n    - id: server\n      type: System.String\n      description: The server from which to load the type. If the server name is `null`, this method automatically reverts to the local machine.\n    return:\n      type: System.Type\n      description: '`System.__ComObject` regardless of whether the CLSID is valid.'\n  overload: System.Type.GetTypeFromCLSID*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)\n  commentId: M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)\n  id: GetTypeFromCLSID(System.Guid,System.Boolean)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetTypeFromCLSID(Guid, Boolean)\n  nameWithType: Type.GetTypeFromCLSID(Guid, Boolean)\n  fullName: Type.GetTypeFromCLSID(Guid, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.\n  remarks: \"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.  \\n  \\n> [!TIP]\\n>  You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.  \\n  \\n Instantiating an unmanaged COM object from its CLSID is a two-step process:  \\n  \\n1.  Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.  \\n  \\n2.  Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object.  \\n  \\n See the example for an illustration.  \\n  \\n Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.\"\n  example:\n  - \"The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application. It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method. An exception is thrown if an error occurs while loading the type.  \\n  \\n [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]\\n [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]\"\n  syntax:\n    content: public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);\n    parameters:\n    - id: clsid\n      type: System.Guid\n      description: The CLSID of the type to get.\n    - id: throwOnError\n      type: System.Boolean\n      description: \"`true` to throw any exception that occurs.  \\n  \\n -or-  \\n  \\n `false` to ignore any exception that occurs.\"\n    return:\n      type: System.Type\n      description: '`System.__ComObject` regardless of whether the CLSID is valid.'\n  overload: System.Type.GetTypeFromCLSID*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetTypeFromCLSID(System.Guid)\n  commentId: M:System.Type.GetTypeFromCLSID(System.Guid)\n  id: GetTypeFromCLSID(System.Guid)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetTypeFromCLSID(Guid)\n  nameWithType: Type.GetTypeFromCLSID(Guid)\n  fullName: Type.GetTypeFromCLSID(Guid)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the type associated with the specified class identifier (CLSID).\n  remarks: \"The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).  The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\\\\CLSID key of the registry. You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.  \\n  \\n> [!TIP]\\n>  You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.  \\n  \\n Instantiating an unmanaged COM object from its CLSID is a two-step process:  \\n  \\n1.  Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.  \\n  \\n2.  Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=fullName> method to instantiate the COM object.  \\n  \\n See the example for an illustration.  \\n  \\n The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument. Note that no exception is thrown if `clsid` is not found in the registry.\"\n  example:\n  - \"The following example uses the CLSID of the Microsoft Word [Application object](http://msdn.microsoft.com/library/office/ff838565.aspx) to retrieve a COM type that represents the Microsoft Word application. It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=fullName> method, and closes it by calling the [Application.Quit](http://msdn.microsoft.com/library/office/ff844895.aspx) method.  \\n  \\n [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]\\n [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]\"\n  syntax:\n    content: public static Type GetTypeFromCLSID (Guid clsid);\n    parameters:\n    - id: clsid\n      type: System.Guid\n      description: The CLSID of the type to get.\n    return:\n      type: System.Type\n      description: '`System.__ComObject` regardless of whether the CLSID is valid.'\n  overload: System.Type.GetTypeFromCLSID*\n  exceptions: []\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\n  commentId: M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\n  id: GetTypeFromHandle(System.RuntimeTypeHandle)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetTypeFromHandle(RuntimeTypeHandle)\n  nameWithType: Type.GetTypeFromHandle(RuntimeTypeHandle)\n  fullName: Type.GetTypeFromHandle(RuntimeTypeHandle)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets the type referenced by the specified type handle.\n  remarks: The handles are valid only in the application domain in which they were obtained.\n  example:\n  - \"The following example uses the <xref:System.Type.GetTypeFromHandle%2A> method to get a <xref:System.Type> object from a <xref:System.RuntimeTypeHandle> provided by the <xref:System.Type.GetTypeHandle%2A> method.  \\n  \\n [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]\\n [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]\\n [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]\"\n  syntax:\n    content: public static Type GetTypeFromHandle (RuntimeTypeHandle handle);\n    parameters:\n    - id: handle\n      type: System.RuntimeTypeHandle\n      description: The object that refers to the type.\n    return:\n      type: System.Type\n      description: The type referenced by the specified <xref href=\"System.RuntimeTypeHandle\"></xref>, or `null` if the <xref href=\"System.RuntimeTypeHandle.Value\"></xref> property of <code>handle</code> is `null`.\n  overload: System.Type.GetTypeFromHandle*\n  exceptions:\n  - type: System.Reflection.TargetInvocationException\n    commentId: T:System.Reflection.TargetInvocationException\n    description: A class initializer is invoked and throws an exception.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetTypeFromProgID(System.String)\n  commentId: M:System.Type.GetTypeFromProgID(System.String)\n  id: GetTypeFromProgID(System.String)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetTypeFromProgID(String)\n  nameWithType: Type.GetTypeFromProgID(String)\n  fullName: Type.GetTypeFromProgID(String)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <xref href=\"System.Type\"></xref>.\n  remarks: This method is provided for COM support. ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static Type GetTypeFromProgID (string progID);\n    parameters:\n    - id: progID\n      type: System.String\n      description: The ProgID of the type to get.\n    return:\n      type: System.Type\n      description: The type associated with the specified ProgID, if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, `null`.\n  overload: System.Type.GetTypeFromProgID*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>progID</code> is `null`.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetTypeFromProgID(System.String,System.Boolean)\n  commentId: M:System.Type.GetTypeFromProgID(System.String,System.Boolean)\n  id: GetTypeFromProgID(System.String,System.Boolean)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetTypeFromProgID(String, Boolean)\n  nameWithType: Type.GetTypeFromProgID(String, Boolean)\n  fullName: Type.GetTypeFromProgID(String, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.\n  remarks: This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.\n  example:\n  - \"The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid. The example then displays the ClassID related to the ProgID, along with any applicable exception message.  \\n  \\n [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]\\n [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]\\n [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static Type GetTypeFromProgID (string progID, bool throwOnError);\n    parameters:\n    - id: progID\n      type: System.String\n      description: The ProgID of the type to get.\n    - id: throwOnError\n      type: System.Boolean\n      description: \"`true` to throw any exception that occurs.  \\n  \\n -or-  \\n  \\n `false` to ignore any exception that occurs.\"\n    return:\n      type: System.Type\n      description: The type associated with the specified program identifier (ProgID), if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, `null`.\n  overload: System.Type.GetTypeFromProgID*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>progID</code> is `null`.\n  - type: System.Runtime.InteropServices.COMException\n    commentId: T:System.Runtime.InteropServices.COMException\n    description: The specified ProgID is not registered.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetTypeFromProgID(System.String,System.String)\n  commentId: M:System.Type.GetTypeFromProgID(System.String,System.String)\n  id: GetTypeFromProgID(System.String,System.String)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetTypeFromProgID(String, String)\n  nameWithType: Type.GetTypeFromProgID(String, String)\n  fullName: Type.GetTypeFromProgID(String, String)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.\n  remarks: This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.\n  example:\n  - \"The following example retrieves a type by passing a ProgID and server name. The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.  \\n  \\n [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]\\n [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]\\n [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static Type GetTypeFromProgID (string progID, string server);\n    parameters:\n    - id: progID\n      type: System.String\n      description: The progID of the type to get.\n    - id: server\n      type: System.String\n      description: The server from which to load the type. If the server name is `null`, this method automatically reverts to the local machine.\n    return:\n      type: System.Type\n      description: The type associated with the specified program identifier (progID), if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, `null`.\n  overload: System.Type.GetTypeFromProgID*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>prodID</code> is `null`.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)\n  commentId: M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)\n  id: GetTypeFromProgID(System.String,System.String,System.Boolean)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetTypeFromProgID(String, String, Boolean)\n  nameWithType: Type.GetTypeFromProgID(String, String, Boolean)\n  fullName: Type.GetTypeFromProgID(String, String, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.\n  remarks: This method is provided for COM support. Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.\n  example:\n  - \"The following example retrieves a type by passing a ProgID and server name. The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.  \\n  \\n [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]\\n [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]\\n [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Security.SecurityCritical]\n\n      public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);\n    parameters:\n    - id: progID\n      type: System.String\n      description: The progID of the <xref href=\"System.Type\"></xref> to get.\n    - id: server\n      type: System.String\n      description: The server from which to load the type. If the server name is `null`, this method automatically reverts to the local machine.\n    - id: throwOnError\n      type: System.Boolean\n      description: \"`true` to throw any exception that occurs.  \\n  \\n -or-  \\n  \\n `false` to ignore any exception that occurs.\"\n    return:\n      type: System.Type\n      description: The type associated with the specified program identifier (progID), if <code>progID</code> is a valid entry in the registry and a type is associated with it; otherwise, `null`.\n  overload: System.Type.GetTypeFromProgID*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: <code>progID</code> is `null`.\n  - type: System.Runtime.InteropServices.COMException\n    commentId: T:System.Runtime.InteropServices.COMException\n    description: The specified progID is not registered.\n  attributes:\n  - type: System.Security.SecurityCriticalAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GetTypeHandle(System.Object)\n  commentId: M:System.Type.GetTypeHandle(System.Object)\n  id: GetTypeHandle(System.Object)\n  parent: System.Type\n  langs:\n  - csharp\n  name: GetTypeHandle(Object)\n  nameWithType: Type.GetTypeHandle(Object)\n  fullName: Type.GetTypeHandle(Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the handle for the <xref href=\"System.Type\"></xref> of a specified object.\n  remarks: The handles are valid only in the application domain in which they were obtained.\n  example:\n  - \"The following example defines the class `MyClass1`, gets an instance of it, and retrieves the runtime handle of the object.  \\n  \\n [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]\\n [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]\\n [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]\"\n  syntax:\n    content: public static RuntimeTypeHandle GetTypeHandle (object o);\n    parameters:\n    - id: o\n      type: System.Object\n      description: The object for which to get the type handle.\n    return:\n      type: System.RuntimeTypeHandle\n      description: The handle for the <xref href=\"System.Type\"></xref> of the specified <xref href=\"System.Object\"></xref>.\n  overload: System.Type.GetTypeHandle*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>o</code> is `null`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.GUID\n  commentId: P:System.Type.GUID\n  id: GUID\n  parent: System.Type\n  langs:\n  - csharp\n  name: GUID\n  nameWithType: Type.GUID\n  fullName: Type.GUID\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the GUID associated with the <xref href=\"System.Type\"></xref>.\n  remarks: A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.\n  example:\n  - \"The following example creates the class `MyClass1` with a public method, creates a `Type` object corresponding to `MyClass1`, and gets the <xref:System.Guid> structure using the `GUID` property of the `Type` class.  \\n  \\n [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]\\n [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]\\n [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]\"\n  syntax:\n    content: public abstract Guid GUID { get; }\n    return:\n      type: System.Guid\n      description: The GUID associated with the <xref href=\"System.Type\"></xref>.\n  overload: System.Type.GUID*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.HasElementType\n  commentId: P:System.Type.HasElementType\n  id: HasElementType\n  parent: System.Type\n  langs:\n  - csharp\n  name: HasElementType\n  nameWithType: Type.HasElementType\n  fullName: Type.HasElementType\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets a value indicating whether the current <xref href=\"System.Type\"></xref> encompasses or refers to another type; that is, whether the current <xref href=\"System.Type\"></xref> is an array, a pointer, or is passed by reference.\n  remarks: \"For example, Type.GetType(\\\"Int32[]\\\").HasElementType returns `true`, but Type.GetType(\\\"Int32\\\").HasElementType returns `false`. HasElementType also returns `true` for \\\"Int32*\\\" and \\\"Int32&\\\".  \\n  \\n If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.\"\n  example:\n  - \"The following example returns `true` or `false` depending on whether or not the object is an array, a reference type, or a pointer.  \\n  \\n [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]\\n [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]\\n [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]\"\n  syntax:\n    content: public bool HasElementType { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is an array, a pointer, or is passed by reference; otherwise, `false`.'\n  overload: System.Type.HasElementType*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.HasElementTypeImpl\n  commentId: M:System.Type.HasElementTypeImpl\n  id: HasElementTypeImpl\n  parent: System.Type\n  langs:\n  - csharp\n  name: HasElementTypeImpl()\n  nameWithType: Type.HasElementTypeImpl()\n  fullName: Type.HasElementTypeImpl()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, implements the <xref href=\"System.Type.HasElementType\"></xref> property and determines whether the current <xref href=\"System.Type\"></xref> encompasses or refers to another type; that is, whether the current <xref href=\"System.Type\"></xref> is an array, a pointer, or is passed by reference.\n  remarks: For example, Type.GetType(\"Int32[]\").HasElementTypeImpl returns `true`, but Type.GetType(\"Int32\").HasElementTypeImpl returns `false`. HasElementTypeImpl also returns `true` for \"Int32*\" and \"Int32&\".\n  example:\n  - \"The following example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method. The main class checks for the `HasElementType` property and displays the element type.  \\n  \\n [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]\\n [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]\\n [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]\"\n  syntax:\n    content: protected abstract bool HasElementTypeImpl ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is an array, a pointer, or is passed by reference; otherwise, `false`.'\n  overload: System.Type.HasElementTypeImpl*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])\n  commentId: M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])\n  id: InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: InvokeMember(String, BindingFlags, Binder, Object, Object[], ParameterModifier[], CultureInfo, String[])\n  nameWithType: Type.InvokeMember(String, BindingFlags, Binder, Object, Object[], ParameterModifier[], CultureInfo, String[])\n  fullName: Type.InvokeMember(String, BindingFlags, Binder, Object, Object[], ParameterModifier[], CultureInfo, String[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.\n  remarks: \"`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.  \\n  \\n> [!NOTE]\\n>  You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.  \\n  \\n When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format \\\"[DispID=##]\\\". For example, if the DispID of MyComMethod is 3, you can specify the string \\\"[DispID=3]\\\" instead of \\\"MyComMethod\\\". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.  \\n  \\n Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `modifiers` and `culture`. `ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.  \\n  \\n Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array. If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.  \\n  \\n The `namedParameters` array can be used to change the order of arguments in an input array. For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, \\\"x\\\" }`, the input array can be passed unchanged to `args` if the array `{ \\\"b\\\", \\\"a\\\" }` is supplied for `namedParameters`.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  \\n  \\n-   Specify `BindingFlags.Public` to include public members in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.  \\n  \\n The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:  \\n  \\n-   `CreateInstance` to invoke a constructor. `name` is ignored. Not valid with other invocation flags.  \\n  \\n-   `InvokeMethod` to invoke a method, but not a constructor or a type initializer. Not valid with `SetField` or `SetProperty`. If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.  \\n  \\n-   `GetField` to get the value of a field. Not valid with `SetField`.  \\n  \\n-   `SetField` to set the value of a field. Not valid with `GetField`.  \\n  \\n-   `GetProperty` to get a property. Not valid with `SetProperty`.  \\n  \\n-   `SetProperty` to set a property. Not valid with `GetProperty`.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n A method will be invoked if both of the following conditions are true:  \\n  \\n-   The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).  \\n  \\n-   The type of each argument can be converted by the binder to the type of the parameter.  \\n  \\n The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.  \\n  \\n After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.  \\n  \\n `InvokeMember` can be used to invoke methods with parameters that have default values. To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags?displayProperty=fullName> to be specified. For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=fullName> to use the default value.  \\n  \\n For example, consider a method such as MyMethod(int x, float y = 2.0). To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument. Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method. If you must do so, use `InvokeMember` instead.  \\n  \\n Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.  \\n  \\n You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags?displayProperty=fullName>. For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:  \\n  \\n `typeof(C).InvokeMember(\\\"F\\\", BindingFlags.SetField, null, c, new Object[] {\\\"strings new value\\\"}, null, null, null);`  \\n  \\n If F is a `String[]`, you can use code such as:  \\n  \\n `typeof(C).InvokeMember(\\\"F\\\", BindingFlags.SetField, null, c, new Object[] {new String[]{\\\"a\\\",\\\"z\\\",\\\"c\\\",\\\"d\\\"}}, null, null, null);`  \\n  \\n which will initialize the field F to this new array. You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:  \\n  \\n `typeof(C).InvokeMember(\\\"F\\\", BindingFlags.SetField, null, c, new Object[] {1, \\\"b\\\"}, null, null, null);`  \\n  \\n This will change string \\\"z\\\" in the array that F holds to string \\\"b\\\".  \\n  \\n> [!NOTE]\\n>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  \\n>   \\n>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.\"\n  syntax:\n    content: public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);\n    parameters:\n    - id: name\n      type: System.String\n      description: \"The string containing the name of the constructor, method, property, or field member to invoke.  \\n  \\n -or-  \\n  \\n An empty string (\\\"\\\") to invoke the default member.  \\n  \\n -or-  \\n  \\n For `IDispatch` members, a string representing the DispID, for example \\\"[DispID=3]\\\".\"\n    - id: invokeAttr\n      type: System.Reflection.BindingFlags\n      description: A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted. The access can be one of the `BindingFlags` such as `Public`, `NonPublic`, `Private`, `InvokeMethod`, `GetField`, and so on. The type of lookup need not be specified. If the type of lookup is omitted, `BindingFlags.Public` | `BindingFlags.Instance` | `BindingFlags.Static` are used.\n    - id: binder\n      type: System.Reflection.Binder\n      description: \"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \\n  \\n -or-  \\n  \\n A null reference (Nothing in Visual Basic), to use the <xref href=\\\"System.Type.DefaultBinder\\\"></xref>. Note that explicitly defining a <xref href=\\\"System.Reflection.Binder\\\"></xref> object may be required for successfully invoking method overloads with variable arguments.\"\n    - id: target\n      type: System.Object\n      description: The object on which to invoke the specified member.\n    - id: args\n      type: System.Object[]\n      description: An array containing the arguments to pass to the member to invoke.\n    - id: modifiers\n      type: System.Reflection.ParameterModifier[]\n      description: \"An array of <xref href=\\\"System.Reflection.ParameterModifier\\\"></xref> objects representing the attributes associated with the corresponding element in the <code>args</code> array. A parameter's associated attributes are stored in the member's signature.  \\n  \\n The default binder processes this parameter only when calling a COM component.\"\n    - id: culture\n      type: System.Globalization.CultureInfo\n      description: \"The <xref href=\\\"System.Globalization.CultureInfo\\\"></xref> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.  \\n  \\n -or-  \\n  \\n A null reference (`Nothing` in Visual Basic) to use the current thread's <xref href=\\\"System.Globalization.CultureInfo\\\"></xref>.\"\n    - id: namedParameters\n      type: System.String[]\n      description: An array containing the names of the parameters to which the values in the <code>args</code> array are passed.\n    return:\n      type: System.Object\n      description: An object representing the return value of the invoked member.\n  overload: System.Type.InvokeMember*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>invokeAttr</code> does not contain `CreateInstance` and <code>name</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>args</code> and <code>modifiers</code> do not have the same length.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> is not a valid <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> attribute.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> does not contain one of the following binding flags: `InvokeMethod`, `CreateInstance`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains `CreateInstance` combined with `InvokeMethod`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains both `GetField` and `SetField`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains both `GetProperty` and `SetProperty`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains `InvokeMethod` combined with `SetField` or `SetProperty`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains `SetField` and <code>args</code> has more than one element.  \\n  \\n -or-  \\n  \\n The named parameter array is larger than the argument array.  \\n  \\n -or-  \\n  \\n This method is called on a COM object and one of the following binding flags was not passed in: `BindingFlags.InvokeMethod`, `BindingFlags.GetProperty`, `BindingFlags.SetProperty`, `BindingFlags.PutDispProperty`, or `BindingFlags.PutRefDispProperty`.  \\n  \\n -or-  \\n  \\n One of the named parameter arrays contains a string that is `null`.\"\n  - type: System.MethodAccessException\n    commentId: T:System.MethodAccessException\n    description: The specified member is a class initializer.\n  - type: System.MissingFieldException\n    commentId: T:System.MissingFieldException\n    description: The field or property cannot be found.\n  - type: System.MissingMethodException\n    commentId: T:System.MissingMethodException\n    description: \"No method can be found that matches the arguments in <code>args</code>.  \\n  \\n -or-  \\n  \\n No member can be found that has the argument names supplied in <code>namedParameters</code>.  \\n  \\n -or-  \\n  \\n The current <xref href=\\\"System.Type\\\"></xref> object represents a type that contains open type parameters, that is, <xref href=\\\"System.Type.ContainsGenericParameters\\\"></xref> returns `true`.\"\n  - type: System.Reflection.TargetException\n    commentId: T:System.Reflection.TargetException\n    description: The specified member cannot be invoked on <code>target</code>.\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one method matches the binding criteria.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The method represented by <code>name</code> has one or more unspecified generic type parameters. That is, the method's <xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"></xref> property returns `true`.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])\n  commentId: M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])\n  id: InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: InvokeMember(String, BindingFlags, Binder, Object, Object[])\n  nameWithType: Type.InvokeMember(String, BindingFlags, Binder, Object, Object[])\n  fullName: Type.InvokeMember(String, BindingFlags, Binder, Object, Object[])\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Invokes the specified member, using the specified binding constraints and matching the specified argument list.\n  remarks: \"> [!NOTE]\\n>  You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  \\n  \\n-   Specify `BindingFlags.Public` to include public members in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.  \\n  \\n The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:  \\n  \\n-   `CreateInstance` to invoke a constructor. `name` is ignored. Not valid with other invocation flags.  \\n  \\n-   `InvokeMethod` to invoke a method, but not a constructor or a type initializer. Not valid with `SetField` or `SetProperty`. If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.  \\n  \\n-   `GetField` to get the value of a field. Not valid with `SetField`.  \\n  \\n-   `SetField` to set the value of a field. Not valid with `GetField`.  \\n  \\n-   `GetProperty` to get a property. Not valid with `SetProperty`.  \\n  \\n-   `SetProperty` to set a property. Not valid with `GetProperty`.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n A method will be invoked if both of the following conditions are true:  \\n  \\n-   The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).  \\n  \\n-   The type of each argument can be converted by the binder to the type of the parameter.  \\n  \\n The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.  \\n  \\n After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.  \\n  \\n Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.  \\n  \\n You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags?displayProperty=fullName>. For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:  \\n  \\n `typeof(C).InvokeMember(\\\"F\\\", BindingFlags.SetField, null, c, new Object[] {\\\"strings new value\\\"});`  \\n  \\n If F is a `String[]`, you can use code such as:  \\n  \\n `typeof(C).InvokeMember(\\\"F\\\", BindingFlags.SetField, null, c, new Object[] {new String[]{\\\"a\\\",\\\"z\\\",\\\"c\\\",\\\"d\\\"}});`  \\n  \\n which will initialize the field F to this new array. You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:  \\n  \\n `typeof(C).InvokeMember(\\\"F\\\", BindingFlags.SetField, null, c, new Object[] {1, \\\"b\\\"});`  \\n  \\n This will change string \\\"z\\\" in the array that F holds to string \\\"b\\\".  \\n  \\n When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format \\\"[DispID=##]\\\". For example, if the DispID of MyComMethod is 3, you can specify the string \\\"[DispID=3]\\\" instead of \\\"MyComMethod\\\". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.  \\n  \\n> [!NOTE]\\n>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  \\n>   \\n>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.\"\n  example:\n  - \"The following example uses `InvokeMember` to access members of a type.  \\n  \\n [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]\\n [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]\\n [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]\"\n  syntax:\n    content: public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);\n    parameters:\n    - id: name\n      type: System.String\n      description: \"The string containing the name of the constructor, method, property, or field member to invoke.  \\n  \\n -or-  \\n  \\n An empty string (\\\"\\\") to invoke the default member.  \\n  \\n -or-  \\n  \\n For `IDispatch` members, a string representing the DispID, for example \\\"[DispID=3]\\\".\"\n    - id: invokeAttr\n      type: System.Reflection.BindingFlags\n      description: A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted. The access can be one of the `BindingFlags` such as `Public`, `NonPublic`, `Private`, `InvokeMethod`, `GetField`, and so on. The type of lookup need not be specified. If the type of lookup is omitted, `BindingFlags.Public` | `BindingFlags.Instance` | `BindingFlags.Static` are used.\n    - id: binder\n      type: System.Reflection.Binder\n      description: \"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \\n  \\n -or-  \\n  \\n A null reference (`Nothing` in Visual Basic), to use the <xref href=\\\"System.Type.DefaultBinder\\\"></xref>. Note that explicitly defining a <xref href=\\\"System.Reflection.Binder\\\"></xref> object may be required for successfully invoking method overloads with variable arguments.\"\n    - id: target\n      type: System.Object\n      description: The object on which to invoke the specified member.\n    - id: args\n      type: System.Object[]\n      description: An array containing the arguments to pass to the member to invoke.\n    return:\n      type: System.Object\n      description: An object representing the return value of the invoked member.\n  overload: System.Type.InvokeMember*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>invokeAttr</code> does not contain `CreateInstance` and <code>name</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>invokeAttr</code> is not a valid <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> attribute.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> does not contain one of the following binding flags: `InvokeMethod`, `CreateInstance`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains `CreateInstance` combined with `InvokeMethod`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains both `GetField` and `SetField`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains both `GetProperty` and `SetProperty`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains `InvokeMethod` combined with `SetField` or `SetProperty`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains `SetField` and <code>args</code> has more than one element.  \\n  \\n -or-  \\n  \\n This method is called on a COM object and one of the following binding flags was not passed in: `BindingFlags.InvokeMethod`, `BindingFlags.GetProperty`, `BindingFlags.SetProperty`, `BindingFlags.PutDispProperty`, or `BindingFlags.PutRefDispProperty`.  \\n  \\n -or-  \\n  \\n One of the named parameter arrays contains a string that is `null`.\"\n  - type: System.MethodAccessException\n    commentId: T:System.MethodAccessException\n    description: The specified member is a class initializer.\n  - type: System.MissingFieldException\n    commentId: T:System.MissingFieldException\n    description: The field or property cannot be found.\n  - type: System.MissingMethodException\n    commentId: T:System.MissingMethodException\n    description: \"No method can be found that matches the arguments in <code>args</code>.  \\n  \\n -or-  \\n  \\n The current <xref href=\\\"System.Type\\\"></xref> object represents a type that contains open type parameters, that is, <xref href=\\\"System.Type.ContainsGenericParameters\\\"></xref> returns `true`.\"\n  - type: System.Reflection.TargetException\n    commentId: T:System.Reflection.TargetException\n    description: The specified member cannot be invoked on <code>target</code>.\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one method matches the binding criteria.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The .NET Compact Framework does not currently support this method.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The method represented by <code>name</code> has one or more unspecified generic type parameters. That is, the method's <xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"></xref> property returns `true`.\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)\n  commentId: M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)\n  id: InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)\n  parent: System.Type\n  langs:\n  - csharp\n  name: InvokeMember(String, BindingFlags, Binder, Object, Object[], CultureInfo)\n  nameWithType: Type.InvokeMember(String, BindingFlags, Binder, Object, Object[], CultureInfo)\n  fullName: Type.InvokeMember(String, BindingFlags, Binder, Object, Object[], CultureInfo)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.\n  remarks: \"Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=fullName> class to write a custom binder that does process `culture`.  \\n  \\n> [!NOTE]\\n>  You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.  \\n  \\n The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:  \\n  \\n-   Specify `BindingFlags.Public` to include public members in the search.  \\n  \\n-   Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.  \\n  \\n-   Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.  \\n  \\n The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:  \\n  \\n-   `BindingFlags.IgnoreCase` to ignore the case of `name`.  \\n  \\n-   `BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.  \\n  \\n The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:  \\n  \\n-   `CreateInstance` to invoke a constructor. `name` is ignored. Not valid with other invocation flags.  \\n  \\n-   `InvokeMethod` to invoke a method, but not a constructor or a type initializer. Not valid with `SetField` or `SetProperty`. If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.  \\n  \\n-   `GetField` to get the value of a field. Not valid with `SetField`.  \\n  \\n-   `SetField` to set the value of a field. Not valid with `GetField`.  \\n  \\n-   `GetProperty` to get a property. Not valid with `SetProperty`.  \\n  \\n-   `SetProperty` to set a property. Not valid with `GetProperty`.  \\n  \\n See <xref:System.Reflection.BindingFlags?displayProperty=fullName> for more information.  \\n  \\n A method will be invoked if both of the following conditions are true:  \\n  \\n-   The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).  \\n  \\n-   The type of each argument can be converted by the binder to the type of the parameter.  \\n  \\n The binder will find all of the matching methods. These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on). The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.  \\n  \\n After the method is selected, it is invoked. Accessibility is checked at that point. The search may control which set of methods are searched based upon the accessibility attribute associated with the method. The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=fullName> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked. The default binder selects the most specific match.  \\n  \\n Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.  \\n  \\n You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags?displayProperty=fullName>. For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:  \\n  \\n `typeof(C).InvokeMember(\\\"F\\\", BindingFlags.SetField, null, c, new Object[] {\\\"strings new value\\\"}, null);`  \\n  \\n If F is a `String[]`, you can use code such as:  \\n  \\n `typeof(C).InvokeMember(\\\"F\\\", BindingFlags.SetField, null, c, new Object[] {new String[]{\\\"a\\\",\\\"z\\\",\\\"c\\\",\\\"d\\\"}}, null);`  \\n  \\n which will initialize the field F to this new array. You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:  \\n  \\n `typeof(C).InvokeMember(\\\"F\\\", BindingFlags.SetField, null, c, new Object[] {1, \\\"b\\\"}, null);`  \\n  \\n This will change string \\\"z\\\" in the array that F holds to string \\\"b\\\".  \\n  \\n When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format \\\"[DispID=##]\\\". For example, if the DispID of MyComMethod is 3, you can specify the string \\\"[DispID=3]\\\" instead of \\\"MyComMethod\\\". Invoking a member by DispID is faster than looking up the member by name. In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.  \\n  \\n> [!NOTE]\\n>  Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag?displayProperty=fullName> flag and if the grant set of the non-public members is restricted to the callers grant set, or a subset thereof. (See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  \\n>   \\n>  To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.\"\n  syntax:\n    content: public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);\n    parameters:\n    - id: name\n      type: System.String\n      description: \"The string containing the name of the constructor, method, property, or field member to invoke.  \\n  \\n -or-  \\n  \\n An empty string (\\\"\\\") to invoke the default member.  \\n  \\n -or-  \\n  \\n For `IDispatch` members, a string representing the DispID, for example \\\"[DispID=3]\\\".\"\n    - id: invokeAttr\n      type: System.Reflection.BindingFlags\n      description: A bitmask comprised of one or more <xref href=\"System.Reflection.BindingFlags\"></xref> that specify how the search is conducted. The access can be one of the `BindingFlags` such as `Public`, `NonPublic`, `Private`, `InvokeMethod`, `GetField`, and so on. The type of lookup need not be specified. If the type of lookup is omitted, `BindingFlags.Public` | `BindingFlags.Instance` | `BindingFlags.Static` are used.\n    - id: binder\n      type: System.Reflection.Binder\n      description: \"An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.  \\n  \\n -or-  \\n  \\n A null reference (`Nothing` in Visual Basic), to use the <xref href=\\\"System.Type.DefaultBinder\\\"></xref>. Note that explicitly defining a <xref href=\\\"System.Reflection.Binder\\\"></xref> object may be required for successfully invoking method overloads with variable arguments.\"\n    - id: target\n      type: System.Object\n      description: The object on which to invoke the specified member.\n    - id: args\n      type: System.Object[]\n      description: An array containing the arguments to pass to the member to invoke.\n    - id: culture\n      type: System.Globalization.CultureInfo\n      description: \"The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <xref href=\\\"System.String\\\"></xref> to a <xref href=\\\"System.Double\\\"></xref>.  \\n  \\n -or-  \\n  \\n A null reference (`Nothing` in Visual Basic) to use the current thread's <xref href=\\\"System.Globalization.CultureInfo\\\"></xref>.\"\n    return:\n      type: System.Object\n      description: An object representing the return value of the invoked member.\n  overload: System.Type.InvokeMember*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>invokeAttr</code> does not contain `CreateInstance` and <code>name</code> is `null`.\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>invokeAttr</code> is not a valid <xref href=\\\"System.Reflection.BindingFlags\\\"></xref> attribute.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> does not contain one of the following binding flags: `InvokeMethod`, `CreateInstance`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains `CreateInstance` combined with `InvokeMethod`, `GetField`, `SetField`, `GetProperty`, or `SetProperty`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains both `GetField` and `SetField`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains both `GetProperty` and `SetProperty`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains `InvokeMethod` combined with `SetField` or `SetProperty`.  \\n  \\n -or-  \\n  \\n <code>invokeAttr</code> contains `SetField` and <code>args</code> has more than one element.  \\n  \\n -or-  \\n  \\n This method is called on a COM object and one of the following binding flags was not passed in: `BindingFlags.InvokeMethod`, `BindingFlags.GetProperty`, `BindingFlags.SetProperty`, `BindingFlags.PutDispProperty`, or `BindingFlags.PutRefDispProperty`.  \\n  \\n -or-  \\n  \\n One of the named parameter arrays contains a string that is `null`.\"\n  - type: System.MethodAccessException\n    commentId: T:System.MethodAccessException\n    description: The specified member is a class initializer.\n  - type: System.MissingFieldException\n    commentId: T:System.MissingFieldException\n    description: The field or property cannot be found.\n  - type: System.MissingMethodException\n    commentId: T:System.MissingMethodException\n    description: \"No method can be found that matches the arguments in <code>args</code>.  \\n  \\n -or-  \\n  \\n The current <xref href=\\\"System.Type\\\"></xref> object represents a type that contains open type parameters, that is, <xref href=\\\"System.Type.ContainsGenericParameters\\\"></xref> returns `true`.\"\n  - type: System.Reflection.TargetException\n    commentId: T:System.Reflection.TargetException\n    description: The specified member cannot be invoked on <code>target</code>.\n  - type: System.Reflection.AmbiguousMatchException\n    commentId: T:System.Reflection.AmbiguousMatchException\n    description: More than one method matches the binding criteria.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The method represented by <code>name</code> has one or more unspecified generic type parameters. That is, the method's <xref href=\"System.Reflection.MethodInfo.ContainsGenericParameters\"></xref> property returns `true`.\n  attributes: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsAbstract\n  commentId: P:System.Type.IsAbstract\n  id: IsAbstract\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsAbstract\n  nameWithType: Type.IsAbstract\n  fullName: Type.IsAbstract\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is abstract and must be overridden.\n  remarks: \"The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:  \\n  \\n-   The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes. In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.  \\n  \\n-   The current type is an interface.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.\"\n  example:\n  - \"The following example creates an array of <xref:System.Type> objects that represent the following types:contains type returns `true` if the specified object is `abstract`; otherwise, it returns `false`.  \\n  \\n-   `AbstractClass`, an abstract class (a class marked as `abstract` in C# and `MustInherit` in Visual Basic).  \\n  \\n-   `DerivedClass`, a class that inherits from `AbstractClass`.  \\n  \\n-   `SingleClass`, a non-inheritable class. It is defined as `sealed` in C# and `NotInheritable` in Visual Basic.  \\n  \\n-   `ITypeInfo`, an interface.  \\n  \\n-   `ImplementingClass`, a class that implements the `ITypeInfo` interface.  \\n  \\n The method returns `true` only for `AbstractClass`, the abstract class, and `ITypeInfo`, the interface.  \\n  \\n [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]\\n [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]\"\n  syntax:\n    content: public bool IsAbstract { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is abstract; otherwise, `false`.'\n  overload: System.Type.IsAbstract*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsAnsiClass\n  commentId: P:System.Type.IsAnsiClass\n  id: IsAnsiClass\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsAnsiClass\n  nameWithType: Type.IsAnsiClass\n  fullName: Type.IsAnsiClass\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the string format attribute `AnsiClass` is selected for the <xref href=\"System.Type\"></xref>.\n  remarks: \"The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.  \\n  \\n If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \\n  \\n If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.\"\n  example:\n  - \"The following example gets the field information and checks for the `AnsiClass` attribute.  \\n  \\n [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]\\n [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]\\n [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]\"\n  syntax:\n    content: public bool IsAnsiClass { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the string format attribute `AnsiClass` is selected for the <xref href=\"System.Type\"></xref>; otherwise, `false`.'\n  overload: System.Type.IsAnsiClass*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsArray\n  commentId: P:System.Type.IsArray\n  id: IsArray\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsArray\n  nameWithType: Type.IsArray\n  fullName: Type.IsArray\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets a value that indicates whether the type is an array.\n  remarks: \"The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class. It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.  \\n  \\n To check for an array, use code such as:  \\n  \\n```csharp  \\ntypeof(Array).IsAssignableFrom(type)  \\n```  \\n  \\n```vb  \\nGetType(Array).IsAssignableFrom(type)  \\n```  \\n  \\n If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.  \\n  \\n This property is read-only.\"\n  example:\n  - \"The following example demonstrates using the<xref:System.Type.IsArray%2A> property.  \\n  \\n [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]\\n [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]\"\n  syntax:\n    content: public bool IsArray { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current type is an array; otherwise, `false`.'\n  overload: System.Type.IsArray*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsArrayImpl\n  commentId: M:System.Type.IsArrayImpl\n  id: IsArrayImpl\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsArrayImpl()\n  nameWithType: Type.IsArrayImpl()\n  fullName: Type.IsArrayImpl()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, implements the <xref href=\"System.Type.IsArray\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is an array.\n  remarks: An instance of the <xref:System.Array> class must return `false` because it is an object, not an array.\n  example:\n  - \"The following example overrides the `IsArrayImpl` method in the `MyTypeDelegator` class, checks if a variable is an array, and displays the result.  \\n  \\n [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]\\n [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]\\n [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]\"\n  syntax:\n    content: protected abstract bool IsArrayImpl ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is an array; otherwise, `false`.'\n  overload: System.Type.IsArrayImpl*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsAssignableFrom(System.Type)\n  commentId: M:System.Type.IsAssignableFrom(System.Type)\n  id: IsAssignableFrom(System.Type)\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsAssignableFrom(Type)\n  nameWithType: Type.IsAssignableFrom(Type)\n  fullName: Type.IsAssignableFrom(Type)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Determines whether an instance of a specified type can be assigned to an instance of the current type.\n  remarks: \"The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.  \\n  \\n [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]\\n [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  \\n  \\n This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:  \\n  \\n [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]\\n [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  \\n  \\n This method can be overridden by a derived class.  \\n  \\n> [!NOTE]\\n>  A generic type definition is not assignable from a closed constructed type. That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.  \\n  \\n If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built. The following code example demonstrates this using a built type named `B`.  \\n  \\n [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]\\n [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]\"\n  example:\n  - \"The following example demonstrates the `IsAssignableFrom` method using defined classes, integer arrays, and generics.  \\n  \\n [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]\\n [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]\\n [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]\"\n  syntax:\n    content: public virtual bool IsAssignableFrom (Type c);\n    parameters:\n    - id: c\n      type: System.Type\n      description: The type to compare with the current type.\n    return:\n      type: System.Boolean\n      description: \"`true` if any of the following conditions is true:  \\n  \\n-   <code>c</code> and the current instance represent the same type.  \\n  \\n-   <code>c</code> is derived either directly or indirectly from the current instance. <code>c</code> is derived directly from the current instance if it inherits from the current instance; <code>c</code> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.  \\n  \\n-   The current instance is an interface that <code>c</code> implements.  \\n  \\n-   <code>c</code> is a generic type parameter, and the current instance represents one of the constraints of <code>c</code>.  \\n  \\n     In the following example, the current instance is a <xref href=\\\"System.Type\\\"></xref> object that represents the <xref href=\\\"System.IO.Stream\\\"></xref> class. <code>GenericWithConstraint</code> is a generic type whose generic type parameter must be of type    <xref href=\\\"System.IO.Stream\\\"></xref>. Passing its generic type parameter to the <xref href=\\\"System.Type.IsAssignableFrom(System.Type)\\\"></xref> indicates that  an instance of the generic type parameter can be assigned to an <xref href=\\\"System.IO.Stream\\\"></xref> object.  \\n  \\n     [!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)]\\n     [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]  \\n  \\n-   <code>c</code> represents a value type, and the current instance represents <code>Nullable<c></code> (<code>Nullable(Of c)</code> in Visual Basic).  \\n  \\n `false` if none of these conditions are true, or if <code>c</code> is `null`.\"\n  overload: System.Type.IsAssignableFrom*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsAutoClass\n  commentId: P:System.Type.IsAutoClass\n  id: IsAutoClass\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsAutoClass\n  nameWithType: Type.IsAutoClass\n  fullName: Type.IsAutoClass\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the string format attribute `AutoClass` is selected for the <xref href=\"System.Type\"></xref>.\n  remarks: \"The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \\n  \\n If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.\"\n  syntax:\n    content: public bool IsAutoClass { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the string format attribute `AutoClass` is selected for the <xref href=\"System.Type\"></xref>; otherwise, `false`.'\n  overload: System.Type.IsAutoClass*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsAutoLayout\n  commentId: P:System.Type.IsAutoLayout\n  id: IsAutoLayout\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsAutoLayout\n  nameWithType: Type.IsAutoLayout\n  fullName: Type.IsAutoLayout\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.\n  remarks: \"This property is provided as a convenience. Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set. The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>,<xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory.  \\n  \\n For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type. In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.  \\n  \\n> [!NOTE]\\n>  You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.\"\n  example:\n  - \"The following example creates an instance of the type and displays the <xref:System.Type.IsAutoLayout%2A> property.  \\n  \\n [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]\\n [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]\\n [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]\"\n  syntax:\n    content: public bool IsAutoLayout { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type.Attributes\"></xref> property of the current type includes <xref href=\"System.Reflection.TypeAttributes.AutoLayout\"></xref>; otherwise, `false`.'\n  overload: System.Type.IsAutoLayout*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsByRef\n  commentId: P:System.Type.IsByRef\n  id: IsByRef\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsByRef\n  nameWithType: Type.IsByRef\n  fullName: Type.IsByRef\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is passed by reference.\n  remarks: To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.\n  example:\n  - \"The following example demonstrates a use of the `IsByRef` property to check whether a specified type is passed by reference. The example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method. The main class checks for the `HasElementType` property and displays the element type.  \\n  \\n [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]\\n [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]\\n [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]\"\n  syntax:\n    content: public bool IsByRef { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is passed by reference; otherwise, `false`.'\n  overload: System.Type.IsByRef*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsByRefImpl\n  commentId: M:System.Type.IsByRefImpl\n  id: IsByRefImpl\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsByRefImpl()\n  nameWithType: Type.IsByRefImpl()\n  fullName: Type.IsByRefImpl()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, implements the <xref href=\"System.Type.IsByRef\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is passed by reference.\n  syntax:\n    content: protected abstract bool IsByRefImpl ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is passed by reference; otherwise, `false`.'\n  overload: System.Type.IsByRefImpl*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsClass\n  commentId: P:System.Type.IsClass\n  id: IsClass\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsClass\n  nameWithType: Type.IsClass\n  fullName: Type.IsClass\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is a class or a delegate; that is, not a value type or interface.\n  remarks: \"This property returns `true` for classes as well as delegates. It returns `false` for value types (for structures and enumerations) even if they are boxed.  \\n  \\n If the current<xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type.  \\n  \\n> [!NOTE]\\n>  This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes. These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves. For more information, see the <xref:System.Type.IsValueType%2A>and <xref:System.Type.IsEnum%2A> properties.  \\n  \\n The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> attribute. If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property. The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.  \\n  \\n This property is read-only.\"\n  example:\n  - \"The following example creates an instance of a type and indicates whether the type is a class.  \\n  \\n [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]\\n [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]\\n [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]\"\n  syntax:\n    content: public bool IsClass { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is a class; otherwise, `false`.'\n  overload: System.Type.IsClass*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsCOMObject\n  commentId: P:System.Type.IsCOMObject\n  id: IsCOMObject\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsCOMObject\n  nameWithType: Type.IsCOMObject\n  fullName: Type.IsCOMObject\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is a COM object.\n  remarks: \"This method returns `false` for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.  \\n  \\n You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.\"\n  syntax:\n    content: public bool IsCOMObject { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is a COM object; otherwise, `false`.'\n  overload: System.Type.IsCOMObject*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsCOMObjectImpl\n  commentId: M:System.Type.IsCOMObjectImpl\n  id: IsCOMObjectImpl\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsCOMObjectImpl()\n  nameWithType: Type.IsCOMObjectImpl()\n  fullName: Type.IsCOMObjectImpl()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, implements the <xref href=\"System.Type.IsCOMObject\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is a COM object.\n  remarks: This method returns `false` for COM interfaces because they are not objects. COM interfaces can be implemented by Microsoft .NET Framework objects.\n  syntax:\n    content: protected abstract bool IsCOMObjectImpl ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is a COM object; otherwise, `false`.'\n  overload: System.Type.IsCOMObjectImpl*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsConstructedGenericType\n  commentId: P:System.Type.IsConstructedGenericType\n  id: IsConstructedGenericType\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsConstructedGenericType\n  nameWithType: Type.IsConstructedGenericType\n  fullName: Type.IsConstructedGenericType\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets a value that indicates whether this object represents a constructed generic type. You can create instances of a constructed generic type.\n  remarks: \"A constructed generic type has had explicit types supplied for all of its generic type parameters. It is also referred to as a closed generic type.  \\n  \\n When this property is `true`, you can create instances of the current type; when it is `false`, you can't.\"\n  syntax:\n    content: public virtual bool IsConstructedGenericType { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if this object represents a constructed generic type; otherwise, `false`.'\n  overload: System.Type.IsConstructedGenericType*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsContextful\n  commentId: P:System.Type.IsContextful\n  id: IsContextful\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsContextful\n  nameWithType: Type.IsContextful\n  fullName: Type.IsContextful\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> can be hosted in a context.\n  remarks: \"A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization. For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.\"\n  example:\n  - \"The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class. It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.  \\n  \\n [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]\\n [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]\\n [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]\"\n  syntax:\n    content: public bool IsContextful { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> can be hosted in a context; otherwise, `false`.'\n  overload: System.Type.IsContextful*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsContextfulImpl\n  commentId: M:System.Type.IsContextfulImpl\n  id: IsContextfulImpl\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsContextfulImpl()\n  nameWithType: Type.IsContextfulImpl()\n  fullName: Type.IsContextfulImpl()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Implements the <xref href=\"System.Type.IsContextful\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> can be hosted in a context.\n  remarks: \"This method can be overridden by a derived class.  \\n  \\n A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.\"\n  example:\n  - \"The following example demonstrates a use of the `IsContextfulImpl` method.  \\n  \\n [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]\\n [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]\\n [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]\"\n  syntax:\n    content: protected virtual bool IsContextfulImpl ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> can be hosted in a context; otherwise, `false`.'\n  overload: System.Type.IsContextfulImpl*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsEnum\n  commentId: P:System.Type.IsEnum\n  id: IsEnum\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsEnum\n  nameWithType: Type.IsEnum\n  fullName: Type.IsEnum\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the current <xref href=\"System.Type\"></xref> represents an enumeration.\n  remarks: \"This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.  \\n  \\n This property is read-only.\"\n  example:\n  - \"The following example demonstrates how to use the `IsEnum` property.  \\n  \\n [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]\\n [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]\\n [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]\"\n  syntax:\n    content: public virtual bool IsEnum { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current <xref href=\"System.Type\"></xref> represents an enumeration; otherwise, `false`.'\n  overload: System.Type.IsEnum*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsEnumDefined(System.Object)\n  commentId: M:System.Type.IsEnumDefined(System.Object)\n  id: IsEnumDefined(System.Object)\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsEnumDefined(Object)\n  nameWithType: Type.IsEnumDefined(Object)\n  fullName: Type.IsEnumDefined(Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Returns a value that indicates whether the specified value exists in the current enumeration type.\n  syntax:\n    content: public virtual bool IsEnumDefined (object value);\n    parameters:\n    - id: value\n      type: System.Object\n      description: The value to be tested.\n    return:\n      type: System.Boolean\n      description: '`true` if the specified value is a member of the current enumeration type; otherwise, `false`.'\n  overload: System.Type.IsEnumDefined*\n  exceptions:\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: The current type is not an enumeration.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>value</code> is `null`.\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: <code>value</code> is of a type that cannot be the underlying type of an enumeration.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsEquivalentTo(System.Type)\n  commentId: M:System.Type.IsEquivalentTo(System.Type)\n  id: IsEquivalentTo(System.Type)\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsEquivalentTo(Type)\n  nameWithType: Type.IsEquivalentTo(Type)\n  fullName: Type.IsEquivalentTo(Type)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Determines whether two COM types have the same identity and are eligible for type equivalence.\n  remarks: \"Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies. Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type. Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type. The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.  \\n  \\n Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly. The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.  \\n  \\n For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).\"\n  syntax:\n    content: public virtual bool IsEquivalentTo (Type other);\n    parameters:\n    - id: other\n      type: System.Type\n      description: The COM type that is tested for equivalence with the current type.\n    return:\n      type: System.Boolean\n      description: '`true` if the COM types are equivalent; otherwise, `false`. This method also returns `false` if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.'\n  overload: System.Type.IsEquivalentTo*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsExplicitLayout\n  commentId: P:System.Type.IsExplicitLayout\n  id: IsExplicitLayout\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsExplicitLayout\n  nameWithType: Type.IsExplicitLayout\n  fullName: Type.IsExplicitLayout\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.\n  remarks: \"This property is provided as a convenience. Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set. The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory.  \\n  \\n For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type. In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.  \\n  \\n> [!NOTE]\\n>  You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.\"\n  example:\n  - \"The following example creates an instance of a type and displays the value of its <xref:System.Type.IsExplicitLayout%2A> property. It uses the `MySystemTime` class, which is also in the code example for <xref:System.Runtime.InteropServices.StructLayoutAttribute>.  \\n  \\n [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]\\n [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]\"\n  syntax:\n    content: public bool IsExplicitLayout { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type.Attributes\"></xref> property of the current type includes <xref href=\"System.Reflection.TypeAttributes.ExplicitLayout\"></xref>; otherwise, `false`.'\n  overload: System.Type.IsExplicitLayout*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsGenericParameter\n  commentId: P:System.Type.IsGenericParameter\n  id: IsGenericParameter\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsGenericParameter\n  nameWithType: Type.IsGenericParameter\n  fullName: Type.IsGenericParameter\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets a value indicating whether the current <xref href=\"System.Type\"></xref> represents a type parameter in the definition of a generic type or method.\n  remarks: \"<xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.  \\n  \\n-   For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array.  \\n  \\n-   For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method.  \\n  \\n-   For an open constructed type or method, some elements of the array might be specific types and others might be type parameters. <xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters. The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.  \\n  \\n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.\"\n  example:\n  - \"The following example uses the <xref:System.Type.IsGenericParameter%2A> property to test for generic type parameters in a generic type.  \\n  \\n [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]\\n [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]\\n [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]\"\n  syntax:\n    content: public virtual bool IsGenericParameter { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> object represents a type parameter of a generic type definition or generic method definition; otherwise, `false`.'\n  overload: System.Type.IsGenericParameter*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsGenericType\n  commentId: P:System.Type.IsGenericType\n  id: IsGenericType\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsGenericType\n  nameWithType: Type.IsGenericType\n  fullName: Type.IsGenericType\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the current type is a generic type.\n  remarks: \"Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type. Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic. For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.  \\n  \\n The following table summarizes the invariant conditions for common terms used in generic reflection.  \\n  \\n|Term|Invariant|  \\n|----------|---------------|  \\n|generic type definition|The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.<br /><br /> Defines a generic type. A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.<br /><br /> <xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.<br /><br /> Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.|  \\n|generic type|The <xref:System.Type.IsGenericType%2A> property is `true`.<br /><br /> Can be a generic type definition, an open constructed type, or a closed constructed type.<br /><br /> Note that an array type whose element type is generic is not itself a generic type. The same is true of a <xref:System.Type> object representing a pointer to a generic type.|  \\n|open constructed type|The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.<br /><br /> Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.<br /><br /> It is not possible to create an instance of an open constructed type.<br /><br /> Note that not all open constructed types are generic. For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.|  \\n|closed constructed type|The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.<br /><br /> When examined recursively, the type has no unassigned generic parameters.|  \\n|generic type parameter|The <xref:System.Type.IsGenericParameter%2A> property is `true`.<br /><br /> The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.<br /><br /> In a generic type definition, a placeholder for a type that will be assigned later.|  \\n|generic type argument|Can be any type, including a generic type parameter.<br /><br /> Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type. If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.|  \\n  \\n The following code example and table illustrate some of these terms and invariants. The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.  \\n  \\n [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]\\n [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]\\n [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  \\n  \\n The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`. When the C++ and C# code is the same, only one entry is shown.  \\n  \\n|Example|Invariants|  \\n|-------------|----------------|  \\n|`Derived(Of V)`<br /><br /> `Derived<V>`|For this type:<br /><br /> <xref:System.Type.IsGenericType%2A> is `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `true`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true`.|  \\n|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|For this type:<br /><br /> <xref:System.Type.IsGenericType%2A> is `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true`.|  \\n|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|For the type of variable `d`:<br /><br /> <xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `false`.|  \\n|`T`, `U`, and `V` (everywhere they appear)|<xref:System.Type.IsGenericParameter%2A> is `true`.<br /><br /> <xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `false`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters. This does not imply anything about type arguments that are assigned to them later.|  \\n|The type of field `F`|<xref:System.Type.IsGenericType%2A> is `true`.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to to the type parameter of `G`. Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type. The constructed type is open because its type argument (that is, `Base`) is a generic type definition. This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.|  \\n|The nested class `Nested`|<xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.<br /><br /> <xref:System.Type.IsGenericTypeDefinition%2A> is `true`. That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.<br /><br /> <xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters. This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.|\"\n  example:\n  - \"The following code example displays the value of the <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, and <xref:System.Type.ContainsGenericParameters%2A> properties for the types described in the Remarks section. For explanations of the property values, see the accompanying table in Remarks.  \\n  \\n [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]\\n [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]\\n [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]\"\n  syntax:\n    content: public virtual bool IsGenericType { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current type is a generic type; otherwise, `false`.'\n  overload: System.Type.IsGenericType*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsGenericTypeDefinition\n  commentId: P:System.Type.IsGenericTypeDefinition\n  id: IsGenericTypeDefinition\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsGenericTypeDefinition\n  nameWithType: Type.IsGenericTypeDefinition\n  fullName: Type.IsGenericTypeDefinition\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the current <xref href=\"System.Type\"></xref> represents a generic type definition, from which other generic types can be constructed.\n  remarks: \"A generic type definition is a template from which other types can be constructed. For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type. Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.  \\n  \\n Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type. If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.  \\n  \\n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.\"\n  example:\n  - \"The following example displays information about a type, including whether or not it is a generic type definition. Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.  \\n  \\n [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]\\n [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]\\n [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual bool IsGenericTypeDefinition { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> object represents a generic type definition; otherwise, `false`.'\n  overload: System.Type.IsGenericTypeDefinition*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsImport\n  commentId: P:System.Type.IsImport\n  id: IsImport\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsImport\n  nameWithType: Type.IsImport\n  fullName: Type.IsImport\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> has a <xref href=\"System.Runtime.InteropServices.ComImportAttribute\"></xref> attribute applied, indicating that it was imported from a COM type library.\n  remarks: \"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.\"\n  syntax:\n    content: public bool IsImport { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> has a <xref href=\"System.Runtime.InteropServices.ComImportAttribute\"></xref>; otherwise, `false`.'\n  overload: System.Type.IsImport*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsInstanceOfType(System.Object)\n  commentId: M:System.Type.IsInstanceOfType(System.Object)\n  id: IsInstanceOfType(System.Object)\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsInstanceOfType(Object)\n  nameWithType: Type.IsInstanceOfType(Object)\n  fullName: Type.IsInstanceOfType(Object)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Determines whether the specified object is an instance of the current <xref href=\"System.Type\"></xref>.\n  remarks: \"This method can be overridden by a derived class.  \\n  \\n> [!NOTE]\\n>  A constructed type is not an instance of its generic type definition. That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).\"\n  example:\n  - \"The following example demonstrates the use of the `IsInstanceOfType` method.  \\n  \\n [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]\\n [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]\\n [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]\"\n  syntax:\n    content: public virtual bool IsInstanceOfType (object o);\n    parameters:\n    - id: o\n      type: System.Object\n      description: The object to compare with the current type.\n    return:\n      type: System.Boolean\n      description: '`true` if the current `Type` is in the inheritance hierarchy of the object represented by <code>o</code>, or if the current `Type` is an interface that <code>o</code> implements. `false` if neither of these conditions is the case, if <code>o</code> is `null`, or if the current `Type` is an open generic type (that is, <xref href=\"System.Type.ContainsGenericParameters\"></xref> returns `true`).'\n  overload: System.Type.IsInstanceOfType*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsInterface\n  commentId: P:System.Type.IsInterface\n  id: IsInterface\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsInterface\n  nameWithType: Type.IsInterface\n  fullName: Type.IsInterface\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is an interface; that is, not a class or a value type.\n  remarks: \"The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.  \\n  \\n This property is read-only.\"\n  example:\n  - \"The following example creates an interface, checks for the interface type, and indicates whether a class has the `IsInterface` property set.  \\n  \\n [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]\\n [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]\\n [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]\"\n  syntax:\n    content: >-\n      [get: System.Security.SecuritySafeCritical]\n\n      public bool IsInterface { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is an interface; otherwise, `false`.'\n  overload: System.Type.IsInterface*\n  exceptions: []\n  attributes:\n  - type: 'get: System.Security.SecuritySafeCritical'\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsLayoutSequential\n  commentId: P:System.Type.IsLayoutSequential\n  id: IsLayoutSequential\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsLayoutSequential\n  nameWithType: Type.IsLayoutSequential\n  fullName: Type.IsLayoutSequential\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.\n  remarks: \"This property is provided as a convenience. Alternatively, you can use the <xref:System.Reflection.TypeAttributes?displayProperty=fullName>enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes?displayProperty=fullName> is set. The <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, <xref:System.Reflection.TypeAttributes?displayProperty=fullName>, and <xref:System.Reflection.TypeAttributes?displayProperty=fullName> enumeration values indicate the way the fields of the type are laid out in memory.  \\n  \\n For dynamic types, you can specify <xref:System.Reflection.TypeAttributes?displayProperty=fullName> when you create the type. In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName> enumeration value to the type, to specify that layout is sequential.  \\n  \\n> [!NOTE]\\n>  You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.  \\n  \\n For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, \\\"Partition II: Metadata Definition and Semantics\\\". The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](http://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](http://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.\"\n  example:\n  - \"The following example creates an instance of a class for which the <xref:System.Runtime.InteropServices.LayoutKind?displayProperty=fullName>enumeration value in the <xref:System.Runtime.InteropServices.StructLayoutAttribute> class has been set, checks for the <xref:System.Type.IsLayoutSequential%2A> property, and displays the result.  \\n  \\n [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]\\n [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]\\n [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]\"\n  syntax:\n    content: public bool IsLayoutSequential { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type.Attributes\"></xref> property of the current type includes <xref href=\"System.Reflection.TypeAttributes.SequentialLayout\"></xref>; otherwise, `false`.'\n  overload: System.Type.IsLayoutSequential*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsMarshalByRef\n  commentId: P:System.Type.IsMarshalByRef\n  id: IsMarshalByRef\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsMarshalByRef\n  nameWithType: Type.IsMarshalByRef\n  fullName: Type.IsMarshalByRef\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is marshaled by reference.\n  remarks: ''\n  example:\n  - \"The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class. It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.  \\n  \\n [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]\\n [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]\\n [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]\"\n  syntax:\n    content: public bool IsMarshalByRef { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is marshaled by reference; otherwise, `false`.'\n  overload: System.Type.IsMarshalByRef*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsMarshalByRefImpl\n  commentId: M:System.Type.IsMarshalByRefImpl\n  id: IsMarshalByRefImpl\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsMarshalByRefImpl()\n  nameWithType: Type.IsMarshalByRefImpl()\n  fullName: Type.IsMarshalByRefImpl()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Implements the <xref href=\"System.Type.IsMarshalByRef\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is marshaled by reference.\n  remarks: This method can be overridden by a derived class.\n  example:\n  - \"The following example determines whether the given type is marshaled by reference and displays the result.  \\n  \\n [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]\\n [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]\\n [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]\"\n  syntax:\n    content: protected virtual bool IsMarshalByRefImpl ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is marshaled by reference; otherwise, `false`.'\n  overload: System.Type.IsMarshalByRefImpl*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsNested\n  commentId: P:System.Type.IsNested\n  id: IsNested\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsNested\n  nameWithType: Type.IsNested\n  fullName: Type.IsNested\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets a value indicating whether the current <xref href=\"System.Type\"></xref> object represents a type whose definition is nested inside the definition of another type.\n  remarks: \"The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility. To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.  \\n  \\n> [!NOTE]\\n>  The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.\"\n  example:\n  - \"The following example creates an outer class with a number of nested classes that have various types of visibility. It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.  \\n  \\n [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]\\n [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]\"\n  syntax:\n    content: public bool IsNested { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is nested inside another type; otherwise, `false`.'\n  overload: System.Type.IsNested*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsNestedAssembly\n  commentId: P:System.Type.IsNestedAssembly\n  id: IsNestedAssembly\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsNestedAssembly\n  nameWithType: Type.IsNestedAssembly\n  fullName: Type.IsNestedAssembly\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and visible only within its own assembly.\n  remarks: \"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.  \\n  \\n <xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.\"\n  example:\n  - \"The following example creates an outer class with a number of nested classes that have various types of visibility. It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.  \\n  \\n [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]\\n [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]\"\n  syntax:\n    content: public bool IsNestedAssembly { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is nested and visible only within its own assembly; otherwise, `false`.'\n  overload: System.Type.IsNestedAssembly*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsNestedFamANDAssem\n  commentId: P:System.Type.IsNestedFamANDAssem\n  id: IsNestedFamANDAssem\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsNestedFamANDAssem\n  nameWithType: Type.IsNestedFamANDAssem\n  fullName: Type.IsNestedFamANDAssem\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and visible only to classes that belong to both its own family and its own assembly.\n  remarks: \"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.  \\n  \\n <xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.  \\n  \\n> [!NOTE]\\n>  The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly. `protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.  \\n  \\n A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.\"\n  example:\n  - \"The following example creates an outer class with a number of nested classes that have various types of visibility. It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.  \\n  \\n [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]\\n [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]\"\n  syntax:\n    content: public bool IsNestedFamANDAssem { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, `false`.'\n  overload: System.Type.IsNestedFamANDAssem*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsNestedFamily\n  commentId: P:System.Type.IsNestedFamily\n  id: IsNestedFamily\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsNestedFamily\n  nameWithType: Type.IsNestedFamily\n  fullName: Type.IsNestedFamily\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and visible only within its own family.\n  remarks: \"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.  \\n  \\n <xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.  \\n  \\n A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.\"\n  example:\n  - \"The following example creates an outer class with a number of nested classes that have various types of visibility. It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.  \\n  \\n [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]\\n [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]\"\n  syntax:\n    content: public bool IsNestedFamily { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is nested and visible only within its own family; otherwise, `false`.'\n  overload: System.Type.IsNestedFamily*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsNestedFamORAssem\n  commentId: P:System.Type.IsNestedFamORAssem\n  id: IsNestedFamORAssem\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsNestedFamORAssem\n  nameWithType: Type.IsNestedFamORAssem\n  fullName: Type.IsNestedFamORAssem\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and visible only to classes that belong to either its own family or to its own assembly.\n  remarks: \"If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`.  \\n  \\n If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.  \\n  \\n <xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.  \\n  \\n A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.\"\n  example:\n  - \"The following example creates an outer class with a number of nested classes that have various types of visibility. It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.  \\n  \\n [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]\\n [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]\"\n  syntax:\n    content: public bool IsNestedFamORAssem { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, `false`.'\n  overload: System.Type.IsNestedFamORAssem*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsNestedPrivate\n  commentId: P:System.Type.IsNestedPrivate\n  id: IsNestedPrivate\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsNestedPrivate\n  nameWithType: Type.IsNestedPrivate\n  fullName: Type.IsNestedPrivate\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is nested and declared private.\n  remarks: \"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.  \\n  \\n <xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.\"\n  example:\n  - \"The following example creates an outer class with a number of nested classes that have various types of visibility. It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.  \\n  \\n [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]\\n [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]\"\n  syntax:\n    content: public bool IsNestedPrivate { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is nested and declared private; otherwise, `false`.'\n  overload: System.Type.IsNestedPrivate*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsNestedPublic\n  commentId: P:System.Type.IsNestedPublic\n  id: IsNestedPublic\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsNestedPublic\n  nameWithType: Type.IsNestedPublic\n  fullName: Type.IsNestedPublic\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether a class is nested and declared public.\n  remarks: \"If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.  \\n  \\n <xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.\"\n  example:\n  - \"The following example creates an outer class with a number of nested classes that have various types of visibility. It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.  \\n  \\n [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]\\n [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]\"\n  syntax:\n    content: public bool IsNestedPublic { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the class is nested and declared public; otherwise, `false`.'\n  overload: System.Type.IsNestedPublic*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsNotPublic\n  commentId: P:System.Type.IsNotPublic\n  id: IsNotPublic\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsNotPublic\n  nameWithType: Type.IsNotPublic\n  fullName: Type.IsNotPublic\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is not declared public.\n  remarks: \"Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.  \\n  \\n If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`.\"\n  example:\n  - \"This example usesthe `IsNotPublic` property to get the visibility of the type.  \\n  \\n [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]\\n [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  \\n  \\n The following code example demonstrates why you cannot use `IsPublic` and `IsNotPublic` for nested classes.  \\n  \\n [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]\\n [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]\\n [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  \\n  \\n For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of `IsNestedPublic` and `IsNestedPrivate`. The reflection output for this code fragment would be as follows:  \\n  \\n|Class|IsNotPublic|IsPublic|IsNestedPublic|IsNestedPrivate|  \\n|-----------|-----------------|--------------|--------------------|---------------------|  \\n|A|FALSE|TRUE|FALSE|FALSE|  \\n|B|FALSE|FALSE|TRUE|FALSE|  \\n|C|FALSE|FALSE|FALSE|TRUE|\"\n  syntax:\n    content: public bool IsNotPublic { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is not declared public and is not a nested type; otherwise, `false`.'\n  overload: System.Type.IsNotPublic*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsPointer\n  commentId: P:System.Type.IsPointer\n  id: IsPointer\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsPointer\n  nameWithType: Type.IsPointer\n  fullName: Type.IsPointer\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is a pointer.\n  remarks: \"If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.  \\n  \\n This property is read-only.\"\n  example:\n  - \"The following example shows a use of the `IsPointer` property.  \\n  \\n [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]\\n [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]\\n [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]\"\n  syntax:\n    content: public bool IsPointer { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is a pointer; otherwise, `false`.'\n  overload: System.Type.IsPointer*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsPointerImpl\n  commentId: M:System.Type.IsPointerImpl\n  id: IsPointerImpl\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsPointerImpl()\n  nameWithType: Type.IsPointerImpl()\n  fullName: Type.IsPointerImpl()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, implements the <xref href=\"System.Type.IsPointer\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is a pointer.\n  syntax:\n    content: protected abstract bool IsPointerImpl ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is a pointer; otherwise, `false`.'\n  overload: System.Type.IsPointerImpl*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsPrimitive\n  commentId: P:System.Type.IsPrimitive\n  id: IsPrimitive\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsPrimitive\n  nameWithType: Type.IsPrimitive\n  fullName: Type.IsPrimitive\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is one of the primitive types.\n  remarks: \"The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.  \\n  \\n If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.\"\n  example:\n  - \"The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class. It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.  \\n  \\n [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]\\n [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]\\n [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]\"\n  syntax:\n    content: public bool IsPrimitive { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is one of the primitive types; otherwise, `false`.'\n  overload: System.Type.IsPrimitive*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsPrimitiveImpl\n  commentId: M:System.Type.IsPrimitiveImpl\n  id: IsPrimitiveImpl\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsPrimitiveImpl()\n  nameWithType: Type.IsPrimitiveImpl()\n  fullName: Type.IsPrimitiveImpl()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: When overridden in a derived class, implements the <xref href=\"System.Type.IsPrimitive\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is one of the primitive types.\n  remarks: The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.\n  example:\n  - \"The following example determines whether the given type is a primitive type and displays the result.  \\n  \\n [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]\\n [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]\\n [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]\"\n  syntax:\n    content: protected abstract bool IsPrimitiveImpl ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is one of the primitive types; otherwise, `false`.'\n  overload: System.Type.IsPrimitiveImpl*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsPublic\n  commentId: P:System.Type.IsPublic\n  id: IsPublic\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsPublic\n  nameWithType: Type.IsPublic\n  fullName: Type.IsPublic\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is declared public.\n  remarks: \"Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.  \\n  \\n If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`.  \\n  \\n <xref:System.Reflection.TypeAttributes?displayProperty=fullName> selects the visibility attributes.\"\n  example:\n  - \"The following example creates an instance of `MyTestClass`, checks for the `IsPublic` property, and displays the result.  \\n  \\n [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]\\n [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]\\n [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  \\n  \\n For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of <xref:System.Type.IsNestedPublic%2A> and <xref:System.Type.IsNestedPrivate%2A>.\"\n  syntax:\n    content: public bool IsPublic { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is declared public and is not a nested type; otherwise, `false`.'\n  overload: System.Type.IsPublic*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsSealed\n  commentId: P:System.Type.IsSealed\n  id: IsSealed\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsSealed\n  nameWithType: Type.IsSealed\n  fullName: Type.IsSealed\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is declared sealed.\n  remarks: If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`.\n  example:\n  - \"The following example creates an instance of a `sealed` class, checks for the `IsSealed` property, and displays the result.  \\n  \\n [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]\\n [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]\\n [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]\"\n  syntax:\n    content: public bool IsSealed { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is declared sealed; otherwise, `false`.'\n  overload: System.Type.IsSealed*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsSecurityCritical\n  commentId: P:System.Type.IsSecurityCritical\n  id: IsSecurityCritical\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsSecurityCritical\n  nameWithType: Type.IsSecurityCritical\n  fullName: Type.IsSecurityCritical\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.\n  remarks: \"The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  \\n  \\n|Security level|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  \\n|--------------------|------------------------|----------------------------|---------------------------|  \\n|Critical|`true`|`false`|`false`|  \\n|Safe critical|`true`|`true`|`false`|  \\n|Transparent|`false`|`false`|`true`|  \\n  \\n Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.  \\n  \\n> [!IMPORTANT]\\n>  For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.  \\n  \\n For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).\"\n  syntax:\n    content: public virtual bool IsSecurityCritical { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current type is security-critical or security-safe-critical at the current trust level; `false` if it is transparent.'\n  overload: System.Type.IsSecurityCritical*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsSecuritySafeCritical\n  commentId: P:System.Type.IsSecuritySafeCritical\n  id: IsSecuritySafeCritical\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsSecuritySafeCritical\n  nameWithType: Type.IsSecuritySafeCritical\n  fullName: Type.IsSecuritySafeCritical\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.\n  remarks: \"The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). The combinations of these properties are shown in the following table:  \\n  \\n|Security level|IsSecurityCritical|IsSecuritySafeCritical|IsSecurityTransparent|  \\n|--------------------|------------------------|----------------------------|---------------------------|  \\n|Critical|`true`|`false`|`false`|  \\n|Safe critical|`true`|`true`|`false`|  \\n|Transparent|`false`|`false`|`true`|  \\n  \\n Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.  \\n  \\n> [!IMPORTANT]\\n>  For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.  \\n  \\n For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).\"\n  syntax:\n    content: public virtual bool IsSecuritySafeCritical { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current type is security-safe-critical at the current trust level; `false` if it is security-critical or transparent.'\n  overload: System.Type.IsSecuritySafeCritical*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsSecurityTransparent\n  commentId: P:System.Type.IsSecurityTransparent\n  id: IsSecurityTransparent\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsSecurityTransparent\n  nameWithType: Type.IsSecurityTransparent\n  fullName: Type.IsSecurityTransparent\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.\n  remarks: \"If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`.  \\n  \\n The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR). Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.  \\n  \\n> [!IMPORTANT]\\n>  For partial-trust assemblies, the value of this property depends on the current trust level of the assembly. If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly. The assembly and all its types are treated as transparent. The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application). By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted. You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=fullName> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=fullName> properties.  \\n  \\n For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md). For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).\"\n  syntax:\n    content: public virtual bool IsSecurityTransparent { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the type is security-transparent at the current trust level; otherwise, `false`.'\n  overload: System.Type.IsSecurityTransparent*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsSerializable\n  commentId: P:System.Type.IsSerializable\n  id: IsSerializable\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsSerializable\n  nameWithType: Type.IsSerializable\n  fullName: Type.IsSerializable\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is serializable.\n  remarks: \"If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.\"\n  example:\n  - \"The following example creates an instance of `MyTestClass` class, sets the [Serializable] attribute, and checks the `IsSerializable` property for `true` or `false`.  \\n  \\n [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]\\n [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]\\n [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]\"\n  syntax:\n    content: public virtual bool IsSerializable { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is serializable; otherwise, `false`.'\n  overload: System.Type.IsSerializable*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsSpecialName\n  commentId: P:System.Type.IsSpecialName\n  id: IsSpecialName\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsSpecialName\n  nameWithType: Type.IsSpecialName\n  fullName: Type.IsSpecialName\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the type has a name that requires special handling.\n  remarks: \"Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.\"\n  syntax:\n    content: public bool IsSpecialName { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the type has a name that requires special handling; otherwise, `false`.'\n  overload: System.Type.IsSpecialName*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsSubclassOf(System.Type)\n  commentId: M:System.Type.IsSubclassOf(System.Type)\n  id: IsSubclassOf(System.Type)\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsSubclassOf(Type)\n  nameWithType: Type.IsSubclassOf(Type)\n  fullName: Type.IsSubclassOf(Type)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Determines whether the current <xref href=\"System.Type\"></xref> derives from the specified <xref href=\"System.Type\"></xref>.\n  remarks: \"You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:  \\n  \\n-   Whether one class derives from another.  \\n  \\n-   Whether a type derives from <xref:System.ValueType>. However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.  \\n  \\n-   Whether a type derives from <xref:System.Enum>. However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.  \\n  \\n-   Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.  \\n  \\n The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface. Use the<xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.  \\n  \\n [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]\\n [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=fullName> if it has no class constraint.  \\n  \\n> [!NOTE]\\n>  Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>. That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.  \\n  \\n This method can be overridden by a derived class.\"\n  example:\n  - \"The following example creates a class named `Class1` and a derived class named `DerivedC1`. It calls the <xref:System.Type.IsSubclassOf%2A> method to show that `DerivedC1` is a subclass of `Class1`.  \\n  \\n [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]\\n [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public virtual bool IsSubclassOf (Type c);\n    parameters:\n    - id: c\n      type: System.Type\n      description: The type to compare with the current type.\n    return:\n      type: System.Boolean\n      description: '`true` if the current `Type` derives from <code>c</code>; otherwise, `false`. This method also returns `false` if <code>c</code> and the current `Type` are equal.'\n  overload: System.Type.IsSubclassOf*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>c</code> is `null`.\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsSZArray\n  commentId: P:System.Type.IsSZArray\n  id: IsSZArray\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsSZArray\n  nameWithType: Type.IsSZArray\n  fullName: Type.IsSZArray\n  type: Property\n  assemblies:\n  - System.Runtime\n  namespace: System\n  syntax:\n    content: public virtual bool IsSZArray { get; }\n    return:\n      type: System.Boolean\n      description: ''\n  overload: System.Type.IsSZArray*\n  exceptions: []\n  version:\n  - netcore-2.0\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsTypeDefinition\n  commentId: P:System.Type.IsTypeDefinition\n  id: IsTypeDefinition\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsTypeDefinition\n  nameWithType: Type.IsTypeDefinition\n  fullName: Type.IsTypeDefinition\n  type: Property\n  assemblies:\n  - System.Runtime\n  namespace: System\n  syntax:\n    content: public virtual bool IsTypeDefinition { get; }\n    return:\n      type: System.Boolean\n      description: ''\n  overload: System.Type.IsTypeDefinition*\n  exceptions: []\n  version:\n  - netcore-2.0\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsUnicodeClass\n  commentId: P:System.Type.IsUnicodeClass\n  id: IsUnicodeClass\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsUnicodeClass\n  nameWithType: Type.IsUnicodeClass\n  fullName: Type.IsUnicodeClass\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the string format attribute `UnicodeClass` is selected for the <xref href=\"System.Type\"></xref>.\n  remarks: \"The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes. The string format attributes enhance interoperability by defining how strings should be interpreted.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.\"\n  syntax:\n    content: public bool IsUnicodeClass { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the string format attribute `UnicodeClass` is selected for the <xref href=\"System.Type\"></xref>; otherwise, `false`.'\n  overload: System.Type.IsUnicodeClass*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsValueType\n  commentId: P:System.Type.IsValueType\n  id: IsValueType\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsValueType\n  nameWithType: Type.IsValueType\n  fullName: Type.IsValueType\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> is a value type.\n  remarks: \"Value types are types that are represented as sequences of bits; value types are not classes or interfaces. Value types are referred to as \\\"structs\\\" in some programming languages. Enums are a special case of value types.  \\n  \\n This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself. It is the base class for all value types, and therefore any value type can be assigned to it. This would not be possible if <xref:System.ValueType> itself was a value type. Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.  \\n  \\n This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself. For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.  \\n  \\n This property is read-only.\"\n  example:\n  - \"The following example creates a variable of type `MyEnum`, checks for the `IsValueType` property, and displays the result.  \\n  \\n [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]\\n [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]\\n [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]\"\n  syntax:\n    content: public bool IsValueType { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is a value type; otherwise, `false`.'\n  overload: System.Type.IsValueType*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsValueTypeImpl\n  commentId: M:System.Type.IsValueTypeImpl\n  id: IsValueTypeImpl\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsValueTypeImpl()\n  nameWithType: Type.IsValueTypeImpl()\n  fullName: Type.IsValueTypeImpl()\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Implements the <xref href=\"System.Type.IsValueType\"></xref> property and determines whether the <xref href=\"System.Type\"></xref> is a value type; that is, not a class or an interface.\n  remarks: This method is provided to enable the implementation of alternate type systems. It is not generally used in application code.\n  syntax:\n    content: protected virtual bool IsValueTypeImpl ();\n    parameters: []\n    return:\n      type: System.Boolean\n      description: '`true` if the <xref href=\"System.Type\"></xref> is a value type; otherwise, `false`.'\n  overload: System.Type.IsValueTypeImpl*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.IsVariableBoundArray\n  commentId: P:System.Type.IsVariableBoundArray\n  id: IsVariableBoundArray\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsVariableBoundArray\n  nameWithType: Type.IsVariableBoundArray\n  fullName: Type.IsVariableBoundArray\n  type: Property\n  assemblies:\n  - System.Runtime\n  namespace: System\n  syntax:\n    content: public virtual bool IsVariableBoundArray { get; }\n    return:\n      type: System.Boolean\n      description: ''\n  overload: System.Type.IsVariableBoundArray*\n  exceptions: []\n  version:\n  - netcore-2.0\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsVisible\n  commentId: P:System.Type.IsVisible\n  id: IsVisible\n  parent: System.Type\n  langs:\n  - csharp\n  name: IsVisible\n  nameWithType: Type.IsVisible\n  fullName: Type.IsVisible\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a value indicating whether the <xref href=\"System.Type\"></xref> can be accessed by code outside the assembly.\n  remarks: Use this property to determine whether a type is part of the public interface of a component assembly.\n  example:\n  - \"The following code example tests two classes, only one of which is visible outside the assembly.  \\n  \\n [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]\\n [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]\\n [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]\"\n  syntax:\n    content: public bool IsVisible { get; }\n    return:\n      type: System.Boolean\n      description: '`true` if the current <xref href=\"System.Type\"></xref> is a public type or a public nested type such that all the enclosing types are public; otherwise, `false`.'\n  overload: System.Type.IsVisible*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.MakeArrayType(System.Int32)\n  commentId: M:System.Type.MakeArrayType(System.Int32)\n  id: MakeArrayType(System.Int32)\n  parent: System.Type\n  langs:\n  - csharp\n  name: MakeArrayType(Int32)\n  nameWithType: Type.MakeArrayType(Int32)\n  fullName: Type.MakeArrayType(Int32)\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns a <xref href=\"System.Type\"></xref> object representing an array of the current type, with the specified number of dimensions.\n  remarks: \"The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.  \\n  \\n> [!NOTE]\\n>  The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays. A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension. You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension. Use the <xref:System.Type.MakeArrayType> method overload to create vector types.\"\n  example:\n  - \"The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.  \\n  \\n [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]\\n [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]\\n [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual Type MakeArrayType (int rank);\n    parameters:\n    - id: rank\n      type: System.Int32\n      description: The number of dimensions for the array. This number must be less than or equal to 32.\n    return:\n      type: System.Type\n      description: An object representing an array of the current type, with the specified number of dimensions.\n  overload: System.Type.MakeArrayType*\n  exceptions:\n  - type: System.IndexOutOfRangeException\n    commentId: T:System.IndexOutOfRangeException\n    description: <code>rank</code> is invalid. For example, 0 or negative.\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The invoked method is not supported in the base class.\n  - type: System.TypeLoadException\n    commentId: T:System.TypeLoadException\n    description: \"The current type is <xref href=\\\"System.TypedReference\\\"></xref>.  \\n  \\n -or-  \\n  \\n The current type is a `ByRef` type. That is, <xref href=\\\"System.Type.IsByRef\\\"></xref> returns `true`.  \\n  \\n -or-  \\n  \\n <code>rank</code> is greater than 32.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.MakeArrayType\n  commentId: M:System.Type.MakeArrayType\n  id: MakeArrayType\n  parent: System.Type\n  langs:\n  - csharp\n  name: MakeArrayType()\n  nameWithType: Type.MakeArrayType()\n  fullName: Type.MakeArrayType()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns a <xref href=\"System.Type\"></xref> object representing a one-dimensional array of the current type, with a lower bound of zero.\n  remarks: \"The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.  \\n  \\n **Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays. A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension. This method overload can only be used to create vector types, and it is the only way to create a vector type. Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.\"\n  example:\n  - \"The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.  \\n  \\n [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]\\n [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]\\n [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual Type MakeArrayType ();\n    parameters: []\n    return:\n      type: System.Type\n      description: A <xref href=\"System.Type\"></xref> object representing a one-dimensional array of the current type, with a lower bound of zero.\n  overload: System.Type.MakeArrayType*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The invoked method is not supported in the base class. Derived classes must provide an implementation.\n  - type: System.TypeLoadException\n    commentId: T:System.TypeLoadException\n    description: \"The current type is <xref href=\\\"System.TypedReference\\\"></xref>.  \\n  \\n -or-  \\n  \\n The current type is a `ByRef` type. That is, <xref href=\\\"System.Type.IsByRef\\\"></xref> returns `true`.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.MakeByRefType\n  commentId: M:System.Type.MakeByRefType\n  id: MakeByRefType\n  parent: System.Type\n  langs:\n  - csharp\n  name: MakeByRefType()\n  nameWithType: Type.MakeByRefType()\n  fullName: Type.MakeByRefType()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns a <xref href=\"System.Type\"></xref> object that represents the current type when passed as a `ref` parameter (`ByRef` parameter in Visual Basic).\n  remarks: \"The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.  \\n  \\n Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`.\"\n  example:\n  - \"The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.  \\n  \\n [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]\\n [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]\\n [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual Type MakeByRefType ();\n    parameters: []\n    return:\n      type: System.Type\n      description: A <xref href=\"System.Type\"></xref> object that represents the current type when passed as a `ref` parameter (`ByRef` parameter in Visual Basic).\n  overload: System.Type.MakeByRefType*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The invoked method is not supported in the base class.\n  - type: System.TypeLoadException\n    commentId: T:System.TypeLoadException\n    description: \"The current type is <xref href=\\\"System.TypedReference\\\"></xref>.  \\n  \\n -or-  \\n  \\n The current type is a `ByRef` type. That is, <xref href=\\\"System.Type.IsByRef\\\"></xref> returns `true`.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.MakeGenericType(System.Type[])\n  commentId: M:System.Type.MakeGenericType(System.Type[])\n  id: MakeGenericType(System.Type[])\n  parent: System.Type\n  langs:\n  - csharp\n  name: MakeGenericType(Type[])\n  nameWithType: Type.MakeGenericType(Type[])\n  fullName: Type.MakeGenericType(Type[])\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <xref href=\"System.Type\"></xref> object representing the resulting constructed type.\n  remarks: \"The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type. You can use this <xref:System.Type> object to create run-time instances of the constructed type.  \\n  \\n Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types. You might use such open constructed types when you emit dynamic assemblies. For example, consider the classes `Base` and `Derived` in the following code.  \\n  \\n [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]\\n [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]\\n [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  \\n  \\n To generate `Derived` in a dynamic assembly, it is necessary to construct its base type. To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`. Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.  \\n  \\n> [!NOTE]\\n>  A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition. To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.  \\n  \\n The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A>method of any constructed type that was created from the same generic type definition using the same type arguments.  \\n  \\n> [!NOTE]\\n>  An array of generic types is not itself a generic type. You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic). To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type. The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).  \\n  \\n For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.  \\n  \\n## Nested Types  \\n If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic. This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types. Consider the following classes:  \\n  \\n [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]\\n [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]\\n [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  \\n  \\n The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class. Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes. The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.  \\n  \\n If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.  \\n  \\n To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own. To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.  \\n  \\n The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types. Otherwise, the type parameters would not be in scope within the bodies of the nested types. It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md). Consider the following code for the MSIL assembler:  \\n  \\n```  \\n.class public Outer<T> {  \\n    .class nested public Inner<U> {  \\n        .class nested public Innermost {  \\n        }  \\n    }  \\n}  \\n```  \\n  \\n In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope. The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:  \\n  \\n```  \\n.class public Outer<T> {  \\n    .class nested public Inner<T, U> {  \\n        .class nested public Innermost<T, U, V> {  \\n        }  \\n    }  \\n}  \\n```  \\n  \\n You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme.\"\n  example:\n  - \"The following example uses the <xref:System.Type.MakeGenericType%2A> method to create a constructed type from the generic type definition for the <xref:System.Collections.Generic.Dictionary%602> type. The constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.  \\n  \\n [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]\\n [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]\\n [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual Type MakeGenericType (Type[] typeArguments);\n    parameters:\n    - id: typeArguments\n      type: System.Type[]\n      description: An array of types to be substituted for the type parameters of the current generic type.\n    return:\n      type: System.Type\n      description: A <xref href=\"System.Type\"></xref> representing the constructed type formed by substituting the elements of <code>typeArguments</code> for the type parameters of the current generic type.\n  overload: System.Type.MakeGenericType*\n  exceptions:\n  - type: System.InvalidOperationException\n    commentId: T:System.InvalidOperationException\n    description: The current type does not represent a generic type definition. That is, <xref href=\"System.Type.IsGenericTypeDefinition\"></xref> returns `false`.\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: \"<code>typeArguments</code> is `null`.  \\n  \\n -or-  \\n  \\n Any element of <code>typeArguments</code> is `null`.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"The number of elements in <code>typeArguments</code> is not the same as the number of type parameters in the current generic type definition.  \\n  \\n -or-  \\n  \\n Any element of <code>typeArguments</code> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.  \\n  \\n -or-  \\n  \\n <code>typeArguments</code> contains an element that is a pointer type (<xref href=\\\"System.Type.IsPointer\\\"></xref> returns `true`), a by-ref type (<xref href=\\\"System.Type.IsByRef\\\"></xref> returns `true`), or <xref href=\\\"System.Void\\\"></xref>.\"\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The invoked method is not supported in the base class. Derived classes must provide an implementation.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.MakePointerType\n  commentId: M:System.Type.MakePointerType\n  id: MakePointerType\n  parent: System.Type\n  langs:\n  - csharp\n  name: MakePointerType()\n  nameWithType: Type.MakePointerType()\n  fullName: Type.MakePointerType()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns a <xref href=\"System.Type\"></xref> object that represents a pointer to the current type.\n  remarks: \"The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.  \\n  \\n Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`.\"\n  example:\n  - \"The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.  \\n  \\n [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]\\n [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]\\n [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual Type MakePointerType ();\n    parameters: []\n    return:\n      type: System.Type\n      description: A <xref href=\"System.Type\"></xref> object that represents a pointer to the current type.\n  overload: System.Type.MakePointerType*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The invoked method is not supported in the base class.\n  - type: System.TypeLoadException\n    commentId: T:System.TypeLoadException\n    description: \"The current type is <xref href=\\\"System.TypedReference\\\"></xref>.  \\n  \\n -or-  \\n  \\n The current type is a `ByRef` type. That is, <xref href=\\\"System.Type.IsByRef\\\"></xref> returns `true`.\"\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.MemberType\n  commentId: P:System.Type.MemberType\n  id: MemberType\n  parent: System.Type\n  langs:\n  - csharp\n  name: MemberType\n  nameWithType: Type.MemberType\n  fullName: Type.MemberType\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a <xref href=\"System.Reflection.MemberTypes\"></xref> value indicating that this member is a type or a nested type.\n  remarks: \"This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=fullName>. Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objectsfor example, the array returned by <xref:System.Type.GetMembers%2A>the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes?displayProperty=fullName> when a given member is a nested type.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed. For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns<xref:System.Reflection.MemberTypes?displayProperty=fullName>.\"\n  example:\n  - \"The following code example shows the `MemberType` field as a parameter to the `GetMember` method:  \\n  \\n [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]\\n [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]\"\n  syntax:\n    content: public override System.Reflection.MemberTypes MemberType { get; }\n    return:\n      type: System.Reflection.MemberTypes\n      description: A <xref href=\"System.Reflection.MemberTypes\"></xref> value indicating that this member is a type or a nested type.\n  overload: System.Type.MemberType*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.Missing\n  commentId: F:System.Type.Missing\n  id: Missing\n  parent: System.Type\n  langs:\n  - csharp\n  name: Missing\n  nameWithType: Type.Missing\n  fullName: Type.Missing\n  type: Field\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Represents a missing value in the <xref href=\"System.Type\"></xref> information. This field is read-only.\n  remarks: Use the `Missing` field for invocation through reflection to obtain the default value of a parameter. If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.\n  example:\n  - \"The following code example shows the use of the `Missing` field to invoke a method with its default arguments.  \\n  \\n [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]\\n [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]\\n [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  \\n  \\n This code produces the following output:  \\n  \\n a = 10 b = 55.3 c = 12  \\n  \\n a = 10 b = 1.3 c = 1  \\n  \\n a = 10 b = 1.2 c = 1\"\n  syntax:\n    content: public static readonly object Missing;\n    return:\n      type: System.Object\n      description: ''\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.Module\n  commentId: P:System.Type.Module\n  id: Module\n  parent: System.Type\n  langs:\n  - csharp\n  name: Module\n  nameWithType: Type.Module\n  fullName: Type.Module\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the module (the DLL) in which the current <xref href=\"System.Type\"></xref> is defined.\n  remarks: \"If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined. For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.  \\n  \\n Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.\"\n  example:\n  - \"This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and `Module` properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.  \\n  \\n [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]\\n [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]\\n [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]\"\n  syntax:\n    content: public abstract System.Reflection.Module Module { get; }\n    return:\n      type: System.Reflection.Module\n      description: The module in which the current <xref href=\"System.Type\"></xref> is defined.\n  overload: System.Type.Module*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.Name\n  commentId: P:System.Type.Name\n  id: Name\n  parent: System.Type\n  langs:\n  - csharp\n  name: Name\n  nameWithType: Type.Name\n  fullName: Type.Name\n  type: Property\n  assemblies:\n  - System.Runtime\n  namespace: System\n  syntax:\n    content: public abstract string Name { get; }\n    return:\n      type: System.String\n      description: ''\n  overload: System.Type.Name*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.Namespace\n  commentId: P:System.Type.Namespace\n  id: Namespace\n  parent: System.Type\n  langs:\n  - csharp\n  name: Namespace\n  nameWithType: Type.Namespace\n  fullName: Type.Namespace\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets the namespace of the <xref href=\"System.Type\"></xref>.\n  remarks: \"A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure. From the viewpoint of the runtime, there are no namespaces.  \\n  \\n If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition. Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.  \\n  \\n If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.\"\n  example:\n  - \"This following example demonstrates a use of the `Namespace` and <xref:System.Type.Module%2A> properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.  \\n  \\n [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]\\n [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]\\n [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]\"\n  syntax:\n    content: public abstract string Namespace { get; }\n    return:\n      type: System.String\n      description: The namespace of the <xref href=\"System.Type\"></xref>; `null` if the current instance has no namespace or represents a generic parameter.\n  overload: System.Type.Namespace*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.op_Equality(System.Type,System.Type)\n  commentId: M:System.Type.op_Equality(System.Type,System.Type)\n  id: op_Equality(System.Type,System.Type)\n  parent: System.Type\n  langs:\n  - csharp\n  name: op_Equality(Type, Type)\n  nameWithType: Type.op_Equality(Type, Type)\n  fullName: Type.op_Equality(Type, Type)\n  type: Operator\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Indicates whether two <xref href=\"System.Type\"></xref> objects are equal.\n  syntax:\n    content: public static bool op_Equality (Type left, Type right);\n    parameters:\n    - id: left\n      type: System.Type\n      description: The first object to compare.\n    - id: right\n      type: System.Type\n      description: The second object to compare.\n    return:\n      type: System.Boolean\n      description: '`true` if <code>left</code> is equal to <code>right</code>; otherwise, `false`.'\n  overload: System.Type.op_Equality*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.op_Inequality(System.Type,System.Type)\n  commentId: M:System.Type.op_Inequality(System.Type,System.Type)\n  id: op_Inequality(System.Type,System.Type)\n  parent: System.Type\n  langs:\n  - csharp\n  name: op_Inequality(Type, Type)\n  nameWithType: Type.op_Inequality(Type, Type)\n  fullName: Type.op_Inequality(Type, Type)\n  type: Operator\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Indicates whether two <xref href=\"System.Type\"></xref> objects are not equal.\n  syntax:\n    content: public static bool op_Inequality (Type left, Type right);\n    parameters:\n    - id: left\n      type: System.Type\n      description: The first object to compare.\n    - id: right\n      type: System.Type\n      description: The second object to compare.\n    return:\n      type: System.Boolean\n      description: '`true` if <code>left</code> is not equal to <code>right</code>; otherwise, `false`.'\n  overload: System.Type.op_Inequality*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.ReflectedType\n  commentId: P:System.Type.ReflectedType\n  id: ReflectedType\n  parent: System.Type\n  langs:\n  - csharp\n  name: ReflectedType\n  nameWithType: Type.ReflectedType\n  fullName: Type.ReflectedType\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the class object that was used to obtain this member.\n  remarks: For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.\n  example:\n  - \"This example displays the reflected type of a nested class.  \\n  \\n [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]\\n [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]\\n [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]\"\n  syntax:\n    content: public override Type ReflectedType { get; }\n    return:\n      type: System.Type\n      description: The `Type` object through which this <xref href=\"System.Type\"></xref> object was obtained.\n  overload: System.Type.ReflectedType*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)\n  commentId: M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)\n  id: ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)\n  parent: System.Type\n  langs:\n  - csharp\n  name: ReflectionOnlyGetType(String, Boolean, Boolean)\n  nameWithType: Type.ReflectionOnlyGetType(String, Boolean, Boolean)\n  fullName: Type.ReflectionOnlyGetType(String, Boolean, Boolean)\n  type: Method\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the <xref href=\"System.Type\"></xref> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found. The type is loaded for reflection only, not for execution.\n  remarks: \"If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=fullName> method. For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=fullName> property. For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.  \\n  \\n If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.  \\n  \\n The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section. Some exceptions are thrown regardless of the value of `throwIfNotFound`. For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.  \\n  \\n For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).\"\n  syntax:\n    content: public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);\n    parameters:\n    - id: typeName\n      type: System.String\n      description: The assembly-qualified name of the <xref href=\"System.Type\"></xref> to get.\n    - id: throwIfNotFound\n      type: System.Boolean\n      description: '`true` to throw a <xref href=\"System.TypeLoadException\"></xref> if the type cannot be found; `false` to return `null` if the type cannot be found. Specifying `false` also suppresses some other exception conditions, but not all of them. See the Exceptions section.'\n    - id: ignoreCase\n      type: System.Boolean\n      description: '`true` to perform a case-insensitive search for <code>typeName</code>; `false` to perform a case-sensitive search for <code>typeName</code>.'\n    return:\n      type: System.Type\n      description: The type with the specified name, if found; otherwise, `null`. If the type is not found, the <code>throwIfNotFound</code> parameter specifies whether `null` is returned or an exception is thrown. In some cases, an exception is thrown regardless of the value of <code>throwIfNotFound</code>. See the Exceptions section.\n  overload: System.Type.ReflectionOnlyGetType*\n  exceptions:\n  - type: System.ArgumentNullException\n    commentId: T:System.ArgumentNullException\n    description: <code>typeName</code> is `null`.\n  - type: System.Reflection.TargetInvocationException\n    commentId: T:System.Reflection.TargetInvocationException\n    description: A class initializer is invoked and throws an exception.\n  - type: System.TypeLoadException\n    commentId: T:System.TypeLoadException\n    description: \"<code>throwIfNotFound</code> is `true` and the type is not found.  \\n  \\n -or-  \\n  \\n <code>throwIfNotFound</code> is `true` and <code>typeName</code> contains invalid characters, such as an embedded tab.  \\n  \\n -or-  \\n  \\n <code>throwIfNotFound</code> is `true` and <code>typeName</code> is an empty string.  \\n  \\n -or-  \\n  \\n <code>throwIfNotFound</code> is `true` and <code>typeName</code> represents an array type with an invalid size.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents an array of <xref href=\\\"System.TypedReference\\\"></xref> objects.\"\n  - type: System.ArgumentException\n    commentId: T:System.ArgumentException\n    description: \"<code>typeName</code> does not include the assembly name.  \\n  \\n -or-  \\n  \\n <code>throwIfNotFound</code> is `true` and <code>typeName</code> contains invalid syntax; for example, \\\"MyType[,*,]\\\".  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type that has a pointer type, a `ByRef` type, or <xref href=\\\"System.Void\\\"></xref> as one of its type arguments.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type that has an incorrect number of type arguments.  \\n  \\n -or-  \\n  \\n <code>typeName</code> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.\"\n  - type: System.IO.FileNotFoundException\n    commentId: T:System.IO.FileNotFoundException\n    description: <code>throwIfNotFound</code> is `true` and the assembly or one of its dependencies was not found.\n  - type: System.IO.FileLoadException\n    commentId: T:System.IO.FileLoadException\n    description: The assembly or one of its dependencies was found, but could not be loaded.\n  - type: System.BadImageFormatException\n    commentId: T:System.BadImageFormatException\n    description: \"The assembly or one of its dependencies is not valid.  \\n  \\n -or-  \\n  \\n The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.\"\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.StructLayoutAttribute\n  commentId: P:System.Type.StructLayoutAttribute\n  id: StructLayoutAttribute\n  parent: System.Type\n  langs:\n  - csharp\n  name: StructLayoutAttribute\n  nameWithType: Type.StructLayoutAttribute\n  fullName: Type.StructLayoutAttribute\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets a <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"></xref> that describes the layout of the current type.\n  remarks: <xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method. Instead, use this property to get it.\n  example:\n  - \"The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class). The example then uses the <xref:System.Type.StructLayoutAttribute%2A> property to obtain a <xref:System.Runtime.InteropServices.StructLayoutAttribute> for each type, and displays the properties of the attributes.  \\n  \\n [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]\\n [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]\\n [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]\"\n  syntax:\n    content: public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }\n    return:\n      type: System.Runtime.InteropServices.StructLayoutAttribute\n      description: Gets a <xref href=\"System.Runtime.InteropServices.StructLayoutAttribute\"></xref> that describes the gross layout features of the current type.\n  overload: System.Type.StructLayoutAttribute*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The invoked method is not supported in the base class.\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.ToString\n  commentId: M:System.Type.ToString\n  id: ToString\n  parent: System.Type\n  langs:\n  - csharp\n  name: ToString()\n  nameWithType: Type.ToString()\n  fullName: Type.ToString()\n  type: Method\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Returns a `String` representing the name of the current `Type`.\n  remarks: \"This method returns the fully qualified common language runtime namespace and name for all primitive types. For example, the C# instruction, `(long)0.Type().ToString()` returns \\\"System.Int64\\\" instead of merely \\\"Int64\\\".  \\n  \\n If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly. If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.\"\n  example:\n  - \"This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and <xref:System.Type.Module%2A> properties and the `ToString` method of <xref:System.Type>.  \\n  \\n [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]\\n [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]\\n [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  \\n  \\n The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.  \\n  \\n [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]\\n [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]\"\n  syntax:\n    content: public override string ToString ();\n    parameters: []\n    return:\n      type: System.String\n      description: A <xref href=\"System.String\"></xref> representing the name of the current <xref href=\"System.Type\"></xref>.\n  overload: System.Type.ToString*\n  exceptions: []\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.TypeHandle\n  commentId: P:System.Type.TypeHandle\n  id: TypeHandle\n  parent: System.Type\n  langs:\n  - csharp\n  name: TypeHandle\n  nameWithType: Type.TypeHandle\n  fullName: Type.TypeHandle\n  type: Property\n  assemblies:\n  - System.Runtime\n  - mscorlib\n  - netstandard\n  namespace: System\n  summary: Gets the handle for the current <xref href=\"System.Type\"></xref>.\n  remarks: '`TypeHandle` encapsulates a pointer to an internal data structure that represents the type. This handle is unique during the process lifetime. The handle is valid only in the application domain in which it was obtained.'\n  example:\n  - \"The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.  \\n  \\n [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]\\n [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]\\n [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]\"\n  syntax:\n    content: public virtual RuntimeTypeHandle TypeHandle { get; }\n    return:\n      type: System.RuntimeTypeHandle\n      description: The handle for the current <xref href=\"System.Type\"></xref>.\n  overload: System.Type.TypeHandle*\n  exceptions:\n  - type: System.NotSupportedException\n    commentId: T:System.NotSupportedException\n    description: The .NET Compact Framework does not currently support this property.\n  version:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.TypeInitializer\n  commentId: P:System.Type.TypeInitializer\n  id: TypeInitializer\n  parent: System.Type\n  langs:\n  - csharp\n  name: TypeInitializer\n  nameWithType: Type.TypeInitializer\n  fullName: Type.TypeInitializer\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Gets the initializer for the type.\n  remarks: \"Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.  \\n  \\n If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`.\"\n  syntax:\n    content: >-\n      [System.Runtime.InteropServices.ComVisible(true)]\n\n      public System.Reflection.ConstructorInfo TypeInitializer { get; }\n    return:\n      type: System.Reflection.ConstructorInfo\n      description: An object that contains the name of the class constructor for the <xref href=\"System.Type\"></xref>.\n  overload: System.Type.TypeInitializer*\n  exceptions: []\n  attributes:\n  - type: System.Runtime.InteropServices.ComVisibleAttribute\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.UnderlyingSystemType\n  commentId: P:System.Type.UnderlyingSystemType\n  id: UnderlyingSystemType\n  parent: System.Type\n  langs:\n  - csharp\n  name: UnderlyingSystemType\n  nameWithType: Type.UnderlyingSystemType\n  fullName: Type.UnderlyingSystemType\n  type: Property\n  assemblies:\n  - mscorlib\n  - netstandard\n  - System.Runtime\n  namespace: System\n  summary: Indicates the type provided by the common language runtime that represents this type.\n  syntax:\n    content: public abstract Type UnderlyingSystemType { get; }\n    return:\n      type: System.Type\n      description: The underlying system type for the <xref href=\"System.Type\"></xref>.\n  overload: System.Type.UnderlyingSystemType*\n  exceptions: []\n  version:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)\n  commentId: M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)\n  id: System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)\n  isEii: true\n  parent: System.Type\n  langs:\n  - csharp\n  name: _Type.GetIDsOfNames(Guid, IntPtr, UInt32, UInt32, IntPtr)\n  nameWithType: Type._Type.GetIDsOfNames(Guid, IntPtr, UInt32, UInt32, IntPtr)\n  fullName: Type._Type.GetIDsOfNames(Guid, IntPtr, UInt32, UInt32, IntPtr)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System\n  summary: Maps a set of names to a corresponding set of dispatch identifiers.\n  remarks: This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.\n  syntax:\n    content: void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);\n    parameters:\n    - id: riid\n      type: System.Guid\n      description: Reserved for future use. Must be IID_NULL.\n    - id: rgszNames\n      type: System.IntPtr\n      description: Passed-in array of names to be mapped.\n    - id: cNames\n      type: System.UInt32\n      description: Count of the names to be mapped.\n    - id: lcid\n      type: System.UInt32\n      description: The locale context in which to interpret the names.\n    - id: rgDispId\n      type: System.IntPtr\n      description: Caller-allocated array which receives the IDs corresponding to the names.\n  overload: System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames*\n  exceptions:\n  - type: System.NotImplementedException\n    commentId: T:System.NotImplementedException\n    description: Late-bound access using the COM <code>IDispatch</code> interface is not supported.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)\n  commentId: M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)\n  id: System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)\n  isEii: true\n  parent: System.Type\n  langs:\n  - csharp\n  name: _Type.GetTypeInfo(UInt32, UInt32, IntPtr)\n  nameWithType: Type._Type.GetTypeInfo(UInt32, UInt32, IntPtr)\n  fullName: Type._Type.GetTypeInfo(UInt32, UInt32, IntPtr)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System\n  summary: Retrieves the type information for an object, which can then be used to get the type information for an interface.\n  remarks: This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.\n  syntax:\n    content: void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);\n    parameters:\n    - id: iTInfo\n      type: System.UInt32\n      description: The type information to return.\n    - id: lcid\n      type: System.UInt32\n      description: The locale identifier for the type information.\n    - id: ppTInfo\n      type: System.IntPtr\n      description: A pointer to the requested type information object.\n  overload: System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo*\n  exceptions:\n  - type: System.NotImplementedException\n    commentId: T:System.NotImplementedException\n    description: Late-bound access using the COM <code>IDispatch</code> interface is not supported.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)\n  commentId: M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)\n  id: System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)\n  isEii: true\n  parent: System.Type\n  langs:\n  - csharp\n  name: _Type.GetTypeInfoCount(UInt32)\n  nameWithType: Type._Type.GetTypeInfoCount(UInt32)\n  fullName: Type._Type.GetTypeInfoCount(UInt32)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System\n  summary: Retrieves the number of type information interfaces that an object provides (either 0 or 1).\n  remarks: This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.\n  syntax:\n    content: void _Type.GetTypeInfoCount (out uint pcTInfo);\n    parameters:\n    - id: pcTInfo\n      type: System.UInt32\n      description: Points to a location that receives the number of type information interfaces provided by the object.\n  overload: System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount*\n  exceptions:\n  - type: System.NotImplementedException\n    commentId: T:System.NotImplementedException\n    description: Late-bound access using the COM <code>IDispatch</code> interface is not supported.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\n- uid: System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)\n  commentId: M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)\n  id: System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)\n  isEii: true\n  parent: System.Type\n  langs:\n  - csharp\n  name: _Type.Invoke(UInt32, Guid, UInt32, Int16, IntPtr, IntPtr, IntPtr, IntPtr)\n  nameWithType: Type._Type.Invoke(UInt32, Guid, UInt32, Int16, IntPtr, IntPtr, IntPtr, IntPtr)\n  fullName: Type._Type.Invoke(UInt32, Guid, UInt32, Int16, IntPtr, IntPtr, IntPtr, IntPtr)\n  type: Method\n  assemblies:\n  - mscorlib\n  namespace: System\n  summary: Provides access to properties and methods exposed by an object.\n  remarks: This method is for access to managed classes from unmanaged code, and should not be called from managed code. For more information about `IDispatch::Invoke`, see the MSDN Library.\n  syntax:\n    content: void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);\n    parameters:\n    - id: dispIdMember\n      type: System.UInt32\n      description: Identifies the member.\n    - id: riid\n      type: System.Guid\n      description: Reserved for future use. Must be IID_NULL.\n    - id: lcid\n      type: System.UInt32\n      description: The locale context in which to interpret arguments.\n    - id: wFlags\n      type: System.Int16\n      description: Flags describing the context of the call.\n    - id: pDispParams\n      type: System.IntPtr\n      description: Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.\n    - id: pVarResult\n      type: System.IntPtr\n      description: Pointer to the location where the result is to be stored.\n    - id: pExcepInfo\n      type: System.IntPtr\n      description: Pointer to a structure that contains exception information.\n    - id: puArgErr\n      type: System.IntPtr\n      description: The index of the first argument that has an error.\n  overload: System.Type.System#Runtime#InteropServices#_Type#Invoke*\n  exceptions:\n  - type: System.NotImplementedException\n    commentId: T:System.NotImplementedException\n    description: Late-bound access using the COM <code>IDispatch</code> interface is not supported.\n  version:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n  ms.technology:\n  - dotnet-standard\n  author: rpetrusha\n  ms.author: ronpet\n  manager: wpickett\nreferences:\n- uid: System.Object\n  parent: System\n  isExternal: false\n  name: Object\n  nameWithType: Object\n  fullName: System.Object\n- uid: System.ArgumentNullException\n  parent: System\n  isExternal: false\n  name: ArgumentNullException\n  nameWithType: ArgumentNullException\n  fullName: System.ArgumentNullException\n- uid: System.Reflection.TargetInvocationException\n  parent: System.Reflection\n  isExternal: false\n  name: TargetInvocationException\n  nameWithType: TargetInvocationException\n  fullName: System.Reflection.TargetInvocationException\n- uid: System.InvalidOperationException\n  parent: System\n  isExternal: false\n  name: InvalidOperationException\n  nameWithType: InvalidOperationException\n  fullName: System.InvalidOperationException\n- uid: System.NotSupportedException\n  parent: System\n  isExternal: false\n  name: NotSupportedException\n  nameWithType: NotSupportedException\n  fullName: System.NotSupportedException\n- uid: System.ArgumentException\n  parent: System\n  isExternal: false\n  name: ArgumentException\n  nameWithType: ArgumentException\n  fullName: System.ArgumentException\n- uid: System.Reflection.AmbiguousMatchException\n  parent: System.Reflection\n  isExternal: false\n  name: AmbiguousMatchException\n  nameWithType: AmbiguousMatchException\n  fullName: System.Reflection.AmbiguousMatchException\n- uid: System.NullReferenceException\n  parent: System\n  isExternal: false\n  name: NullReferenceException\n  nameWithType: NullReferenceException\n  fullName: System.NullReferenceException\n- uid: System.TypeLoadException\n  parent: System\n  isExternal: false\n  name: TypeLoadException\n  nameWithType: TypeLoadException\n  fullName: System.TypeLoadException\n- uid: System.IO.FileNotFoundException\n  parent: System.IO\n  isExternal: false\n  name: FileNotFoundException\n  nameWithType: FileNotFoundException\n  fullName: System.IO.FileNotFoundException\n- uid: System.IO.FileLoadException\n  parent: System.IO\n  isExternal: false\n  name: FileLoadException\n  nameWithType: FileLoadException\n  fullName: System.IO.FileLoadException\n- uid: System.BadImageFormatException\n  parent: System\n  isExternal: false\n  name: BadImageFormatException\n  nameWithType: BadImageFormatException\n  fullName: System.BadImageFormatException\n- uid: System.Runtime.InteropServices.COMException\n  parent: System.Runtime.InteropServices\n  isExternal: false\n  name: COMException\n  nameWithType: COMException\n  fullName: System.Runtime.InteropServices.COMException\n- uid: System.MethodAccessException\n  parent: System\n  isExternal: false\n  name: MethodAccessException\n  nameWithType: MethodAccessException\n  fullName: System.MethodAccessException\n- uid: System.MissingFieldException\n  parent: System\n  isExternal: false\n  name: MissingFieldException\n  nameWithType: MissingFieldException\n  fullName: System.MissingFieldException\n- uid: System.MissingMethodException\n  parent: System\n  isExternal: false\n  name: MissingMethodException\n  nameWithType: MissingMethodException\n  fullName: System.MissingMethodException\n- uid: System.Reflection.TargetException\n  parent: System.Reflection\n  isExternal: false\n  name: TargetException\n  nameWithType: TargetException\n  fullName: System.Reflection.TargetException\n- uid: System.IndexOutOfRangeException\n  parent: System\n  isExternal: false\n  name: IndexOutOfRangeException\n  nameWithType: IndexOutOfRangeException\n  fullName: System.IndexOutOfRangeException\n- uid: System.NotImplementedException\n  parent: System\n  isExternal: false\n  name: NotImplementedException\n  nameWithType: NotImplementedException\n  fullName: System.NotImplementedException\n- uid: System.Type.#ctor\n  parent: System.Type\n  isExternal: false\n  name: Type()\n  nameWithType: Type.Type()\n  fullName: Type.Type()\n- uid: System.Type.Assembly\n  parent: System.Type\n  isExternal: false\n  name: Assembly\n  nameWithType: Type.Assembly\n  fullName: Type.Assembly\n- uid: System.Reflection.Assembly\n  parent: System.Reflection\n  isExternal: false\n  name: Assembly\n  nameWithType: Assembly\n  fullName: System.Reflection.Assembly\n- uid: System.Type.AssemblyQualifiedName\n  parent: System.Type\n  isExternal: false\n  name: AssemblyQualifiedName\n  nameWithType: Type.AssemblyQualifiedName\n  fullName: Type.AssemblyQualifiedName\n- uid: System.String\n  parent: System\n  isExternal: false\n  name: String\n  nameWithType: String\n  fullName: System.String\n- uid: System.Type.Attributes\n  parent: System.Type\n  isExternal: false\n  name: Attributes\n  nameWithType: Type.Attributes\n  fullName: Type.Attributes\n- uid: System.Reflection.TypeAttributes\n  parent: System.Reflection\n  isExternal: false\n  name: TypeAttributes\n  nameWithType: TypeAttributes\n  fullName: System.Reflection.TypeAttributes\n- uid: System.Type.BaseType\n  parent: System.Type\n  isExternal: false\n  name: BaseType\n  nameWithType: Type.BaseType\n  fullName: Type.BaseType\n- uid: System.Type\n  parent: System\n  isExternal: false\n  name: Type\n  nameWithType: Type\n  fullName: System.Type\n- uid: System.Type.ContainsGenericParameters\n  parent: System.Type\n  isExternal: false\n  name: ContainsGenericParameters\n  nameWithType: Type.ContainsGenericParameters\n  fullName: Type.ContainsGenericParameters\n- uid: System.Boolean\n  parent: System\n  isExternal: false\n  name: Boolean\n  nameWithType: Boolean\n  fullName: System.Boolean\n- uid: System.Type.DeclaringMethod\n  parent: System.Type\n  isExternal: false\n  name: DeclaringMethod\n  nameWithType: Type.DeclaringMethod\n  fullName: Type.DeclaringMethod\n- uid: System.Reflection.MethodBase\n  parent: System.Reflection\n  isExternal: false\n  name: MethodBase\n  nameWithType: MethodBase\n  fullName: System.Reflection.MethodBase\n- uid: System.Type.DeclaringType\n  parent: System.Type\n  isExternal: false\n  name: DeclaringType\n  nameWithType: Type.DeclaringType\n  fullName: Type.DeclaringType\n- uid: System.Type.DefaultBinder\n  parent: System.Type\n  isExternal: false\n  name: DefaultBinder\n  nameWithType: Type.DefaultBinder\n  fullName: Type.DefaultBinder\n- uid: System.Reflection.Binder\n  parent: System.Reflection\n  isExternal: false\n  name: Binder\n  nameWithType: Binder\n  fullName: System.Reflection.Binder\n- uid: System.Type.Delimiter\n  parent: System.Type\n  isExternal: false\n  name: Delimiter\n  nameWithType: Type.Delimiter\n  fullName: Type.Delimiter\n- uid: System.Char\n  parent: System\n  isExternal: false\n  name: Char\n  nameWithType: Char\n  fullName: System.Char\n- uid: System.Type.EmptyTypes\n  parent: System.Type\n  isExternal: false\n  name: EmptyTypes\n  nameWithType: Type.EmptyTypes\n  fullName: Type.EmptyTypes\n- uid: System.Type[]\n  parent: System\n  isExternal: false\n  name: Type[]\n  nameWithType: Type[]\n  fullName: System.Type[]\n  spec.csharp:\n  - uid: System.Type\n    name: Type\n    nameWithType: Type\n    fullName: System.Type\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Type.Equals(System.Object)\n  parent: System.Type\n  isExternal: false\n  name: Equals(Object)\n  nameWithType: Type.Equals(Object)\n  fullName: Type.Equals(Object)\n- uid: System.Type.Equals(System.Type)\n  parent: System.Type\n  isExternal: false\n  name: Equals(Type)\n  nameWithType: Type.Equals(Type)\n  fullName: Type.Equals(Type)\n- uid: System.Type.FilterAttribute\n  parent: System.Type\n  isExternal: false\n  name: FilterAttribute\n  nameWithType: Type.FilterAttribute\n  fullName: Type.FilterAttribute\n- uid: System.Reflection.MemberFilter\n  parent: System.Reflection\n  isExternal: false\n  name: MemberFilter\n  nameWithType: MemberFilter\n  fullName: System.Reflection.MemberFilter\n- uid: System.Type.FilterName\n  parent: System.Type\n  isExternal: false\n  name: FilterName\n  nameWithType: Type.FilterName\n  fullName: Type.FilterName\n- uid: System.Type.FilterNameIgnoreCase\n  parent: System.Type\n  isExternal: false\n  name: FilterNameIgnoreCase\n  nameWithType: Type.FilterNameIgnoreCase\n  fullName: Type.FilterNameIgnoreCase\n- uid: System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)\n  parent: System.Type\n  isExternal: false\n  name: FindInterfaces(TypeFilter, Object)\n  nameWithType: Type.FindInterfaces(TypeFilter, Object)\n  fullName: Type.FindInterfaces(TypeFilter, Object)\n- uid: System.Reflection.TypeFilter\n  parent: System.Reflection\n  isExternal: false\n  name: TypeFilter\n  nameWithType: TypeFilter\n  fullName: System.Reflection.TypeFilter\n- uid: System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)\n  parent: System.Type\n  isExternal: false\n  name: FindMembers(MemberTypes, BindingFlags, MemberFilter, Object)\n  nameWithType: Type.FindMembers(MemberTypes, BindingFlags, MemberFilter, Object)\n  fullName: Type.FindMembers(MemberTypes, BindingFlags, MemberFilter, Object)\n- uid: System.Reflection.MemberInfo\n  name: MemberInfo\n  nameWithType: MemberInfo\n  fullName: System.Reflection.MemberInfo\n- uid: System.Reflection.MemberInfo[]\n  parent: System.Reflection\n  isExternal: false\n  name: MemberInfo[]\n  nameWithType: MemberInfo[]\n  fullName: System.Reflection.MemberInfo[]\n  spec.csharp:\n  - uid: System.Reflection.MemberInfo\n    name: MemberInfo\n    nameWithType: MemberInfo\n    fullName: System.Reflection.MemberInfo\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Reflection.MemberTypes\n  parent: System.Reflection\n  isExternal: false\n  name: MemberTypes\n  nameWithType: MemberTypes\n  fullName: System.Reflection.MemberTypes\n- uid: System.Reflection.BindingFlags\n  parent: System.Reflection\n  isExternal: false\n  name: BindingFlags\n  nameWithType: BindingFlags\n  fullName: System.Reflection.BindingFlags\n- uid: System.Type.FullName\n  parent: System.Type\n  isExternal: false\n  name: FullName\n  nameWithType: Type.FullName\n  fullName: Type.FullName\n- uid: System.Type.GenericParameterAttributes\n  parent: System.Type\n  isExternal: false\n  name: GenericParameterAttributes\n  nameWithType: Type.GenericParameterAttributes\n  fullName: Type.GenericParameterAttributes\n- uid: System.Reflection.GenericParameterAttributes\n  parent: System.Reflection\n  isExternal: false\n  name: GenericParameterAttributes\n  nameWithType: GenericParameterAttributes\n  fullName: System.Reflection.GenericParameterAttributes\n- uid: System.Type.GenericParameterPosition\n  parent: System.Type\n  isExternal: false\n  name: GenericParameterPosition\n  nameWithType: Type.GenericParameterPosition\n  fullName: Type.GenericParameterPosition\n- uid: System.Int32\n  parent: System\n  isExternal: false\n  name: Int32\n  nameWithType: Int32\n  fullName: System.Int32\n- uid: System.Type.GenericTypeArguments\n  parent: System.Type\n  isExternal: false\n  name: GenericTypeArguments\n  nameWithType: Type.GenericTypeArguments\n  fullName: Type.GenericTypeArguments\n- uid: System.Type.GetArrayRank\n  parent: System.Type\n  isExternal: false\n  name: GetArrayRank()\n  nameWithType: Type.GetArrayRank()\n  fullName: Type.GetArrayRank()\n- uid: System.Type.GetAttributeFlagsImpl\n  parent: System.Type\n  isExternal: false\n  name: GetAttributeFlagsImpl()\n  nameWithType: Type.GetAttributeFlagsImpl()\n  fullName: Type.GetAttributeFlagsImpl()\n- uid: System.Type.GetConstructor(System.Type[])\n  parent: System.Type\n  isExternal: false\n  name: GetConstructor(Type[])\n  nameWithType: Type.GetConstructor(Type[])\n  fullName: Type.GetConstructor(Type[])\n- uid: System.Reflection.ConstructorInfo\n  parent: System.Reflection\n  isExternal: false\n  name: ConstructorInfo\n  nameWithType: ConstructorInfo\n  fullName: System.Reflection.ConstructorInfo\n- uid: System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  isExternal: false\n  name: GetConstructor(BindingFlags, Binder, Type[], ParameterModifier[])\n  nameWithType: Type.GetConstructor(BindingFlags, Binder, Type[], ParameterModifier[])\n  fullName: Type.GetConstructor(BindingFlags, Binder, Type[], ParameterModifier[])\n- uid: System.Reflection.ParameterModifier\n  name: ParameterModifier\n  nameWithType: ParameterModifier\n  fullName: System.Reflection.ParameterModifier\n- uid: System.Reflection.ParameterModifier[]\n  parent: System.Reflection\n  isExternal: false\n  name: ParameterModifier[]\n  nameWithType: ParameterModifier[]\n  fullName: System.Reflection.ParameterModifier[]\n  spec.csharp:\n  - uid: System.Reflection.ParameterModifier\n    name: ParameterModifier\n    nameWithType: ParameterModifier\n    fullName: System.Reflection.ParameterModifier\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  isExternal: false\n  name: GetConstructor(BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  nameWithType: Type.GetConstructor(BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  fullName: Type.GetConstructor(BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n- uid: System.Reflection.CallingConventions\n  parent: System.Reflection\n  isExternal: false\n  name: CallingConventions\n  nameWithType: CallingConventions\n  fullName: System.Reflection.CallingConventions\n- uid: System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  isExternal: false\n  name: GetConstructorImpl(BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  nameWithType: Type.GetConstructorImpl(BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  fullName: Type.GetConstructorImpl(BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n- uid: System.Type.GetConstructors\n  parent: System.Type\n  isExternal: false\n  name: GetConstructors()\n  nameWithType: Type.GetConstructors()\n  fullName: Type.GetConstructors()\n- uid: System.Reflection.ConstructorInfo[]\n  parent: System.Reflection\n  isExternal: false\n  name: ConstructorInfo[]\n  nameWithType: ConstructorInfo[]\n  fullName: System.Reflection.ConstructorInfo[]\n  spec.csharp:\n  - uid: System.Reflection.ConstructorInfo\n    name: ConstructorInfo\n    nameWithType: ConstructorInfo\n    fullName: System.Reflection.ConstructorInfo\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Type.GetConstructors(System.Reflection.BindingFlags)\n  parent: System.Type\n  isExternal: false\n  name: GetConstructors(BindingFlags)\n  nameWithType: Type.GetConstructors(BindingFlags)\n  fullName: Type.GetConstructors(BindingFlags)\n- uid: System.Type.GetDefaultMembers\n  parent: System.Type\n  isExternal: false\n  name: GetDefaultMembers()\n  nameWithType: Type.GetDefaultMembers()\n  fullName: Type.GetDefaultMembers()\n- uid: System.Type.GetElementType\n  parent: System.Type\n  isExternal: false\n  name: GetElementType()\n  nameWithType: Type.GetElementType()\n  fullName: Type.GetElementType()\n- uid: System.Type.GetEnumName(System.Object)\n  parent: System.Type\n  isExternal: false\n  name: GetEnumName(Object)\n  nameWithType: Type.GetEnumName(Object)\n  fullName: Type.GetEnumName(Object)\n- uid: System.Type.GetEnumNames\n  parent: System.Type\n  isExternal: false\n  name: GetEnumNames()\n  nameWithType: Type.GetEnumNames()\n  fullName: Type.GetEnumNames()\n- uid: System.String[]\n  parent: System\n  isExternal: false\n  name: String[]\n  nameWithType: String[]\n  fullName: System.String[]\n  spec.csharp:\n  - uid: System.String\n    name: String\n    nameWithType: String\n    fullName: System.String\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Type.GetEnumUnderlyingType\n  parent: System.Type\n  isExternal: false\n  name: GetEnumUnderlyingType()\n  nameWithType: Type.GetEnumUnderlyingType()\n  fullName: Type.GetEnumUnderlyingType()\n- uid: System.Type.GetEnumValues\n  parent: System.Type\n  isExternal: false\n  name: GetEnumValues()\n  nameWithType: Type.GetEnumValues()\n  fullName: Type.GetEnumValues()\n- uid: System.Array\n  parent: System\n  isExternal: false\n  name: Array\n  nameWithType: Array\n  fullName: System.Array\n- uid: System.Type.GetEvent(System.String)\n  parent: System.Type\n  isExternal: false\n  name: GetEvent(String)\n  nameWithType: Type.GetEvent(String)\n  fullName: Type.GetEvent(String)\n- uid: System.Reflection.EventInfo\n  parent: System.Reflection\n  isExternal: false\n  name: EventInfo\n  nameWithType: EventInfo\n  fullName: System.Reflection.EventInfo\n- uid: System.Type.GetEvent(System.String,System.Reflection.BindingFlags)\n  parent: System.Type\n  isExternal: false\n  name: GetEvent(String, BindingFlags)\n  nameWithType: Type.GetEvent(String, BindingFlags)\n  fullName: Type.GetEvent(String, BindingFlags)\n- uid: System.Type.GetEvents\n  parent: System.Type\n  isExternal: false\n  name: GetEvents()\n  nameWithType: Type.GetEvents()\n  fullName: Type.GetEvents()\n- uid: System.Reflection.EventInfo[]\n  parent: System.Reflection\n  isExternal: false\n  name: EventInfo[]\n  nameWithType: EventInfo[]\n  fullName: System.Reflection.EventInfo[]\n  spec.csharp:\n  - uid: System.Reflection.EventInfo\n    name: EventInfo\n    nameWithType: EventInfo\n    fullName: System.Reflection.EventInfo\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Type.GetEvents(System.Reflection.BindingFlags)\n  parent: System.Type\n  isExternal: false\n  name: GetEvents(BindingFlags)\n  nameWithType: Type.GetEvents(BindingFlags)\n  fullName: Type.GetEvents(BindingFlags)\n- uid: System.Type.GetField(System.String)\n  parent: System.Type\n  isExternal: false\n  name: GetField(String)\n  nameWithType: Type.GetField(String)\n  fullName: Type.GetField(String)\n- uid: System.Reflection.FieldInfo\n  parent: System.Reflection\n  isExternal: false\n  name: FieldInfo\n  nameWithType: FieldInfo\n  fullName: System.Reflection.FieldInfo\n- uid: System.Type.GetField(System.String,System.Reflection.BindingFlags)\n  parent: System.Type\n  isExternal: false\n  name: GetField(String, BindingFlags)\n  nameWithType: Type.GetField(String, BindingFlags)\n  fullName: Type.GetField(String, BindingFlags)\n- uid: System.Type.GetFields\n  parent: System.Type\n  isExternal: false\n  name: GetFields()\n  nameWithType: Type.GetFields()\n  fullName: Type.GetFields()\n- uid: System.Reflection.FieldInfo[]\n  parent: System.Reflection\n  isExternal: false\n  name: FieldInfo[]\n  nameWithType: FieldInfo[]\n  fullName: System.Reflection.FieldInfo[]\n  spec.csharp:\n  - uid: System.Reflection.FieldInfo\n    name: FieldInfo\n    nameWithType: FieldInfo\n    fullName: System.Reflection.FieldInfo\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Type.GetFields(System.Reflection.BindingFlags)\n  parent: System.Type\n  isExternal: false\n  name: GetFields(BindingFlags)\n  nameWithType: Type.GetFields(BindingFlags)\n  fullName: Type.GetFields(BindingFlags)\n- uid: System.Type.GetGenericArguments\n  parent: System.Type\n  isExternal: false\n  name: GetGenericArguments()\n  nameWithType: Type.GetGenericArguments()\n  fullName: Type.GetGenericArguments()\n- uid: System.Type.GetGenericParameterConstraints\n  parent: System.Type\n  isExternal: false\n  name: GetGenericParameterConstraints()\n  nameWithType: Type.GetGenericParameterConstraints()\n  fullName: Type.GetGenericParameterConstraints()\n- uid: System.Type.GetGenericTypeDefinition\n  parent: System.Type\n  isExternal: false\n  name: GetGenericTypeDefinition()\n  nameWithType: Type.GetGenericTypeDefinition()\n  fullName: Type.GetGenericTypeDefinition()\n- uid: System.Type.GetHashCode\n  parent: System.Type\n  isExternal: false\n  name: GetHashCode()\n  nameWithType: Type.GetHashCode()\n  fullName: Type.GetHashCode()\n- uid: System.Type.GetInterface(System.String)\n  parent: System.Type\n  isExternal: false\n  name: GetInterface(String)\n  nameWithType: Type.GetInterface(String)\n  fullName: Type.GetInterface(String)\n- uid: System.Type.GetInterface(System.String,System.Boolean)\n  parent: System.Type\n  isExternal: false\n  name: GetInterface(String, Boolean)\n  nameWithType: Type.GetInterface(String, Boolean)\n  fullName: Type.GetInterface(String, Boolean)\n- uid: System.Type.GetInterfaceMap(System.Type)\n  parent: System.Type\n  isExternal: false\n  name: GetInterfaceMap(Type)\n  nameWithType: Type.GetInterfaceMap(Type)\n  fullName: Type.GetInterfaceMap(Type)\n- uid: System.Reflection.InterfaceMapping\n  parent: System.Reflection\n  isExternal: false\n  name: InterfaceMapping\n  nameWithType: InterfaceMapping\n  fullName: System.Reflection.InterfaceMapping\n- uid: System.Type.GetInterfaces\n  parent: System.Type\n  isExternal: false\n  name: GetInterfaces()\n  nameWithType: Type.GetInterfaces()\n  fullName: Type.GetInterfaces()\n- uid: System.Type.GetMember(System.String)\n  parent: System.Type\n  isExternal: false\n  name: GetMember(String)\n  nameWithType: Type.GetMember(String)\n  fullName: Type.GetMember(String)\n- uid: System.Type.GetMember(System.String,System.Reflection.BindingFlags)\n  parent: System.Type\n  isExternal: false\n  name: GetMember(String, BindingFlags)\n  nameWithType: Type.GetMember(String, BindingFlags)\n  fullName: Type.GetMember(String, BindingFlags)\n- uid: System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)\n  parent: System.Type\n  isExternal: false\n  name: GetMember(String, MemberTypes, BindingFlags)\n  nameWithType: Type.GetMember(String, MemberTypes, BindingFlags)\n  fullName: Type.GetMember(String, MemberTypes, BindingFlags)\n- uid: System.Type.GetMembers\n  parent: System.Type\n  isExternal: false\n  name: GetMembers()\n  nameWithType: Type.GetMembers()\n  fullName: Type.GetMembers()\n- uid: System.Type.GetMembers(System.Reflection.BindingFlags)\n  parent: System.Type\n  isExternal: false\n  name: GetMembers(BindingFlags)\n  nameWithType: Type.GetMembers(BindingFlags)\n  fullName: Type.GetMembers(BindingFlags)\n- uid: System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  isExternal: false\n  name: GetMethod(String, BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  nameWithType: Type.GetMethod(String, BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  fullName: Type.GetMethod(String, BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n- uid: System.Reflection.MethodInfo\n  parent: System.Reflection\n  isExternal: false\n  name: MethodInfo\n  nameWithType: MethodInfo\n  fullName: System.Reflection.MethodInfo\n- uid: System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  isExternal: false\n  name: GetMethod(String, BindingFlags, Binder, Type[], ParameterModifier[])\n  nameWithType: Type.GetMethod(String, BindingFlags, Binder, Type[], ParameterModifier[])\n  fullName: Type.GetMethod(String, BindingFlags, Binder, Type[], ParameterModifier[])\n- uid: System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  isExternal: false\n  name: GetMethod(String, Type[], ParameterModifier[])\n  nameWithType: Type.GetMethod(String, Type[], ParameterModifier[])\n  fullName: Type.GetMethod(String, Type[], ParameterModifier[])\n- uid: System.Type.GetMethod(System.String)\n  parent: System.Type\n  isExternal: false\n  name: GetMethod(String)\n  nameWithType: Type.GetMethod(String)\n  fullName: Type.GetMethod(String)\n- uid: System.Type.GetMethod(System.String,System.Reflection.BindingFlags)\n  parent: System.Type\n  isExternal: false\n  name: GetMethod(String, BindingFlags)\n  nameWithType: Type.GetMethod(String, BindingFlags)\n  fullName: Type.GetMethod(String, BindingFlags)\n- uid: System.Type.GetMethod(System.String,System.Type[])\n  parent: System.Type\n  isExternal: false\n  name: GetMethod(String, Type[])\n  nameWithType: Type.GetMethod(String, Type[])\n  fullName: Type.GetMethod(String, Type[])\n- uid: System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  isExternal: false\n  name: GetMethodImpl(String, BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  nameWithType: Type.GetMethodImpl(String, BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n  fullName: Type.GetMethodImpl(String, BindingFlags, Binder, CallingConventions, Type[], ParameterModifier[])\n- uid: System.Type.GetMethods\n  parent: System.Type\n  isExternal: false\n  name: GetMethods()\n  nameWithType: Type.GetMethods()\n  fullName: Type.GetMethods()\n- uid: System.Reflection.MethodInfo[]\n  parent: System.Reflection\n  isExternal: false\n  name: MethodInfo[]\n  nameWithType: MethodInfo[]\n  fullName: System.Reflection.MethodInfo[]\n  spec.csharp:\n  - uid: System.Reflection.MethodInfo\n    name: MethodInfo\n    nameWithType: MethodInfo\n    fullName: System.Reflection.MethodInfo\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Type.GetMethods(System.Reflection.BindingFlags)\n  parent: System.Type\n  isExternal: false\n  name: GetMethods(BindingFlags)\n  nameWithType: Type.GetMethods(BindingFlags)\n  fullName: Type.GetMethods(BindingFlags)\n- uid: System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)\n  parent: System.Type\n  isExternal: false\n  name: GetNestedType(String, BindingFlags)\n  nameWithType: Type.GetNestedType(String, BindingFlags)\n  fullName: Type.GetNestedType(String, BindingFlags)\n- uid: System.Type.GetNestedType(System.String)\n  parent: System.Type\n  isExternal: false\n  name: GetNestedType(String)\n  nameWithType: Type.GetNestedType(String)\n  fullName: Type.GetNestedType(String)\n- uid: System.Type.GetNestedTypes(System.Reflection.BindingFlags)\n  parent: System.Type\n  isExternal: false\n  name: GetNestedTypes(BindingFlags)\n  nameWithType: Type.GetNestedTypes(BindingFlags)\n  fullName: Type.GetNestedTypes(BindingFlags)\n- uid: System.Type.GetNestedTypes\n  parent: System.Type\n  isExternal: false\n  name: GetNestedTypes()\n  nameWithType: Type.GetNestedTypes()\n  fullName: Type.GetNestedTypes()\n- uid: System.Type.GetProperties\n  parent: System.Type\n  isExternal: false\n  name: GetProperties()\n  nameWithType: Type.GetProperties()\n  fullName: Type.GetProperties()\n- uid: System.Reflection.PropertyInfo\n  name: PropertyInfo\n  nameWithType: PropertyInfo\n  fullName: System.Reflection.PropertyInfo\n- uid: System.Reflection.PropertyInfo[]\n  parent: System.Reflection\n  isExternal: false\n  name: PropertyInfo[]\n  nameWithType: PropertyInfo[]\n  fullName: System.Reflection.PropertyInfo[]\n  spec.csharp:\n  - uid: System.Reflection.PropertyInfo\n    name: PropertyInfo\n    nameWithType: PropertyInfo\n    fullName: System.Reflection.PropertyInfo\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Type.GetProperties(System.Reflection.BindingFlags)\n  parent: System.Type\n  isExternal: false\n  name: GetProperties(BindingFlags)\n  nameWithType: Type.GetProperties(BindingFlags)\n  fullName: Type.GetProperties(BindingFlags)\n- uid: System.Type.GetProperty(System.String)\n  parent: System.Type\n  isExternal: false\n  name: GetProperty(String)\n  nameWithType: Type.GetProperty(String)\n  fullName: Type.GetProperty(String)\n- uid: System.Type.GetProperty(System.String,System.Reflection.BindingFlags)\n  parent: System.Type\n  isExternal: false\n  name: GetProperty(String, BindingFlags)\n  nameWithType: Type.GetProperty(String, BindingFlags)\n  fullName: Type.GetProperty(String, BindingFlags)\n- uid: System.Type.GetProperty(System.String,System.Type)\n  parent: System.Type\n  isExternal: false\n  name: GetProperty(String, Type)\n  nameWithType: Type.GetProperty(String, Type)\n  fullName: Type.GetProperty(String, Type)\n- uid: System.Type.GetProperty(System.String,System.Type[])\n  parent: System.Type\n  isExternal: false\n  name: GetProperty(String, Type[])\n  nameWithType: Type.GetProperty(String, Type[])\n  fullName: Type.GetProperty(String, Type[])\n- uid: System.Type.GetProperty(System.String,System.Type,System.Type[])\n  parent: System.Type\n  isExternal: false\n  name: GetProperty(String, Type, Type[])\n  nameWithType: Type.GetProperty(String, Type, Type[])\n  fullName: Type.GetProperty(String, Type, Type[])\n- uid: System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  isExternal: false\n  name: GetProperty(String, Type, Type[], ParameterModifier[])\n  nameWithType: Type.GetProperty(String, Type, Type[], ParameterModifier[])\n  fullName: Type.GetProperty(String, Type, Type[], ParameterModifier[])\n- uid: System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  isExternal: false\n  name: GetProperty(String, BindingFlags, Binder, Type, Type[], ParameterModifier[])\n  nameWithType: Type.GetProperty(String, BindingFlags, Binder, Type, Type[], ParameterModifier[])\n  fullName: Type.GetProperty(String, BindingFlags, Binder, Type, Type[], ParameterModifier[])\n- uid: System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])\n  parent: System.Type\n  isExternal: false\n  name: GetPropertyImpl(String, BindingFlags, Binder, Type, Type[], ParameterModifier[])\n  nameWithType: Type.GetPropertyImpl(String, BindingFlags, Binder, Type, Type[], ParameterModifier[])\n  fullName: Type.GetPropertyImpl(String, BindingFlags, Binder, Type, Type[], ParameterModifier[])\n- uid: System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)\n  parent: System.Type\n  isExternal: false\n  name: GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>, Boolean, Boolean)\n  nameWithType: Type.GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>, Boolean, Boolean)\n  fullName: Type.GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>, Boolean, Boolean)\n- uid: System.Func`2\n  name: Func<T,TResult>\n  nameWithType: Func<T,TResult>\n  fullName: System.Func<T,TResult>\n- uid: System.Reflection.AssemblyName\n  name: AssemblyName\n  nameWithType: AssemblyName\n  fullName: System.Reflection.AssemblyName\n- uid: System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly}\n  parent: System\n  isExternal: false\n  name: Func<AssemblyName,Assembly>\n  nameWithType: Func<AssemblyName,Assembly>\n  fullName: System.Func<System.Reflection.AssemblyName,System.Reflection.Assembly>\n  spec.csharp:\n  - uid: System.Func`2\n    name: Func\n    nameWithType: Func\n    fullName: System.Func\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.Reflection.AssemblyName\n    name: AssemblyName\n    nameWithType: AssemblyName\n    fullName: System.Reflection.AssemblyName\n  - name: ','\n    nameWithType: ','\n    fullName: ','\n  - uid: System.Reflection.Assembly\n    name: Assembly\n    nameWithType: Assembly\n    fullName: System.Reflection.Assembly\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.Func`4\n  name: Func<T1,T2,T3,TResult>\n  nameWithType: Func<T1,T2,T3,TResult>\n  fullName: System.Func<T1,T2,T3,TResult>\n- uid: System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type}\n  parent: System\n  isExternal: false\n  name: Func<Assembly,String,Boolean,Type>\n  nameWithType: Func<Assembly,String,Boolean,Type>\n  fullName: System.Func<System.Reflection.Assembly,System.String,System.Boolean,System.Type>\n  spec.csharp:\n  - uid: System.Func`4\n    name: Func\n    nameWithType: Func\n    fullName: System.Func\n  - name: <\n    nameWithType: <\n    fullName: <\n  - uid: System.Reflection.Assembly\n    name: Assembly\n    nameWithType: Assembly\n    fullName: System.Reflection.Assembly\n  - name: ','\n    nameWithType: ','\n    fullName: ','\n  - uid: System.String\n    name: String\n    nameWithType: String\n    fullName: System.String\n  - name: ','\n    nameWithType: ','\n    fullName: ','\n  - uid: System.Boolean\n    name: Boolean\n    nameWithType: Boolean\n    fullName: System.Boolean\n  - name: ','\n    nameWithType: ','\n    fullName: ','\n  - uid: System.Type\n    name: Type\n    nameWithType: Type\n    fullName: System.Type\n  - name: '>'\n    nameWithType: '>'\n    fullName: '>'\n- uid: System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)\n  parent: System.Type\n  isExternal: false\n  name: GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>, Boolean)\n  nameWithType: Type.GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>, Boolean)\n  fullName: Type.GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>, Boolean)\n- uid: System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})\n  parent: System.Type\n  isExternal: false\n  name: GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>)\n  nameWithType: Type.GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>)\n  fullName: Type.GetType(String, Func<AssemblyName,Assembly>, Func<Assembly,String,Boolean,Type>)\n- uid: System.Type.GetType\n  parent: System.Type\n  isExternal: false\n  name: GetType()\n  nameWithType: Type.GetType()\n  fullName: Type.GetType()\n- uid: System.Type.GetType(System.String,System.Boolean)\n  parent: System.Type\n  isExternal: false\n  name: GetType(String, Boolean)\n  nameWithType: Type.GetType(String, Boolean)\n  fullName: Type.GetType(String, Boolean)\n- uid: System.Type.GetType(System.String)\n  parent: System.Type\n  isExternal: false\n  name: GetType(String)\n  nameWithType: Type.GetType(String)\n  fullName: Type.GetType(String)\n- uid: System.Type.GetType(System.String,System.Boolean,System.Boolean)\n  parent: System.Type\n  isExternal: false\n  name: GetType(String, Boolean, Boolean)\n  nameWithType: Type.GetType(String, Boolean, Boolean)\n  fullName: Type.GetType(String, Boolean, Boolean)\n- uid: System.Type.GetTypeArray(System.Object[])\n  parent: System.Type\n  isExternal: false\n  name: GetTypeArray(Object[])\n  nameWithType: Type.GetTypeArray(Object[])\n  fullName: Type.GetTypeArray(Object[])\n- uid: System.Object[]\n  parent: System\n  isExternal: false\n  name: Object[]\n  nameWithType: Object[]\n  fullName: System.Object[]\n  spec.csharp:\n  - uid: System.Object\n    name: Object\n    nameWithType: Object\n    fullName: System.Object\n  - name: '[]'\n    nameWithType: '[]'\n    fullName: '[]'\n- uid: System.Type.GetTypeCode(System.Type)\n  parent: System.Type\n  isExternal: false\n  name: GetTypeCode(Type)\n  nameWithType: Type.GetTypeCode(Type)\n  fullName: Type.GetTypeCode(Type)\n- uid: System.TypeCode\n  parent: System\n  isExternal: false\n  name: TypeCode\n  nameWithType: TypeCode\n  fullName: System.TypeCode\n- uid: System.Type.GetTypeCodeImpl\n  parent: System.Type\n  isExternal: false\n  name: GetTypeCodeImpl()\n  nameWithType: Type.GetTypeCodeImpl()\n  fullName: Type.GetTypeCodeImpl()\n- uid: System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)\n  parent: System.Type\n  isExternal: false\n  name: GetTypeFromCLSID(Guid, String, Boolean)\n  nameWithType: Type.GetTypeFromCLSID(Guid, String, Boolean)\n  fullName: Type.GetTypeFromCLSID(Guid, String, Boolean)\n- uid: System.Guid\n  parent: System\n  isExternal: false\n  name: Guid\n  nameWithType: Guid\n  fullName: System.Guid\n- uid: System.Type.GetTypeFromCLSID(System.Guid,System.String)\n  parent: System.Type\n  isExternal: false\n  name: GetTypeFromCLSID(Guid, String)\n  nameWithType: Type.GetTypeFromCLSID(Guid, String)\n  fullName: Type.GetTypeFromCLSID(Guid, String)\n- uid: System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)\n  parent: System.Type\n  isExternal: false\n  name: GetTypeFromCLSID(Guid, Boolean)\n  nameWithType: Type.GetTypeFromCLSID(Guid, Boolean)\n  fullName: Type.GetTypeFromCLSID(Guid, Boolean)\n- uid: System.Type.GetTypeFromCLSID(System.Guid)\n  parent: System.Type\n  isExternal: false\n  name: GetTypeFromCLSID(Guid)\n  nameWithType: Type.GetTypeFromCLSID(Guid)\n  fullName: Type.GetTypeFromCLSID(Guid)\n- uid: System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)\n  parent: System.Type\n  isExternal: false\n  name: GetTypeFromHandle(RuntimeTypeHandle)\n  nameWithType: Type.GetTypeFromHandle(RuntimeTypeHandle)\n  fullName: Type.GetTypeFromHandle(RuntimeTypeHandle)\n- uid: System.RuntimeTypeHandle\n  parent: System\n  isExternal: false\n  name: RuntimeTypeHandle\n  nameWithType: RuntimeTypeHandle\n  fullName: System.RuntimeTypeHandle\n- uid: System.Type.GetTypeFromProgID(System.String)\n  parent: System.Type\n  isExternal: false\n  name: GetTypeFromProgID(String)\n  nameWithType: Type.GetTypeFromProgID(String)\n  fullName: Type.GetTypeFromProgID(String)\n- uid: System.Type.GetTypeFromProgID(System.String,System.Boolean)\n  parent: System.Type\n  isExternal: false\n  name: GetTypeFromProgID(String, Boolean)\n  nameWithType: Type.GetTypeFromProgID(String, Boolean)\n  fullName: Type.GetTypeFromProgID(String, Boolean)\n- uid: System.Type.GetTypeFromProgID(System.String,System.String)\n  parent: System.Type\n  isExternal: false\n  name: GetTypeFromProgID(String, String)\n  nameWithType: Type.GetTypeFromProgID(String, String)\n  fullName: Type.GetTypeFromProgID(String, String)\n- uid: System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)\n  parent: System.Type\n  isExternal: false\n  name: GetTypeFromProgID(String, String, Boolean)\n  nameWithType: Type.GetTypeFromProgID(String, String, Boolean)\n  fullName: Type.GetTypeFromProgID(String, String, Boolean)\n- uid: System.Type.GetTypeHandle(System.Object)\n  parent: System.Type\n  isExternal: false\n  name: GetTypeHandle(Object)\n  nameWithType: Type.GetTypeHandle(Object)\n  fullName: Type.GetTypeHandle(Object)\n- uid: System.Type.GUID\n  parent: System.Type\n  isExternal: false\n  name: GUID\n  nameWithType: Type.GUID\n  fullName: Type.GUID\n- uid: System.Type.HasElementType\n  parent: System.Type\n  isExternal: false\n  name: HasElementType\n  nameWithType: Type.HasElementType\n  fullName: Type.HasElementType\n- uid: System.Type.HasElementTypeImpl\n  parent: System.Type\n  isExternal: false\n  name: HasElementTypeImpl()\n  nameWithType: Type.HasElementTypeImpl()\n  fullName: Type.HasElementTypeImpl()\n- uid: System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])\n  parent: System.Type\n  isExternal: false\n  name: InvokeMember(String, BindingFlags, Binder, Object, Object[], ParameterModifier[], CultureInfo, String[])\n  nameWithType: Type.InvokeMember(String, BindingFlags, Binder, Object, Object[], ParameterModifier[], CultureInfo, String[])\n  fullName: Type.InvokeMember(String, BindingFlags, Binder, Object, Object[], ParameterModifier[], CultureInfo, String[])\n- uid: System.Globalization.CultureInfo\n  parent: System.Globalization\n  isExternal: false\n  name: CultureInfo\n  nameWithType: CultureInfo\n  fullName: System.Globalization.CultureInfo\n- uid: System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])\n  parent: System.Type\n  isExternal: false\n  name: InvokeMember(String, BindingFlags, Binder, Object, Object[])\n  nameWithType: Type.InvokeMember(String, BindingFlags, Binder, Object, Object[])\n  fullName: Type.InvokeMember(String, BindingFlags, Binder, Object, Object[])\n- uid: System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)\n  parent: System.Type\n  isExternal: false\n  name: InvokeMember(String, BindingFlags, Binder, Object, Object[], CultureInfo)\n  nameWithType: Type.InvokeMember(String, BindingFlags, Binder, Object, Object[], CultureInfo)\n  fullName: Type.InvokeMember(String, BindingFlags, Binder, Object, Object[], CultureInfo)\n- uid: System.Type.IsAbstract\n  parent: System.Type\n  isExternal: false\n  name: IsAbstract\n  nameWithType: Type.IsAbstract\n  fullName: Type.IsAbstract\n- uid: System.Type.IsAnsiClass\n  parent: System.Type\n  isExternal: false\n  name: IsAnsiClass\n  nameWithType: Type.IsAnsiClass\n  fullName: Type.IsAnsiClass\n- uid: System.Type.IsArray\n  parent: System.Type\n  isExternal: false\n  name: IsArray\n  nameWithType: Type.IsArray\n  fullName: Type.IsArray\n- uid: System.Type.IsArrayImpl\n  parent: System.Type\n  isExternal: false\n  name: IsArrayImpl()\n  nameWithType: Type.IsArrayImpl()\n  fullName: Type.IsArrayImpl()\n- uid: System.Type.IsAssignableFrom(System.Type)\n  parent: System.Type\n  isExternal: false\n  name: IsAssignableFrom(Type)\n  nameWithType: Type.IsAssignableFrom(Type)\n  fullName: Type.IsAssignableFrom(Type)\n- uid: System.Type.IsAutoClass\n  parent: System.Type\n  isExternal: false\n  name: IsAutoClass\n  nameWithType: Type.IsAutoClass\n  fullName: Type.IsAutoClass\n- uid: System.Type.IsAutoLayout\n  parent: System.Type\n  isExternal: false\n  name: IsAutoLayout\n  nameWithType: Type.IsAutoLayout\n  fullName: Type.IsAutoLayout\n- uid: System.Type.IsByRef\n  parent: System.Type\n  isExternal: false\n  name: IsByRef\n  nameWithType: Type.IsByRef\n  fullName: Type.IsByRef\n- uid: System.Type.IsByRefImpl\n  parent: System.Type\n  isExternal: false\n  name: IsByRefImpl()\n  nameWithType: Type.IsByRefImpl()\n  fullName: Type.IsByRefImpl()\n- uid: System.Type.IsClass\n  parent: System.Type\n  isExternal: false\n  name: IsClass\n  nameWithType: Type.IsClass\n  fullName: Type.IsClass\n- uid: System.Type.IsCOMObject\n  parent: System.Type\n  isExternal: false\n  name: IsCOMObject\n  nameWithType: Type.IsCOMObject\n  fullName: Type.IsCOMObject\n- uid: System.Type.IsCOMObjectImpl\n  parent: System.Type\n  isExternal: false\n  name: IsCOMObjectImpl()\n  nameWithType: Type.IsCOMObjectImpl()\n  fullName: Type.IsCOMObjectImpl()\n- uid: System.Type.IsConstructedGenericType\n  parent: System.Type\n  isExternal: false\n  name: IsConstructedGenericType\n  nameWithType: Type.IsConstructedGenericType\n  fullName: Type.IsConstructedGenericType\n- uid: System.Type.IsContextful\n  parent: System.Type\n  isExternal: false\n  name: IsContextful\n  nameWithType: Type.IsContextful\n  fullName: Type.IsContextful\n- uid: System.Type.IsContextfulImpl\n  parent: System.Type\n  isExternal: false\n  name: IsContextfulImpl()\n  nameWithType: Type.IsContextfulImpl()\n  fullName: Type.IsContextfulImpl()\n- uid: System.Type.IsEnum\n  parent: System.Type\n  isExternal: false\n  name: IsEnum\n  nameWithType: Type.IsEnum\n  fullName: Type.IsEnum\n- uid: System.Type.IsEnumDefined(System.Object)\n  parent: System.Type\n  isExternal: false\n  name: IsEnumDefined(Object)\n  nameWithType: Type.IsEnumDefined(Object)\n  fullName: Type.IsEnumDefined(Object)\n- uid: System.Type.IsEquivalentTo(System.Type)\n  parent: System.Type\n  isExternal: false\n  name: IsEquivalentTo(Type)\n  nameWithType: Type.IsEquivalentTo(Type)\n  fullName: Type.IsEquivalentTo(Type)\n- uid: System.Type.IsExplicitLayout\n  parent: System.Type\n  isExternal: false\n  name: IsExplicitLayout\n  nameWithType: Type.IsExplicitLayout\n  fullName: Type.IsExplicitLayout\n- uid: System.Type.IsGenericParameter\n  parent: System.Type\n  isExternal: false\n  name: IsGenericParameter\n  nameWithType: Type.IsGenericParameter\n  fullName: Type.IsGenericParameter\n- uid: System.Type.IsGenericType\n  parent: System.Type\n  isExternal: false\n  name: IsGenericType\n  nameWithType: Type.IsGenericType\n  fullName: Type.IsGenericType\n- uid: System.Type.IsGenericTypeDefinition\n  parent: System.Type\n  isExternal: false\n  name: IsGenericTypeDefinition\n  nameWithType: Type.IsGenericTypeDefinition\n  fullName: Type.IsGenericTypeDefinition\n- uid: System.Type.IsImport\n  parent: System.Type\n  isExternal: false\n  name: IsImport\n  nameWithType: Type.IsImport\n  fullName: Type.IsImport\n- uid: System.Type.IsInstanceOfType(System.Object)\n  parent: System.Type\n  isExternal: false\n  name: IsInstanceOfType(Object)\n  nameWithType: Type.IsInstanceOfType(Object)\n  fullName: Type.IsInstanceOfType(Object)\n- uid: System.Type.IsInterface\n  parent: System.Type\n  isExternal: false\n  name: IsInterface\n  nameWithType: Type.IsInterface\n  fullName: Type.IsInterface\n- uid: System.Type.IsLayoutSequential\n  parent: System.Type\n  isExternal: false\n  name: IsLayoutSequential\n  nameWithType: Type.IsLayoutSequential\n  fullName: Type.IsLayoutSequential\n- uid: System.Type.IsMarshalByRef\n  parent: System.Type\n  isExternal: false\n  name: IsMarshalByRef\n  nameWithType: Type.IsMarshalByRef\n  fullName: Type.IsMarshalByRef\n- uid: System.Type.IsMarshalByRefImpl\n  parent: System.Type\n  isExternal: false\n  name: IsMarshalByRefImpl()\n  nameWithType: Type.IsMarshalByRefImpl()\n  fullName: Type.IsMarshalByRefImpl()\n- uid: System.Type.IsNested\n  parent: System.Type\n  isExternal: false\n  name: IsNested\n  nameWithType: Type.IsNested\n  fullName: Type.IsNested\n- uid: System.Type.IsNestedAssembly\n  parent: System.Type\n  isExternal: false\n  name: IsNestedAssembly\n  nameWithType: Type.IsNestedAssembly\n  fullName: Type.IsNestedAssembly\n- uid: System.Type.IsNestedFamANDAssem\n  parent: System.Type\n  isExternal: false\n  name: IsNestedFamANDAssem\n  nameWithType: Type.IsNestedFamANDAssem\n  fullName: Type.IsNestedFamANDAssem\n- uid: System.Type.IsNestedFamily\n  parent: System.Type\n  isExternal: false\n  name: IsNestedFamily\n  nameWithType: Type.IsNestedFamily\n  fullName: Type.IsNestedFamily\n- uid: System.Type.IsNestedFamORAssem\n  parent: System.Type\n  isExternal: false\n  name: IsNestedFamORAssem\n  nameWithType: Type.IsNestedFamORAssem\n  fullName: Type.IsNestedFamORAssem\n- uid: System.Type.IsNestedPrivate\n  parent: System.Type\n  isExternal: false\n  name: IsNestedPrivate\n  nameWithType: Type.IsNestedPrivate\n  fullName: Type.IsNestedPrivate\n- uid: System.Type.IsNestedPublic\n  parent: System.Type\n  isExternal: false\n  name: IsNestedPublic\n  nameWithType: Type.IsNestedPublic\n  fullName: Type.IsNestedPublic\n- uid: System.Type.IsNotPublic\n  parent: System.Type\n  isExternal: false\n  name: IsNotPublic\n  nameWithType: Type.IsNotPublic\n  fullName: Type.IsNotPublic\n- uid: System.Type.IsPointer\n  parent: System.Type\n  isExternal: false\n  name: IsPointer\n  nameWithType: Type.IsPointer\n  fullName: Type.IsPointer\n- uid: System.Type.IsPointerImpl\n  parent: System.Type\n  isExternal: false\n  name: IsPointerImpl()\n  nameWithType: Type.IsPointerImpl()\n  fullName: Type.IsPointerImpl()\n- uid: System.Type.IsPrimitive\n  parent: System.Type\n  isExternal: false\n  name: IsPrimitive\n  nameWithType: Type.IsPrimitive\n  fullName: Type.IsPrimitive\n- uid: System.Type.IsPrimitiveImpl\n  parent: System.Type\n  isExternal: false\n  name: IsPrimitiveImpl()\n  nameWithType: Type.IsPrimitiveImpl()\n  fullName: Type.IsPrimitiveImpl()\n- uid: System.Type.IsPublic\n  parent: System.Type\n  isExternal: false\n  name: IsPublic\n  nameWithType: Type.IsPublic\n  fullName: Type.IsPublic\n- uid: System.Type.IsSealed\n  parent: System.Type\n  isExternal: false\n  name: IsSealed\n  nameWithType: Type.IsSealed\n  fullName: Type.IsSealed\n- uid: System.Type.IsSecurityCritical\n  parent: System.Type\n  isExternal: false\n  name: IsSecurityCritical\n  nameWithType: Type.IsSecurityCritical\n  fullName: Type.IsSecurityCritical\n- uid: System.Type.IsSecuritySafeCritical\n  parent: System.Type\n  isExternal: false\n  name: IsSecuritySafeCritical\n  nameWithType: Type.IsSecuritySafeCritical\n  fullName: Type.IsSecuritySafeCritical\n- uid: System.Type.IsSecurityTransparent\n  parent: System.Type\n  isExternal: false\n  name: IsSecurityTransparent\n  nameWithType: Type.IsSecurityTransparent\n  fullName: Type.IsSecurityTransparent\n- uid: System.Type.IsSerializable\n  parent: System.Type\n  isExternal: false\n  name: IsSerializable\n  nameWithType: Type.IsSerializable\n  fullName: Type.IsSerializable\n- uid: System.Type.IsSpecialName\n  parent: System.Type\n  isExternal: false\n  name: IsSpecialName\n  nameWithType: Type.IsSpecialName\n  fullName: Type.IsSpecialName\n- uid: System.Type.IsSubclassOf(System.Type)\n  parent: System.Type\n  isExternal: false\n  name: IsSubclassOf(Type)\n  nameWithType: Type.IsSubclassOf(Type)\n  fullName: Type.IsSubclassOf(Type)\n- uid: System.Type.IsSZArray\n  parent: System.Type\n  isExternal: false\n  name: IsSZArray\n  nameWithType: Type.IsSZArray\n  fullName: Type.IsSZArray\n- uid: System.Type.IsTypeDefinition\n  parent: System.Type\n  isExternal: false\n  name: IsTypeDefinition\n  nameWithType: Type.IsTypeDefinition\n  fullName: Type.IsTypeDefinition\n- uid: System.Type.IsUnicodeClass\n  parent: System.Type\n  isExternal: false\n  name: IsUnicodeClass\n  nameWithType: Type.IsUnicodeClass\n  fullName: Type.IsUnicodeClass\n- uid: System.Type.IsValueType\n  parent: System.Type\n  isExternal: false\n  name: IsValueType\n  nameWithType: Type.IsValueType\n  fullName: Type.IsValueType\n- uid: System.Type.IsValueTypeImpl\n  parent: System.Type\n  isExternal: false\n  name: IsValueTypeImpl()\n  nameWithType: Type.IsValueTypeImpl()\n  fullName: Type.IsValueTypeImpl()\n- uid: System.Type.IsVariableBoundArray\n  parent: System.Type\n  isExternal: false\n  name: IsVariableBoundArray\n  nameWithType: Type.IsVariableBoundArray\n  fullName: Type.IsVariableBoundArray\n- uid: System.Type.IsVisible\n  parent: System.Type\n  isExternal: false\n  name: IsVisible\n  nameWithType: Type.IsVisible\n  fullName: Type.IsVisible\n- uid: System.Type.MakeArrayType(System.Int32)\n  parent: System.Type\n  isExternal: false\n  name: MakeArrayType(Int32)\n  nameWithType: Type.MakeArrayType(Int32)\n  fullName: Type.MakeArrayType(Int32)\n- uid: System.Type.MakeArrayType\n  parent: System.Type\n  isExternal: false\n  name: MakeArrayType()\n  nameWithType: Type.MakeArrayType()\n  fullName: Type.MakeArrayType()\n- uid: System.Type.MakeByRefType\n  parent: System.Type\n  isExternal: false\n  name: MakeByRefType()\n  nameWithType: Type.MakeByRefType()\n  fullName: Type.MakeByRefType()\n- uid: System.Type.MakeGenericType(System.Type[])\n  parent: System.Type\n  isExternal: false\n  name: MakeGenericType(Type[])\n  nameWithType: Type.MakeGenericType(Type[])\n  fullName: Type.MakeGenericType(Type[])\n- uid: System.Type.MakePointerType\n  parent: System.Type\n  isExternal: false\n  name: MakePointerType()\n  nameWithType: Type.MakePointerType()\n  fullName: Type.MakePointerType()\n- uid: System.Type.MemberType\n  parent: System.Type\n  isExternal: false\n  name: MemberType\n  nameWithType: Type.MemberType\n  fullName: Type.MemberType\n- uid: System.Type.Missing\n  parent: System.Type\n  isExternal: false\n  name: Missing\n  nameWithType: Type.Missing\n  fullName: Type.Missing\n- uid: System.Type.Module\n  parent: System.Type\n  isExternal: false\n  name: Module\n  nameWithType: Type.Module\n  fullName: Type.Module\n- uid: System.Reflection.Module\n  parent: System.Reflection\n  isExternal: false\n  name: Module\n  nameWithType: Module\n  fullName: System.Reflection.Module\n- uid: System.Type.Name\n  parent: System.Type\n  isExternal: false\n  name: Name\n  nameWithType: Type.Name\n  fullName: Type.Name\n- uid: System.Type.Namespace\n  parent: System.Type\n  isExternal: false\n  name: Namespace\n  nameWithType: Type.Namespace\n  fullName: Type.Namespace\n- uid: System.Type.op_Equality(System.Type,System.Type)\n  parent: System.Type\n  isExternal: false\n  name: op_Equality(Type, Type)\n  nameWithType: Type.op_Equality(Type, Type)\n  fullName: Type.op_Equality(Type, Type)\n- uid: System.Type.op_Inequality(System.Type,System.Type)\n  parent: System.Type\n  isExternal: false\n  name: op_Inequality(Type, Type)\n  nameWithType: Type.op_Inequality(Type, Type)\n  fullName: Type.op_Inequality(Type, Type)\n- uid: System.Type.ReflectedType\n  parent: System.Type\n  isExternal: false\n  name: ReflectedType\n  nameWithType: Type.ReflectedType\n  fullName: Type.ReflectedType\n- uid: System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)\n  parent: System.Type\n  isExternal: false\n  name: ReflectionOnlyGetType(String, Boolean, Boolean)\n  nameWithType: Type.ReflectionOnlyGetType(String, Boolean, Boolean)\n  fullName: Type.ReflectionOnlyGetType(String, Boolean, Boolean)\n- uid: System.Type.StructLayoutAttribute\n  parent: System.Type\n  isExternal: false\n  name: StructLayoutAttribute\n  nameWithType: Type.StructLayoutAttribute\n  fullName: Type.StructLayoutAttribute\n- uid: System.Runtime.InteropServices.StructLayoutAttribute\n  parent: System.Runtime.InteropServices\n  isExternal: false\n  name: StructLayoutAttribute\n  nameWithType: StructLayoutAttribute\n  fullName: System.Runtime.InteropServices.StructLayoutAttribute\n- uid: System.Type.ToString\n  parent: System.Type\n  isExternal: false\n  name: ToString()\n  nameWithType: Type.ToString()\n  fullName: Type.ToString()\n- uid: System.Type.TypeHandle\n  parent: System.Type\n  isExternal: false\n  name: TypeHandle\n  nameWithType: Type.TypeHandle\n  fullName: Type.TypeHandle\n- uid: System.Type.TypeInitializer\n  parent: System.Type\n  isExternal: false\n  name: TypeInitializer\n  nameWithType: Type.TypeInitializer\n  fullName: Type.TypeInitializer\n- uid: System.Type.UnderlyingSystemType\n  parent: System.Type\n  isExternal: false\n  name: UnderlyingSystemType\n  nameWithType: Type.UnderlyingSystemType\n  fullName: Type.UnderlyingSystemType\n- uid: System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)\n  parent: System.Type\n  isExternal: false\n  name: _Type.GetIDsOfNames(Guid, IntPtr, UInt32, UInt32, IntPtr)\n  nameWithType: Type._Type.GetIDsOfNames(Guid, IntPtr, UInt32, UInt32, IntPtr)\n  fullName: Type._Type.GetIDsOfNames(Guid, IntPtr, UInt32, UInt32, IntPtr)\n- uid: System.IntPtr\n  parent: System\n  isExternal: false\n  name: IntPtr\n  nameWithType: IntPtr\n  fullName: System.IntPtr\n- uid: System.UInt32\n  parent: System\n  isExternal: false\n  name: UInt32\n  nameWithType: UInt32\n  fullName: System.UInt32\n- uid: System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)\n  parent: System.Type\n  isExternal: false\n  name: _Type.GetTypeInfo(UInt32, UInt32, IntPtr)\n  nameWithType: Type._Type.GetTypeInfo(UInt32, UInt32, IntPtr)\n  fullName: Type._Type.GetTypeInfo(UInt32, UInt32, IntPtr)\n- uid: System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)\n  parent: System.Type\n  isExternal: false\n  name: _Type.GetTypeInfoCount(UInt32)\n  nameWithType: Type._Type.GetTypeInfoCount(UInt32)\n  fullName: Type._Type.GetTypeInfoCount(UInt32)\n- uid: System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)\n  parent: System.Type\n  isExternal: false\n  name: _Type.Invoke(UInt32, Guid, UInt32, Int16, IntPtr, IntPtr, IntPtr, IntPtr)\n  nameWithType: Type._Type.Invoke(UInt32, Guid, UInt32, Int16, IntPtr, IntPtr, IntPtr, IntPtr)\n  fullName: Type._Type.Invoke(UInt32, Guid, UInt32, Int16, IntPtr, IntPtr, IntPtr, IntPtr)\n- uid: System.Int16\n  parent: System\n  isExternal: false\n  name: Int16\n  nameWithType: Int16\n  fullName: System.Int16\n- uid: System.Type.#ctor*\n  parent: System.Type\n  isExternal: false\n  name: Type\n  nameWithType: Type.Type\n  fullName: Type.Type\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.Assembly*\n  parent: System.Type\n  isExternal: false\n  name: Assembly\n  nameWithType: Type.Assembly\n  fullName: Type.Assembly\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.AssemblyQualifiedName*\n  parent: System.Type\n  isExternal: false\n  name: AssemblyQualifiedName\n  nameWithType: Type.AssemblyQualifiedName\n  fullName: Type.AssemblyQualifiedName\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.Attributes*\n  parent: System.Type\n  isExternal: false\n  name: Attributes\n  nameWithType: Type.Attributes\n  fullName: Type.Attributes\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.BaseType*\n  parent: System.Type\n  isExternal: false\n  name: BaseType\n  nameWithType: Type.BaseType\n  fullName: Type.BaseType\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.ContainsGenericParameters*\n  parent: System.Type\n  isExternal: false\n  name: ContainsGenericParameters\n  nameWithType: Type.ContainsGenericParameters\n  fullName: Type.ContainsGenericParameters\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.DeclaringMethod*\n  parent: System.Type\n  isExternal: false\n  name: DeclaringMethod\n  nameWithType: Type.DeclaringMethod\n  fullName: Type.DeclaringMethod\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.DeclaringType*\n  parent: System.Type\n  isExternal: false\n  name: DeclaringType\n  nameWithType: Type.DeclaringType\n  fullName: Type.DeclaringType\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.DefaultBinder*\n  parent: System.Type\n  isExternal: false\n  name: DefaultBinder\n  nameWithType: Type.DefaultBinder\n  fullName: Type.DefaultBinder\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.Equals*\n  parent: System.Type\n  isExternal: false\n  name: Equals\n  nameWithType: Type.Equals\n  fullName: Type.Equals\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.FindInterfaces*\n  parent: System.Type\n  isExternal: false\n  name: FindInterfaces\n  nameWithType: Type.FindInterfaces\n  fullName: Type.FindInterfaces\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.FindMembers*\n  parent: System.Type\n  isExternal: false\n  name: FindMembers\n  nameWithType: Type.FindMembers\n  fullName: Type.FindMembers\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.FullName*\n  parent: System.Type\n  isExternal: false\n  name: FullName\n  nameWithType: Type.FullName\n  fullName: Type.FullName\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GenericParameterAttributes*\n  parent: System.Type\n  isExternal: false\n  name: GenericParameterAttributes\n  nameWithType: Type.GenericParameterAttributes\n  fullName: Type.GenericParameterAttributes\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GenericParameterPosition*\n  parent: System.Type\n  isExternal: false\n  name: GenericParameterPosition\n  nameWithType: Type.GenericParameterPosition\n  fullName: Type.GenericParameterPosition\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GenericTypeArguments*\n  parent: System.Type\n  isExternal: false\n  name: GenericTypeArguments\n  nameWithType: Type.GenericTypeArguments\n  fullName: Type.GenericTypeArguments\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetArrayRank*\n  parent: System.Type\n  isExternal: false\n  name: GetArrayRank\n  nameWithType: Type.GetArrayRank\n  fullName: Type.GetArrayRank\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetAttributeFlagsImpl*\n  parent: System.Type\n  isExternal: false\n  name: GetAttributeFlagsImpl\n  nameWithType: Type.GetAttributeFlagsImpl\n  fullName: Type.GetAttributeFlagsImpl\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetConstructor*\n  parent: System.Type\n  isExternal: false\n  name: GetConstructor\n  nameWithType: Type.GetConstructor\n  fullName: Type.GetConstructor\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetConstructorImpl*\n  parent: System.Type\n  isExternal: false\n  name: GetConstructorImpl\n  nameWithType: Type.GetConstructorImpl\n  fullName: Type.GetConstructorImpl\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetConstructors*\n  parent: System.Type\n  isExternal: false\n  name: GetConstructors\n  nameWithType: Type.GetConstructors\n  fullName: Type.GetConstructors\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetDefaultMembers*\n  parent: System.Type\n  isExternal: false\n  name: GetDefaultMembers\n  nameWithType: Type.GetDefaultMembers\n  fullName: Type.GetDefaultMembers\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetElementType*\n  parent: System.Type\n  isExternal: false\n  name: GetElementType\n  nameWithType: Type.GetElementType\n  fullName: Type.GetElementType\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetEnumName*\n  parent: System.Type\n  isExternal: false\n  name: GetEnumName\n  nameWithType: Type.GetEnumName\n  fullName: Type.GetEnumName\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetEnumNames*\n  parent: System.Type\n  isExternal: false\n  name: GetEnumNames\n  nameWithType: Type.GetEnumNames\n  fullName: Type.GetEnumNames\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetEnumUnderlyingType*\n  parent: System.Type\n  isExternal: false\n  name: GetEnumUnderlyingType\n  nameWithType: Type.GetEnumUnderlyingType\n  fullName: Type.GetEnumUnderlyingType\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetEnumValues*\n  parent: System.Type\n  isExternal: false\n  name: GetEnumValues\n  nameWithType: Type.GetEnumValues\n  fullName: Type.GetEnumValues\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetEvent*\n  parent: System.Type\n  isExternal: false\n  name: GetEvent\n  nameWithType: Type.GetEvent\n  fullName: Type.GetEvent\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetEvents*\n  parent: System.Type\n  isExternal: false\n  name: GetEvents\n  nameWithType: Type.GetEvents\n  fullName: Type.GetEvents\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetField*\n  parent: System.Type\n  isExternal: false\n  name: GetField\n  nameWithType: Type.GetField\n  fullName: Type.GetField\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetFields*\n  parent: System.Type\n  isExternal: false\n  name: GetFields\n  nameWithType: Type.GetFields\n  fullName: Type.GetFields\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetGenericArguments*\n  parent: System.Type\n  isExternal: false\n  name: GetGenericArguments\n  nameWithType: Type.GetGenericArguments\n  fullName: Type.GetGenericArguments\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetGenericParameterConstraints*\n  parent: System.Type\n  isExternal: false\n  name: GetGenericParameterConstraints\n  nameWithType: Type.GetGenericParameterConstraints\n  fullName: Type.GetGenericParameterConstraints\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetGenericTypeDefinition*\n  parent: System.Type\n  isExternal: false\n  name: GetGenericTypeDefinition\n  nameWithType: Type.GetGenericTypeDefinition\n  fullName: Type.GetGenericTypeDefinition\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetHashCode*\n  parent: System.Type\n  isExternal: false\n  name: GetHashCode\n  nameWithType: Type.GetHashCode\n  fullName: Type.GetHashCode\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetInterface*\n  parent: System.Type\n  isExternal: false\n  name: GetInterface\n  nameWithType: Type.GetInterface\n  fullName: Type.GetInterface\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetInterfaceMap*\n  parent: System.Type\n  isExternal: false\n  name: GetInterfaceMap\n  nameWithType: Type.GetInterfaceMap\n  fullName: Type.GetInterfaceMap\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetInterfaces*\n  parent: System.Type\n  isExternal: false\n  name: GetInterfaces\n  nameWithType: Type.GetInterfaces\n  fullName: Type.GetInterfaces\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetMember*\n  parent: System.Type\n  isExternal: false\n  name: GetMember\n  nameWithType: Type.GetMember\n  fullName: Type.GetMember\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetMembers*\n  parent: System.Type\n  isExternal: false\n  name: GetMembers\n  nameWithType: Type.GetMembers\n  fullName: Type.GetMembers\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetMethod*\n  parent: System.Type\n  isExternal: false\n  name: GetMethod\n  nameWithType: Type.GetMethod\n  fullName: Type.GetMethod\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetMethodImpl*\n  parent: System.Type\n  isExternal: false\n  name: GetMethodImpl\n  nameWithType: Type.GetMethodImpl\n  fullName: Type.GetMethodImpl\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetMethods*\n  parent: System.Type\n  isExternal: false\n  name: GetMethods\n  nameWithType: Type.GetMethods\n  fullName: Type.GetMethods\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetNestedType*\n  parent: System.Type\n  isExternal: false\n  name: GetNestedType\n  nameWithType: Type.GetNestedType\n  fullName: Type.GetNestedType\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetNestedTypes*\n  parent: System.Type\n  isExternal: false\n  name: GetNestedTypes\n  nameWithType: Type.GetNestedTypes\n  fullName: Type.GetNestedTypes\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetProperties*\n  parent: System.Type\n  isExternal: false\n  name: GetProperties\n  nameWithType: Type.GetProperties\n  fullName: Type.GetProperties\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetProperty*\n  parent: System.Type\n  isExternal: false\n  name: GetProperty\n  nameWithType: Type.GetProperty\n  fullName: Type.GetProperty\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetPropertyImpl*\n  parent: System.Type\n  isExternal: false\n  name: GetPropertyImpl\n  nameWithType: Type.GetPropertyImpl\n  fullName: Type.GetPropertyImpl\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetType*\n  parent: System.Type\n  isExternal: false\n  name: GetType\n  nameWithType: Type.GetType\n  fullName: Type.GetType\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  - netcore-1.0\n  - netcore-1.1\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetTypeArray*\n  parent: System.Type\n  isExternal: false\n  name: GetTypeArray\n  nameWithType: Type.GetTypeArray\n  fullName: Type.GetTypeArray\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetTypeCode*\n  parent: System.Type\n  isExternal: false\n  name: GetTypeCode\n  nameWithType: Type.GetTypeCode\n  fullName: Type.GetTypeCode\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetTypeCodeImpl*\n  parent: System.Type\n  isExternal: false\n  name: GetTypeCodeImpl\n  nameWithType: Type.GetTypeCodeImpl\n  fullName: Type.GetTypeCodeImpl\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetTypeFromCLSID*\n  parent: System.Type\n  isExternal: false\n  name: GetTypeFromCLSID\n  nameWithType: Type.GetTypeFromCLSID\n  fullName: Type.GetTypeFromCLSID\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetTypeFromHandle*\n  parent: System.Type\n  isExternal: false\n  name: GetTypeFromHandle\n  nameWithType: Type.GetTypeFromHandle\n  fullName: Type.GetTypeFromHandle\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetTypeFromProgID*\n  parent: System.Type\n  isExternal: false\n  name: GetTypeFromProgID\n  nameWithType: Type.GetTypeFromProgID\n  fullName: Type.GetTypeFromProgID\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GetTypeHandle*\n  parent: System.Type\n  isExternal: false\n  name: GetTypeHandle\n  nameWithType: Type.GetTypeHandle\n  fullName: Type.GetTypeHandle\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.GUID*\n  parent: System.Type\n  isExternal: false\n  name: GUID\n  nameWithType: Type.GUID\n  fullName: Type.GUID\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.HasElementType*\n  parent: System.Type\n  isExternal: false\n  name: HasElementType\n  nameWithType: Type.HasElementType\n  fullName: Type.HasElementType\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.HasElementTypeImpl*\n  parent: System.Type\n  isExternal: false\n  name: HasElementTypeImpl\n  nameWithType: Type.HasElementTypeImpl\n  fullName: Type.HasElementTypeImpl\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.InvokeMember*\n  parent: System.Type\n  isExternal: false\n  name: InvokeMember\n  nameWithType: Type.InvokeMember\n  fullName: Type.InvokeMember\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsAbstract*\n  parent: System.Type\n  isExternal: false\n  name: IsAbstract\n  nameWithType: Type.IsAbstract\n  fullName: Type.IsAbstract\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsAnsiClass*\n  parent: System.Type\n  isExternal: false\n  name: IsAnsiClass\n  nameWithType: Type.IsAnsiClass\n  fullName: Type.IsAnsiClass\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsArray*\n  parent: System.Type\n  isExternal: false\n  name: IsArray\n  nameWithType: Type.IsArray\n  fullName: Type.IsArray\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsArrayImpl*\n  parent: System.Type\n  isExternal: false\n  name: IsArrayImpl\n  nameWithType: Type.IsArrayImpl\n  fullName: Type.IsArrayImpl\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsAssignableFrom*\n  parent: System.Type\n  isExternal: false\n  name: IsAssignableFrom\n  nameWithType: Type.IsAssignableFrom\n  fullName: Type.IsAssignableFrom\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsAutoClass*\n  parent: System.Type\n  isExternal: false\n  name: IsAutoClass\n  nameWithType: Type.IsAutoClass\n  fullName: Type.IsAutoClass\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsAutoLayout*\n  parent: System.Type\n  isExternal: false\n  name: IsAutoLayout\n  nameWithType: Type.IsAutoLayout\n  fullName: Type.IsAutoLayout\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsByRef*\n  parent: System.Type\n  isExternal: false\n  name: IsByRef\n  nameWithType: Type.IsByRef\n  fullName: Type.IsByRef\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsByRefImpl*\n  parent: System.Type\n  isExternal: false\n  name: IsByRefImpl\n  nameWithType: Type.IsByRefImpl\n  fullName: Type.IsByRefImpl\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsClass*\n  parent: System.Type\n  isExternal: false\n  name: IsClass\n  nameWithType: Type.IsClass\n  fullName: Type.IsClass\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsCOMObject*\n  parent: System.Type\n  isExternal: false\n  name: IsCOMObject\n  nameWithType: Type.IsCOMObject\n  fullName: Type.IsCOMObject\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsCOMObjectImpl*\n  parent: System.Type\n  isExternal: false\n  name: IsCOMObjectImpl\n  nameWithType: Type.IsCOMObjectImpl\n  fullName: Type.IsCOMObjectImpl\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsConstructedGenericType*\n  parent: System.Type\n  isExternal: false\n  name: IsConstructedGenericType\n  nameWithType: Type.IsConstructedGenericType\n  fullName: Type.IsConstructedGenericType\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsContextful*\n  parent: System.Type\n  isExternal: false\n  name: IsContextful\n  nameWithType: Type.IsContextful\n  fullName: Type.IsContextful\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsContextfulImpl*\n  parent: System.Type\n  isExternal: false\n  name: IsContextfulImpl\n  nameWithType: Type.IsContextfulImpl\n  fullName: Type.IsContextfulImpl\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsEnum*\n  parent: System.Type\n  isExternal: false\n  name: IsEnum\n  nameWithType: Type.IsEnum\n  fullName: Type.IsEnum\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsEnumDefined*\n  parent: System.Type\n  isExternal: false\n  name: IsEnumDefined\n  nameWithType: Type.IsEnumDefined\n  fullName: Type.IsEnumDefined\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsEquivalentTo*\n  parent: System.Type\n  isExternal: false\n  name: IsEquivalentTo\n  nameWithType: Type.IsEquivalentTo\n  fullName: Type.IsEquivalentTo\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsExplicitLayout*\n  parent: System.Type\n  isExternal: false\n  name: IsExplicitLayout\n  nameWithType: Type.IsExplicitLayout\n  fullName: Type.IsExplicitLayout\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsGenericParameter*\n  parent: System.Type\n  isExternal: false\n  name: IsGenericParameter\n  nameWithType: Type.IsGenericParameter\n  fullName: Type.IsGenericParameter\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsGenericType*\n  parent: System.Type\n  isExternal: false\n  name: IsGenericType\n  nameWithType: Type.IsGenericType\n  fullName: Type.IsGenericType\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsGenericTypeDefinition*\n  parent: System.Type\n  isExternal: false\n  name: IsGenericTypeDefinition\n  nameWithType: Type.IsGenericTypeDefinition\n  fullName: Type.IsGenericTypeDefinition\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsImport*\n  parent: System.Type\n  isExternal: false\n  name: IsImport\n  nameWithType: Type.IsImport\n  fullName: Type.IsImport\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsInstanceOfType*\n  parent: System.Type\n  isExternal: false\n  name: IsInstanceOfType\n  nameWithType: Type.IsInstanceOfType\n  fullName: Type.IsInstanceOfType\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsInterface*\n  parent: System.Type\n  isExternal: false\n  name: IsInterface\n  nameWithType: Type.IsInterface\n  fullName: Type.IsInterface\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsLayoutSequential*\n  parent: System.Type\n  isExternal: false\n  name: IsLayoutSequential\n  nameWithType: Type.IsLayoutSequential\n  fullName: Type.IsLayoutSequential\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsMarshalByRef*\n  parent: System.Type\n  isExternal: false\n  name: IsMarshalByRef\n  nameWithType: Type.IsMarshalByRef\n  fullName: Type.IsMarshalByRef\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsMarshalByRefImpl*\n  parent: System.Type\n  isExternal: false\n  name: IsMarshalByRefImpl\n  nameWithType: Type.IsMarshalByRefImpl\n  fullName: Type.IsMarshalByRefImpl\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsNested*\n  parent: System.Type\n  isExternal: false\n  name: IsNested\n  nameWithType: Type.IsNested\n  fullName: Type.IsNested\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsNestedAssembly*\n  parent: System.Type\n  isExternal: false\n  name: IsNestedAssembly\n  nameWithType: Type.IsNestedAssembly\n  fullName: Type.IsNestedAssembly\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsNestedFamANDAssem*\n  parent: System.Type\n  isExternal: false\n  name: IsNestedFamANDAssem\n  nameWithType: Type.IsNestedFamANDAssem\n  fullName: Type.IsNestedFamANDAssem\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsNestedFamily*\n  parent: System.Type\n  isExternal: false\n  name: IsNestedFamily\n  nameWithType: Type.IsNestedFamily\n  fullName: Type.IsNestedFamily\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsNestedFamORAssem*\n  parent: System.Type\n  isExternal: false\n  name: IsNestedFamORAssem\n  nameWithType: Type.IsNestedFamORAssem\n  fullName: Type.IsNestedFamORAssem\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsNestedPrivate*\n  parent: System.Type\n  isExternal: false\n  name: IsNestedPrivate\n  nameWithType: Type.IsNestedPrivate\n  fullName: Type.IsNestedPrivate\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsNestedPublic*\n  parent: System.Type\n  isExternal: false\n  name: IsNestedPublic\n  nameWithType: Type.IsNestedPublic\n  fullName: Type.IsNestedPublic\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsNotPublic*\n  parent: System.Type\n  isExternal: false\n  name: IsNotPublic\n  nameWithType: Type.IsNotPublic\n  fullName: Type.IsNotPublic\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsPointer*\n  parent: System.Type\n  isExternal: false\n  name: IsPointer\n  nameWithType: Type.IsPointer\n  fullName: Type.IsPointer\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsPointerImpl*\n  parent: System.Type\n  isExternal: false\n  name: IsPointerImpl\n  nameWithType: Type.IsPointerImpl\n  fullName: Type.IsPointerImpl\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsPrimitive*\n  parent: System.Type\n  isExternal: false\n  name: IsPrimitive\n  nameWithType: Type.IsPrimitive\n  fullName: Type.IsPrimitive\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsPrimitiveImpl*\n  parent: System.Type\n  isExternal: false\n  name: IsPrimitiveImpl\n  nameWithType: Type.IsPrimitiveImpl\n  fullName: Type.IsPrimitiveImpl\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsPublic*\n  parent: System.Type\n  isExternal: false\n  name: IsPublic\n  nameWithType: Type.IsPublic\n  fullName: Type.IsPublic\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsSealed*\n  parent: System.Type\n  isExternal: false\n  name: IsSealed\n  nameWithType: Type.IsSealed\n  fullName: Type.IsSealed\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsSecurityCritical*\n  parent: System.Type\n  isExternal: false\n  name: IsSecurityCritical\n  nameWithType: Type.IsSecurityCritical\n  fullName: Type.IsSecurityCritical\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsSecuritySafeCritical*\n  parent: System.Type\n  isExternal: false\n  name: IsSecuritySafeCritical\n  nameWithType: Type.IsSecuritySafeCritical\n  fullName: Type.IsSecuritySafeCritical\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsSecurityTransparent*\n  parent: System.Type\n  isExternal: false\n  name: IsSecurityTransparent\n  nameWithType: Type.IsSecurityTransparent\n  fullName: Type.IsSecurityTransparent\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsSerializable*\n  parent: System.Type\n  isExternal: false\n  name: IsSerializable\n  nameWithType: Type.IsSerializable\n  fullName: Type.IsSerializable\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsSpecialName*\n  parent: System.Type\n  isExternal: false\n  name: IsSpecialName\n  nameWithType: Type.IsSpecialName\n  fullName: Type.IsSpecialName\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsSubclassOf*\n  parent: System.Type\n  isExternal: false\n  name: IsSubclassOf\n  nameWithType: Type.IsSubclassOf\n  fullName: Type.IsSubclassOf\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsSZArray*\n  parent: System.Type\n  isExternal: false\n  name: IsSZArray\n  nameWithType: Type.IsSZArray\n  fullName: Type.IsSZArray\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsTypeDefinition*\n  parent: System.Type\n  isExternal: false\n  name: IsTypeDefinition\n  nameWithType: Type.IsTypeDefinition\n  fullName: Type.IsTypeDefinition\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsUnicodeClass*\n  parent: System.Type\n  isExternal: false\n  name: IsUnicodeClass\n  nameWithType: Type.IsUnicodeClass\n  fullName: Type.IsUnicodeClass\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsValueType*\n  parent: System.Type\n  isExternal: false\n  name: IsValueType\n  nameWithType: Type.IsValueType\n  fullName: Type.IsValueType\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsValueTypeImpl*\n  parent: System.Type\n  isExternal: false\n  name: IsValueTypeImpl\n  nameWithType: Type.IsValueTypeImpl\n  fullName: Type.IsValueTypeImpl\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsVariableBoundArray*\n  parent: System.Type\n  isExternal: false\n  name: IsVariableBoundArray\n  nameWithType: Type.IsVariableBoundArray\n  fullName: Type.IsVariableBoundArray\n  monikers:\n  - netcore-2.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.IsVisible*\n  parent: System.Type\n  isExternal: false\n  name: IsVisible\n  nameWithType: Type.IsVisible\n  fullName: Type.IsVisible\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.MakeArrayType*\n  parent: System.Type\n  isExternal: false\n  name: MakeArrayType\n  nameWithType: Type.MakeArrayType\n  fullName: Type.MakeArrayType\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.MakeByRefType*\n  parent: System.Type\n  isExternal: false\n  name: MakeByRefType\n  nameWithType: Type.MakeByRefType\n  fullName: Type.MakeByRefType\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.MakeGenericType*\n  parent: System.Type\n  isExternal: false\n  name: MakeGenericType\n  nameWithType: Type.MakeGenericType\n  fullName: Type.MakeGenericType\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.MakePointerType*\n  parent: System.Type\n  isExternal: false\n  name: MakePointerType\n  nameWithType: Type.MakePointerType\n  fullName: Type.MakePointerType\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.MemberType*\n  parent: System.Type\n  isExternal: false\n  name: MemberType\n  nameWithType: Type.MemberType\n  fullName: Type.MemberType\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.Module*\n  parent: System.Type\n  isExternal: false\n  name: Module\n  nameWithType: Type.Module\n  fullName: Type.Module\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.Name*\n  parent: System.Type\n  isExternal: false\n  name: Name\n  nameWithType: Type.Name\n  fullName: Type.Name\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.Namespace*\n  parent: System.Type\n  isExternal: false\n  name: Namespace\n  nameWithType: Type.Namespace\n  fullName: Type.Namespace\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.op_Equality*\n  parent: System.Type\n  isExternal: false\n  name: op_Equality\n  nameWithType: Type.op_Equality\n  fullName: Type.op_Equality\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.op_Inequality*\n  parent: System.Type\n  isExternal: false\n  name: op_Inequality\n  nameWithType: Type.op_Inequality\n  fullName: Type.op_Inequality\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.ReflectedType*\n  parent: System.Type\n  isExternal: false\n  name: ReflectedType\n  nameWithType: Type.ReflectedType\n  fullName: Type.ReflectedType\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.ReflectionOnlyGetType*\n  parent: System.Type\n  isExternal: false\n  name: ReflectionOnlyGetType\n  nameWithType: Type.ReflectionOnlyGetType\n  fullName: Type.ReflectionOnlyGetType\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.StructLayoutAttribute*\n  parent: System.Type\n  isExternal: false\n  name: StructLayoutAttribute\n  nameWithType: Type.StructLayoutAttribute\n  fullName: Type.StructLayoutAttribute\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.ToString*\n  parent: System.Type\n  isExternal: false\n  name: ToString\n  nameWithType: Type.ToString\n  fullName: Type.ToString\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.TypeHandle*\n  parent: System.Type\n  isExternal: false\n  name: TypeHandle\n  nameWithType: Type.TypeHandle\n  fullName: Type.TypeHandle\n  monikers:\n  - netcore-1.0\n  - netcore-1.1\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-1.0\n  - netstandard-1.1\n  - netstandard-1.2\n  - netstandard-1.3\n  - netstandard-1.4\n  - netstandard-1.5\n  - netstandard-1.6\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.TypeInitializer*\n  parent: System.Type\n  isExternal: false\n  name: TypeInitializer\n  nameWithType: Type.TypeInitializer\n  fullName: Type.TypeInitializer\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.UnderlyingSystemType*\n  parent: System.Type\n  isExternal: false\n  name: UnderlyingSystemType\n  nameWithType: Type.UnderlyingSystemType\n  fullName: Type.UnderlyingSystemType\n  monikers:\n  - netcore-2.0\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - netstandard-2.0\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames*\n  parent: System.Type\n  isExternal: false\n  name: System.Runtime.InteropServices._Type.GetIDsOfNames\n  nameWithType: Type.System.Runtime.InteropServices._Type.GetIDsOfNames\n  fullName: Type.System.Runtime.InteropServices._Type.GetIDsOfNames\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo*\n  parent: System.Type\n  isExternal: false\n  name: System.Runtime.InteropServices._Type.GetTypeInfo\n  nameWithType: Type.System.Runtime.InteropServices._Type.GetTypeInfo\n  fullName: Type.System.Runtime.InteropServices._Type.GetTypeInfo\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount*\n  parent: System.Type\n  isExternal: false\n  name: System.Runtime.InteropServices._Type.GetTypeInfoCount\n  nameWithType: Type.System.Runtime.InteropServices._Type.GetTypeInfoCount\n  fullName: Type.System.Runtime.InteropServices._Type.GetTypeInfoCount\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Type.System#Runtime#InteropServices#_Type#Invoke*\n  parent: System.Type\n  isExternal: false\n  name: System.Runtime.InteropServices._Type.Invoke\n  nameWithType: Type.System.Runtime.InteropServices._Type.Invoke\n  fullName: Type.System.Runtime.InteropServices._Type.Invoke\n  monikers:\n  - netframework-4.5.1\n  - netframework-4.5.2\n  - netframework-4.5\n  - netframework-4.6.1\n  - netframework-4.6.2\n  - netframework-4.6\n  - netframework-4.7\n  - xamarinandroid-7.1\n  - xamarinios-10.8\n  - xamarinmac-3.0\n  content_git_url: https://github.com/dotnet/docs/blob/master/xml/System/Type.xml\n- uid: System.Object.Equals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: Equals(Object, Object)\n  nameWithType: Object.Equals(Object, Object)\n  fullName: Object.Equals(Object, Object)\n- uid: System.Object.MemberwiseClone\n  parent: System.Object\n  isExternal: false\n  name: MemberwiseClone()\n  nameWithType: Object.MemberwiseClone()\n  fullName: Object.MemberwiseClone()\n- uid: System.Object.ReferenceEquals(System.Object,System.Object)\n  parent: System.Object\n  isExternal: false\n  name: ReferenceEquals(Object, Object)\n  nameWithType: Object.ReferenceEquals(Object, Object)\n  fullName: Object.ReferenceEquals(Object, Object)\n- uid: System.Reflection.IntrospectionExtensions.GetTypeInfo(System.Type)\n  parent: System.Reflection.IntrospectionExtensions\n  isExternal: false\n  name: GetTypeInfo(Type)\n  nameWithType: IntrospectionExtensions.GetTypeInfo(Type)\n  fullName: IntrospectionExtensions.GetTypeInfo(Type)\n- uid: System.Reflection.RuntimeReflectionExtensions.GetRuntimeEvent(System.Type,System.String)\n  parent: System.Reflection.RuntimeReflectionExtensions\n  isExternal: false\n  name: GetRuntimeEvent(Type, String)\n  nameWithType: RuntimeReflectionExtensions.GetRuntimeEvent(Type, String)\n  fullName: RuntimeReflectionExtensions.GetRuntimeEvent(Type, String)\n- uid: System.Reflection.RuntimeReflectionExtensions.GetRuntimeEvents(System.Type)\n  parent: System.Reflection.RuntimeReflectionExtensions\n  isExternal: false\n  name: GetRuntimeEvents(Type)\n  nameWithType: RuntimeReflectionExtensions.GetRuntimeEvents(Type)\n  fullName: RuntimeReflectionExtensions.GetRuntimeEvents(Type)\n- uid: System.Reflection.RuntimeReflectionExtensions.GetRuntimeField(System.Type,System.String)\n  parent: System.Reflection.RuntimeReflectionExtensions\n  isExternal: false\n  name: GetRuntimeField(Type, String)\n  nameWithType: RuntimeReflectionExtensions.GetRuntimeField(Type, String)\n  fullName: RuntimeReflectionExtensions.GetRuntimeField(Type, String)\n- uid: System.Reflection.RuntimeReflectionExtensions.GetRuntimeFields(System.Type)\n  parent: System.Reflection.RuntimeReflectionExtensions\n  isExternal: false\n  name: GetRuntimeFields(Type)\n  nameWithType: RuntimeReflectionExtensions.GetRuntimeFields(Type)\n  fullName: RuntimeReflectionExtensions.GetRuntimeFields(Type)\n- uid: System.Reflection.RuntimeReflectionExtensions.GetRuntimeMethod(System.Type,System.String,System.Type[])\n  parent: System.Reflection.RuntimeReflectionExtensions\n  isExternal: false\n  name: GetRuntimeMethod(Type, String, Type[])\n  nameWithType: RuntimeReflectionExtensions.GetRuntimeMethod(Type, String, Type[])\n  fullName: RuntimeReflectionExtensions.GetRuntimeMethod(Type, String, Type[])\n- uid: System.Reflection.RuntimeReflectionExtensions.GetRuntimeMethods(System.Type)\n  parent: System.Reflection.RuntimeReflectionExtensions\n  isExternal: false\n  name: GetRuntimeMethods(Type)\n  nameWithType: RuntimeReflectionExtensions.GetRuntimeMethods(Type)\n  fullName: RuntimeReflectionExtensions.GetRuntimeMethods(Type)\n- uid: System.Reflection.RuntimeReflectionExtensions.GetRuntimeProperties(System.Type)\n  parent: System.Reflection.RuntimeReflectionExtensions\n  isExternal: false\n  name: GetRuntimeProperties(Type)\n  nameWithType: RuntimeReflectionExtensions.GetRuntimeProperties(Type)\n  fullName: RuntimeReflectionExtensions.GetRuntimeProperties(Type)\n- uid: System.Reflection.RuntimeReflectionExtensions.GetRuntimeProperty(System.Type,System.String)\n  parent: System.Reflection.RuntimeReflectionExtensions\n  isExternal: false\n  name: GetRuntimeProperty(Type, String)\n  nameWithType: RuntimeReflectionExtensions.GetRuntimeProperty(Type, String)\n  fullName: RuntimeReflectionExtensions.GetRuntimeProperty(Type, String)\n- uid: System.Reflection.TypeExtensions.GetConstructor(System.Type,System.Type[])\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetConstructor(Type, Type[])\n  nameWithType: TypeExtensions.GetConstructor(Type, Type[])\n  fullName: TypeExtensions.GetConstructor(Type, Type[])\n- uid: System.Reflection.TypeExtensions.GetConstructors(System.Type)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetConstructors(Type)\n  nameWithType: TypeExtensions.GetConstructors(Type)\n  fullName: TypeExtensions.GetConstructors(Type)\n- uid: System.Reflection.TypeExtensions.GetConstructors(System.Type,System.Reflection.BindingFlags)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetConstructors(Type, BindingFlags)\n  nameWithType: TypeExtensions.GetConstructors(Type, BindingFlags)\n  fullName: TypeExtensions.GetConstructors(Type, BindingFlags)\n- uid: System.Reflection.TypeExtensions.GetDefaultMembers(System.Type)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetDefaultMembers(Type)\n  nameWithType: TypeExtensions.GetDefaultMembers(Type)\n  fullName: TypeExtensions.GetDefaultMembers(Type)\n- uid: System.Reflection.TypeExtensions.GetEvent(System.Type,System.String)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetEvent(Type, String)\n  nameWithType: TypeExtensions.GetEvent(Type, String)\n  fullName: TypeExtensions.GetEvent(Type, String)\n- uid: System.Reflection.TypeExtensions.GetEvent(System.Type,System.String,System.Reflection.BindingFlags)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetEvent(Type, String, BindingFlags)\n  nameWithType: TypeExtensions.GetEvent(Type, String, BindingFlags)\n  fullName: TypeExtensions.GetEvent(Type, String, BindingFlags)\n- uid: System.Reflection.TypeExtensions.GetEvents(System.Type)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetEvents(Type)\n  nameWithType: TypeExtensions.GetEvents(Type)\n  fullName: TypeExtensions.GetEvents(Type)\n- uid: System.Reflection.TypeExtensions.GetEvents(System.Type,System.Reflection.BindingFlags)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetEvents(Type, BindingFlags)\n  nameWithType: TypeExtensions.GetEvents(Type, BindingFlags)\n  fullName: TypeExtensions.GetEvents(Type, BindingFlags)\n- uid: System.Reflection.TypeExtensions.GetField(System.Type,System.String)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetField(Type, String)\n  nameWithType: TypeExtensions.GetField(Type, String)\n  fullName: TypeExtensions.GetField(Type, String)\n- uid: System.Reflection.TypeExtensions.GetField(System.Type,System.String,System.Reflection.BindingFlags)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetField(Type, String, BindingFlags)\n  nameWithType: TypeExtensions.GetField(Type, String, BindingFlags)\n  fullName: TypeExtensions.GetField(Type, String, BindingFlags)\n- uid: System.Reflection.TypeExtensions.GetFields(System.Type)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetFields(Type)\n  nameWithType: TypeExtensions.GetFields(Type)\n  fullName: TypeExtensions.GetFields(Type)\n- uid: System.Reflection.TypeExtensions.GetFields(System.Type,System.Reflection.BindingFlags)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetFields(Type, BindingFlags)\n  nameWithType: TypeExtensions.GetFields(Type, BindingFlags)\n  fullName: TypeExtensions.GetFields(Type, BindingFlags)\n- uid: System.Reflection.TypeExtensions.GetGenericArguments(System.Type)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetGenericArguments(Type)\n  nameWithType: TypeExtensions.GetGenericArguments(Type)\n  fullName: TypeExtensions.GetGenericArguments(Type)\n- uid: System.Reflection.TypeExtensions.GetInterfaces(System.Type)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetInterfaces(Type)\n  nameWithType: TypeExtensions.GetInterfaces(Type)\n  fullName: TypeExtensions.GetInterfaces(Type)\n- uid: System.Reflection.TypeExtensions.GetMember(System.Type,System.String)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetMember(Type, String)\n  nameWithType: TypeExtensions.GetMember(Type, String)\n  fullName: TypeExtensions.GetMember(Type, String)\n- uid: System.Reflection.TypeExtensions.GetMember(System.Type,System.String,System.Reflection.BindingFlags)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetMember(Type, String, BindingFlags)\n  nameWithType: TypeExtensions.GetMember(Type, String, BindingFlags)\n  fullName: TypeExtensions.GetMember(Type, String, BindingFlags)\n- uid: System.Reflection.TypeExtensions.GetMembers(System.Type)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetMembers(Type)\n  nameWithType: TypeExtensions.GetMembers(Type)\n  fullName: TypeExtensions.GetMembers(Type)\n- uid: System.Reflection.TypeExtensions.GetMembers(System.Type,System.Reflection.BindingFlags)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetMembers(Type, BindingFlags)\n  nameWithType: TypeExtensions.GetMembers(Type, BindingFlags)\n  fullName: TypeExtensions.GetMembers(Type, BindingFlags)\n- uid: System.Reflection.TypeExtensions.GetMethod(System.Type,System.String)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetMethod(Type, String)\n  nameWithType: TypeExtensions.GetMethod(Type, String)\n  fullName: TypeExtensions.GetMethod(Type, String)\n- uid: System.Reflection.TypeExtensions.GetMethod(System.Type,System.String,System.Reflection.BindingFlags)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetMethod(Type, String, BindingFlags)\n  nameWithType: TypeExtensions.GetMethod(Type, String, BindingFlags)\n  fullName: TypeExtensions.GetMethod(Type, String, BindingFlags)\n- uid: System.Reflection.TypeExtensions.GetMethod(System.Type,System.String,System.Type[])\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetMethod(Type, String, Type[])\n  nameWithType: TypeExtensions.GetMethod(Type, String, Type[])\n  fullName: TypeExtensions.GetMethod(Type, String, Type[])\n- uid: System.Reflection.TypeExtensions.GetMethods(System.Type)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetMethods(Type)\n  nameWithType: TypeExtensions.GetMethods(Type)\n  fullName: TypeExtensions.GetMethods(Type)\n- uid: System.Reflection.TypeExtensions.GetMethods(System.Type,System.Reflection.BindingFlags)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetMethods(Type, BindingFlags)\n  nameWithType: TypeExtensions.GetMethods(Type, BindingFlags)\n  fullName: TypeExtensions.GetMethods(Type, BindingFlags)\n- uid: System.Reflection.TypeExtensions.GetNestedType(System.Type,System.String,System.Reflection.BindingFlags)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetNestedType(Type, String, BindingFlags)\n  nameWithType: TypeExtensions.GetNestedType(Type, String, BindingFlags)\n  fullName: TypeExtensions.GetNestedType(Type, String, BindingFlags)\n- uid: System.Reflection.TypeExtensions.GetNestedTypes(System.Type,System.Reflection.BindingFlags)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetNestedTypes(Type, BindingFlags)\n  nameWithType: TypeExtensions.GetNestedTypes(Type, BindingFlags)\n  fullName: TypeExtensions.GetNestedTypes(Type, BindingFlags)\n- uid: System.Reflection.TypeExtensions.GetProperties(System.Type)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetProperties(Type)\n  nameWithType: TypeExtensions.GetProperties(Type)\n  fullName: TypeExtensions.GetProperties(Type)\n- uid: System.Reflection.TypeExtensions.GetProperties(System.Type,System.Reflection.BindingFlags)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetProperties(Type, BindingFlags)\n  nameWithType: TypeExtensions.GetProperties(Type, BindingFlags)\n  fullName: TypeExtensions.GetProperties(Type, BindingFlags)\n- uid: System.Reflection.TypeExtensions.GetProperty(System.Type,System.String)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetProperty(Type, String)\n  nameWithType: TypeExtensions.GetProperty(Type, String)\n  fullName: TypeExtensions.GetProperty(Type, String)\n- uid: System.Reflection.TypeExtensions.GetProperty(System.Type,System.String,System.Reflection.BindingFlags)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetProperty(Type, String, BindingFlags)\n  nameWithType: TypeExtensions.GetProperty(Type, String, BindingFlags)\n  fullName: TypeExtensions.GetProperty(Type, String, BindingFlags)\n- uid: System.Reflection.TypeExtensions.GetProperty(System.Type,System.String,System.Type)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetProperty(Type, String, Type)\n  nameWithType: TypeExtensions.GetProperty(Type, String, Type)\n  fullName: TypeExtensions.GetProperty(Type, String, Type)\n- uid: System.Reflection.TypeExtensions.GetProperty(System.Type,System.String,System.Type,System.Type[])\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: GetProperty(Type, String, Type, Type[])\n  nameWithType: TypeExtensions.GetProperty(Type, String, Type, Type[])\n  fullName: TypeExtensions.GetProperty(Type, String, Type, Type[])\n- uid: System.Reflection.TypeExtensions.IsAssignableFrom(System.Type,System.Type)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: IsAssignableFrom(Type, Type)\n  nameWithType: TypeExtensions.IsAssignableFrom(Type, Type)\n  fullName: TypeExtensions.IsAssignableFrom(Type, Type)\n- uid: System.Reflection.TypeExtensions.IsInstanceOfType(System.Type,System.Object)\n  parent: System.Reflection.TypeExtensions\n  isExternal: false\n  name: IsInstanceOfType(Type, Object)\n  nameWithType: TypeExtensions.IsInstanceOfType(Type, Object)\n  fullName: TypeExtensions.IsInstanceOfType(Type, Object)\n- uid: System.Reflection.IReflect\n  parent: System.Reflection\n  isExternal: false\n  name: IReflect\n  nameWithType: IReflect\n  fullName: System.Reflection.IReflect\n- uid: System.Runtime.InteropServices._Type\n  parent: System.Runtime.InteropServices\n  isExternal: false\n  name: _Type\n  nameWithType: _Type\n  fullName: System.Runtime.InteropServices._Type\n"}